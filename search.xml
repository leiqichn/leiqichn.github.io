<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 结构化设计</title>
    <url>/2023-09-13-476441b87811.html</url>
    <content><![CDATA[<h1 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h1><p><strong>自顶向下的设计 是自顶向下的分解</strong> -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题<br><img src="/../../imgs/Pasted%20image%2020230913232308.png"></p>
<h1 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h1><p>自顶向上的实现，实现一个一个子问题</p>
<p>程序由三种基本结构组成，<strong>顺序-分支-循环</strong><img src="/../../imgs/Pasted%20image%2020230913232249.png"></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="/../../imgs/Pasted%20image%2020230913232729.png"><br><img src="/../../imgs/Pasted%20image%2020230913232746.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020230913232825.png"><br><img src="/../../imgs/Pasted%20image%2020230913232951.png"><br><img src="/../../imgs/Pasted%20image%2020230913232936.png"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>docker容器打包成本地压缩镜像并load</title>
    <url>/2024-08-11-a8e2c27fed87.html</url>
    <content><![CDATA[<h1 id="docker容器打包成镜像和压缩"><a href="#docker容器打包成镜像和压缩" class="headerlink" title="docker容器打包成镜像和压缩"></a>docker容器打包成镜像和压缩</h1><p>（1）将容器保存成新的镜像<br>相当于加了一层，使用docker commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker commit -a &#x27;run_code&#x27; b4293c3b9202  myimage:v2</span><br></pre></td></tr></table></figure>


<p>（2）将镜像打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o mask_detection_v5.tar myimage:v5</span><br></pre></td></tr></table></figure>


<p>(3) 将镜像包压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zcvf myimage.tar.gz myimage.tar</span><br></pre></td></tr></table></figure>


<p><strong>还有一种容器的打包和压缩一步到位的方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save myimage:v5 | gzip &gt; myimage.tar.gz</span><br></pre></td></tr></table></figure>


<p>docker镜像压缩包解压及镜像载入</p>
<p>一步加载压缩的镜像命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load &lt; myimage.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（1）压缩包解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf myimage.tar.gz</span><br></pre></td></tr></table></figure>


<p>得到.tar格式的镜像包</p>
<p>（2）镜像载入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker load -i myimage.tar</span><br></pre></td></tr></table></figure>


<p>载入后查看已经加载的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>



<h1 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交互式运行</span></span><br><span class="line">docker run -it myimage:v1 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="进入已经运行的容器"><a href="#进入已经运行的容器" class="headerlink" title="进入已经运行的容器"></a>进入已经运行的容器</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it [imagesID] bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Go 浮点数次方</title>
    <url>/2024-12-03-3d026e7b5bec.html</url>
    <content><![CDATA[<p>在Go语言中，计算一个数的几次方可以通过标准库中的<code>math</code>包来实现。<code>math</code>包提供了一个<code>Pow</code>函数，用于计算x的y次方。</p>
<h3 id="使用math-Pow函数"><a href="#使用math-Pow函数" class="headerlink" title="使用math.Pow函数"></a>使用<code>math.Pow</code>函数</h3><p><code>math.Pow</code>函数的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pow</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure>

<p>这个函数接受两个<code>float64</code>类型的参数：<code>x</code>是底数，<code>y</code>是指数，返回<code>x</code>的<code>y</code>次方的结果。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用<code>math.Pow</code>函数的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算2的3次方</span></span><br><span class="line">    result := math.Pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;2的3次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算3的2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;3的2次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算10的-2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">10</span>, <span class="number">-2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;10的-2次方是: %v\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2的3次方是: 8</span><br><span class="line">3的2次方是: 9</span><br><span class="line">10的-2次方是: 0.01</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>math.Pow</code>函数的参数和返回值都是<code>float64</code>类型，因此如果你需要计算整数的次方，可能需要先将整数转换为<code>float64</code>，然后再进行计算。</li>
<li>如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go 中是否使用make创建slice的区别</title>
    <url>/2023-10-05-9d3185fd2258.html</url>
    <content><![CDATA[<p>go slice 的make 会创建默认长度 且值为0 的slice </p>
<p>在 Go 语言中，可以使用 <code>make</code> 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 <code>make</code> 和不使用 <code>make</code> 创建切片的主要区别：</p>
<p><strong>使用 <code>make</code> 创建切片：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 make 创建切片，指定长度和容量 </span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<ol>
<li><p><strong>指定长度和容量：</strong> 使用 <code>make</code> 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。</p>
</li>
<li><p><strong>底层数组初始化：</strong> 使用 <code>make</code> 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，<code>slice</code> 是一个包含5个零值整数的切片。</p>
</li>
</ol>
<p><strong>不使用 <code>make</code> 创建切片：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用 make 创建切片，长度为 5 </span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&#96;</p>
<ol>
<li><p><strong>自动确定长度：</strong> 不使用 <code>make</code> 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，<code>slice</code> 的长度是5，因为提供了5个整数。</p>
</li>
<li><p><strong>容量与长度相同：</strong> 如果不使用 <code>make</code> 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>使用 <code>make</code> 创建切片时，您可以明确控制切片的容量，并<strong>按长度初始化为0值</strong>，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。</li>
<li>不使用 <code>make</code> 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。</li>
</ul>
<p>无论使用哪种方式创建切片，都可以使用 <code>append</code> 函数来动态增长切片的长度。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Golang LeetCode 刷题必备基础和常用模板</title>
    <url>/2025-06-13-e749796f24c2.html</url>
    <content><![CDATA[<h1 id="Golang-LeetCode-刷题必备基础备忘录"><a href="#Golang-LeetCode-刷题必备基础备忘录" class="headerlink" title="Golang LeetCode 刷题必备基础备忘录"></a>Golang LeetCode 刷题必备基础备忘录</h1><h2 id="1-基础数据结构用法"><a href="#1-基础数据结构用法" class="headerlink" title="1. 基础数据结构用法"></a>1. 基础数据结构用法</h2><h3 id="数组-切片-Slice"><a href="#数组-切片-Slice" class="headerlink" title="数组&#x2F;切片 (Slice)"></a>数组&#x2F;切片 (Slice)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// 长度5</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 长度0，容量10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>) <span class="comment">// 追加</span></span><br><span class="line"><span class="built_in">len</span>(slice) <span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">copy</span>(dest, src) <span class="comment">// 复制</span></span><br><span class="line">sort.Ints(slice) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 字节长度(非字符数)</span></span><br><span class="line">utf8.RuneCountInString(s) <span class="comment">// 字符数</span></span><br><span class="line">strings.Contains(s, <span class="string">&quot;ell&quot;</span>) <span class="comment">// true</span></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>) <span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line">strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>) <span class="comment">// &quot;a-b&quot;</span></span><br><span class="line">strconv.Itoa(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line">strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// 123, error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> s &#123; <span class="comment">// r是rune类型(Unicode码点)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %c\n&quot;</span>, i, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 (Map)"></a>映射 (Map)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">val, exists := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// exists为bool表示是否存在</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>) <span class="comment">// 删除键</span></span><br></pre></td></tr></table></figure>

<h3 id="链表-List"><a href="#链表-List" class="headerlink" title="链表 (List)"></a>链表 (List)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line">l := list.New()</span><br><span class="line">l.PushBack(<span class="number">1</span>)</span><br><span class="line">l.PushFront(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">    fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-常用算法模板"><a href="#2-常用算法模板" class="headerlink" title="2. 常用算法模板"></a>2. 常用算法模板</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pivot := nums[<span class="number">0</span>]</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= right; &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot &#123;</span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            left++</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &gt; pivot &#123;</span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums[:left])</span><br><span class="line">    quickSort(nums[right+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-标准库重要包"><a href="#3-标准库重要包" class="headerlink" title="3. 标准库重要包"></a>3. 标准库重要包</h2><h3 id="sort-排序包"><a href="#sort-排序包" class="headerlink" title="sort 排序包"></a><code>sort</code> 排序包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型排序</span></span><br><span class="line">sort.Ints(arr)</span><br><span class="line">sort.Strings(arr)</span><br><span class="line">sort.Float64s(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="container-heap-堆实现"><a href="#container-heap-堆实现" class="headerlink" title="container/heap 堆实现"></a><code>container/heap</code> 堆实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆示例</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x any)        &#123; *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">h := &amp;MinHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">smallest := heap.Pop(h)</span><br></pre></td></tr></table></figure>

<h3 id="math-数学包"><a href="#math-数学包" class="headerlink" title="math 数学包"></a><code>math</code> 数学包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line">math.Max(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Min(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Abs(<span class="type">float64</span>)</span><br><span class="line">math.Pow(x, y <span class="type">float64</span>)</span><br><span class="line">math.Sqrt(<span class="type">float64</span>)</span><br><span class="line">math.Ceil(<span class="type">float64</span>)</span><br><span class="line">math.Floor(<span class="type">float64</span>)</span><br><span class="line">math.MaxInt32 <span class="comment">// 常量</span></span><br><span class="line">math.MinInt32</span><br></pre></td></tr></table></figure>

<h2 id="4-并发编程基础"><a href="#4-并发编程基础" class="headerlink" title="4. 并发编程基础"></a>4. 并发编程基础</h2><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 并发执行的代码</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 缓冲通道</span></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// 发送</span></span><br><span class="line">val := &lt;-ch <span class="comment">// 接收</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select多路复用</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-常用技巧"><a href="#5-常用技巧" class="headerlink" title="5. 常用技巧"></a>5. 常用技巧</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n &amp; <span class="number">1</span> <span class="comment">// 判断奇偶</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span> <span class="comment">// 除以2</span></span><br><span class="line">n &lt;&lt; <span class="number">1</span> <span class="comment">// 乘以2</span></span><br><span class="line">a ^ b <span class="comment">// 异或</span></span><br><span class="line">a &amp;^ b <span class="comment">// 位清除</span></span><br></pre></td></tr></table></figure>

<h3 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a>常用常量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INT_MAX = <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> INT_MIN = ^INT_MAX</span><br></pre></td></tr></table></figure>

<h3 id="快速输入输出-竞赛用"><a href="#快速输入输出-竞赛用" class="headerlink" title="快速输入输出 (竞赛用)"></a>快速输入输出 (竞赛用)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line">fmt.Fscan(reader, &amp;a, &amp;b)</span><br><span class="line">fmt.Fprintln(writer, a+b)</span><br></pre></td></tr></table></figure>

<h2 id="6-测试用例写法"><a href="#6-测试用例写法" class="headerlink" title="6. 测试用例写法"></a>6. 测试用例写法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        input <span class="type">int</span></span><br><span class="line">        want <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;case1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;case2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> got := Func(tt.input); got != tt.want &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;Func() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-常见题型解题要点"><a href="#7-常见题型解题要点" class="headerlink" title="7. 常见题型解题要点"></a>7. 常见题型解题要点</h2><ol>
<li><strong>双指针</strong>：数组&#x2F;链表问题，滑动窗口</li>
<li><strong>DFS&#x2F;BFS</strong>：树&#x2F;图遍历，回溯问题</li>
<li><strong>动态规划</strong>：状态转移方程，备忘录</li>
<li><strong>贪心算法</strong>：局部最优解</li>
<li><strong>并查集</strong>：连通性问题</li>
<li><strong>前缀和&#x2F;差分数组</strong>：区间查询&#x2F;更新</li>
<li><strong>单调栈</strong>：下一个更大&#x2F;小元素问题</li>
</ol>
<h2 id="1-双指针技巧"><a href="#1-双指针技巧" class="headerlink" title="1. 双指针技巧"></a>1. 双指针技巧</h2><h3 id="数组-链表问题模板"><a href="#数组-链表问题模板" class="headerlink" title="数组&#x2F;链表问题模板"></a>数组&#x2F;链表问题模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针找链表中点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序数组两数之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        sum := nums[left] + nums[right]</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxLen := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        freq[s[right]]++</span><br><span class="line">        <span class="comment">// 窗口收缩条件</span></span><br><span class="line">        <span class="keyword">for</span> freq[s[right]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            freq[s[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = max(maxLen, right-left+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-DFS-BFS-算法"><a href="#2-DFS-BFS-算法" class="headerlink" title="2. DFS&#x2F;BFS 算法"></a>2. DFS&#x2F;BFS 算法</h2><h3 id="树遍历模板"><a href="#树遍历模板" class="headerlink" title="树遍历模板"></a>树遍历模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS 递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    dfs(root.Left)</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    dfs(root.Right)</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">var</span> level []<span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            level = <span class="built_in">append</span>(level, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, level)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h2><h3 id="经典DP模板"><a href="#经典DP模板" class="headerlink" title="经典DP模板"></a>经典DP模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列 (备忘录)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-1背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(weights []<span class="type">int</span>, values []<span class="type">int</span>, W <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(weights)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, W+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= W; w++ &#123;</span><br><span class="line">            <span class="keyword">if</span> weights[i<span class="number">-1</span>] &gt; w &#123;</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-weights[i<span class="number">-1</span>]]+values[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h2><h3 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intervalSchedule</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        start := interval[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = interval[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a>5. 并查集</h2><h3 id="标准实现"><a href="#标准实现" class="headerlink" title="标准实现"></a>标准实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionFind <span class="keyword">struct</span> &#123;</span><br><span class="line">    parent []<span class="type">int</span></span><br><span class="line">    count  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> *UnionFind &#123;</span><br><span class="line">    parent := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> parent &#123;</span><br><span class="line">        parent[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;UnionFind&#123;parent, n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Find(x <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> uf.parent[x] != x &#123;</span><br><span class="line">        uf.parent[x] = uf.parent[uf.parent[x]] <span class="comment">// 路径压缩</span></span><br><span class="line">        x = uf.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Union(x, y <span class="type">int</span>) &#123;</span><br><span class="line">    rootX := uf.Find(x)</span><br><span class="line">    rootY := uf.Find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.parent[rootX] = rootY</span><br><span class="line">    uf.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-前缀和与差分数组"><a href="#6-前缀和与差分数组" class="headerlink" title="6. 前缀和与差分数组"></a>6. 前缀和与差分数组</h2><h3 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="keyword">type</span> PrefixSum <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrefixSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> *PrefixSum &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    prefix := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        prefix[i] = prefix[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PrefixSum&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PrefixSum)</span></span> Query(i, j <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ps.prefix[j+<span class="number">1</span>] - ps.prefix[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="keyword">type</span> NumMatrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> NumMatrix &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NumMatrix&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    prefix := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        prefix[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            prefix[i][j] = prefix[i<span class="number">-1</span>][j] + prefix[i][j<span class="number">-1</span>] - prefix[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NumMatrix&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumMatrix)</span></span> SumRegion(row1 <span class="type">int</span>, col1 <span class="type">int</span>, row2 <span class="type">int</span>, col2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.prefix[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - this.prefix[row1][col2+<span class="number">1</span>] - this.prefix[row2+<span class="number">1</span>][col1] + this.prefix[row1][col1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><h3 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElements</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> res &#123;</span><br><span class="line">        res[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125; <span class="comment">// 存储索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++ &#123;</span><br><span class="line">        num := nums[i%n]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; num &gt; nums[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            res[top] = num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heights = <span class="built_in">append</span>(heights, <span class="number">0</span>) <span class="comment">// 哨兵</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;           <span class="comment">// 哨兵</span></span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(heights); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            h := heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            w := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">            maxArea = max(maxArea, h*w)</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各题型解题要点总结"><a href="#各题型解题要点总结" class="headerlink" title="各题型解题要点总结"></a>各题型解题要点总结</h2><ol>
<li><p><strong>双指针</strong>：</p>
<ul>
<li>数组问题：注意有序数组的特殊性质</li>
<li>滑动窗口：明确窗口收缩条件，维护窗口状态</li>
</ul>
</li>
<li><p><strong>DFS&#x2F;BFS</strong>：</p>
<ul>
<li>树遍历：前中后序选择取决于问题需求</li>
<li>回溯：注意状态恢复，剪枝优化</li>
</ul>
</li>
<li><p><strong>动态规划</strong>：</p>
<ul>
<li>明确状态定义和转移方程</li>
<li>考虑空间优化（滚动数组）</li>
</ul>
</li>
<li><p><strong>贪心算法</strong>：</p>
<ul>
<li>证明贪心选择的正确性</li>
<li>通常需要先排序</li>
</ul>
</li>
<li><p><strong>并查集</strong>：</p>
<ul>
<li>路径压缩和按秩合并优化</li>
<li>处理连通分量问题</li>
</ul>
</li>
<li><p><strong>前缀和&#x2F;差分</strong>：</p>
<ul>
<li>前缀和用于快速区间查询</li>
<li>差分数组用于快速区间更新</li>
</ul>
</li>
<li><p><strong>单调栈</strong>：</p>
<ul>
<li>维护栈内元素的单调性</li>
<li>用于解决”下一个更大&#x2F;小元素”类问题</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Golang slice作为参数传递给函数需要使用指针</title>
    <url>/2024-04-11-22166b2f52d0.html</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dfs(<span class="number">1</span>,n,k,&amp;res,&amp;[]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s, n, k <span class="type">int</span>, res *[][]<span class="type">int</span>, item *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*item) == k &#123;</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, *item...))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := s; i &lt;= n-(k-<span class="built_in">len</span>(*item))+<span class="number">1</span>; i++&#123;</span><br><span class="line">        *item = <span class="built_in">append</span>(*item, i)</span><br><span class="line">        dfs(i+<span class="number">1</span>, n, k, res, item)</span><br><span class="line">        *item = (*item)[:<span class="built_in">len</span>(*item)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 <strong>append 函数或者直接索引赋值的方式，</strong>那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。</p>
<p>这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。</p>
<p>例如，在 <code>combine</code> 函数中，如果想要 <code>dfs</code> 函数能够修改 <code>res</code> slice 的长度（即添加新的组合到 <code>res</code> 中），那么需要传递 <code>res</code> 的指针的指针。这样，当 <code>dfs</code> 函数执行 <code>*res = append(*res, newCombination...)</code> 时，它会修改原始的 <code>res</code> slice 而不是它的副本。</p>
<p>传递指针的原因是为了：</p>
<ol>
<li><p><strong>避免不必要的副本创建</strong>：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。</p>
</li>
<li><p><strong>确保函数内部的修改能够反映到原始数据上</strong>：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。</p>
</li>
<li><p><strong>提高代码的效率和性能</strong>：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。</p>
</li>
</ol>
<p>还可以转化为全局变量；需要注意的是<br>go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res [][]<span class="type">int</span> <span class="comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 需要进行初始化</span></span><br><span class="line">    path = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 结束条件</span></span><br><span class="line">	<span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(n, k ,startIdx <span class="type">int</span>)</span></span></span><br><span class="line">	backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k ,startIdx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 提前返回需要return</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            pathTmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(path))</span><br><span class="line">			<span class="built_in">copy</span>(pathTmp, path)</span><br><span class="line">			res = <span class="built_in">append</span>(res, pathTmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := startIdx;i&lt;= n ;i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path,i)</span><br><span class="line">			backtracking(n,k,i+<span class="number">1</span>)</span><br><span class="line">			path = path[:(<span class="built_in">len</span>(path) <span class="number">-1</span>)]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtracking(n,k,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; <strong>tempPath :&#x3D; []int{}</strong>,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。<br>copy(tempPath, path)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res [][]<span class="type">int</span> <span class="comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    path = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 结束条件</span></span><br><span class="line">	<span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span></span><br><span class="line">    backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>, startIndex <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            tempPath := <span class="built_in">make</span>([]<span class="type">int</span>, k) <span class="comment">// tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。</span></span><br><span class="line">            <span class="built_in">copy</span>(tempPath, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tempPath)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:= startIndex; i &lt;= n; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (n -i +<span class="number">1</span> ) &lt; (k -<span class="built_in">len</span>(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            backtracking(n, k, i+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	backtracking(n,k,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 使用new创建slice</title>
    <url>/2024-07-21-01f71b57e534.html</url>
    <content><![CDATA[<p>在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。</p>
<p>然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s *[]<span class="type">int</span> <span class="comment">// 声明一个指向int类型slice的指针</span></span><br><span class="line">s = <span class="built_in">new</span>([]<span class="type">int</span>) <span class="comment">// 分配一个int类型的slice，并将其地址赋给s</span></span><br></pre></td></tr></table></figure>

<p>但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, length, capacity) <span class="comment">// 创建一个长度为 length，容量为 capacity 的int类型slice</span></span><br></pre></td></tr></table></figure>

<p>如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">*s = <span class="built_in">make</span>([]<span class="type">int</span>, length, capacity) <span class="comment">// 通过解引用指针并使用make来初始化slice</span></span><br></pre></td></tr></table></figure>

<p>在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 学习资料</title>
    <url>/2025-06-15-4bfc586514c9.html</url>
    <content><![CDATA[<p><a href="https://github.com/anzhihe/learning/blob/8de2b0bd2ad36d296e1808080073cdb8521627af/golang/README.md?plain=1#L26">learning&#x2F;golang&#x2F;README.md at 8de2b0bd2ad36d296e1808080073cdb8521627af · anzhihe&#x2F;learning</a></p>
<h2 id="Golang-learning-book-and-source-code-Head-First-Go英文版-Go程序设计语言-Go语言实战-Go语言核心编程笔记-Go学习笔记-第四版-Go源码剖析（书签版）-Go-web-编程-Go-Web-编程-Go并发编程实战-第1版-Go并发编程实战-第2版-Lite-Go语言并发之道-Go网络编程-Go语言圣经-中文版-2020最新Gin框架中文文档-大厂Go工程师面试题集锦-Golang常见面试题目解析"><a href="#Golang-learning-book-and-source-code-Head-First-Go英文版-Go程序设计语言-Go语言实战-Go语言核心编程笔记-Go学习笔记-第四版-Go源码剖析（书签版）-Go-web-编程-Go-Web-编程-Go并发编程实战-第1版-Go并发编程实战-第2版-Lite-Go语言并发之道-Go网络编程-Go语言圣经-中文版-2020最新Gin框架中文文档-大厂Go工程师面试题集锦-Golang常见面试题目解析" class="headerlink" title="Golang learning book and source code- Head First Go英文版- Go程序设计语言- Go语言实战- Go语言核心编程笔记- Go学习笔记 第四版- Go源码剖析（书签版）- Go_web_编程- Go Web 编程- Go并发编程实战_第1版- Go并发编程实战_第2版_Lite- Go语言并发之道- Go网络编程- Go语言圣经(中文版)- 2020最新Gin框架中文文档- 大厂Go工程师面试题集锦- Golang常见面试题目解析"></a>Golang learning <a href="/golang/book"><strong>book</strong></a> and source code<br>- <a href="/golang/book/Head%20First%20Go.pdf">Head First Go英文版</a><br>- <a href="/golang/book/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E8%AF%A6%E7%BB%86%E4%B9%A6%E7%AD%BE%E3%80%81%E6%B8%85%E6%99%B0%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89.pdf">Go程序设计语言</a><br>- <a href="/golang/book/Go%20%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98.pdf">Go语言实战</a><br>- <a href="/golang/book/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9F%A9%E9%A1%BA%E5%B9%B3.zip">Go语言核心编程笔记</a><br>- <a href="/golang/book/Go%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">Go学习笔记 第四版</a><br>- <a href="/golang/book/Go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf">Go源码剖析（书签版）</a><br>- <a href="/golang/book/Go_web_%E7%BC%96%E7%A8%8B.pdf">Go_web_编程</a><br>- <a href="/golang/book/Go%20Web%20%E7%BC%96%E7%A8%8B.pdf">Go Web 编程</a><br>- <a href="/golang/book/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E7%AC%AC1%E7%89%88.pdf">Go并发编程实战_第1版</a><br>- <a href="/golang/book/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E7%AC%AC2%E7%89%88_Lite.pdf">Go并发编程实战_第2版_Lite</a><br>- <a href="https://drive.google.com/file/d/1_i-G4EQABtfhTsfgbPmXS5MOIjn6qd7M/view?usp=sharing">Go语言并发之道</a><br>- <a href="/golang/book/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.pdf">Go网络编程</a><br>- <a href="/golang/book/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F(%E4%B8%AD%E6%96%87%E7%89%88).pdf">Go语言圣经(中文版)</a><br>- <a href="/golang/book/2020%E6%9C%80%E6%96%B0Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-%E7%BF%BB%E8%AF%91-asong-%E6%97%A0%E6%B0%B4%E5%8D%B0%E7%89%88%E6%9C%ACV1.1.pdf">2020最新Gin框架中文文档</a><br>- <a href="/golang/book/%E5%A4%A7%E5%8E%82Go%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.docx">大厂Go工程师面试题集锦</a><br>- <a href="/golang/book/Golang%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90.pdf">Golang常见面试题目解析</a></h2><ul>
<li><a href="https://golang.org/">Golang官网</a></li>
<li><a href="https://golang.org/doc/">Golang doc</a></li>
<li><a href="https://blog.golang.org/">The Go Blog</a></li>
<li><a href="https://github.com/golang/go">Golang github</a></li>
<li><a href="https://gobyexample.com/">Go by Example</a></li>
<li><a href="https://play.golang.org/">The Go Playground</a></li>
<li><a href="https://segmentfault.com/a/1190000013739000">Golang 新手可能会踩的 50 个坑</a></li>
<li><a href="https://gfw.go101.org/article/101.html">Go语言101</a></li>
<li><a href="https://studygolang.com/">Go语言中文网</a></li>
<li><a href="https://github.com/unknwon/go-study-index">Go 语言学习资料与社区索引</a></li>
<li><a href="https://github.com/dariubs/GoBooks">Go Books</a></li>
<li><a href="https://github.com/unknwon/the-way-to-go_ZH_CN">《Go入门指南》</a></li>
<li><a href="http://c.biancheng.net/golang/">《Go语言入门教程》</a></li>
<li><a href="https://github.com/astaxie/build-https://github.com/unknwon/go-study-indexweb-application-with-golang">build-web-application-with-golang</a></li>
<li><a href="https://github.com/linehk/gopl">Go 程序设计语言代码示例和练习题参考答案</a></li>
<li><a href="https://golang.design/under-the-hood/">Go 语言原本</a></li>
<li><a href="https://golang2.eddycjy.com/">Go 语言编程之旅</a></li>
<li><a href="https://lailin.xyz/post/singleton.html">Go设计模式</a></li>
<li><a href="https://www.topgoer.cn/">地鼠文档</a></li>
<li><a href="https://chegva.com/5202.html">Go语言快速入门实战开发</a></li>
</ul>
<p>参考：<a href="https://github.com/anzhihe/learning.git">https://github.com/anzhihe/learning.git</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言-byte和rune 有什么区别 byte rune 转为int</title>
    <url>/2023-05-11-257639a12a8e.html</url>
    <content><![CDATA[<p>在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。</p>
<p>byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。<br>rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。<br>因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。</p>
<p>将 byte 或 rune 转换为 int 可以使用类型转换操作符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="type">byte</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">i := <span class="type">int</span>(b) - <span class="type">int</span>(<span class="string">&#x27;0&#x27;</span>) <span class="comment">// 将 byte &#x27;0&#x27; 转换为 int 0</span></span><br><span class="line"><span class="comment">// 上边可以简写为</span></span><br><span class="line">i := b - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">r := <span class="type">rune</span>(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line">i := <span class="type">int</span>(r)             <span class="comment">// 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点）</span></span><br></pre></td></tr></table></figure>

<p>将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line">b := <span class="type">byte</span>(i)   <span class="comment">// 溢出！编译器会忽略高位部分，直接取低位部分的字节</span></span><br><span class="line">r := <span class="type">rune</span>(i)</span><br><span class="line"><span class="keyword">if</span> r &lt; <span class="number">0xFFFF</span> &#123;</span><br><span class="line">    r = <span class="type">rune</span>(b) <span class="comment">// 类型断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言-copy</title>
    <url>/2023-05-11-27c67ecef2a3.html</url>
    <content><![CDATA[<p>在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。</p>
<p>使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含元素的数组</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 定义要删除的元素下标</span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line"><span class="comment">// 利用 append 函数和 copy 函数删除指定下标的元素</span></span><br><span class="line"><span class="built_in">copy</span>(a[index:], a[index+<span class="number">1</span>:])</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 打印删除后的数组</span></span><br><span class="line">fmt.Println(a) <span class="comment">// 输出 [1 2 4 5]</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。</p>
<p>在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。</p>
<p>在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。</p>
<p>在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(a[index:], a[index+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言-多态</title>
    <url>/2023-04-20-af074e588287.html</url>
    <content><![CDATA[<p>Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。</p>
<p>我们来实现这样一个例子：</p>
<ul>
<li>实现猫和狗<strong>两个对象</strong>，并且他们都有动作：叫，<strong>但叫声不同</strong>。再实现一个<strong>对象鸟</strong>，他除了叫，还会<strong>飞</strong>。</li>
</ul>
<p>下面是基于Go语言，实现题目要求的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Cry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Cry() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Cry() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Cry() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;叽叽喳喳&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bird)</span></span> Fly() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我会飞&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> animal Animal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一只猫</span></span><br><span class="line">    animal = Cat&#123;&#125;</span><br><span class="line">    animal.Cry()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一只狗</span></span><br><span class="line">    animal = Dog&#123;&#125;</span><br><span class="line">    animal.Cry()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一只鸟</span></span><br><span class="line">    bird := Bird&#123;&#125;</span><br><span class="line">    animal = bird</span><br><span class="line">    animal.Cry()</span><br><span class="line">    bird.Fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。</p>
<p>运行上述代码，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">喵喵喵</span><br><span class="line">汪汪汪</span><br><span class="line">叽叽喳喳</span><br><span class="line">我会飞</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们使用了<strong>接口的多态特性</strong>，通过定义<strong>Animal接口</strong>，实现了<strong>不同类型的对象之间的通用性</strong>，并且在<strong>Bird中新增了Fly() 方法</strong>，符合面向对象的<strong>开放封闭原则</strong>。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言-接口</title>
    <url>/2023-04-20-89710477a7ed.html</url>
    <content><![CDATA[<p>在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。</p>
<p>以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> Print() &#123;</span><br><span class="line">    fmt.Println(u.name,<span class="string">&quot;我爱加班&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAll</span><span class="params">(ps []Printer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> ps &#123;</span><br><span class="line">        p.Print()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ps []Printer</span><br><span class="line">    ps = <span class="built_in">append</span>(ps, User&#123;<span class="string">&quot;Alice&quot;</span>&#125;)</span><br><span class="line">    ps = <span class="built_in">append</span>(ps, User&#123;<span class="string">&quot;Bob&quot;</span>&#125;)</span><br><span class="line">    printAll(ps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Alice 我爱加班</span><br><span class="line">Bob 我爱加班</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们通过接口将<strong>User类型</strong>与PrintAll() 函数解耦，这样当我们需要添加<strong>新的类型时，只需要实现Print()方法</strong>即可，而不需要修改<strong>PrintAll()函数实现</strong>。</p>
<p>比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改<strong>PrintAll()函数实现</strong>。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，<strong>有相同的特征</strong>，我们将其抽象出来，降低代码耦合性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Boss <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Boss)</span></span> Print() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你明天不用来了&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照<strong>合同的规定</strong>进行处理。</p>
<p>同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言删除指定索引元素</title>
    <url>/2023-05-10-741623f2e4fb.html</url>
    <content><![CDATA[<p>在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。</p>
<p>以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    i := <span class="number">2</span> <span class="comment">// 要删除的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片</span></span><br><span class="line">    b := <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">    fmt.Println(b) <span class="comment">// 输出 [1 2 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。</p>
<p>接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。</p>
<p>最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言指定索引插入元素</title>
    <url>/2023-05-10-5e3b5c8e7446.html</url>
    <content><![CDATA[<p>在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。</p>
<p>下面是一个示例代码，它插入一个元素到切片的第二个位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    i := <span class="number">1</span> <span class="comment">// 要插入的位置</span></span><br><span class="line">    b := <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">5</span>&#125;, a[i:]...)...) <span class="comment">// 在切片的第二个位置插入数字5</span></span><br><span class="line">    fmt.Println(b) <span class="comment">// 输出 [1 5 2 3 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。</p>
<p>接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。</p>
<p>最后，我们将结果赋值给变量 b 并打印输出它。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>goland中debug 无法显示全局变量解决</title>
    <url>/2024-05-07-c105be0dd846.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240508002347.png">实际只会有局部变量，没有全局变量test</p>
<p><img src="/../../imgs/Pasted%20image%2020240508002425.png"></p>
<p>解决方法：</p>
<p>右键  选择+ New Watch ； 或者 按按键 Insert </p>
<p>添加变量 test 即可</p>
<p><img src="/../../imgs/Pasted%20image%2020240508002502.png"><img src="/../../imgs/Pasted%20image%2020240508002708.png"></p>
<h1 id="添加成功"><a href="#添加成功" class="headerlink" title="添加成功"></a>添加成功</h1><p><img src="/../../imgs/Pasted%20image%2020240508002737.png"><br>之后每次单步执行都会显示变量结果：<br><img src="/../../imgs/Pasted%20image%2020240508002814.png"></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang slice无法添加指针</title>
    <url>/2024-05-02-247b79126fb5.html</url>
    <content><![CDATA[<p>在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向<code>int</code>的指针，比如<code>timePtr *int</code>，你可以通过<code>*timePtr</code>来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。</p>
<p>在你提供的<code>add</code>函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(timePtr *<span class="type">int</span>)</span></span> &#123; *timePtr += <span class="number">1</span> &#125; <span class="comment">// 增加一秒</span></span><br></pre></td></tr></table></figure>

<p><code>timePtr</code>是一个指向<code>int</code>的指针。虽然你可以通过<code>*timePtr</code>来间接修改它所指向的<code>int</code>值，但是你不能使用这个指针来创建一个关于<code>*int</code>的切片。原因如下：</p>
<ol>
<li><p><strong>指针的值是地址</strong>：<code>timePtr</code>变量存储的是<code>currentTime</code>变量的内存地址，而不是<code>currentTime</code>的值。切片是基于数组的，它们需要一个具体的数据集合来创建。</p>
</li>
<li><p><strong>切片的元素类型</strong>：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于<code>*int</code>的切片，<strong>因为切片的元素类型是</strong><code>int</code>，而不是<code>*int</code>（指向<code>int</code>的指针）。</p>
</li>
<li><p><strong>切片创建语法</strong>：创建切片通常需要一个数组或另一个切片作为基础，或者使用<code>make</code>函数指定长度和容量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">slice1 := arr[:] <span class="comment">// 基于数组的切片</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 使用make创建切片</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在<code>main</code>函数中声明这样一个切片，并在CRUD操作中更新它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentTime <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> history []<span class="type">int</span> <span class="comment">// 用于记录历史时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(timePtr *<span class="type">int</span>, historyPtr *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *timePtr++</span><br><span class="line">    historyPtr = <span class="built_in">append</span>(*historyPtr, *timePtr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    currentTime = <span class="number">0</span></span><br><span class="line">    history = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 初始化历史切片</span></span><br><span class="line"></span><br><span class="line">    add(&amp;currentTime, &amp;history)</span><br><span class="line">    <span class="comment">// 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;History of times:&quot;</span>, history)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>history</code>是一个切片，用于存储时间点的历史记录。每次调用<code>add</code>函数时，我们不仅更新<code>currentTime</code>，还将新的时间点添加到<code>history</code>切片中。注意，由于切片是引用类型，我们传递<code>&amp;history</code>来允许函数修改原始切片。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang 中格式化打印单个字符</title>
    <url>/2024-05-03-ec16a5fd018e.html</url>
    <content><![CDATA[<p>在Go语言中，<code>fmt.Printf</code> 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。</p>
<p><code>%c</code> 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 <code>fmt.Printf</code> 中使用 <code>%c</code>，并且传入一个整数（<code>int</code> 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> codePoint <span class="type">int</span> = <span class="number">65</span> <span class="comment">// ASCII码中A的码点</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, codePoint) <span class="comment">// 输出: A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 <code>codePoint</code> 的值为 <code>65</code>，它是大写字母 “A” 在ASCII编码中的码点。<code>fmt.Printf(&quot;%c\n&quot;, codePoint)</code> 将这个整数值格式化为字符 “A” 并输出。</p>
<p>在处理字节数组 <code>[]byte</code> 并想要将每个字节转换为对应的字符时，<code>%c</code> 非常有用，因为Go的 <code>string</code> 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    bytes := []<span class="type">byte</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, b := <span class="keyword">range</span> bytes &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Byte %d: %c\n&quot;</span>, i, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// Byte 0: h</span></span><br><span class="line">    <span class="comment">// Byte 1: e</span></span><br><span class="line">    <span class="comment">// Byte 2: l</span></span><br><span class="line">    <span class="comment">// Byte 3: l</span></span><br><span class="line">    <span class="comment">// Byte 4: o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们遍历字符串 <code>&quot;hello&quot;</code> 的字节表示，并使用 <code>%c</code> 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <url>/2024-02-24-4fbd7a88bf6f.html</url>
    <content><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p>
<pre><code>*res = append(*res, root.Val)
dfs(root.Left, res)
dfs(root.Right, res)
</code></pre>
<p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p>
<p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p>
<p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p>
<p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang 堆中返回的值为什么是最后一个，不是0位</title>
    <url>/2025-06-12-6ce91bef2b21.html</url>
    <content><![CDATA[<p>这涉及到 Go 中 <code>sort.Slice</code> 和堆(<code>container/heap</code>) 实现的<strong>关键区别</strong>。虽然它们都使用 <code>Less</code> 函数，但行为完全不同：</p>
<h3 id="1-sort-Slice-的-Less-函数（排序场景）"><a href="#1-sort-Slice-的-Less-函数（排序场景）" class="headerlink" title="1. sort.Slice 的 Less 函数（排序场景）"></a>1. <code>sort.Slice</code> 的 <code>Less</code> 函数（排序场景）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age <span class="comment">// 升序排序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：直接定义最终排序顺序</li>
<li><strong>结果</strong>：当 <code>people[i].Age &lt; people[j].Age</code> 时，<code>i</code> 会排在 <code>j</code> 前面 → <strong>升序排列</strong></li>
<li><strong>内存布局</strong>：切片物理位置就是有序的，索引0是最小值，最后索引是最大值</li>
</ul>
<h3 id="2-堆的-Less-函数（堆场景）"><a href="#2-堆的-Less-函数（堆场景）" class="headerlink" title="2. 堆的 Less 函数（堆场景）"></a>2. 堆的 <code>Less</code> 函数（堆场景）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> h[i] &lt; h[j] <span class="comment">// 最小堆定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：定义堆的<strong>父子节点关系</strong>（不是最终排序顺序！）</li>
<li><strong>堆性质</strong>：在最小堆中，任意父节点 ≤ 子节点</li>
<li><strong>内存布局</strong>：堆是<strong>半排序</strong>的树状结构（数组实现）：<ul>
<li>索引0位置是<strong>根节点（最小值）</strong></li>
<li>最后一个元素位置<strong>不固定</strong>（可能大也可能小）</li>
</ul>
</li>
</ul>
<h3 id="关键区别：Pop-的实现"><a href="#关键区别：Pop-的实现" class="headerlink" title="关键区别：Pop() 的实现"></a>关键区别：<code>Pop()</code> 的实现</h3><p>堆的 <code>Pop()</code> 操作有特殊处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]  <span class="comment">// 取出最后一个元素</span></span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么取最后一个元素？</strong> 因为在标准库 <code>heap.Pop()</code> 中已经做了前置操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准库 heap.Pop() 的伪代码：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := h.Len()</span><br><span class="line">    h.Swap(<span class="number">0</span>, n<span class="number">-1</span>)  <span class="comment">// 关键！交换根节点(最小值)和最后一个节点</span></span><br><span class="line">    down(h, <span class="number">0</span>, n<span class="number">-1</span>) <span class="comment">// 重新堆化</span></span><br><span class="line">    <span class="keyword">return</span> h.Pop()   <span class="comment">// 此时调用用户实现的Pop（取最后元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆操作流程（最小堆为例）"><a href="#堆操作流程（最小堆为例）" class="headerlink" title="堆操作流程（最小堆为例）"></a>堆操作流程（最小堆为例）</h3><ol>
<li><p><strong>初始化堆</strong>：<code>[3, 1, 5]</code> → 堆化后: <code>[1, 3, 5]</code></p>
<ul>
<li>索引0&#x3D;1（最小值）</li>
<li>最后索引&#x3D;5</li>
</ul>
</li>
<li><p><strong><code>heap.Pop()</code> 内部过程</strong>：</p>
<ul>
<li>交换根节点和最后节点: <code>[5, 3, 1]</code></li>
<li>重新堆化前n-1个元素: <code>[3, 5]</code> → 堆化后 <code>[3, 5]</code></li>
<li>调用用户 <code>Pop()</code> 返回最后元素 <code>1</code>（最小值）</li>
</ul>
</li>
<li><p><strong>结果</strong>：</p>
<ul>
<li>堆变为 <code>[3, 5]</code></li>
<li>弹出值 <code>1</code>（最小值）</li>
</ul>
</li>
</ol>
<h3 id="为什么最后位置不是最大值？"><a href="#为什么最后位置不是最大值？" class="headerlink" title="为什么最后位置不是最大值？"></a>为什么最后位置不是最大值？</h3><ul>
<li>堆的<strong>物理存储不是全排序的</strong>，只保证父≤子</li>
<li>最后一个元素是<strong>最后一片叶子节点</strong>，可能很小也可能很大</li>
<li>通过 <code>Swap(0, n-1)</code> 操作，实际弹出的是原根节点（最小值）</li>
</ul>
<h3 id="堆的视觉表示"><a href="#堆的视觉表示" class="headerlink" title="堆的视觉表示"></a>堆的视觉表示</h3><p>初始数组：<code>[3, 1, 5]</code><br>堆化后内存布局：<code>[1, 3, 5]</code><br>树状结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1    (根节点=最小值)</span><br><span class="line"> / \</span><br><span class="line">3   5  (5是最后一个叶子节点)</span><br></pre></td></tr></table></figure>
<p>Pop 时交换根和最后叶子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5    (临时根)</span><br><span class="line"> / </span><br><span class="line">3    [1被交换到最后位置]</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>sort.Slice</code></th>
<th><code>container/heap</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Less</code> 作用</td>
<td>定义最终排序顺序</td>
<td>定义父子节点关系</td>
</tr>
<tr>
<td>内存布局</td>
<td>完全有序</td>
<td>半有序（树状结构）</td>
</tr>
<tr>
<td>索引0位置</td>
<td>最小值（升序时）</td>
<td>根节点（最小值）</td>
</tr>
<tr>
<td>最后索引位置</td>
<td>最大值（升序时）</td>
<td>不固定（最后一个叶子节点）</td>
</tr>
<tr>
<td><code>Pop()</code> 行为</td>
<td>无此操作</td>
<td>返回交换后的最后一个元素（原根节点）</td>
</tr>
</tbody></table>
<p>因此，在堆实现中：</p>
<ul>
<li><code>h[i] &lt; h[j]</code> 定义的是最小堆（根节点最小）</li>
<li><code>Pop()</code> 返回最小值，因为标准库在调用用户 <code>Pop()</code> 前已交换了根节点和最后节点</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>go语言-回调函数（钩子）</title>
    <url>/2023-05-25-2cbe3a05ec00.html</url>
    <content><![CDATA[<p>在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。</p>
<p>以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printWithCallback</span><span class="params">(callback <span class="keyword">func</span>(<span class="type">string</span>)</span></span>) &#123;</span><br><span class="line">    text := <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">    fmt.Println(text)</span><br><span class="line">    callback(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    callback := <span class="function"><span class="keyword">func</span><span class="params">(text <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Printed: %s\n&quot;</span>, text)</span><br><span class="line">    &#125;</span><br><span class="line">    printWithCallback(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。</p>
<p>当程序运行起来后，会输出如下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">Printed: Hello, world!</span><br></pre></td></tr></table></figure>

<p>这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。</p>
<p>对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeElapsedCallback</span><span class="params">(start time.Time)</span></span> &#123;</span><br><span class="line">    elapsed := time.Now().Sub(start)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heavyCalculation</span><span class="params">(callback <span class="keyword">func</span>(time.Time)</span></span>) &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="comment">// 这里进行任何需要测量时间的操作</span></span><br><span class="line">    callback(start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    heavyCalculation(TimeElapsedCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。</p>
<p>在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容：</p>
<p>Time elapsed: 1.001201ms<br>以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。</p>
<h2 id="回调函数的不同"><a href="#回调函数的不同" class="headerlink" title="回调函数的不同"></a>回调函数的不同</h2><p>以下是不使用回调函数的方式实现计算程序执行时间的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heavyCalculation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="comment">// 这里进行任何需要测量时间的操作</span></span><br><span class="line">    elapsed := time.Since(start)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    heavyCalculation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。</p>
<p>在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。</p>
<p>当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。</p>
<p>使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。</p>
<p>而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。</p>
<p>钩子函数的使用场景非常广泛，在几乎<strong>所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。</strong></p>
<h2 id="以下是使用回调函数的优点："><a href="#以下是使用回调函数的优点：" class="headerlink" title="以下是使用回调函数的优点："></a>以下是使用回调函数的优点：</h2><p>灵活性：可以轻松地将自定义代码插入到已有的代码流程中。<br>可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。<br>易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。<br>总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2025-06-17-fc658b18e8e3.html</url>
    <content><![CDATA[<p>在 Go 语言中，<code>switch</code> 语句提供了灵活的条件分支控制，相比其他语言有更多特性。以下是详细用法和示例：</p>
<hr>
<h3 id="1-基础值匹配"><a href="#1-基础值匹配" class="headerlink" title="1. 基础值匹配"></a>1. <strong>基础值匹配</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">day := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> day &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Wednesday&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Thursday&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Weekend&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-多值匹配（逗号分隔）"><a href="#2-多值匹配（逗号分隔）" class="headerlink" title="2. 多值匹配（逗号分隔）"></a>2. <strong>多值匹配（逗号分隔）</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">char := <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Vowel&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sometimes vowel&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Consonant&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-无表达式（替代-if-else）"><a href="#3-无表达式（替代-if-else）" class="headerlink" title="3. 无表达式（替代 if-else）"></a>3. <strong>无表达式（替代 if-else）</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">score := <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">80</span>: <span class="comment">// 满足条件</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-类型判断（Type-Switch）"><a href="#4-类型判断（Type-Switch）" class="headerlink" title="4. 类型判断（Type Switch）"></a>4. <strong>类型判断（Type Switch）</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">switch</span> v := data.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Integer:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;String:&quot;</span>, v) <span class="comment">// 输出: String: hello</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-穿透执行（fallthrough）"><a href="#5-穿透执行（fallthrough）" class="headerlink" title="5. 穿透执行（fallthrough）"></a>5. <strong>穿透执行（fallthrough）</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;One&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Two&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">fallthrough</span>        <span class="comment">// 强制执行下一个 case</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Three&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Two\nThree</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-初始化语句"><a href="#6-初始化语句" class="headerlink" title="6. 初始化语句"></a>6. <strong>初始化语句</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> lang := <span class="string">&quot;Go&quot;</span>; lang &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Java&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Enterprise&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Go&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Efficient&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键特性总结："><a href="#关键特性总结：" class="headerlink" title="关键特性总结："></a>关键特性总结：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自动终止</strong></td>
<td>无需 <code>break</code>，执行完 case 后自动退出 switch</td>
</tr>
<tr>
<td><strong>多值匹配</strong></td>
<td>用逗号分隔多个值（如 <code>case 1, 2, 3</code>）</td>
</tr>
<tr>
<td><strong>无表达式模式</strong></td>
<td>类似 <code>if-else</code> 链，更简洁的条件分支</td>
</tr>
<tr>
<td><strong>类型判断</strong></td>
<td>通过 <code>data.(type)</code> 检测接口值的实际类型</td>
</tr>
<tr>
<td><strong>fallthrough</strong></td>
<td>显式声明继续执行下一个 case（<strong>不判断条件</strong>）</td>
</tr>
<tr>
<td><strong>作用域隔离</strong></td>
<td>支持在 <code>switch</code> 后初始化局部变量（如 <code>switch x := 10; &#123; ... &#125;</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> hour := time.Now().Hour(); &#123;</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Morning&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">18</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Afternoon&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Night&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Go 的 <code>switch</code> 设计强调简洁和安全，避免 C&#x2F;C++ 中因忘记 <code>break</code> 导致的错误。根据场景选择合适用法可大幅提升代码可读性。</p>
</blockquote>
]]></content>
      <categories>
        <category>G</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】slice append 和copy对比</title>
    <url>/2025-06-16-fa2f5d4a144d.html</url>
    <content><![CDATA[<h1 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, info)</span><br><span class="line">		<span class="built_in">copy</span>(result[info[<span class="number">1</span>] +<span class="number">1</span>:], result[info[<span class="number">1</span>]:])<span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">		result[info[<span class="number">1</span>]] = info<span class="comment">//将插入元素位置插入元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc reconstructQueue(people [][]<span class="type">int</span>) [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, info)</span><br><span class="line">		pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 在 pos 处分割并拼接</span></span><br><span class="line">        result[pos] = info      <span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/Pasted%20image%2020250616235439.png"><br>两个 <code>reconstructQueue</code> 函数的主要区别在于 <strong>插入元素的方式</strong>，而第二个版本能通过是因为它正确处理了 <strong>切片的动态扩容和元素移动</strong></p>
<hr>
<h3 id="关键问题分析"><a href="#关键问题分析" class="headerlink" title="关键问题分析"></a><strong>关键问题分析</strong></h3><h4 id="1-第一个版本的问题（Slice-操作）"><a href="#1-第一个版本的问题（Slice-操作）" class="headerlink" title="1. 第一个版本的问题（Slice 操作）"></a>1. <strong>第一个版本的问题（Slice 操作）</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line">pos := info[<span class="number">1</span>]</span><br><span class="line">result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 尝试在 pos 处腾出位置</span></span><br><span class="line">result[pos] = info                     <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure>
<p><strong>问题原因</strong>：</p>
<ul>
<li><strong><code>append(result[:pos+1], result[pos:]...)</code> 会导致数据错乱</strong><br>当 <code>pos</code> 不是最后一个位置时，<code>result[pos:]</code> 会包含刚刚追加的 <code>info</code>（因为上一步 <code>append(result, info)</code> 已经增加了长度），导致切片拼接时重复复制元素，最终结果错误。</li>
</ul>
<h4 id="2-第二个版本的正确性（copy-操作）"><a href="#2-第二个版本的正确性（copy-操作）" class="headerlink" title="2. 第二个版本的正确性（copy 操作）"></a>2. <strong>第二个版本的正确性（copy 操作）</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line"><span class="built_in">copy</span>(result[info[<span class="number">1</span>]+<span class="number">1</span>:], result[info[<span class="number">1</span>]:]) <span class="comment">// 正确后移元素</span></span><br><span class="line">result[info[<span class="number">1</span>]] = info                 <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么正确</strong>：</p>
<ul>
<li><code>copy</code> <strong>直接覆盖内存</strong>，不会因 <code>append</code> 的嵌套调用引发数据错乱。</li>
<li>逻辑清晰：先扩展切片，再移动元素，最后插入新值。</li>
</ul>
<hr>
<h3 id="修复第一个版本的方法"><a href="#修复第一个版本的方法" class="headerlink" title="修复第一个版本的方法"></a><strong>修复第一个版本的方法</strong></h3><p>如果仍想用 <strong>Slice 操作</strong>，需避免提前追加元素，改为直接插入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">        pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos], <span class="built_in">append</span>([][]<span class="type">int</span>&#123;info&#125;, result[pos:]...)...) <span class="comment">// 直接插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键修改</strong>：</p>
<ul>
<li>使用 <code>append([][]int&#123;info&#125;, result[pos:]...)</code> 一次性完成插入，避免提前扩展切片。</li>
</ul>
<hr>
<h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a><strong>两种方式的对比</strong></h3><table>
<thead>
<tr>
<th>操作方式</th>
<th>代码示例</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>copy</strong></td>
<td><code>copy(result[pos+1:], result[pos:])</code></td>
<td>内存操作直接，不易出错</td>
<td>代码稍显冗长</td>
</tr>
<tr>
<td><strong>Slice 拼接</strong></td>
<td><code>append(result[:pos], append([][]int&#123;info&#125;, result[pos:]...)...)</code></td>
<td>代码简洁</td>
<td>嵌套 <code>append</code> 可读性略低</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么第二个版本更鲁棒？"><a href="#为什么第二个版本更鲁棒？" class="headerlink" title="为什么第二个版本更鲁棒？"></a><strong>为什么第二个版本更鲁棒？</strong></h3><ol>
<li><strong><code>copy</code> 是底层内存复制</strong><br>不会受切片共享或嵌套 <code>append</code> 的影响，适合需要精确控制内存的场景。</li>
<li><strong><code>append</code> 的嵌套可能导致临时切片</strong><br>在复杂逻辑中容易引入错误（如你的第一个版本）。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>推荐使用 <code>copy</code> 的版本</strong>：逻辑清晰，适合大多数场景。</li>
<li>如果追求代码简洁，可以用修复后的 <strong>Slice 拼接</strong>，但需注意 <code>append</code> 的副作用。</li>
</ul>
<blockquote>
<p><strong>关键教训</strong>：在操作切片时，**避免在同一个逻辑块中混合多次 <code>append</code>**，除非你能确保切片长度的变化不会影响后续操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】Golang 新手可能会踩的 50 个坑</title>
    <url>/2025-06-15-bd60604455f8.html</url>
    <content><![CDATA[<p>转载：<a href="https://github.com/wuYin">wuYin</a>&#x2F;<a href="https://github.com/wuYin/blog">blog</a> </p>
<p>原文：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">50 Shades of Go: Traps, Gotchas, and Common Mistakes</a>，翻译已获作者 <a href="https://twitter.com/kcqon">kcqon</a> 授权。</p>
<span id="more"></span>

<p>不久前发现在知乎这篇质量很高的文章，打算加上自己的理解翻译一遍。文章分为三部分：初级篇 1-34，中级篇 35-50，高级篇 51-57</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p>
<p>如果花时间学习官方 doc、wiki、<a href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>
<h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-一般不能单独放一行"><a href="#1-左大括号-一般不能单独放一行" class="headerlink" title="1. 左大括号 { 一般不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 一般不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>					</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;	<span class="comment">// 无函数体					</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.&#x2F;main.go: missing function body<br>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>注意代码块等特殊情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123; 并不遵守分号注入规则，不会在其后边自动加分，此时可换行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://blog.csdn.net/icyday/article/details/8265864?hmsr=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">Golang中自动加分号的特殊分隔符</a></p>
<h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p>
<p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span> 	<span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> one <span class="type">int</span> 	<span class="comment">// error: one declared and not used</span></span><br><span class="line">	two := <span class="number">2</span>	<span class="comment">// error: two declared and not used</span></span><br><span class="line">	<span class="keyword">var</span> three <span class="type">int</span>	<span class="comment">// error: three declared and not used</span></span><br><span class="line">	three = <span class="number">3</span>		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">	_ = one</span><br><span class="line">	</span><br><span class="line">	two := <span class="number">2</span></span><br><span class="line">	<span class="built_in">println</span>(two)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">	one = three</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">	four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>	<span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span>	<span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span>	<span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = log.Println</span><br><span class="line">	_ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>	<span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	one := <span class="number">0</span></span><br><span class="line">	one, two := <span class="number">1</span>, <span class="number">2</span>	<span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">	one, two = two, one	<span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">	result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data info</span><br><span class="line">	data.result, err := work()	<span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data info</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span>	<span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">	data.result, err = work()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">1</span></span><br><span class="line">	<span class="built_in">println</span>(x)		<span class="comment">// 1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">println</span>(x)	<span class="comment">// 1</span></span><br><span class="line">		x := <span class="number">2</span></span><br><span class="line">		<span class="built_in">println</span>(x)	<span class="comment">// 2	// 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(x)		<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Go 开发者常犯的错，而且不易被发现。</p>
<p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go tool vet -shadow main.go</span></span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure>

<p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$GOPATH</span>/bin/go-nyet main.go</span></span><br><span class="line">main.go:10:3:Shadowing variable `x`</span><br></pre></td></tr></table></figure>



<h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>	<span class="comment">// error: use of untyped nil</span></span><br><span class="line">	_ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">	_ = x</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>		<span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="built_in">cap</span>(m)) 	<span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11.  string 类型的变量值不能为 nil"></a>11.  string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>	<span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;	<span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">		s = <span class="string">&quot;default&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span>	<span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		s = <span class="string">&quot;default&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">		fmt.Println(arr)	<span class="comment">// [7 2 3]</span></span><br><span class="line">	&#125;(x)</span><br><span class="line">	fmt.Println(x)			<span class="comment">// [1 2 3]	// 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		(*arr)[<span class="number">0</span>] = <span class="number">7</span>	</span><br><span class="line">		fmt.Println(arr)	<span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">	&#125;(&amp;x)</span><br><span class="line">	fmt.Println(x)	<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">		fmt.Println(x)	<span class="comment">// [7 2 3]</span></span><br><span class="line">	&#125;(x)</span><br><span class="line">	fmt.Println(x)	<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">		fmt.Println(v)	<span class="comment">// 1 2 3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;	<span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li><p>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</p>
</li>
<li><p>使用“独立”的切片分两步：</p>
</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
<ul>
<li><p>对每个内部 slice 进行内存分配</p>
<p>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">2</span></span><br><span class="line">	y := <span class="number">4</span></span><br><span class="line">	</span><br><span class="line">	table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">	<span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">		table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用“共享底层数组”的切片</li>
</ol>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">	raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">		raw[i] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化原始 slice</span></span><br><span class="line">	fmt.Println(raw, &amp;raw[<span class="number">4</span>])	<span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120 </span></span><br><span class="line">    </span><br><span class="line">	table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">		table[i] = raw[i*w : i*w + w]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])	<span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于多维数组的参考</p>
<p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p>
<p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p>
<h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span></span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>

<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)	<span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;text&quot;</span></span><br><span class="line">	x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>		<span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;text&quot;</span></span><br><span class="line">	xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">	xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>	<span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">	x = <span class="type">string</span>(xBytes)</span><br><span class="line">	fmt.Println(x)	<span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;text&quot;</span></span><br><span class="line">	xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">	xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">	x = <span class="type">string</span>(xRunes)</span><br><span class="line">	fmt.Println(x)	<span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p>
<p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li>
<li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li>
</ul>
<p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p>
<h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<p>这种处理方式和其他语言一样，比如 PHP 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span>	<span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span></span><br><span class="line">string(6) &quot;中文&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span></span><br><span class="line">string(1) &quot;�&quot;	</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span></span><br><span class="line">string(3) &quot;中&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">	fmt.Println(x[<span class="number">0</span>])		<span class="comment">// 97</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">	fmt.Println(utf8.ValidString(str1))	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">	fmt.Println(utf8.ValidString(str2))	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">	str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">	fmt.Println(utf8.ValidString(str3))	<span class="comment">// true	// 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(char))	<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> 返回的是字符串的  byte 数量，而不是像 Python  中那样是计算 Unicode 字符数。</p>
<p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(char))	<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	char := <span class="string">&quot;é&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(char))	<span class="comment">// 3</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(char))	<span class="comment">// 2</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;cafe\u0301&quot;</span>)	<span class="comment">// café	// 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p>
<h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="type">int</span> &#123;</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">2</span>	<span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;	</span><br><span class="line">	z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p>
<h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)		<span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">	log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>
<h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)	<span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4	// 错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)	<span class="comment">// 0x41 0xfe 0x2 0xff 0x4	// 正确</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p>
<p> <img src="https://contents.yinzige.com/map-range.png"></p>
<h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> char &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:	<span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">		<span class="comment">// fallthrough	// 返回 true</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为多条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> char &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code>  只作为运算符而非表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	++i			<span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">	fmt.Println(data[i++])	<span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	i++</span><br><span class="line">	fmt.Println(data[i])	<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(~<span class="number">2</span>)		<span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)		<span class="comment">// 00000010</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)	<span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10000010 [A]</span><br><span class="line">00000010 [B]</span><br><span class="line">11111101 (NOT B)</span><br><span class="line">00000010 ^ 11111111 = 11111101 [B XOR 0xff]</span><br><span class="line">10000010 ^ 00000010 = 10000000 [A XOR B]</span><br><span class="line">10000010 &amp; 00000010 = 00000010 [A AND B]</span><br><span class="line">10000010 &amp;^00000010 = 10000000 [A &#x27;AND NOT&#x27; B]</span><br><span class="line">10000010&amp;(^00000010)= 10000000 [A AND (NOT B)]</span><br></pre></td></tr></table></figure>



<h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)	<span class="comment">// &amp; 优先 +</span></span><br><span class="line">	<span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">	<span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">	<span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)	<span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">	<span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">	<span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">	<span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)	<span class="comment">// | 优先 ^</span></span><br><span class="line">	<span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">	<span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">	<span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>



<h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以  <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)	<span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">	encoded, _ := json.Marshal(in)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(encoded))	<span class="comment">// &#123;&quot;One&quot;:1&#125;	// 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> out MyData</span><br><span class="line">	json.Unmarshal(encoded, &amp;out)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out) 	<span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workerCount := <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> doIt(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)		<span class="comment">// 模拟 goroutine 正在执行 </span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<p> <img src="https://contents.yinzige.com/goroutine-exits.png"></p>
<p>常用解决办法：使用 “WaitGroup”  变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	workerCount := <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p> <img src="https://contents.yinzige.com/dead-goroutine.png"></p>
<p>看起来好像 goroutine 都执行完了，然而报错：</p>
<blockquote>
<p>fatal error: all goroutines are asleep - deadlock!</p>
</blockquote>
<p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p>
<p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	workerCount := <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)	<span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;	<span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p> <img src="https://contents.yinzige.com/right-goroutine.png"></p>
<h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)	<span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">	ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p> <img src="https://contents.yinzige.com/unbuffed-chan.png"></p>
<h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			ch &lt;- idx</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-ch)		<span class="comment">// 输出第一个发送的值</span></span><br><span class="line">	<span class="built_in">close</span>(ch)			<span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)	<span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p> <img src="https://contents.yinzige.com/channnel.png"></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的  goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">				fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行效果：</p>
<p> <img src="https://contents.yinzige.com/normal-channel.png"></p>
<h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil  的 channel"></a>34. 使用了值为 <code>nil </code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<blockquote>
<p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p>
</blockquote>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">		<span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">		<span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> out &lt;- val:</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">				out = <span class="literal">nil</span></span><br><span class="line">				in = inCh</span><br><span class="line">			<span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">				out = outCh</span><br><span class="line">				in = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">0</span>)</span><br><span class="line">	inCh &lt;- <span class="number">1</span></span><br><span class="line">	inCh &lt;- <span class="number">2</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：<br> <img src="https://contents.yinzige.com/runns.png"></p>
<h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num   <span class="type">int</span></span><br><span class="line">	key   *<span class="type">string</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">	this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">	this.num = <span class="number">8</span></span><br><span class="line">	*this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">	this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">	d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">	d.pointerFunc()	<span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">	d.valueFunc()	<span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p> <img src="https://contents.yinzige.com/change-origal.png"></p>
<h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()	<span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p>
<blockquote>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
</blockquote>
<p>应该先检查 HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">	checkError(err)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()	<span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=json</a>: x509: certificate signed by unknown authority</p>
</blockquote>
<p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p>
<ul>
<li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li>
<li>手动调用 <code>defer</code> 来关闭响应体：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p>
<p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)	<span class="comment">// 手动丢弃读取完毕的数据</span></span><br></pre></td></tr></table></figure>

<p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)  </span><br></pre></td></tr></table></figure>



<h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p>
<ul>
<li>直接设置请求变量的 <code>Close </code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li>
<li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	req.Close = <span class="literal">true</span></span><br><span class="line">	<span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)	// 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">	resp, err := http.DefaultClient.Do(req)</span><br><span class="line">	<span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">	client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(resp.StatusCode)	<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	checkError(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需求选择使用场景：</p>
<ul>
<li><p>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</p>
</li>
<li><p>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</p>
</li>
</ul>
<h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])	<span class="comment">// float64</span></span><br><span class="line">	<span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)	<span class="comment">// 类型断言错误</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>panic: interface conversion: interface {} is float64, not int</p>
</blockquote>
<p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p>
<ul>
<li><p>将 int 值转为 float 统一使用</p>
</li>
<li><p>将 decode 后需要的 float 值转为 int 使用</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">	decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 	<span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">  	<span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  	<span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  	decoder.UseNumber()</span><br><span class="line">  	<span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  		log.Fatalln(err)</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">  	err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">	checkError(err)</span><br><span class="line">   	fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">  	<span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  		Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">  	checkError(err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型</p>
<p>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">		[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">		[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">		<span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">			StatusCode <span class="type">uint64</span></span><br><span class="line">			StatusName <span class="type">string</span></span><br><span class="line">			Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">			Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">		checkError(err)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">		err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			result.StatusName = name</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">		err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			result.StatusCode = code</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num     <span class="type">int</span></span><br><span class="line">	fp      <span class="type">float32</span></span><br><span class="line">	<span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">	str     <span class="type">string</span></span><br><span class="line">	char    <span class="type">rune</span></span><br><span class="line">	yes     <span class="type">bool</span></span><br><span class="line">	events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">	handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ref     *<span class="type">byte</span></span><br><span class="line">	raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num    <span class="type">int</span></span><br><span class="line">	checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>		<span class="comment">// 无法比较</span></span><br><span class="line">	doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>		<span class="comment">// 无法比较</span></span><br><span class="line">	m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>	<span class="comment">// 无法比较</span></span><br><span class="line">	bytes  []<span class="type">byte</span>			<span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p>
</blockquote>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   	<span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">	b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>DeepEqual()</code> 并不总适合于比较 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line">	<span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">	v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">	data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">		<span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	encoded, _ := json.Marshal(data)</span><br><span class="line">	<span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">	fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code>  和 <code>strings.EqualFold()</code> </p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p>
<ul>
<li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">	b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">recover</span>()	<span class="comment">// 什么都不会捕捉</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)	<span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">	<span class="built_in">recover</span>()	<span class="comment">// 不会被执行</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		doRecover()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>recobered:  <nil>   panic: not good</p>
</blockquote>
<h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		v *= <span class="number">10</span>		<span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;data: &quot;</span>, data)	<span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		data[i] = v * <span class="number">10</span>	</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;data: &quot;</span>, data)	<span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		v.num *= <span class="number">10</span>	<span class="comment">// 直接使用指针更新</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])	<span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])	<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">	<span class="keyword">return</span> raw[:<span class="number">3</span>]	<span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := get()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])	<span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">	raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])	<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">	res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := get()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])	<span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">	sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">	dir1 := path[:sepIndex]</span><br><span class="line">	dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))		<span class="comment">// AAAA</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))		<span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">	dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">   	<span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))	<span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line">    </span><br><span class="line">	path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))		<span class="comment">// AAAAsuffix</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))		<span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))	<span class="comment">// AAAAsuffix/uffixBBBB	// 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改 </p>
<p>解决方法：</p>
<ul>
<li>重新分配新的 slice 并拷贝你需要的数据</li>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">	sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]		<span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">	dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">	dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">	path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))		<span class="comment">// AAAAsuffix</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))		<span class="comment">// BBBBBBBBB</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))	<span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p>
<h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)	<span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">	s2 := s1[<span class="number">1</span>:]</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)	<span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		s2[i] += <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">	fmt.Println(s1)		<span class="comment">// [1 22 23]</span></span><br><span class="line">	fmt.Println(s2)		<span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)	<span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		s2[i] += <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s1)		<span class="comment">// [1 22 23]	// 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">	fmt.Println(s2)		<span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mtx myMutex</span><br><span class="line">	mtx.Lock()</span><br><span class="line">	mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p>
</blockquote>
<p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> locker myLocker</span><br><span class="line">	locker.Lock()</span><br><span class="line">	locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> locker myLocker</span><br><span class="line">	locker.Lock()</span><br><span class="line">	locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">			<span class="comment">//break	// 死循环，一直打印 breaking out...</span></span><br><span class="line">			<span class="keyword">break</span> loop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p>
<h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		vCopy := v</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(vCopy)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(in)</span><br><span class="line">		&#125;(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下边这个稍复杂的 3 个示例区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">	fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 three three three </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		v := v</span><br><span class="line">		<span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;	<span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line">		<span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>result:  2</p>
</blockquote>
<h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dir := os.Args[<span class="number">1</span>]</span><br><span class="line">	start, err := os.Stat(dir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">		os.Exit(<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">	filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">		f, err := os.Open(target)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)	<span class="comment">//error:too many open files</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()	<span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用 f 资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建 10000 个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for n in &#123;1..10000&#125;; do</span><br><span class="line">	echo content &gt; &quot;file$&#123;n&#125;.txt&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p> <img src="https://contents.yinzige.com/file-open-errors.png"></p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			f, err := os.Open(target)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span>	<span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> f.Close()	<span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 使用 f 资源</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">	<span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)	<span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)	<span class="comment">// [not an int], data:  great</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))	</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel  <code>default</code> 语句：</p>
<p><code>default</code> 的缓冲 channel  保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p>
<h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">	d1.<span class="built_in">print</span>()	<span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">	in.<span class="built_in">print</span>()	<span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">		<span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()	<span class="comment">// m[&quot;x&quot;] 是不可寻址的	// 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cannot use data literal (type data) as type printer in assignment:</p>
<p>data does not implement printer (print method has pointer receiver)</p>
<p>cannot call pointer method on m[“x”]<br>cannot take the address of m[“x”]</p>
</blockquote>
<h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">		<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cannot assign to struct field m[“x”].name in map</p>
</blockquote>
<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">	s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">	fmt.Println(s)	<span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p>
<p>更新 map 中 struct 元素的字段值，有 2 个方法：</p>
<ul>
<li>使用局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">		<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">	r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">	fmt.Println(m)	<span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用指向元素的 map 指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">		<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span>	<span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">	fmt.Println(m[<span class="string">&quot;x&quot;</span>])	<span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">		<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span>	 </span><br><span class="line">	fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
</blockquote>
<h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(data, data == <span class="literal">nil</span>)	<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">	fmt.Println(in, in == <span class="literal">nil</span>)	<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">	in = data</span><br><span class="line">	fmt.Println(in, in == <span class="literal">nil</span>)	<span class="comment">// &lt;nil&gt; false	// data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">			result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)	<span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)			<span class="comment">// *struct &#123;&#125;	// res 不是 nil，它的值为 nil</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)			<span class="comment">// &lt;nil&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">			result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>	<span class="comment">// 明确指明返回 nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)	<span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p>
<p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置： <img src="https://contents.yinzige.com/allocation.png"></p>
<h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p>
<p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p>
<p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p>
<p><code>GOMAXPROCS</code>  的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))	<span class="comment">// 4</span></span><br><span class="line">	fmt.Println(runtime.NumCPU())	<span class="comment">// 4</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))	<span class="comment">// 20</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))	<span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">3</span></span><br><span class="line">	b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(a)</span><br><span class="line">	<span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> u1()	<span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">	<span class="keyword">go</span> u2()	</span><br><span class="line">	<span class="keyword">go</span> p()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p> <img src="https://contents.yinzige.com/reorder.png"></p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p>
<h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)	<span class="comment">// 并不内联执行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p>
<p> <img src="https://contents.yinzige.com/not-inlined.png"></p>
<p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p> <img src="https://contents.yinzige.com/gosched.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p>
<p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p>
<p>后续再更新类似高质量文章的翻译 😍</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>什么是二进制的按位或和按位异或</title>
    <url>/2023-06-08-3d1c210a715f.html</url>
    <content><![CDATA[<p>按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！</p>
<p>按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input bit a | input bit b | output </span><br><span class="line">------------------------------- </span><br><span class="line">	0        |     0      | 0 </span><br><span class="line">	0        |     1      | 1 </span><br><span class="line">	1        |     0      | 1 </span><br><span class="line">	1        |     1      | 1</span><br></pre></td></tr></table></figure>

<p>例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  110</span><br><span class="line">| 011</span><br><span class="line">-----</span><br><span class="line">  111</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input bit a | input bit b | output</span><br><span class="line">-------------------------------</span><br><span class="line">        0    |    0      |   0</span><br><span class="line">        0    |    1      |   1</span><br><span class="line">        1    |    0      |   1</span><br><span class="line">        1    |    1      |   0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  110</span><br><span class="line">^ 011</span><br><span class="line">-----</span><br><span class="line">  101</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按位或，就是只要有1 就为1 (包含了1  1 ；0 1；1  0；三种)<br>按位异或，必须一个0一个1，才为1 （包含0 1；1  0；两种）<br>大家记住了吗？</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>依赖注入</title>
    <url>/2024-07-21-618c8c29b962.html</url>
    <content><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>使用接口来实现依赖注入，降低模块间的耦合。<br><strong>概念</strong>： 依赖注入是一种设计模式，它允许你将组件的依赖关系（即其他组件或服务）从组件本身中分离出来，并在组件外部进行配置。这样做可以减少组件之间的耦合，使得代码更加模块化，易于测试和维护。</p>
<p><strong>Go 语言实现</strong>： 在 Go 语言中，可以通过接口来实现依赖注入。接口定义了组件所需的行为，然后你可以在运行时注入任何实现了这些行为的具体类型。</p>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>降低耦合</strong>：组件不直接依赖于具体的实现类，而是依赖于接口，这降低了组件之间的耦合度。</li>
<li><strong>提高灵活性</strong>：可以轻易地替换依赖的具体实现，而不需要修改组件的代码。</li>
<li><strong>易于测试</strong>：可以为测试注入模拟对象（mocks），从而可以隔离测试组件，不依赖于外部服务或组件。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">    Log(message <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l ConsoleLogger)</span></span> Log(message <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Log-DEBUG:&quot;</span>, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConsoleLoggerINFO <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l ConsoleLoggerINFO)</span></span> Log(message <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Log-INFO:&quot;</span>, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Application <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Application)</span></span> SetLogger(logger Logger) &#123;</span><br><span class="line">    a.logger = logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := Application&#123;&#125;</span><br><span class="line">    consoleLogger := ConsoleLogger&#123;&#125;</span><br><span class="line">    app.SetLogger(consoleLogger)</span><br><span class="line">    app.logger.Log(<span class="string">&quot;Application started&quot;</span>)</span><br><span class="line">    consoleLoggerInfo := ConsoleLoggerINFO&#123;&#125;</span><br><span class="line">    app.SetLogger(consoleLoggerInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边通过Go语言的Logger接口包含了Log方法, Application包含了Logger接口。  Application可以通过SetLogger来设置任何实现接口中Log 方法的就，可以方便切换日志类型。这就是依赖注入，每个部分都是个组件，可以随意方便的更换</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>回调函数和直接调用的区别</title>
    <url>/2024-07-21-023e6a227482.html</url>
    <content><![CDATA[<p>回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异：</p>
<ol>
<li><p><strong>调用时机</strong>：</p>
<ul>
<li><strong>直接调用</strong>：函数A直接调用函数B，函数B的执行是立即的，并且是在函数A的控制下进行的。</li>
<li><strong>回调函数</strong>：函数A接收函数B作为参数，但函数B的执行时机可能由外部事件或条件触发，不一定立即执行。</li>
</ul>
</li>
<li><p><strong>控制流</strong>：</p>
<ul>
<li><strong>直接调用</strong>：控制流是线性的，函数B执行完毕后，控制权返回给函数A。</li>
<li><strong>回调函数</strong>：控制流可能会中断，函数A执行到某个点后，将控制权交给函数B，函数B执行完毕后，控制权可能不会直接返回给函数A，而是等待某个条件满足后才继续执行。</li>
</ul>
</li>
<li><p><strong>执行环境</strong>：</p>
<ul>
<li><strong>直接调用</strong>：函数B在函数A的上下文中执行，可以访问函数A的局部变量。</li>
<li><strong>回调函数</strong>：函数B可能在不同的上下文中执行，例如在异步操作完成后，此时它可能无法访问函数A的局部变量。</li>
</ul>
</li>
<li><p><strong>目的和用途</strong>：</p>
<ul>
<li><strong>直接调用</strong>：通常用于直接执行某个操作或计算。</li>
<li><strong>回调函数</strong>：通常用于响应事件、处理异步操作的结果或在特定条件下触发后续操作。</li>
</ul>
</li>
<li><p><strong>编程模式</strong>：</p>
<ul>
<li><strong>直接调用</strong>：更符合同步编程模式，代码执行顺序明确。</li>
<li><strong>回调函数</strong>：常用于异步编程模式，代码的执行顺序可能不那么明确，需要更多的控制结构来管理。</li>
</ul>
</li>
<li><p><strong>函数定义</strong>：</p>
<ul>
<li><strong>直接调用</strong>：函数B在被调用时不需要特定的定义或约束。</li>
<li><strong>回调函数</strong>：函数B可能需要符合特定的接口或签名，以便作为回调被其他函数使用。</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li><strong>直接调用</strong>：错误处理通常在调用者（函数A）中进行。</li>
<li><strong>回调函数</strong>：错误处理可能需要在回调函数本身中进行，调用者可能不知道回调函数何时被调用。</li>
</ul>
</li>
<li><p><strong>代码组织</strong>：</p>
<ul>
<li><strong>直接调用</strong>：代码组织可能更直观，因为函数调用关系清晰。</li>
<li><strong>回调函数</strong>：代码组织可能需要更多的设计考虑，以确保回调函数在适当的时机被调用，并且逻辑清晰。</li>
</ul>
</li>
</ol>
<p>使用回调函数而不是直接调用的原因通常与程序设计的复杂性、灵活性和可扩展性有关。例如，在处理异步事件、网络请求或用户界面操作时，回调函数提供了一种有效的方式来处理这些操作的结果，而不需要阻塞主程序流程。此外，回调函数还可以帮助实现更高层次的抽象，如事件监听器、中间件等</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用递归</title>
    <url>/2024-05-08-23291165e2d9.html</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：返回nums root 节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(nums []<span class="type">int</span>,left <span class="type">int</span> , right <span class="type">int</span>)</span></span> *TreeNode&#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := (left + right)/<span class="number">2</span></span><br><span class="line">    root := &amp;TreeNode&#123;nums[mid],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    root.Left =  traversal(nums,left,mid<span class="number">-1</span>) <span class="comment">// 把后边 root 节点添加到当前root left 左节点上</span></span><br><span class="line">    root.Right = traversal(nums,mid+<span class="number">1</span>,right) <span class="comment">// 把后边 root 节点添加到当前root right 左节点上</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤：</p>
<ol>
<li><p><strong>识别重复模式</strong>：</p>
<ul>
<li>确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。</li>
</ul>
</li>
<li><p><strong>定义递归函数</strong>：</p>
<ul>
<li>根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。</li>
</ul>
</li>
<li><p><strong>确定基本情况</strong>：</p>
<ul>
<li>找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。</li>
</ul>
</li>
<li><p><strong>分解问题</strong>：</p>
<ul>
<li>将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。</li>
</ul>
</li>
<li><p><strong>递归工作</strong>：</p>
<ul>
<li>描述递归如何工作，包括如何从子问题的解中构建出原问题的解。</li>
</ul>
</li>
<li><p><strong>合并结果</strong>：</p>
<ul>
<li>确定如何将子问题的解合并为原问题的解。</li>
</ul>
</li>
<li><p><strong>编写伪代码</strong>：</p>
<ul>
<li>在编写实际代码之前，先用伪代码描述递归逻辑。</li>
</ul>
</li>
<li><p><strong>考虑边界条件</strong>：</p>
<ul>
<li>考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。</li>
</ul>
</li>
<li><p><strong>优化性能</strong>：</p>
<ul>
<li>如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。</li>
</ul>
</li>
<li><p><strong>测试和调试</strong>：</p>
<ul>
<li>编写测试用例来验证递归逻辑，并调试任何出现的问题。</li>
</ul>
</li>
</ol>
<p>以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成：</p>
<ul>
<li><p><strong>重复模式</strong>：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。</p>
</li>
<li><p><strong>定义递归函数</strong>：<code>traversal</code> 函数接收一个数组和两个索引，表示当前考虑的子数组。</p>
</li>
<li><p><strong>确定基本情况</strong>：如果左索引大于右索引，说明子数组为空，返回 <code>nil</code>。</p>
</li>
<li><p><strong>分解问题</strong>：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 <code>traversal</code> 函数。</p>
</li>
<li><p><strong>递归工作</strong>：递归地构建左子树和右子树，然后将它们连接到当前根节点。</p>
</li>
<li><p><strong>合并结果</strong>：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。</p>
</li>
<li><p><strong>编写伪代码</strong>：在脑中或纸上概述递归调用的流程。</p>
</li>
<li><p><strong>考虑边界条件</strong>：确保数组索引不会超出数组边界。</p>
</li>
<li><p><strong>优化性能</strong>：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。</p>
</li>
<li><p><strong>测试和调试</strong>：通过在不同的数组输入上测试函数来确保其正确性。</p>
</li>
</ul>
<p>通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>结构体指针作为map key 结构体值改变对map有影响吗</title>
    <url>/2023-05-10-7dfabb45bbc2.html</url>
    <content><![CDATA[<p>最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：<strong>go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？</strong><br>接下来让我们一起看看：</p>
<p>当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据</p>
<p>例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[*<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	x := <span class="number">1</span></span><br><span class="line">	p := &amp;x</span><br><span class="line"></span><br><span class="line">	m[p] = <span class="string">&quot;A&quot;</span> <span class="comment">// 添加数据</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m) <span class="comment">// map[0xc000016088:A]</span></span><br><span class="line"></span><br><span class="line">	*p = <span class="number">2</span> <span class="comment">// 修改变量x的值</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m) <span class="comment">// map[0xc000016088:A]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。</p>
<p>接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。</p>
<p>总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令 将前台任务挂到后台运行</title>
    <url>/2023-03-18-87649bcaf9cc.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用<code>bg</code>  挂后台的命令。</p>
<p><strong>第一步：ctrl + z</strong></p>
<p><strong>第二步：jobs  查看任务id</strong></p>
<p><strong>第三步： bg %任务id</strong></p>
<p><img src="/../../imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 将用户追加到对应用户组</title>
    <url>/2023-09-17-5141f57450ab.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文目的是为了将多个用户设置同组用户，并且同组内用户<strong>新建文件的默认权限</strong>是同组内用户可读写。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>将test 添加到GroupA</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">usermod -a -G GroupName UserName</span><br><span class="line"><span class="comment"># 例如将test 追加到GroupA</span></span><br><span class="line">usermod -a -G GroupA <span class="built_in">test</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改新建文件的默认权限</li>
</ol>
<p>在.bashrc 里添加</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <url>/2025-01-13-1b5c01477594.html</url>
    <content><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *</span><br></pre></td></tr></table></figure>

<p>解释一下这个命令：</p>
<ul>
<li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li>
<li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li>
<li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul>
<li><code>s</code> 表示替换操作。</li>
<li><code>hide: true</code> 是要被替换的字符串。</li>
<li><code>hide: false</code> 是替换后的字符串。</li>
<li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li>
</ul>
</li>
<li><code>*</code> 表示当前文件夹下的所有文件。</li>
</ul>
<p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure>

<p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure>

<p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>jupyter</title>
    <url>/2024-06-21-02cd02e81f22.html</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pip install notebook</p>
<p>用于启动 Jupyter Notebook 服务的一系列命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jupyter-notebook stop 8888</span><br><span class="line">JUPYTER_TOKEN=$(&lt; /dev/urandom <span class="built_in">tr</span> -dc A-Za-z0-9 | <span class="built_in">head</span> -c16; <span class="built_in">echo</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JUPYTER_TOKEN</span></span><br><span class="line"><span class="built_in">nohup</span> jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=<span class="variable">$JUPYTER_TOKEN</span> &amp;</span><br><span class="line">jupyter-notebook list</span><br></pre></td></tr></table></figure>

<p>这里是每条命令的简要说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jupyter-notebook stop 8888：停止端口为 8888 的 Jupyter Notebook 服务。</span><br><span class="line">JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)：生成一个随机的 16 位的 token，用于 Jupyter Notebook 的安全认证。</span><br><span class="line">nohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。</span><br><span class="line">jupyter-notebook list：列出当前运行的 Jupyter Notebook 服务。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="conda-对应版本"><a href="#conda-对应版本" class="headerlink" title="conda　对应版本"></a>conda　对应版本</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建glm4-demo python 3.10的虚拟环境</span></span><br><span class="line">conda create --name glm4-demo python=3.10</span><br><span class="line"></span><br><span class="line">conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch</span><br></pre></td></tr></table></figure>

<p><a href="https://pytorch.org/">PyTorch</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240721120138.png"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">conda install python=3.10 pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>

<p>指定python版本：<br><img src="/../../imgs/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1721534117437.png"><br>conda install python&#x3D;3.10 pytorch&#x3D;2.3.0 torchvision torchaudio pytorch-cuda&#x3D;12.1 -c pytorch -c nvidia</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>三种Python3 判断字典中是否存在对应key的方法</title>
    <url>/2023-10-19-8f51ae9ef5a1.html</url>
    <content><![CDATA[<h1 id="第一种：使用get-方法"><a href="#第一种：使用get-方法" class="headerlink" title="第一种：使用get()方法"></a>第一种：使用get()方法</h1><p> <strong>生成一个字典</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>打印返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(dict.get(&#x27;name&#x27;))  # 结果返回对应val</span><br><span class="line">print(dict.get(&#x27;id&#x27;))  # 结果返回None</span><br></pre></td></tr></table></figure>

<p>第二种：使用keys()方法</p>
<p> <strong>生成一个字典</strong><br>dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’}<br> <strong>判断是否存在，其中dict.keys()是列出字典所有的key</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;name&#x27; in dict.keys())  # 结果返回True</span><br><span class="line">print(&#x27;id&#x27; in dict.keys())  # 结果返回False</span><br></pre></td></tr></table></figure>

<p>除了使用in也可以使用not in，用于判定这个key不存在</p>
<p>第三种：使用 in 关键字</p>
<p><strong>生成一个字典</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong># 判断key是否存在于dict中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;name&#x27; in dict)  # 结果返回True</span><br><span class="line">print(&#x27;id&#x27; in dict)  # 结果返回False</span><br></pre></td></tr></table></figure>


<h1 id="补充：生成默认字典（collections-defaultdict）"><a href="#补充：生成默认字典（collections-defaultdict）" class="headerlink" title="补充：生成默认字典（collections.defaultdict）"></a>补充：生成默认字典（<code>collections.defaultdict</code>）</h1><p>使用<code>defaultdict(int)</code>来创建<code>maps</code>，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tupleSameProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        maps = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                product = nums[i] * nums[j]</span><br><span class="line">                ans += maps[product] * <span class="number">4</span></span><br><span class="line">                maps[product] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>本地运行LeetCode的Python代码 调试</title>
    <url>/2023-10-19-6057db0e071e.html</url>
    <content><![CDATA[<p>最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦</p>
<p>要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类：</p>
<p>创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。</p>
<p>导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br></pre></td></tr></table></figure>

<p>创建Solution类并在其中定义问题的解决方案。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 实现你的解决方案</span></span><br><span class="line">        <span class="comment"># 例如，找到两个数的和等于目标，并返回它们的索引</span></span><br><span class="line">        num_to_index = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            complement = target - num</span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> num_to_index:</span><br><span class="line">                <span class="keyword">return</span> [num_to_index[complement], i]</span><br><span class="line">            num_to_index[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>创建一个main函数来测试你的解决方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用Solution类的方法进行测试</span></span><br><span class="line">    result = solution.twoSum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python leetcode_solution.py</span><br></pre></td></tr></table></figure>

<p>这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Windows Git自动转换为Linux换行符</title>
    <url>/2025-04-28-84ca2c3d5919.html</url>
    <content><![CDATA[<p>在 Git 中处理不同操作系统（Windows&#x2F;Linux&#x2F;macOS）的换行符（<code>LF</code> 和 <code>CRLF</code>）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：</p>
<hr>
<h3 id="1-核心配置：core-autocrlf"><a href="#1-核心配置：core-autocrlf" class="headerlink" title="1. 核心配置：core.autocrlf"></a><strong>1. 核心配置：<code>core.autocrlf</code></strong></h3><p>通过设置 <code>core.autocrlf</code> 属性，让 Git 自动转换换行符：</p>
<h4 id="不同操作系统的推荐设置"><a href="#不同操作系统的推荐设置" class="headerlink" title="不同操作系统的推荐设置"></a><strong>不同操作系统的推荐设置</strong></h4><ul>
<li><p><strong>Windows（推荐）</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时转换为 CRLF</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Linux&#x2F;macOS（推荐）</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时不转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-强制规范：-gitattributes-文件"><a href="#2-强制规范：-gitattributes-文件" class="headerlink" title="2. 强制规范：.gitattributes 文件"></a><strong>2. 强制规范：<code>.gitattributes</code> 文件</strong></h3><p>在项目根目录创建 <code>.gitattributes</code> 文件，<strong>优先级高于全局配置</strong>，适合团队协作。</p>
<h4 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 所有文本文件使用 LF 换行符</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># 排除二进制文件（避免误处理）</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br><span class="line">*.zip binary</span><br><span class="line"></span><br><span class="line"># 指定特定文件类型（可选）</span><br><span class="line">*.sh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>text=auto</code>：Git 自动识别文本文件。</li>
<li><code>eol=lf</code> 或 <code>eol=crlf</code>：强制统一换行符。</li>
</ul>
<hr>
<h3 id="3-修复已存在的换行符问题"><a href="#3-修复已存在的换行符问题" class="headerlink" title="3. 修复已存在的换行符问题"></a><strong>3. 修复已存在的换行符问题</strong></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol>
<li><p>删除缓存并重置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached -r .  <span class="comment"># 清除缓存</span></span><br><span class="line">git reset --hard      <span class="comment"># 重置文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新添加文件并提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;fix: normalize line endings&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-检查换行符状态"><a href="#4-检查换行符状态" class="headerlink" title="4. 检查换行符状态"></a><strong>4. 检查换行符状态</strong></h3><h4 id="检查文件换行符："><a href="#检查文件换行符：" class="headerlink" title="检查文件换行符："></a><strong>检查文件换行符</strong>：</h4><ul>
<li><p><strong>Linux&#x2F;macOS</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file yourfile.txt</span><br><span class="line"><span class="comment"># 输出中包含 &quot;LF&quot; 或 &quot;CRLF&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows（PowerShell）</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> yourfile.txt <span class="literal">-Encoding</span> Byte | <span class="built_in">Select-String</span> <span class="string">&quot;0D 0A&quot;</span></span><br><span class="line"><span class="comment"># 存在 &quot;0D 0A&quot; 表示 CRLF</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查看-Git-换行符转换日志："><a href="#查看-Git-换行符转换日志：" class="headerlink" title="查看 Git 换行符转换日志："></a><strong>查看 Git 换行符转换日志</strong>：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-files --eol</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a><strong>常见问题解决</strong></h3><ul>
<li><p>**警告 <code>LF will be replaced by CRLF</code>**：<br>正常提示，表示 Git 正在按配置转换换行符。</p>
</li>
<li><p><strong>文件被标记为已修改（仅换行符变化）</strong>：<br>运行以下命令清除差异：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.whitespace cr-at-eol</span><br><span class="line">git add --renormalize .</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>混合换行符导致冲突</strong>：<br>使用 <code>.gitattributes</code> 强制统一换行符，并重新提交文件。</p>
</li>
</ul>
<hr>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol>
<li><strong>团队协作</strong>：在项目中添加 <code>.gitattributes</code> 文件，统一换行符规则。</li>
<li><strong>编辑器配置</strong>：设置 IDE（如 VSCode）默认使用 <code>LF</code>（<a href="https://stackoverflow.com/a/44788470">配置示例</a>）。</li>
<li><strong>Windows 用户</strong>：安装 Git 时选择 <code>Checkout as-is, commit Unix-style line endings</code>。</li>
</ol>
<hr>
<p>通过上述配置，Git 会自动处理换行符，避免跨平台协作时的混乱！ 🛠️</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git stash</title>
    <url>/2024-08-21-d34ebab44074.html</url>
    <content><![CDATA[<p>当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：</p>
<p>放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- .obsidian/workspace.json</span><br></pre></td></tr></table></figure>

<p>再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>如果不想放弃这些更改，而是想将它们暂时保存起来，可以使用 git stash 命令：</p>
<p>保存更改：使用 git stash 将更改保存到一个临时区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>拉取远程更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>



<p><code>git stash</code> 是 Git 中用于临时保存工作目录和暂存区改动的工具，适用于需要切换分支或处理其他任务但不想提交未完成工作的场景。</p>
<hr>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h3><ol>
<li><p><strong>保存当前改动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash                   <span class="comment"># 默认保存，消息为自动生成</span></span><br><span class="line">git stash push -m <span class="string">&quot;备注&quot;</span>    <span class="comment"># 保存并添加自定义备注</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>选项</strong>：<ul>
<li><code>-u</code> 或 <code>--include-untracked</code>：包含未被跟踪的文件（新增但未 <code>git add</code> 的文件）。</li>
<li><code>-a</code> 或 <code>--all</code>：包含所有文件（包括被 <code>.gitignore</code> 忽略的文件）。</li>
<li><code>--keep-index</code>：仅保存工作区未暂存的改动，保留暂存区内容。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查看保存的 stash 列表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：<code>stash@&#123;0&#125;: On main: 备注</code></li>
</ul>
</li>
<li><p><strong>恢复改动</strong></p>
<ul>
<li><strong>恢复最近一次的 stash 并删除记录</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li>
<li><strong>恢复指定 stash 但不删除记录</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;n&#125;  <span class="comment"># n 为 stash 编号，如 stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除 stash</strong></p>
<ul>
<li><strong>删除指定 stash</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>清空所有 stash</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a><strong>高级用法</strong></h3><ol>
<li><p><strong>从 stash 创建分支</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash branch 分支名 stash@&#123;n&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于指定 stash 创建新分支，并自动应用改动（适用于 stash 与当前分支冲突时）。</li>
</ul>
</li>
<li><p><strong>查看 stash 的改动详情</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash show stash@&#123;n&#125;    <span class="comment"># 显示简略差异</span></span><br><span class="line">git stash show -p stash@&#123;n&#125; <span class="comment"># 显示完整差异（类似 git diff）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><strong>默认行为</strong>：<ul>
<li><code>git stash</code> 会保存 <strong>工作区未提交的修改</strong> 和 <strong>暂存区的修改</strong>。</li>
<li>恢复时，已暂存的改动会重新回到暂存区，未暂存的改动保留在工作区。</li>
</ul>
</li>
<li><strong>未跟踪文件</strong>：<ul>
<li>默认不保存未被跟踪的文件（需用 <code>-u</code> 或 <code>--include-untracked</code>）。</li>
</ul>
</li>
<li><strong>冲突处理</strong>：<ul>
<li>如果恢复时发生冲突，需手动解决后执行 <code>git add</code> 和 <code>git restore --staged</code> 或提交。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h3><ol>
<li><p><strong>临时切换分支</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash -m <span class="string">&quot;保存功能 A 的进度&quot;</span></span><br><span class="line">git checkout 其他分支</span><br><span class="line"><span class="comment"># 处理其他任务后返回</span></span><br><span class="line">git checkout 原分支</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保存包含未跟踪文件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash -u -m <span class="string">&quot;包含新文件&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复指定 stash</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list              <span class="comment"># 查看列表</span></span><br><span class="line">git stash apply stash@&#123;2&#125;  <span class="comment"># 应用第三个 stash</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 设置免密配置-全局免密-单仓库免密-SSH免密</title>
    <url>/2024-01-01-91517aa963bc.html</url>
    <content><![CDATA[<h1 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h1><p>我们要首先知道一个简单的概念:<br>https通过<strong>记住账号密码免登</strong>，ssh通过<strong>校验生成的密钥免登</strong>。 通常都用ssh校验。</p>
<p>查看通信方式</p>
<p>在项目目录中运行命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>如果出现提示是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin  https://gitee.com/xxx/xxx.git (fetch)</span><br><span class="line">origin  https://gitee.com/xxx/xxx.git (push)</span><br></pre></td></tr></table></figure>

<p>则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密<br>如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址<br><img src="/../../imgs/Pasted%20image%2020240101151457.png"></p>
<h1 id="一、https-方式及免密码配置"><a href="#一、https-方式及免密码配置" class="headerlink" title="一、https 方式及免密码配置"></a>一、https 方式及免密码配置</h1><h3 id="0-项目中-git-基本配置"><a href="#0-项目中-git-基本配置" class="headerlink" title="0. 项目中 git 基本配置"></a>0. 项目中 git 基本配置</h3><p>全局用户名密码配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;lei_qi@outlook.com&quot;</span><br></pre></td></tr></table></figure>

<p>项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令</span><br><span class="line">git init</span><br><span class="line"># 关联远程仓库</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;初始化&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。</p>
<p>这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。</p>
<h3 id="1-全局免密码配置"><a href="#1-全局免密码配置" class="headerlink" title="1.全局免密码配置"></a>1.全局免密码配置</h3><p>配置存储模式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p>执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store</p>
<p>Linux 下查看：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>

<p>windows10 下当前用户路径：<code>%USERPROFILE%</code><br>内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = lenovo</span><br><span class="line">        email = xxxx@outlook.com</span><br><span class="line">[credential]</span><br><span class="line">        helper = store</span><br></pre></td></tr></table></figure>

<p>然后在项目目录，执行git pull&#x2F;git push命令，会提示输入<strong>账号密码</strong>。这次输入账号密码之后，就会<strong>记住</strong>账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。<br><img src="/../../imgs/Pasted%20image%2020240101145902.png"></p>
<h3 id="2、单项目免密码配置"><a href="#2、单项目免密码配置" class="headerlink" title="2、单项目免密码配置"></a>2、单项目免密码配置</h3><p>编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://gitee.com/xxx/xxx.git</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]   </span><br><span class="line">url = https://yourusername:password@gitee.com/xxx/xxxx.git</span><br></pre></td></tr></table></figure>

<p>也就是在 <code>https://</code> 之后，增加 <code>用户名:密码@</code></p>
<h1 id="二-SSH免密登录"><a href="#二-SSH免密登录" class="headerlink" title="二. SSH免密登录"></a>二. SSH免密登录</h1><p>如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式,</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>github 网页增加本机SSH key</p>
<p>git ssh 方式免密提交方式需要将 <code>ssh-keygen</code> 生成的公钥放到服务器上</p>
<p>全局用户名密码配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot; </span><br><span class="line">git config --global user.email &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure>

<p>项目初始化，生成 .git 目录，配置 ssh 远程项目地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 如果是新仓库需要git init ;否则不需要git init; git init</span><br><span class="line"># git 关联远程仓库</span><br><span class="line">git remote add origin git@gitee.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>

<h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><p>1、首先需要检查你电脑是否已经有 SSH key</p>
<p>运行 git Bash 客户端，检查本机的ssh密钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure>

<p>如果提示：No such file or directory ，说明是第一次使用 git。</p>
<p>如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ mkdir key_backup   </span><br><span class="line">$ cp id_rsa* key_backup   </span><br><span class="line">$ rm id_rsa*</span><br></pre></td></tr></table></figure>

<p>2、执行生成公钥和私钥的命令，生成新的密钥：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>代码参数：</p>
<p>-t 指定密钥类型，默认是 rsa ，可以省略。</p>
<p>-C 设置注释文字，比如邮箱。</p>
<p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p>
<p>按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p>
<p>执行查看公钥信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>Windows 系统，位置在用户目录下 .ssh文件夹中。<code>%USERPROFILE%</code></p>
<h2 id="复制公钥信息到远端仓库"><a href="#复制公钥信息到远端仓库" class="headerlink" title="复制公钥信息到远端仓库"></a>复制公钥信息到远端仓库</h2><p><strong>gitee</strong><br>打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8c26fae5769cb56da5e20c884a33c702_720w.webp"></p>
<p><strong>github</strong><br>Settings -SSH and GPG keys - New SSH key<br><img src="app://db738d3bb1089e4d04f6eb022a68209f31bf/D:/obsidian_note/LeiQi_Blog/source/imgs/Pasted%20image%2020240101151324.png?1704093204312"><br>然后，提交时就不再需要用户名和密码了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;ssh免密提交&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>参考:<br><a href="https://zhuanlan.zhihu.com/p/358721423">https://zhuanlan.zhihu.com/p/358721423</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>github同步gitee</title>
    <url>/2024-07-18-e17dac938cf8.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240719003858.png"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git更新仓库地址</title>
    <url>/2024-07-23-764a3cd05cde.html</url>
    <content><![CDATA[<p>使用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://gitee.com/xxxxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git强制拉取远端</title>
    <url>/2023-10-22-9bf76366f18c.html</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/&lt;branch_name&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p>
<p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p>
<p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p>
<p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>设置github 同步到gitee</title>
    <url>/2024-07-21-3ee37da7ed1c.html</url>
    <content><![CDATA[<ol>
<li>复制自己电脑的<strong>私钥</strong>到github</li>
<li>复制自己电脑的<strong>公钥</strong>到gitee<img src="/../../imgs/Pasted%20image%2020240721222254.png"></li>
<li>获取gitee 的私人令牌</li>
<li>创建.github&#x2F;workflows&#x2F;xxx.ymal<br><img src="/../../imgs/Pasted%20image%2020240721221805.png"></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">to</span> <span class="string">Gitee</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">wearerequired/git-mirror-action@master</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 GitHub 源仓库地址</span></span><br><span class="line">          <span class="attr">source-repo:</span> <span class="string">git@github.com:leiqichn/novelBigModel.git</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 目标仓库地址</span></span><br><span class="line">          <span class="attr">destination-repo:</span> <span class="string">git@gitee.com:leiqichn/novelBigModel.git</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2023-03-13-519b5e93f019.html</url>
    <content><![CDATA[<div style="text-align: center">

<h1 id="欢迎来到我的空间"><a href="#欢迎来到我的空间" class="headerlink" title="欢迎来到我的空间!"></a>欢迎来到我的空间!</h1></div>

<div style="text-align: center">

<h1 id="我的第"><a href="#我的第" class="headerlink" title="我的第 "></a>我的第 <img src="https://profile-counter.glitch.me/leiqitop/count.svg" alt="Visitor Count"></h1></div>


<div style="text-align: center">

<h1 id="个朋友！"><a href="#个朋友！" class="headerlink" title="个朋友！"></a>个朋友！</h1></div>

<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul>
<li><p>🌱 毕业于复旦大学</p>
</li>
<li><p>⭐ 现就职于华为，软件开发工程师</p>
</li>
</ul>
<h2 id="兴趣-👨🏽‍💻"><a href="#兴趣-👨🏽‍💻" class="headerlink" title="兴趣 👨🏽‍💻"></a>兴趣 👨🏽‍💻</h2><ul>
<li><p>项目: NLP, Large Language Model, Golang Project, Python Project, Vue Project.</p>
</li>
<li><p>编程语言 : Golang, Python, C++&#x2F;C, Java</p>
</li>
</ul>
<h2 id="开源项目经验-👯"><a href="#开源项目经验-👯" class="headerlink" title="开源项目经验 👯"></a>开源项目经验 👯</h2><p><strong>As a manager</strong> ：</p>
<ul>
<li><a href="https://tianchi.aliyun.com/competition/entrance/532210/customize509">优酷x天池 「酷文」小说创作大模型挑战赛</a>: DeepThinking Team Leader, <strong>Third Prize</strong>.</li>
</ul>
<p><strong>As a member</strong> :</p>
<ul>
<li><p><a href="https://github.com/TianlabTech/PhenoBERT.git">PhenoBERT</a> : <strong>PhenoBERT:</strong> A combined deep learning method for automated recognition of human phenotype ontology</p>
</li>
<li><p><a href="">IEEE Journal of Biomedical and Health Informatics（IF&#x3D;5.77）</a> : Reviewer</p>
</li>
</ul>
<h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ul>
<li><a href="https://tianchi.aliyun.com/competition/entrance/532210/customize509">优酷x天池 「酷文」小说创作大模型挑战赛</a>: DeepThinking Team Leader, <strong>Third Prize</strong>.</li>
</ul>
<h2 id="欢迎志同道合的朋友"><a href="#欢迎志同道合的朋友" class="headerlink" title="欢迎志同道合的朋友~"></a>欢迎志同道合的朋友~</h2><p>本站是为了记录自己学习和生活，欢迎大家多多交流讨论。<br>希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！</p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p><img src="/../../imgs/qrcode.jpg"></p>
]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang list.List 双向链表实现LRU</title>
    <url>/2025-06-15-60ed4ee14474.html</url>
    <content><![CDATA[<h1 id="Go语言中使用双向链表-list-List-实现LRU缓存"><a href="#Go语言中使用双向链表-list-List-实现LRU缓存" class="headerlink" title="Go语言中使用双向链表(list.List)实现LRU缓存"></a>Go语言中使用双向链表(list.List)实现LRU缓存</h1><p>LeetCode第146题”LRU缓存”来演示如何在Go语言中使用<code>container/list</code>包中的双向链表。</p>
<h2 id="LRU缓存题目要求"><a href="#LRU缓存题目要求" class="headerlink" title="LRU缓存题目要求"></a>LRU缓存题目要求</h2><p>设计一个LRU (Least Recently Used) 缓存机制，它应该支持以下操作：</p>
<ul>
<li><code>Get(key)</code>: 如果密钥存在则获取值，否则返回-1</li>
<li><code>Put(key, value)</code>: 如果密钥不存在，则写入数据；当缓存容量达到上限时，删除最久未使用的数据</li>
</ul>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>我们将使用<code>container/list</code>包中的双向链表来跟踪访问顺序，同时使用map来实现快速查找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUCache 结构体</span></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity <span class="type">int</span>                      <span class="comment">// 缓存容量</span></span><br><span class="line">	list     *list.List               <span class="comment">// 双向链表用于维护访问顺序</span></span><br><span class="line">	cache    <span class="keyword">map</span>[<span class="type">int</span>]*list.Element    <span class="comment">// 哈希表用于快速查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 用于存储键值对</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   <span class="type">int</span></span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 初始化LRU缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	<span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">		capacity: capacity,</span><br><span class="line">		list:     list.New(),</span><br><span class="line">		cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取键对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line">		<span class="comment">// 将访问的元素移动到链表头部表示最近使用</span></span><br><span class="line">		l.list.MoveToFront(elem)</span><br><span class="line">		<span class="keyword">return</span> elem.Value.(*entry).value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 插入或更新键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果键已存在，更新值并移动到头部</span></span><br><span class="line">	<span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line">		l.list.MoveToFront(elem)</span><br><span class="line">		elem.Value.(*entry).value = value</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果缓存已满，删除最近最少使用的元素（链表尾部）</span></span><br><span class="line">	<span class="keyword">if</span> l.list.Len() == l.capacity &#123;</span><br><span class="line">		tail := l.list.Back()</span><br><span class="line">		<span class="keyword">if</span> tail != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(l.cache, tail.Value.(*entry).key)</span><br><span class="line">			l.list.Remove(tail)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加新元素到链表头部</span></span><br><span class="line">	elem := l.list.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">	l.cache[key] = elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> <strong>使用slice 实现</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity <span class="type">int</span></span><br><span class="line">	keysList []<span class="type">int</span> <span class="comment">// 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间</span></span><br><span class="line">	keysMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// 存放key value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	<span class="comment">//return</span></span><br><span class="line">	<span class="keyword">return</span> LRUCache&#123;capacity, <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果key存在于缓存中，则返回关键字的值，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ele, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		<span class="keyword">return</span> ele</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 关键字存在 则更新值为value</span></span><br><span class="line">	<span class="comment">// 不存在，则插入value</span></span><br><span class="line">	<span class="comment">// 如果插入超过数量capacity 则删除最久没有使用的关键字【list]</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		this.keysMap[key] = value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		this.keysMap[key] = value</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(this.keysList) &gt; this.capacity &#123;</span><br><span class="line">			<span class="built_in">delete</span>(this.keysMap, this.keysList[<span class="number">0</span>]) <span class="comment">// 这里删除key 从list队列中获取</span></span><br><span class="line">			this.keysList = this.keysList[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> updateListKey(key <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.keysList); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> key == this.keysList[i] &#123;</span><br><span class="line">			this.keysList = <span class="built_in">append</span>(this.keysList[:i], this.keysList[i+<span class="number">1</span>:]...) <span class="comment">// 删除该key, 然后放在末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	this.keysList = <span class="built_in">append</span>(this.keysList, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ol>
<li><p><strong>双向链表的使用</strong>:</p>
<ul>
<li><code>list.New()</code> 创建一个新的双向链表</li>
<li><code>PushFront()</code> 在链表头部插入元素</li>
<li><code>MoveToFront()</code> 将元素移动到链表头部</li>
<li><code>Back()</code> 获取链表尾部元素</li>
<li><code>Remove()</code> 从链表中删除元素</li>
</ul>
</li>
<li><p><strong>LRU策略实现</strong>:</p>
<ul>
<li>最近访问的元素总是放在链表头部</li>
<li>当需要淘汰元素时，删除链表尾部的元素</li>
<li>使用map实现O(1)时间的查找</li>
</ul>
</li>
<li><p><strong>性能分析</strong>:</p>
<ul>
<li>Get操作时间复杂度: O(1)</li>
<li>Put操作时间复杂度: O(1)</li>
<li>空间复杂度: O(capacity)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言中的byte类型与Unicode码点与整数的转换</title>
    <url>/2023-07-09-dda1c4b9508f.html</url>
    <content><![CDATA[<h1 id="byte类型与Unicode码点的转换"><a href="#byte类型与Unicode码点的转换" class="headerlink" title="byte类型与Unicode码点的转换"></a>byte类型与Unicode码点的转换</h1><p>在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。</p>
<p>当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="type">byte</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">	i := <span class="type">int</span>(b)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\n&quot;</span>, b, b, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Byte: A, Unicode码点: <span class="number">65</span>, 转换后的整数: <span class="number">65</span></span><br></pre></td></tr></table></figure>

<p>可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。</p>
<h1 id="byte类型与整数的转换"><a href="#byte类型与整数的转换" class="headerlink" title="byte类型与整数的转换"></a>byte类型与整数的转换</h1><p>之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；<br>在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   ch := <span class="string">&#x27;0&#x27;</span>  </span><br><span class="line">   num := <span class="type">int</span>(ch - <span class="string">&#x27;0&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\n&quot;</span>, ch, ch, num)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">字符: <span class="number">0</span>, unicode码点或者<span class="type">byte</span>对应的数值: <span class="number">48</span>, 转换后的整数: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，字符 ‘0’ 成功转换为整数 0。<br>其中需要注意的是：在Go语言中，格式化输出时 <code>%c</code> 是一个占位符，用于表示要输出的值是一个Unicode字符。<br>具体来说，<code>%c</code> 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48</p>
<p>这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；<br>如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/2023-08-07-e74632bdccbf.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230807233035.png"></p>
<p>list Elemet 双向列表；<br><img src="/../../imgs/Pasted%20image%2020230807233013.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">cap</span>  <span class="type">int</span>                    <span class="comment">// 缓存容量</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*list.Element<span class="comment">//!!! 双向链表 使用Element // 双向链表节点 指向的map</span></span><br><span class="line">    list *list.List             <span class="comment">// 双向链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> keyVal <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, val <span class="type">int</span> <span class="comment">// 节点的Key和Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        <span class="built_in">cap</span>:   capacity,                            <span class="comment">// 初始化缓存容量</span></span><br><span class="line">        cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element),          <span class="comment">// 初始化map映射</span></span><br><span class="line">        list:  list.New(),                           <span class="comment">// 初始化双向链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="comment">// 如果map里有key对应的双向链表节点</span></span><br><span class="line">        this.list.MoveToFront(elem)                  <span class="comment">// 把节点移动到链表头</span></span><br><span class="line">        <span class="keyword">return</span> elem.Value.(*keyVal).val              <span class="comment">// 返回节点的value值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>                                        <span class="comment">// 没有找到的情况下，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="comment">// 如果map里有key对应的双向链表节点</span></span><br><span class="line">        this.list.MoveToFront(elem)                  <span class="comment">// 把节点移动到链表头</span></span><br><span class="line">        <span class="comment">//!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值；</span></span><br><span class="line">        elem.Value.(*keyVal).val = value             <span class="comment">// 更新节点的value值 </span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> this.list.Len() &gt;= this.<span class="built_in">cap</span> &#123;                 <span class="comment">// 如果超过了缓存容量</span></span><br><span class="line">        tail := this.list.Back()                     <span class="comment">// 获取链表的尾节点</span></span><br><span class="line">        k := tail.Value.(*keyVal).key                <span class="comment">// 获取节点的key</span></span><br><span class="line">        this.list.Remove(tail)                       <span class="comment">// 从链表中删除尾节点</span></span><br><span class="line">        <span class="built_in">delete</span>(this.cache, k)                        <span class="comment">// 从map中删除尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) <span class="comment">// 将节点添加到链表头</span></span><br><span class="line">    this.cache[key] = elem                           <span class="comment">// 将节点映射到map中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 1071. 字符串的最大公因子</title>
    <url>/2024-01-03-58e186a9065e.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240103231323.png"></p>
<p><strong>解题思路：</strong></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcdOfStrings</span><span class="params">(str1 <span class="type">string</span>, str2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n1, n2 := <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最长的可能的子串长度开始尝试</span></span><br><span class="line">    <span class="keyword">for</span> i := min(n1, n2); i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> n1%i == <span class="number">0</span> &amp;&amp; n2%i == <span class="number">0</span> &#123;</span><br><span class="line">            commonSubstring := str1[:i]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123;</span><br><span class="line">                <span class="keyword">return</span> commonSubstring</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查字符串是否能够整除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkDivisible</span><span class="params">(s <span class="type">string</span>, sub <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    repeats := <span class="built_in">len</span>(s) / <span class="built_in">len</span>(sub)</span><br><span class="line">    concatenated := repeatString(sub, repeats)</span><br><span class="line">    <span class="keyword">return</span> s == concatenated</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatString</span><span class="params">(s <span class="type">string</span>, count <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">        result += s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>辗转相除法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcdOfStrings</span><span class="params">(str1 <span class="type">string</span>, str2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1 + str2 != str2 + str1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    gcd := gcd(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2))</span><br><span class="line">    <span class="keyword">return</span> str1[<span class="number">0</span>:gcd]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 110.平衡二叉树</title>
    <url>/2023-03-28-c58b9cf85e3e.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（Leetcode）</a></p>
<p><font color="#2DC26B">简单 </font><br>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p>
<p><strong>输入：</strong>root &#x3D; [3,9,20,null,null,15,7]<br><strong>输出：</strong>true</p>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p>
<p><strong>输入：</strong>root &#x3D; [1,2,2,3,3,null,null,4,4]<br><strong>输出：</strong>false</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>root &#x3D; []<br><strong>输出：</strong>true</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里是求<strong>高度</strong>： 节点到叶子节点的最长距离，使用<strong>后序遍历</strong><br><strong>深度</strong>是root 到该节点的最长距离（距离☞节点数），使用<strong>前序遍历</strong></p>
<p>因此只要分别计算左右子树的高度，并且做差不大于1就行</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用-1 记录 res 不是平衡二叉树<br>每次执行，都需要判断是不是等于-1，直接返回-1</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 136.只出现一次的数字</title>
    <url>/2023-10-16-66afbe22520d.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/single-number/description/">136. 只出现一次的数字</a><br><img src="/../../imgs/Pasted%20image%2020231016232403.png"><br>[TOC]</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p>
</blockquote>
<p>答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。</p>
<p>任何数和 0做异或运算，结果仍然是原来的数<br>任何数和其自身做异或运算，结果是 0<br><img src="https://pic.leetcode.cn/1697469725-QtsjoA-image.png" alt="image.png"></p>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>描述你的解题方法</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度:</p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度:</p>
<blockquote>
<p>添加空间复杂度, 示例： $O(1)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ol>
<li><p>hash</p>
<figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	numsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		numsMap[val] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key, val := <span class="keyword">range</span> numsMap &#123;</span><br><span class="line">		<span class="keyword">if</span> val == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算</p>
<figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    single := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        single ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode1603. 设计停车系统</title>
    <url>/2023-09-26-aeddfdb3bdac.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/design-parking-system/description/">1603. 设计停车系统</a></p>
</blockquote>
<p>  [TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。</p>
</blockquote>
<p>虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。</p>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>lastCar [3]int 添加上边的数组</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p>添加空间复杂度, 示例： $O(1)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="keyword">type</span> ParkingSystem <span class="keyword">struct</span> &#123;</span><br><span class="line">    lastCar [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(big <span class="type">int</span>, medium <span class="type">int</span>, small <span class="type">int</span>)</span></span> ParkingSystem &#123;</span><br><span class="line">    <span class="keyword">var</span> parkingSystem  ParkingSystem</span><br><span class="line">    parkingSystem.lastCar[<span class="number">0</span>] = big</span><br><span class="line">    parkingSystem.lastCar[<span class="number">1</span>] = medium</span><br><span class="line">    parkingSystem.lastCar[<span class="number">2</span>] = small</span><br><span class="line">    <span class="keyword">return</span> parkingSystem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ParkingSystem)</span></span> AddCar(carType <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    carIdx := carType - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> this.lastCar[carIdx] &gt; <span class="number">0</span> &#123;</span><br><span class="line">        this.lastCar[carIdx]--</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver）</span></span><br><span class="line"><span class="comment"> * param_1 := obj.AddCar(carType);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 200.岛屿数量</title>
    <url>/2023-05-10-da8c57fb590a.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230511010424.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	r := <span class="built_in">len</span>(grid)</span><br><span class="line">	c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	visited := <span class="built_in">make</span>([][]<span class="type">byte</span>, r)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">		visited[i] = <span class="built_in">make</span>([]<span class="type">byte</span>, c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历二维slice</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; c; j++ &#123;</span><br><span class="line">			<span class="comment">// 每个位置</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                dfs(grid, i, j, visited)</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="type">byte</span>, i <span class="type">int</span>, j <span class="type">int</span>, visited [][]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">len</span>(grid)</span><br><span class="line">	c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边界判断</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= r || j &gt;= c &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断值，是海水直接返回</span></span><br><span class="line">	<span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 判断是否走过</span></span><br><span class="line">	<span class="keyword">if</span> visited[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改变状态为海水,并修改为走过</span></span><br><span class="line">	grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    visited[i][j] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	<span class="comment">//单层递归逻辑，四面八方递归</span></span><br><span class="line">	dfs(grid, i+<span class="number">1</span>, j, visited)</span><br><span class="line">	dfs(grid, i, j+<span class="number">1</span>, visited)</span><br><span class="line">	dfs(grid, i<span class="number">-1</span>, j, visited)</span><br><span class="line">	dfs(grid, i, j<span class="number">-1</span>, visited)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也可以使用方向二维数组来遍历</p>
<p>可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="type">byte</span>, i <span class="type">int</span>, j <span class="type">int</span>, visited [][]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方向变化值dirs</span></span><br><span class="line">    dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界判断</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= r || j &gt;= c &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断值，是海水直接返回</span></span><br><span class="line">    <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否走过</span></span><br><span class="line">    <span class="keyword">if</span> visited[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变状态为海水,并修改为走过</span></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    visited[i][j] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历dirs，对四个方向进行递归</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">        new_i, new_j := i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]</span><br><span class="line">        dfs(grid, new_i, new_j, visited)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。</p>
<p><strong>使用额外的visited 的时候，一定要作为dfs 的入参，让其拷贝一份</strong><br>在 <code>dfs</code> 函数的递归调用中，条件判断 <code>if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok</code> 可能会导致部分陆地未被正确访问。原因是 <code>visited</code> 在函<strong>数调用之间是全局共享的</strong>，而不是每次调用都重新初始化（leetcode 的测试环境会造成影响）。</p>
<p>为了解决这个问题，你可以将 <code>visited</code> 变量作为参数传递给 <code>dfs</code> 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码：</p>
<p>需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。</p>
<h1 id="对应BFS实现"><a href="#对应BFS实现" class="headerlink" title="对应BFS实现"></a>对应BFS实现</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">    y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dirct = [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                res++</span><br><span class="line">                bfs(grid, i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(grid [][]<span class="type">byte</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    queue := []point&#123;&#123;i, j&#125;&#125;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>  <span class="comment">// 标记为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        current := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, item := <span class="keyword">range</span> dirct &#123;</span><br><span class="line">            myRow := current.x + item[<span class="number">0</span>]</span><br><span class="line">            myCol := current.y + item[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> myRow &gt;= <span class="number">0</span> &amp;&amp; myRow &lt; r &amp;&amp; myCol &gt;= <span class="number">0</span> &amp;&amp; myCol &lt; c &amp;&amp; grid[myRow][myCol] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                grid[myRow][myCol] = <span class="string">&#x27;0&#x27;</span>  <span class="comment">// 标记为已访问</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, point&#123;myRow, myCol&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">    y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dirct = [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[point]<span class="type">int</span>)  <span class="comment">// 使用局部变量，每次调用都重新初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                res++</span><br><span class="line">                dfs(grid, i, j, visited)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="type">byte</span>, i, j <span class="type">int</span>, visited <span class="keyword">map</span>[point]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= r || j &gt;= c &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="comment">// 和visited 等价</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := visited[point&#123;i, j&#125;]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment">// 和visited 等价</span></span><br><span class="line">    visited[point&#123;i, j&#125;] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> dirct &#123;</span><br><span class="line">        myRow := i + item[<span class="number">0</span>]</span><br><span class="line">        myCol := j + item[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> _, ok := visited[point&#123;myRow, myCol&#125;]; !ok &#123; <span class="comment">// 这里和前边 if _, ok := visited[point&#123;i, j&#125;]; ok 二选一</span></span><br><span class="line">            dfs(grid, myRow, myCol, visited)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是岛屿数量的 Go 语言代码中，有一点需要注意。在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a> 岛屿问题一文搞定</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>图遍历，岛屿问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 257.二叉树的所有路径</title>
    <url>/2023-03-28-53b6b0695943.html</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    path = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">	backTracking(root)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 终点 左右子节点都为nil</span></span><br><span class="line">	<span class="keyword">if</span> isLeafNode(root) &#123;</span><br><span class="line">        NodeValStr := strconv.Itoa(root.Val)</span><br><span class="line">	    path = <span class="built_in">append</span>(path, NodeValStr)</span><br><span class="line">		pathStr := strings.Join(path, <span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">		res = <span class="built_in">append</span>(res, pathStr)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前序遍历 中左右</span></span><br><span class="line">	<span class="comment">// 遍历 每次递归的操作</span></span><br><span class="line">	NodeVal:= strconv.Itoa(root.Val)<span class="comment">// 中</span></span><br><span class="line">	path = <span class="built_in">append</span>(path, NodeVal)</span><br><span class="line">	<span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123; <span class="comment">// 左</span></span><br><span class="line">		backTracking(root.Left)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123; <span class="comment">// 右</span></span><br><span class="line">		backTracking(root.Right)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLeafNode</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> node.Right==<span class="literal">nil</span> &amp;&amp; node.Left== <span class="literal">nil</span> &amp;&amp; node!= <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 404.左叶子之和</title>
    <url>/2023-03-29-c131676dd7b1.html</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 递归</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    leftNode := root.Left</span><br><span class="line">	leftNodeVal := sumOfLeftLeaves(root.Left) <span class="comment">// 左</span></span><br><span class="line">    rightNodeVal := sumOfLeftLeaves(root.Right)<span class="comment">// 右</span></span><br><span class="line">	<span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; leftNode.Left == <span class="literal">nil</span> &amp;&amp; leftNode.Right == <span class="literal">nil</span> &#123; <span class="comment">// 中</span></span><br><span class="line">		leftNodeVal = leftNode.Val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 单次循环</span></span><br><span class="line">    res = leftNodeVal + rightNodeVal <span class="comment">// 中，左边+右边</span></span><br><span class="line">	<span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 513.找树左下角的值</title>
    <url>/2023-04-03-03cca064ab00.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（Leetcode）</a></p>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg"></p>
<p><strong>输入:</strong> root &#x3D; [2,1,3]<br><strong>输出:</strong> 1</p>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg"></p>
<p><strong>输入:</strong> [1,2,3,4,null,5,6,null,null,7]<br><strong>输出:</strong> 7</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,104]</code></li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本题可以转化为什么呢？</p>
<blockquote>
<p>1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值<br>2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> depth <span class="type">int</span>   <span class="comment">// 全局变量 最大深度</span></span><br><span class="line"><span class="keyword">var</span> res <span class="type">int</span>     <span class="comment">// 记录最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    depth, res = <span class="number">0</span>, <span class="number">0</span>   </span><br><span class="line">    dfs(root, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode, d <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里判断nil ,后边左右节点就不用判断了</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; depth &lt; d &#123; </span><br><span class="line">        depth = d</span><br><span class="line">        res = root.Val</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.Left, d+<span class="number">1</span>)   </span><br><span class="line">    dfs(root.Right, d+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.迭代</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">-1</span></span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	<span class="comment">//res 在哪里更新呢？</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="comment">// 遍历每一层</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:]</span><br><span class="line">			<span class="comment">// 获取每一层的最左边的位置，更新res</span></span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">				res = top.Val</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, top.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代2 每层用一个切片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">-1</span></span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过另外一个切片来添加的解法也要尝试学习一下</span></span><br><span class="line">	queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	<span class="comment">//res 在哪里更新呢？</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="comment">// 使用nextqueue 保存每一层，然后追加到queue</span></span><br><span class="line">		nextqueue := []*TreeNode&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:]</span><br><span class="line">		    res = nextqueue[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextqueue = <span class="built_in">append</span>(nextqueue, top.Left)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextqueue = <span class="built_in">append</span>(nextqueue, top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		queue = <span class="built_in">append</span>(queue,nextqueue...)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>如果要求最右边的值呢？这里该怎么求呢？</p>
<p>只需要将 遍历左右的顺序颠倒一下即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">-1</span></span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	<span class="comment">//res 在哪里更新呢？</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="comment">// 遍历每一层</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:]</span><br><span class="line">			<span class="comment">// 获取每一层的最左边的位置，更新res</span></span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">				res = top.Val</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, top.Left)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>go语言实现优先队列</title>
    <url>/2024-05-18-dfe0612e31db.html</url>
    <content><![CDATA[<p>Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。</p>
<h3 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1. 优先队列"></a>1. 优先队列</h3><p>优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。</p>
<h3 id="2-最大堆"><a href="#2-最大堆" class="headerlink" title="2. 最大堆"></a>2. 最大堆</h3><p>最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。</p>
<h3 id="3-最小堆"><a href="#3-最小堆" class="headerlink" title="3. 最小堆"></a>3. 最小堆</h3><p>最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="定义堆的元素类型"><a href="#定义堆的元素类型" class="headerlink" title="定义堆的元素类型"></a>定义堆的元素类型</h4><p>首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<h4 id="实现heap-Interface接口"><a href="#实现heap-Interface接口" class="headerlink" title="实现heap.Interface接口"></a>实现heap.Interface接口</h4><p>要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125; <span class="comment">// 对于最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="使用heap-Init初始化堆"><a href="#使用heap-Init初始化堆" class="headerlink" title="使用heap.Init初始化堆"></a>使用heap.Init初始化堆</h4><p>在使用堆之前，你需要调用heap.Init来初始化它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h IntHeap <span class="comment">// 先声明h</span></span><br><span class="line"></span><br><span class="line">heap.Init(&amp;h) <span class="comment">// 再使用heap.Init(&amp;h) 初始化h指针</span></span><br></pre></td></tr></table></figure>

<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用heap.Push来添加元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">heap.Push(&amp;h, <span class="number">10</span>)</span><br><span class="line">heap.Push(&amp;&amp;h, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h := &amp;MyHeap&#123;&#125;  <span class="comment">// 创建堆实例</span></span><br><span class="line">heap.Init(h)       <span class="comment">// 初始化堆</span></span><br><span class="line">heap.Push(h, item) <span class="comment">// 添加元素</span></span><br><span class="line">item := heap.Pop(h) <span class="comment">// 取出元素</span></span><br></pre></td></tr></table></figure>

<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用heap.Pop来移除并获取堆顶元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">top := heap.Pop(&amp;h)</span><br><span class="line">fmt.Printf(<span class="string">&quot;top element: %v\n&quot;</span>, top)</span><br></pre></td></tr></table></figure>

<h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。</p>
<h3 id="转换为最大堆"><a href="#转换为最大堆" class="headerlink" title="转换为最大堆"></a>转换为最大堆</h3><p>如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 对于最大堆</span></span><br></pre></td></tr></table></figure>

<p>以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。</p>
<h1 id="结构体-优先队列"><a href="#结构体-优先队列" class="headerlink" title="结构体 优先队列"></a>结构体 优先队列</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value    <span class="type">string</span></span><br><span class="line">    Priority <span class="type">int</span></span><br><span class="line">    Index    <span class="type">int</span> <span class="comment">// 堆中的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 优先值大的先出（最大堆）</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].Priority &gt; pq[j].Priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].Index = i</span><br><span class="line">    pq[j].Index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x any) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.Index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() any &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span>  <span class="comment">// 避免内存泄漏</span></span><br><span class="line">    item.Index = <span class="number">-1</span> <span class="comment">// 标记已移除</span></span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新元素的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Update(item *Item, value <span class="type">string</span>, priority <span class="type">int</span>) &#123;</span><br><span class="line">    item.Value = value</span><br><span class="line">    item.Priority = priority</span><br><span class="line">    heap.Fix(pq, item.Index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=problem-list-v2&envId=IAmiWIlN">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240520000338.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2024 Lei Qi. All rights reserved.</span></span><br><span class="line"><span class="comment"> * Author: Lei Qi</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Date: 2024/5/20 上午12:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> leetcode215</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	h := heapify(nums) <span class="comment">// 转化为heap 类型</span></span><br><span class="line">	<span class="keyword">var</span> res any</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		res = heap.Pop(&amp;h)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res.(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BigHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h BigHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h BigHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 大根堆</span></span><br><span class="line">	<span class="keyword">return</span> h[i] &gt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h BigHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	tmp := h[i]</span><br><span class="line">	h[i] = h[j]</span><br><span class="line">	h[j] = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BigHeap)</span></span> Push(x any) &#123; <span class="comment">// 使用any 或者interface</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素待定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BigHeap)</span></span> Pop() any &#123;</span><br><span class="line">	x := (*h)[h.Len()<span class="number">-1</span>]</span><br><span class="line">	*h = (*h)[:h.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 nums 转换成 BigHeap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(nums []<span class="type">int</span>)</span></span> BigHeap &#123;</span><br><span class="line"></span><br><span class="line">    h := BigHeap(nums) <span class="comment">// bigHeap 本身就是slice 的别名，所以可以转换</span></span><br><span class="line">    <span class="comment">// 或者使用下边两行</span></span><br><span class="line">	h := <span class="built_in">make</span>(BigHeap, <span class="built_in">len</span>(nums)) <span class="comment">// 新建BigHeap，长度为lenNums</span></span><br><span class="line">	<span class="built_in">copy</span>(h, nums)                 <span class="comment">// 将num copy 到 BigHeap 中去</span></span><br><span class="line">	heap.Init(&amp;h)                 <span class="comment">// 需要输入指针</span></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240521004343.png"></p>
<p>涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方法一：小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    map_num:=<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//记录每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> _,item:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        map_num[item]++</span><br><span class="line">    &#125;</span><br><span class="line">    h:=&amp;IHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    <span class="comment">//所有元素入堆，堆的长度为k</span></span><br><span class="line">    <span class="keyword">for</span> key,value:=<span class="keyword">range</span> map_num&#123;</span><br><span class="line">        heap.Push(h,[<span class="number">2</span>]<span class="type">int</span>&#123;key,value&#125;)</span><br><span class="line">        <span class="keyword">if</span> h.Len()&gt;k&#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res:=<span class="built_in">make</span>([]<span class="type">int</span>,k)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序返回堆中的元素</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++&#123;</span><br><span class="line">        res[k-i<span class="number">-1</span>]=heap.Pop(h).([<span class="number">2</span>]<span class="type">int</span>)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建小顶堆</span></span><br><span class="line"><span class="keyword">type</span> IHeap [][<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Len()<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Less (i,j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i][<span class="number">1</span>]&lt;h[j][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Swap(i,j <span class="type">int</span>) &#123;</span><br><span class="line">    h[i],h[j]=h[j],h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">    *h=<span class="built_in">append</span>(*h,x.([<span class="number">2</span>]<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    old:=*h</span><br><span class="line">    n:=<span class="built_in">len</span>(old)</span><br><span class="line">    x:=old[n<span class="number">-1</span>]</span><br><span class="line">    *h=old[<span class="number">0</span>:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode  1.两数之和</title>
    <url>/2024-08-21-64c0a1f316e6.html</url>
    <content><![CDATA[<p>有两种思路：</p>
<ol>
<li>使用暴力遍历， 复杂度的是 O(n ^2)</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:= i+<span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用哈希表，是O(n)<br>  使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> idx, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		maps[num] = idx</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> idx, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; <span class="comment">// 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意</span></span><br><span class="line">			<span class="keyword">return</span> []<span class="type">int</span>&#123;idx, idx2&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 102. 二叉树的层序遍历</title>
    <url>/2023-05-23-a419f5d1c6af.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523224632.png"></p>
<h1 id="使用slice"><a href="#使用slice" class="headerlink" title="使用slice"></a>使用slice</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 层序遍历 使用size 记录每层数组 queue node 队列</span></span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    queue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        levels := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:<span class="built_in">len</span>(queue)] <span class="comment">//切掉元素0</span></span><br><span class="line"></span><br><span class="line">            levels = <span class="built_in">append</span>(levels, node.Val) <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span>  &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, levels)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="使用list"><a href="#使用list" class="headerlink" title="使用list"></a>使用list</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;<span class="comment">//防止为空</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := &amp;list.List&#123;&#125;</span><br><span class="line">    queue.PushBack(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        length := queue.Len()               <span class="comment">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）     </span></span><br><span class="line">        <span class="keyword">var</span> levelQueue []<span class="type">int</span></span><br><span class="line">        fmt.Println(length)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">            node := queue.Remove(queue.Front()).(*TreeNode)    <span class="comment">//出队列</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            levelQueue = <span class="built_in">append</span>(levelQueue, node.Val)    <span class="comment">//将值加入本层切片中</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, levelQueue)          <span class="comment">//放入结果集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 104.二叉树的深度</title>
    <url>/2023-05-30-b1879d2b65d1.html</url>
    <content><![CDATA[<p>个人网站：<a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531000419.png"></p>
<p>二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。</p>
<p>所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span> <span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxdepth</span><span class="params">(root *treenode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(maxdepth(root.left), maxdepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>可以使用模板层序遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	depth := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue := list.New()</span><br><span class="line">	queue.PushBack(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := queue.Len()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			<span class="comment">// 切掉第一个元素</span></span><br><span class="line">			first := queue.Remove(queue.Front()).(*TreeNode) <span class="comment">//注意层序遍历是切掉前边一个</span></span><br><span class="line">			<span class="keyword">if</span> first.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue.PushBack(first.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> first.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue.PushBack(first.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片实现"><a href="#切片实现" class="headerlink" title="切片实现"></a>切片实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	depth := <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	queue = <span class="built_in">append</span>(queue,root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123; <span class="comment">// queue 不为空的时候</span></span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;size ;i++ &#123;<span class="comment">// 遍历一层</span></span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 取最上层元素，并切掉该元素</span></span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">        depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用一个临时切片来存储当前层所有节点的子节点"><a href="#使用一个临时切片来存储当前层所有节点的子节点" class="headerlink" title="使用一个临时切片来存储当前层所有节点的子节点"></a>使用一个临时切片来存储当前层所有节点的子节点</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用切片实现队列</span></span><br><span class="line">	<span class="keyword">var</span> queue []*TreeNode</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	depth := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前层的节点数量</span></span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用一个临时切片来存储当前层所有节点的子节点</span></span><br><span class="line">		<span class="keyword">var</span> nextLevel []*TreeNode</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			<span class="comment">// 从队列头部移除节点</span></span><br><span class="line">			node := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 移除队列的第一个元素</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将左子树和右子树添加到下一层的队列</span></span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextLevel = <span class="built_in">append</span>(nextLevel, node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextLevel = <span class="built_in">append</span>(nextLevel, node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将下一层的节点赋值给当前层的队列</span></span><br><span class="line">		queue = nextLevel</span><br><span class="line">		<span class="comment">// 每次循环处理一层的节点</span></span><br><span class="line">		depth++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 108.将有序数组转换为二叉搜索树</title>
    <url>/2023-05-04-ce9a22434c37.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020230504232459.png"></p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑<br>注意递归函数定义，严格按照定义调用递归<br>使用前序遍历 中左右</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：返回nums root 节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(nums []<span class="type">int</span>,left <span class="type">int</span> , right <span class="type">int</span>)</span></span> *TreeNode&#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := (left + right)/<span class="number">2</span></span><br><span class="line">    root := &amp;TreeNode&#123;nums[mid],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    root.Left =  traversal(nums,left,mid<span class="number">-1</span>) <span class="comment">// 把后边 root 节点添加到当前root left 左节点上</span></span><br><span class="line">    root.Right = traversal(nums,mid+<span class="number">1</span>,right) <span class="comment">// 把后边 root 节点添加到当前root right 左节点上</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1091.二进制矩阵中的最短路径</title>
    <url>/2023-05-26-5abcbf266873.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230526235236.png"><br>DFS 超时版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(grid)</span><br><span class="line">	<span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[n<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> help <span class="function"><span class="keyword">func</span><span class="params">(i, j, tmp <span class="type">int</span>)</span></span></span><br><span class="line"></span><br><span class="line">	help = <span class="function"><span class="keyword">func</span><span class="params">(i, j, tmp <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 判断是否越界或已经访问过当前节点</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i == n<span class="number">-1</span> &amp;&amp; j == n<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// 当到达终点时，更新res</span></span><br><span class="line">			<span class="keyword">if</span> tmp+<span class="number">1</span> &lt; res || res == <span class="number">0</span> &#123;</span><br><span class="line">				res = tmp + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将当前点标记为已访问</span></span><br><span class="line">		grid[i][j] = <span class="number">1</span></span><br><span class="line">		tmp++</span><br><span class="line">		<span class="keyword">for</span> _, item := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">			x := i + item[<span class="number">0</span>]</span><br><span class="line">			y := j + item[<span class="number">1</span>]</span><br><span class="line">			help(x, y, tmp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 回溯操作，将当前点复原为未访问状态</span></span><br><span class="line">		grid[i][j] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	help(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>BFS，最短路径使用BFS </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x,y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// queue 维护</span></span><br><span class="line">	m,n := <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[point]<span class="type">int</span>)</span><br><span class="line">	queue := <span class="built_in">make</span>([]point,<span class="number">0</span>)</span><br><span class="line">	step := <span class="number">1</span></span><br><span class="line">	start := point&#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">	end := point&#123;m<span class="number">-1</span>,n<span class="number">-1</span>&#125;</span><br><span class="line">	dirs := []point&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;</span><br><span class="line">	<span class="comment">// 起点为1 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue = <span class="built_in">append</span>(queue,start)</span><br><span class="line">	visited[start] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="comment">// 将当前队列中的所有节点向四周扩散</span></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; size; i++&#123;</span><br><span class="line">			cur := queue[<span class="number">0</span>] <span class="comment">// 当前cur</span></span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 切掉当前点</span></span><br><span class="line">			<span class="comment">// 判断是否是终点</span></span><br><span class="line">			<span class="keyword">if</span> cur == end &#123;</span><br><span class="line">				<span class="keyword">return</span> step</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 遍历八个方向 判断是否符合边界条件</span></span><br><span class="line">			<span class="keyword">for</span> _, dir :=<span class="keyword">range</span> dirs&#123;</span><br><span class="line">				newX := cur.x + dir.x</span><br><span class="line">				newY := cur.y + dir.y</span><br><span class="line">				newPoint := point&#123;newX,newY&#125;</span><br><span class="line">				<span class="keyword">if</span> newX &gt;=<span class="number">0</span> &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=<span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==<span class="number">0</span> &amp;&amp; grid[newX][newY]==<span class="number">0</span> &#123;</span><br><span class="line">					visited[point&#123;newX,newY&#125;] = <span class="number">1</span></span><br><span class="line">					queue =<span class="built_in">append</span>(queue,newPoint)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		step++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 只能为0 的路径才可以更新到queue  边界控制</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>&gt; <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solutions/1076268/bfszui-duan-lu-jing-wen-ti-bfsdfsde-si-k-ngc5/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a>### 解题思路</strong></p>
<blockquote>
<p>典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。</p>
</blockquote>
<p><strong>&gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？</strong></p>
<blockquote>
<p>1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</p>
</blockquote>
<p><strong>&gt; ### BFS解法中的visited为什么可以全局使用？</strong></p>
<blockquote>
<p>BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二维数组最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1170. 比较字符串最小字母出现频次</title>
    <url>/2023-06-14-88f65f0a1bb7.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/">1170. 比较字符串最小字母出现频次 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230614235423.png"></p>
<p><strong>后缀和（</strong>Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。</p>
<p>具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。</p>
<p>在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。</p>
<h2 id="不使用后缀和"><a href="#不使用后缀和" class="headerlink" title="不使用后缀和"></a>不使用后缀和</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    ch := <span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> c &lt; ch &#123;</span><br><span class="line">        ch = c</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == ch &#123;</span><br><span class="line">        cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSmallerByFrequency</span><span class="params">(queries []<span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="comment">// 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> words &#123;</span><br><span class="line">        count[f(s)] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, c := <span class="keyword">range</span> count &#123; <span class="comment">// 遍历count</span></span><br><span class="line">            <span class="keyword">if</span> c&gt;<span class="number">0</span> &amp;&amp; f(s) &lt; idx &#123;<span class="comment">// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c</span></span><br><span class="line">                res[i]+=c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用后缀和"><a href="#使用后缀和" class="headerlink" title="使用后缀和"></a>使用后缀和</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    ch := <span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> c &lt; ch &#123;</span><br><span class="line">        ch = c</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == ch &#123;</span><br><span class="line">        cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSmallerByFrequency</span><span class="params">(queries []<span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="comment">// 先计算word 里的每个数</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> words &#123;</span><br><span class="line">        count[f(s)] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算后缀和,i+1 就是大于i位置的所有个数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">9</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">        count[i] += count[i + <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        res[i] = count[f(s) + <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？</strong></p>
<p>在<code>numSmallerByFrequency</code>函数中， <code>count</code>数组记录的是各个不同频次出现的次数，因此 <code>count[i]</code>代表所有最小字母出现频次不于 i 的字符串的数量。</p>
<p>如果对于 <code>queries</code> 中的某个字符串 <code>s</code> ，它的最小字母出现频次为 <code>f(s)</code>，那么可以依据 <code>count</code> 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 <code>f(s)+1</code> 开始的所有频次出现次数即可：</p>
<p><code>res[i] = count[f(s) + 1]</code></p>
<p>这里使用的是 <code>f(s)+1</code> 而不是 <code>f(s)</code> 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 122买动态股票的最佳时机II</title>
    <url>/2023-05-27-5cebfed1675b.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230527235217.png"></p>
<p>每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。</p>
<p>相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。</p>
<p>下面是代码解释：</p>
<p>首先定义变量 sum 记录当前总利润。<br>然后从第二个价格开始遍历，计算当日价格与前一天价格之差。<br>如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。<br>最后返回累计的总利润。<br>这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="comment">// 累加每次大于0的交易</span></span><br><span class="line">        <span class="keyword">if</span> prices[i] - prices[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1396.设计地铁系统</title>
    <url>/2023-05-18-0a0f1bd6a4a5.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/design-underground-system/description/">1396. 设计地铁系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230518233218.png"></p>
<p>设计题：</p>
<p>设计数据结构</p>
<ul>
<li>user<ul>
<li>startTime int  </li>
<li>endTime int</li>
<li>startStationName string</li>
<li>endStatationName string</li>
</ul>
</li>
<li>UndergroundSystem<ul>
<li>userMap map[int]*user</li>
<li>pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间</li>
</ul>
</li>
</ul>
<p>注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">	startTime <span class="type">int</span></span><br><span class="line">	endTime <span class="type">int</span></span><br><span class="line">	startStationName <span class="type">string</span></span><br><span class="line">	endStatationName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UndergroundSystem <span class="keyword">struct</span> &#123;</span><br><span class="line">	userMap <span class="keyword">map</span>[<span class="type">int</span>]*user</span><br><span class="line">	pathMap <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span> <span class="comment">// 存放对应路程的用时，用于计算平均时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> UndergroundSystem &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">return</span> UndergroundSystem&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*user),<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> CheckIn(id <span class="type">int</span>, stationName <span class="type">string</span>, t <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//userMap 添加</span></span><br><span class="line">	this.userMap[id] = &amp;user&#123;id:id&#125; <span class="comment">// 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址</span></span><br><span class="line">	this.userMap[id].startTime = t</span><br><span class="line">	this.userMap[id].startStationName = stationName</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> CheckOut(id <span class="type">int</span>, stationName <span class="type">string</span>, t <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//出站时，更新user.end* ;append pathmap</span></span><br><span class="line">	useTime := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> _,ok := this.userMap[id] ;ok &#123;</span><br><span class="line">		this.userMap[id].endTime = t</span><br><span class="line">		this.userMap[id].endStatationName = stationName</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mapKey := this.userMap[id].startStationName +<span class="string">&quot;-&gt;&quot;</span> + this.userMap[id].endStatationName</span><br><span class="line">	useTime = this.userMap[id].endTime - this.userMap[id].startTime</span><br><span class="line">	this.pathMap[mapKey] = <span class="built_in">append</span>(this.pathMap[mapKey],useTime)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> GetAverageTime(startStation <span class="type">string</span>, endStation <span class="type">string</span>) <span class="type">float64</span> &#123;</span><br><span class="line">	mapKey := startStation +<span class="string">&quot;-&gt;&quot;</span> + endStation</span><br><span class="line">	<span class="keyword">return</span> average(this.pathMap[mapKey])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">average</span><span class="params">(s []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum +=v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(sum)/<span class="type">float64</span>(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.CheckIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj.CheckOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>设计题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 144. 二叉树的前序遍历</title>
    <url>/2023-05-23-62bd8ef029a5.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（Leetcode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020230523224940.png"></p>
<p>记得提前判断是否为空，否则会报找不到内存指针的错误<br><img src="/../../imgs/Pasted%20image%2020230523225147.png"></p>
<p>注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。<a href="leetcode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">leetcode 102. 二叉树的层序遍历</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	stack := list.New()</span><br><span class="line">	res :=  []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span>&#123;<span class="comment">//防止为空</span></span><br><span class="line">			<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	stack.PushBack(root)</span><br><span class="line">	<span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		top := stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">		res = <span class="built_in">append</span>(res,top.Val)</span><br><span class="line">		<span class="keyword">if</span> top.Right !=<span class="literal">nil</span> &#123;</span><br><span class="line">			stack.PushBack(top.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> top.Left !=<span class="literal">nil</span> &#123;</span><br><span class="line">			stack.PushBack(top.Left)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 155.最小栈</title>
    <url>/2023-10-12-cfa4d16bfad5.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈</a></p>
</blockquote>
<p><img src="/../../imgs/Pasted%20image%2020231013000854.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>栈</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度:</p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度:</p>
<blockquote>
<p>添加空间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</span></span><br><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack    []<span class="type">int</span> <span class="comment">// 主栈</span></span><br><span class="line">	minStack []<span class="type">int</span> <span class="comment">// 辅助栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">	minStacks := MinStack&#123;[]<span class="type">int</span>&#123;&#125;, []<span class="type">int</span>&#123;math.MaxInt&#125;&#125;</span><br><span class="line">	<span class="keyword">return</span> minStacks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 同时比较辅助站的的top元素，如果更小 则添加到辅助站</span></span><br><span class="line">	this.stack = <span class="built_in">append</span>(this.stack, x)</span><br><span class="line">	minTmp := min(x, this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>])</span><br><span class="line">	this.minStack = <span class="built_in">append</span>(this.minStack, minTmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">	this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">	this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1726.同积元组</title>
    <url>/2023-10-20-9599b5db4d91.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组</a></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>使用排列组合的方法，开始使用三种语言同时写leetcode.</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p><img src="/../../imgs/Pasted%20image%2020231020003943.png"></p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度:</p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度:</p>
<blockquote>
<p>添加空间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tupleSameProduct</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    cnt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;<span class="comment">// j +1 不要重复</span></span><br><span class="line">            cnt[nums[i] * nums[j]]++ <span class="comment">// 使用map 遍历每次乘积对应次数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cnt &#123;</span><br><span class="line">        ans += v * (v - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tupleSameProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cnt[nums[i] * nums[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : cnt) &#123;</span><br><span class="line">            ans += v * (v - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def tupleSameProduct(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maps = dict()</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i+1,n):</span><br><span class="line">                if nums[i]*nums[j] in maps:</span><br><span class="line">                    maps[nums[i] * nums[j]] += 1</span><br><span class="line">                else:</span><br><span class="line">                    maps[nums[i] * nums[j]] = 1</span><br><span class="line"></span><br><span class="line">        ans = 0</span><br><span class="line">        for _, v in maps.items():</span><br><span class="line">            ans += v*(v-1) *4</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1845. 座位预约管理系统</title>
    <url>/2023-10-06-c2afb6383992.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统</a></p>
</blockquote>
<p>个人博客,记录学习: <a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a><br>  [TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存.</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>使用slice 的index来表示座位号,<br>1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.<br>2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n;</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度:</p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度:</p>
<blockquote>
<p>添加空间复杂度, 示例： $O(n)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><strong>使用slice</strong><br>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> SeatManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	seats []<span class="type">int</span></span><br><span class="line">	min <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> SeatManager &#123;</span><br><span class="line">	set:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> SeatManager&#123;seats:set,min:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Reserve() <span class="type">int</span> &#123;</span><br><span class="line">	value := this.min</span><br><span class="line">	this.seats[value]=<span class="number">1</span></span><br><span class="line">	length := <span class="built_in">len</span> (this.seats)</span><br><span class="line">	fmt.Println(length)</span><br><span class="line">	i:=value</span><br><span class="line">	<span class="keyword">for</span> ;i&lt;length+<span class="number">1</span>;i++&#123;</span><br><span class="line">		<span class="keyword">if</span> this.seats[i]==<span class="number">1</span>&#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		this.min=i <span class="comment">// 中间变量，更新下次的最小座位号</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value <span class="comment">// 最小的座位号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="type">int</span>)  &#123;</span><br><span class="line">	this.seats[seatNumber] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> seatNumber &lt; this.min&#123;</span><br><span class="line">		this.min=seatNumber</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>使用map</strong><br>map 有个用例会超时</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SeatManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	seatMap   <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	minSeat   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> SeatManager &#123;</span><br><span class="line">	seatMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123; <span class="comment">// 注意从0 开始初始化</span></span><br><span class="line">		seatMap[i] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	seatMan := SeatManager&#123;</span><br><span class="line">		seatMap,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seatMan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Reserve() <span class="type">int</span> &#123;</span><br><span class="line">  value := this.minSeat</span><br><span class="line">	this.seatMap[value] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i:= value; i &lt;= <span class="built_in">len</span>(this.seatMap);i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> this.seatMap[i] == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.minSeat = i</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="type">int</span>) &#123;</span><br><span class="line">  this.seatMap[seatNumber] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> seatNumber &lt; this.minSeat &#123;</span><br><span class="line">    this.minSeat = seatNumber</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1845.座位预约管理系统</title>
    <url>/2023-05-22-97adde03f66a.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523000703.png"></p>
<h3 id="超时版本"><a href="#超时版本" class="headerlink" title="超时版本"></a>超时版本</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> seat <span class="keyword">struct</span> &#123;</span><br><span class="line">	seatId <span class="type">int</span></span><br><span class="line">	isFree <span class="type">int</span> <span class="comment">// 空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SeatManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	seats   <span class="keyword">map</span>[<span class="type">int</span>]*seat</span><br><span class="line">	isFrees []<span class="type">int</span> <span class="comment">// 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> SeatManager &#123;</span><br><span class="line">	<span class="keyword">var</span> a = SeatManager&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*seat, n), <span class="built_in">make</span>([]<span class="type">int</span>, n)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		id := i + <span class="number">1</span></span><br><span class="line">		a.seats[id] = &amp;seat&#123;id, <span class="number">1</span>&#125;</span><br><span class="line">		a.isFrees[i] = id <span class="comment">// 初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Reserve() <span class="type">int</span> &#123;</span><br><span class="line">	sort.Ints(this.isFrees)</span><br><span class="line">	top := this.isFrees[<span class="number">0</span>]</span><br><span class="line">	this.seats[top].isFree = <span class="number">0</span></span><br><span class="line">	this.isFrees = this.isFrees[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 或者使用map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="type">int</span>) &#123;</span><br><span class="line">	this.seats[seatNumber].isFree = <span class="number">1</span></span><br><span class="line">	this.isFrees = <span class="built_in">append</span>(this.isFrees,seatNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="通过版本"><a href="#通过版本" class="headerlink" title="通过版本"></a>通过版本</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> SeatManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	seats []<span class="type">int</span></span><br><span class="line">	min <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> SeatManager &#123;</span><br><span class="line">	set:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> SeatManager&#123;seats:set,min:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Reserve() <span class="type">int</span> &#123;</span><br><span class="line">	value := this.min</span><br><span class="line">	this.seats[value]=<span class="number">1</span></span><br><span class="line">	length := <span class="built_in">len</span> (this.seats)</span><br><span class="line">	fmt.Println(length)</span><br><span class="line">	i:=value</span><br><span class="line">	<span class="keyword">for</span> ;i&lt;length+<span class="number">1</span>;i++&#123;</span><br><span class="line">		<span class="keyword">if</span> this.seats[i]==<span class="number">1</span>&#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		this.min=i <span class="comment">// 中间变量，更新下次的最小座位号</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value <span class="comment">// 最小的座位号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="type">int</span>)  &#123;</span><br><span class="line">	this.seats[seatNumber]=<span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> seatNumber &lt; this.min&#123;</span><br><span class="line">		this.min=seatNumber</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 208. 实现 Trie (前缀树)</title>
    <url>/2024-04-16-1150f59f3df6.html</url>
    <content><![CDATA[<p>Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。</p>
<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240417003637.png"></p>
<p>Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。</p>
<p>为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    Value <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    Next  *TrieNode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    children [<span class="number">26</span>]*TrieNode</span><br><span class="line"></span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// TrieNode 代表Trie中的每个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    children [<span class="number">26</span>]*TrieNode</span><br><span class="line"></span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 代表整个前缀树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    root *TrieNode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 初始化一个Trie对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 将word插入到trie中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">    node := this.root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line"></span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">            node.children[index] = &amp;TrieNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node.children[index]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.isEnd = <span class="literal">true</span> <span class="comment">// 标记单词结束的节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Search 在trie中搜索word</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    node := this.root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line"></span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果路径中的节点不存在，说明word不在trie中</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node.children[index]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.isEnd <span class="comment">// 检查最后一个节点是否标记为单词结尾</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// StartsWith 返回trie中是否有任何单词以prefix为前缀</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    node := this.root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line"></span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果路径中的节点不存在，说明没有以prefix为前缀的word</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node.children[index]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 所有的char都在路径中，说明trie有以prefix为前缀的word</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 222.完全二叉树的节点个数</title>
    <url>/2023-03-28-da7418525964.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（Leetcode）</a></p>
<p>给出一个完全二叉树，求出该树的节点个数。<br><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
<p>示例 1：<br><img src="/../../imgs/Pasted%20image%2020230328221334.png"></p>
<ul>
<li>输入：root &#x3D; [1,2,3,4,5,6]</li>
<li>输出：6</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：root &#x3D; []</li>
<li>输出：0</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：root &#x3D; [1]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>树中节点的数目范围是[0, 5 * 10^4]</li>
<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4</li>
<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>使用普通二叉树的思想来求，使用层序遍历 或者递归<br>  增加一个变量来存<strong>node</strong> 的个数</li>
<li>利用<strong>完全二叉树</strong>的性质，他只有最后一层没有填满，并且是从左到右依次填满的。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>思路1：普通二叉树</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">1</span> <span class="comment">//记录res, 递归算root=1</span></span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        count += countNodes(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        count += countNodes(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := list.New()</span><br><span class="line">    q.PushBack(root)</span><br><span class="line">    res := <span class="number">0</span> <span class="comment">// 记录res, 这里root 加入到了队列，所以res=0 而不是1</span></span><br><span class="line">    <span class="keyword">for</span> q.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := q.Len()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := q.Remove(q.Front()).(*TreeNode)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2：完全二叉树</strong></p>
<ol>
<li>确定递归函数的参数和返回值 ： 输入根节点，返回int 节点数<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li>递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</li>
<li>单层递归逻辑：<br> 需要先求左子右树的节点数量（我们转化为满二叉树，使用公式计算）然后加上root<br> 结果等于 leftTreeNum + rightTreeNum + 1  （leftTreeNum为左子满二叉树，rightTreeNum为右子满二叉树，1是root）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    leftH, rightH := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    leftNode := root.Left</span><br><span class="line">    rightNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> leftNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        leftNode = leftNode.Left</span><br><span class="line">        leftH++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        rightNode = rightNode.Right</span><br><span class="line">        rightH++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</span></span><br><span class="line">    <span class="keyword">if</span> leftH == rightH &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftH) - <span class="number">1</span>  <span class="comment">// 2左移 即为平方</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftTreeNum := countNodes(root.Left) <span class="comment">// 左</span></span><br><span class="line">    rightTreeNum := countNodes(root.Right) <span class="comment">// 右</span></span><br><span class="line">    res := leftTreeNum + rightTreeNum + <span class="number">1</span> <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 226. 翻转二叉树</title>
    <url>/2023-05-23-d59f64e0619b.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523230644.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 定义将二叉树翻转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点</span></span><br><span class="line">    root.Right,root.Left = root.Left,root.Right </span><br><span class="line">    <span class="comment">// 将右子树翻转</span></span><br><span class="line">    invertTree(root.Right)</span><br><span class="line">    <span class="comment">// 将左子树翻转</span></span><br><span class="line">    invertTree(root.Left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 2460.对数组执行操作 2023.05.06每日一题</title>
    <url>/2023-06-05-869070f8049d.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/apply-operations-to-an-array/description/">2460. 对数组执行操作 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230605224628.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接模拟</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>第一版<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyOperations</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">	res = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 第一次遍历 进行赋值操作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			nums[i] *= <span class="number">2</span></span><br><span class="line">			nums[i+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第二次遍历 将非0移动到前边</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] != <span class="number">0</span> &#123;</span><br><span class="line">			res[index] = nums[i]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二版<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyOperations</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; n &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            nums[i] *= <span class="number">2</span></span><br><span class="line">            nums[i + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != <span class="number">0</span> &#123;</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 2511 最多可以摧毁的敌人城堡数目</title>
    <url>/2023-09-02-72954cc13c19.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/description/?envType=daily-question&envId=2023-09-02">2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020230902205220.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>抽象出来就是求1和-1间最大连续0 的数量。</p>
<p>有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？</p>
<p>1.当然可以分类讨论，代码会很复杂，判断很多，容易出错</p>
<ol start="2">
<li>使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureForts</span><span class="params">(forts []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    ans, pre := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pre 记录的是 1 或 -1 的位置 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, fort := <span class="keyword">range</span> forts &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fort == <span class="number">-1</span> || fort == <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= <span class="number">0</span> &amp;&amp; forts[pre] != fort &#123;</span><br><span class="line"></span><br><span class="line">                ans = max(ans, i - pre - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = i</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 2594修车的最少时间</title>
    <url>/2023-09-07-b8c038c07b41.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230908000057.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>能力值为 <code>r</code> 的机械工可以在 t&#x3D; <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。<br>可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repairCars</span><span class="params">(ranks []<span class="type">int</span>, cars <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    l , r := <span class="number">1</span>, ranks[<span class="number">0</span>] * cars * cars</span><br><span class="line">    <span class="keyword">var</span> check = <span class="function"><span class="keyword">func</span><span class="params">(m <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        cnt := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, x := <span class="keyword">range</span> ranks &#123;</span><br><span class="line">            cnt += <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(m / x)))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= cars</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        m := (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check(m) &#123;</span><br><span class="line">            r = m</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol>
<li><p><code>l</code> 和 <code>r</code> 的初始化：</p>
<ul>
<li><code>l</code> 初始化为1，表示最小可能的修理时间。</li>
<li><code>r</code> 初始化为 <code>ranks[0] * cars * cars</code>，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。</li>
</ul>
</li>
<li><p><code>check</code> 函数定义：</p>
<ul>
<li>这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 <code>m</code> 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 <code>m</code> 时间内能修理多少辆车，然后累加到 <code>cnt</code> 变量中。</li>
<li>如果 <code>cnt</code> 大于或等于需要修理的汽车数量 <code>cars</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li><p>二分查找循环：</p>
<ul>
<li>使用一个二分查找循环来查找最小的修理时间。循环条件是 <code>l &lt; r</code>，即当最小时间小于最大时间时，继续循环。</li>
<li>在每次循环中，计算中间值 <code>m</code>，并调用 <code>check(m)</code> 检查是否满足修理所有汽车的条件。</li>
<li>如果满足条件，则将 <code>r</code> 更新为 <code>m</code>，因为我们希望找到更小的修理时间。</li>
<li>如果不满足条件，则将 <code>l</code> 更新为 <code>m + 1</code>，因为我们需要增加修理时间。</li>
<li>这样，不断地缩小时间范围，直到找到最小的修理时间。</li>
</ul>
</li>
<li><p>最终返回结果：</p>
<ul>
<li>一旦 <code>l</code> 不再小于 <code>r</code>，循环结束，说明已经找到了最小的修理时间，将其转换为 <code>int64</code> 类型并返回。</li>
</ul>
</li>
</ol>
<p>我们总结一下二分查找适用的场景</p>
<h1 id="二分查找算法适用场景"><a href="#二分查找算法适用场景" class="headerlink" title="二分查找算法适用场景"></a>二分查找算法适用场景</h1><p><strong>递增或递减规律</strong>：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。</p>
<p><strong>有序数据集合</strong>：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。</p>
<p><strong>快速查找</strong>：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。</p>
<p><strong>确定性问题</strong>：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。</p>
<p><strong>时间复杂度要求较高</strong>：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。</p>
<p><strong>可比较性数据</strong>：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。</p>
<p><strong>搜索范围可确定</strong>：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。</p>
<p><strong>内存连续性</strong>：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。</p>
<p>一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 28.找出字符串中第一个匹配项的下标</title>
    <url>/2023-05-31-396a1cd3c61e.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531222721.png"></p>
<h1 id="简单解法"><a href="#简单解法" class="headerlink" title="简单解法"></a>简单解法</h1><p>利用split 函数，判断是否能够拆分，如果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片</span></span><br><span class="line">	splitList := strings.Split(haystack, needle)</span><br><span class="line">	<span class="comment">// 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(splitList)== <span class="number">1</span> &amp;&amp; needle!=haystack &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(splitList) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(splitList[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// needle 在haystack的最开头，返回0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    haystack := <span class="string">&quot;good&quot;</span>  </span><br><span class="line">    needle := <span class="string">&quot;go&quot;</span>  </span><br><span class="line">    splitList := strings.Split(haystack, needle) <span class="comment">// 如果在首位相同，前边会有个空字符串。  </span></span><br><span class="line">    fmt.Println(splitList, <span class="built_in">len</span>(splitList))  </span><br><span class="line">    fmt.Println(<span class="string">&quot;tmp:&quot;</span>, splitList[<span class="number">0</span>])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;&quot;  &quot;od&quot;] 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h1><p>朴素解法<br>直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配：</p>
<p>匹配成功：返回本次匹配的原串「发起点」。<br>匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cur := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cur &lt; <span class="built_in">len</span>(haystack) &#123;</span><br><span class="line">        p1 := cur</span><br><span class="line">        p2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p1 &lt; <span class="built_in">len</span>(haystack) &amp;&amp; p2 &lt; <span class="built_in">len</span>(needle) &amp;&amp; needle[p2] == haystack[p1] &#123;</span><br><span class="line">            p1++</span><br><span class="line">            p2++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以修改为for 循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(haystack); i++ &#123;</span><br><span class="line">        p1 := i</span><br><span class="line">        p2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p1 &lt; <span class="built_in">len</span>(haystack) &amp;&amp; p2 &lt; <span class="built_in">len</span>(needle) &amp;&amp; needle[p2] == haystack[p1] &#123;</span><br><span class="line">            p1++</span><br><span class="line">            p2++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="TODO-KMP-算法"><a href="#TODO-KMP-算法" class="headerlink" title="TODO　KMP 算法"></a>TODO　KMP 算法</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 355设计推特</title>
    <url>/2024-05-10-b1491b9671d6.html</url>
    <content><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/design-twitter/description/">355. 设计推特</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Twitter <span class="keyword">struct</span> &#123;</span><br><span class="line">	userMap <span class="keyword">map</span>[<span class="type">int</span>]*User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	userId    <span class="type">int</span></span><br><span class="line">	followees <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span></span><br><span class="line">	tweets    []*Tweet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tweet <span class="keyword">struct</span> &#123;</span><br><span class="line">	tweetId <span class="type">int</span></span><br><span class="line">	time    <span class="type">int</span></span><br><span class="line">	userId  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推特时间排序</span></span><br><span class="line"><span class="keyword">var</span> tweetCount <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Twitter &#123;</span><br><span class="line">	<span class="keyword">return</span> Twitter&#123;userMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*User)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> PostTweet(userId <span class="type">int</span>, tweetId <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 新建tweet  将自己设置为关注</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;</span><br><span class="line">		t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="built_in">make</span>([]*Tweet, <span class="number">0</span>), followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">		tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;</span><br><span class="line">		t.userMap[userId].tweets = <span class="built_in">append</span>(t.userMap[userId].tweets, tweet)</span><br><span class="line">		t.userMap[userId].followees[userId] = <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;</span><br><span class="line">		t.userMap[userId].tweets = <span class="built_in">append</span>(t.userMap[userId].tweets, tweet)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将tweetId 时间做一个新增</span></span><br><span class="line">	tweetCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> Follow(followerId <span class="type">int</span>, followeeId <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果关注人不存在则新建</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;</span><br><span class="line">        t.userMap[followerId] = &amp;User&#123;</span><br><span class="line">            userId:        followerId,</span><br><span class="line">            followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次新建user的时候 将自己加入自己关注</span></span><br><span class="line">        t.userMap[followerId].followees[followerId] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被关注人不存在则新建</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;</span><br><span class="line">        t.userMap[followeeId] = &amp;User&#123;</span><br><span class="line">            userId:        followeeId,</span><br><span class="line">            followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次新建user的时候 将自己加入自己关注</span></span><br><span class="line">        t.userMap[followeeId].followees[followeeId] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.userMap[followerId].followees[followeeId] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> Unfollow(followerId <span class="type">int</span>, followeeId <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;</span><br><span class="line">		<span class="built_in">delete</span>(t.userMap[followerId].followees, followeeId)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">	resTop10 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	tweeters := []*Tweet&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[userId]; ok &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> followeeId, _ := <span class="keyword">range</span> t.userMap[userId].followees &#123;</span><br><span class="line">			tweeters = <span class="built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(tweeters, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">		resTop10 = <span class="built_in">append</span>(resTop10, tweeters[i].tweetId)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resTop10</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 376.摆动序列</title>
    <url>/2023-05-23-7b5e53100757.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230524010708.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count, preDiff, curDiff <span class="type">int</span></span><br><span class="line">    count = <span class="number">1</span> <span class="comment">// 初始化计数为1，至少有一个数字是有效的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="comment">// 如果数组长度小于2，直接返回计数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        curDiff = nums[i+<span class="number">1</span>] - nums[i] <span class="comment">// 计算当前数字之间的差值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据差值的正负和前一个差值的正负进行判断</span></span><br><span class="line">        <span class="comment">// 如果满足摆动序列的条件，更新前一个差值和计数值</span></span><br><span class="line">        <span class="keyword">if</span> (curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            preDiff = curDiff</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count <span class="comment">// 返回最终的计数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <url>/2024-01-23-1cb0809a7893.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>]&#123;</span><br><span class="line">			<span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>] <span class="comment">// 身高由大到小排列</span></span><br><span class="line"></span><br><span class="line">	&#125;)i</span><br><span class="line">	<span class="comment">// 再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">		<span class="built_in">copy</span>(people[p[<span class="number">1</span>]+<span class="number">1</span> :i+<span class="number">1</span>], people[p[<span class="number">1</span>] :i+<span class="number">1</span>])  <span class="comment">// 腾空出一个位置</span></span><br><span class="line">        people[p[<span class="number">1</span>]] = pi</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> people</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p>
</li>
<li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p>
</li>
<li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p>
</li>
<li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p>
</li>
</ol>
<p>最终，返回重新排列后的队列 <code>people</code>。</p>
<p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p>
<p>让我们考虑一下为什么使用 <code>i+1</code>：</p>
<ol>
<li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li>
<li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li>
<li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 455.分发饼干</title>
    <url>/2023-05-21-c1aa51f444e0.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/assign-cookies/description/">455. 分发饼干 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230521231054.png"></p>
<p><a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a> 欢迎关注我的博客，定时更新golang 刷题笔记</p>
<p>贪心的策略：</p>
<blockquote>
<p>贪心算法一般分为如下四步：<br> 将问题分解为若干个子问题<br>找出适合的贪心策略<br>求解每一个子问题的最优解<br>将局部最优解堆叠成全局最优解</p>
</blockquote>
<p>排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;<br>如果没有越界并且饼干大于等于胃口，则childIdx ++；res++</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值</span></span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 用小饼干 来满足最小的胃口</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="comment">// 判断越界 饼干大于胃口</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(g) &amp;&amp; s[i] &gt;= g[j]  &#123; <span class="comment">// len不越界的条件需要在前边</span></span><br><span class="line"></span><br><span class="line">            res++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 53.最大子数和</title>
    <url>/2023-05-25-8fc7b96cd054.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p>
</blockquote>
<p><strong>个人网站：</strong> <a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><img src="https://pic.leetcode.cn/1685028457-IOzjjG-image.png" alt="image.png"><br>[TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>方法1  算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。</p>
</blockquote>
<blockquote>
<p>方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums<a href="dp%5B0%5D">0</a>; 遍历顺序，从idx &#x3D; 1 开始遍历。</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p> $O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p> $O(1)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	res := math.MinInt32</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		count += nums[i]</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> count &lt; <span class="number">0</span> &#123;</span><br><span class="line">			count = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2 使用了类似动态规划的思想</span></span><br><span class="line"><span class="comment">// 定义 nums[i] 当前元素，nums[i-1] 前序列之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	max := nums[<span class="number">0</span>] <span class="comment">//初始化最大值为前边一个元素</span></span><br><span class="line">	<span class="comment">// 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ;i &lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i+<span class="number">1</span>] + nums[i] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 超过最大值，则更新</span></span><br><span class="line">		<span class="keyword">if</span> nums[i+<span class="number">1</span>] &gt;  max &#123;</span><br><span class="line">			max = nums[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 706. 设计哈希映射 Golang</title>
    <url>/2023-05-20-e3f31d125f9b.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashmap/description/">706. 设计哈希映射 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230520230121.png"><br>使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List</p>
<h2 id="使用结构体（非指针）"><a href="#使用结构体（非指针）" class="headerlink" title="使用结构体（非指针）"></a>使用结构体（非指针）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链地址法</span></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base := 769</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	k <span class="type">int</span></span><br><span class="line">	v <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	hashMaps []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash集合可以使用数组链表；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashMap &#123;</span><br><span class="line">	<span class="keyword">return</span> MyHashMap&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func　(this *MyHashMap) hash(key int, value int)&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et := e.Value.(entry); et.k == key &#123;</span><br><span class="line">			e.Value = entry&#123;key, value&#125; <span class="comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123;</span><br><span class="line">			<span class="keyword">return</span> et.v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Remove(key <span class="type">int</span>) &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123;</span><br><span class="line">			this.hashMaps[hash].Remove(e)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="使用结构体指针"><a href="#使用结构体指针" class="headerlink" title="使用结构体指针"></a>使用结构体指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链地址法</span></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base := 769</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	k <span class="type">int</span></span><br><span class="line">	v <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	hashMaps []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash集合可以使用数组链表；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashMap &#123;</span><br><span class="line">	<span class="keyword">return</span> MyHashMap&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et := e.Value.(*entry); et.k == key &#123; <span class="comment">// 注意list 的元素类型是空接口，需要断言类型</span></span><br><span class="line">			et.v = value  <span class="comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; <span class="comment">// 可以缩写为if et := e.Value.(entry); et.k == key  用于断言，并找key</span></span><br><span class="line">			<span class="keyword">return</span> et.v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Remove(key <span class="type">int</span>) &#123;</span><br><span class="line">	hash := key % base</span><br><span class="line">	<span class="keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		<span class="keyword">if</span> et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123;</span><br><span class="line">			this.hashMaps[hash].Remove(e)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <url>/2024-01-23-183e0ff5f5ef.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p>
<p>使用回溯的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 结束条件</span></span><br><span class="line">	<span class="keyword">var</span> backtracking <span class="function"><span class="keyword">func</span><span class="params">(n, k ,startIdx <span class="type">int</span>)</span></span></span><br><span class="line">	backtracking = <span class="function"><span class="keyword">func</span><span class="params">(n, k ,startIdx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 提前返回需要return</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">            pathTmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(path))</span><br><span class="line">			<span class="built_in">copy</span>(pathTmp, path)</span><br><span class="line">			res = <span class="built_in">append</span>(res, pathTmp)</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// return </span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path,i)</span><br><span class="line">			backtracking(n,k,i+<span class="number">1</span>) <span class="comment">// i+1 进行下一轮</span></span><br><span class="line">			path = path[:(<span class="built_in">len</span>(path) <span class="number">-1</span>)]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtracking(n,k,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol>
<li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p>
</li>
<li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p>
</li>
<li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p>
</li>
<li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p>
</li>
<li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p>
</li>
<li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <url>/2024-01-22-f8790b7ced8e.html</url>
    <content><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> traversal <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    traversal = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	traversal(node.Left)</span><br><span class="line">	res = <span class="built_in">append</span>(res,node.Val)</span><br><span class="line">	traversal(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    traversal(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st := list.New()</span><br><span class="line">    cur := root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> || st.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            st.PushBack(cur)</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = st.Remove(st.Back()).(*TreeNode)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, cur.Val)</span><br><span class="line">            cur = cur.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是对代码的解释：</p>
<ol>
<li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p>
</li>
<li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p>
</li>
<li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p>
</li>
<li><p><code>cur := root</code>: 初始化当前节点为根节点。</p>
</li>
<li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p>
</li>
<li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p>
<ul>
<li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p>
</li>
<li><p><code>cur = cur.Left</code>: 移动到左子树。</p>
</li>
</ul>
</li>
<li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p>
<ul>
<li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p>
</li>
<li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p>
</li>
<li><p><code>cur = cur.Right</code>: 移动到右子树。</p>
</li>
</ul>
</li>
<li><p>循环回到第5步，直到栈为空。</p>
</li>
</ol>
<p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p>
<p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p>
<ul>
<li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p>
</li>
<li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p>
</li>
</ul>
<p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p>
<p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 单调栈</title>
    <url>/2024-02-24-dd95d981cb94.html</url>
    <content><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p>
<p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123; <span class="comment">// 倒着入栈是为了后边正着出栈</span></span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &amp;&amp; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] &lt;= nums[i] &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            s = s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的更大元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123; <span class="comment">// 没有更大的元素</span></span><br><span class="line">            res[i] = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[i] = s[<span class="built_in">len</span>(s)<span class="number">-1</span>] <span class="comment">// 正着出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">append</span>(s, nums[i]) <span class="comment">// 当前元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 双指针</title>
    <url>/2024-03-23-84678021105b.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除有序数组中的重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    slow:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast:=<span class="number">1</span>;fast &lt;<span class="built_in">len</span>(nums);fast++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != nums[slow] &#123;</span><br><span class="line">            slow++<span class="comment">// 跳到下个位置，保存slow</span></span><br><span class="line"></span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p>
<p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p>
<p><strong>注意到以下性质：</strong></p>
<ul>
<li>左指针左边均为非零数；</li>
<li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	slow, n := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; n; fast++ &#123; <span class="comment">// 注意第一个是0的时候需要比较</span></span><br><span class="line">		<span class="keyword">if</span> nums[fast] != <span class="number">0</span> &#123; <span class="comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span></span><br><span class="line">			nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">			slow++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(height); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(height); j++ &#123;</span><br><span class="line">			area := (j - i) * min(height[i], height[j])</span><br><span class="line">			ans = max(area,ans)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span> <span class="comment">// 初始化两边指针</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        area := (right - left) * min(height[left], height[right]) <span class="comment">// 计算面积</span></span><br><span class="line">        ans = max(ans, area) <span class="comment">// 计算最大值</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123; </span><br><span class="line">            left++ <span class="comment">// 移动短的那个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/../../imgs/Pasted%20image%2020240326011627.png"></p>
<p>前缀和，后缀和<br>木桶效应，当前能装的水，取决于两边最大值 的最小值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    preMax := <span class="built_in">make</span>([]<span class="type">int</span>, n) <span class="comment">// preMax[i] 表示从 height[0] 到 height[i] 的最大值</span></span><br><span class="line">    preMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        preMax[i] = max(preMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sufMax := <span class="built_in">make</span>([]<span class="type">int</span>, n) <span class="comment">// sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值</span></span><br><span class="line">    sufMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        sufMax[i] = max(sufMax[i+<span class="number">1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, h := <span class="keyword">range</span> height &#123;</span><br><span class="line">        ans += min(preMax[i], sufMax[i]) - h <span class="comment">// 累加每个水桶能接多少水</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    left, right, preMax, sufMax := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        preMax = max(preMax, height[left])</span><br><span class="line">        sufMax = max(sufMax, height[right])</span><br><span class="line">        <span class="keyword">if</span> preMax &lt; sufMax &#123;</span><br><span class="line">            ans += preMax - height[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += sufMax - height[right]</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 最大深度和最小深度</title>
    <url>/2023-07-29-4df215f63090.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020230729235323.png"><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230729235305.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>深度 是指从根节点到该节点的距离（节点数量）<br>高度 是指从该节点到叶子节点的角力（节点数量）</p>
<p><strong>最大深度</strong> 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)<br><strong>最小子树</strong> 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现：</p>
<h1 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h1><h2 id="递归分治"><a href="#递归分治" class="headerlink" title="递归分治"></a>递归分治</h2><p>后序遍历 需要调用自生函数，需要严格按照定义调用递归。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    rightMaxDepth := maxDepth(root.Right)</span><br><span class="line">    leftMaxDepth := maxDepth(root.Left)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(rightMaxDepth,leftMaxDepth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	depth := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	queue = <span class="built_in">append</span>(queue,root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123; <span class="comment">// queue 不为空的时候</span></span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;size ;i++ &#123;<span class="comment">// 遍历一层</span></span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 取最上层元素，并切掉该元素</span></span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Left)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>后序遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最小深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    rightMaxDepth := minDepth(root.Right)</span><br><span class="line"></span><br><span class="line">    leftMaxDepth := minDepth(root.Left)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &amp;&amp; root.Left !=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftMaxDepth <span class="comment">// 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right !=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightMaxDepth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(rightMaxDepth,leftMaxDepth)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代-层序遍历-1"><a href="#迭代-层序遍历-1" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	depth := <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	queue := []*TreeNode&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	queue = <span class="built_in">append</span>(queue,root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123; <span class="comment">// queue 不为空的时候</span></span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;size ;i++ &#123;<span class="comment">// 遍历一层</span></span><br><span class="line">			top := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 取最上层元素，并切掉该元素</span></span><br><span class="line">			<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Right)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue,top.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> top.Right == <span class="literal">nil</span> &amp;&amp; top.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> depth + <span class="number">1</span> <span class="comment">// 当前节点也算哦</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        depth++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 每日温度 单调栈</title>
    <url>/2024-05-20-1fbf9ee2486f.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020250615183912.png"></p>
<p><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240521001833.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020250615171658.png"><br>栈里边存放的是还没有找到后边更大值的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从左向右，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(temperatures)  <span class="comment">// 长度 </span></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, length)   <span class="comment">// 返回的数组</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;            <span class="comment">// 单调栈</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i ++ &#123;</span><br><span class="line">        temperature := temperatures[i] </span><br><span class="line">        fmt.Println(<span class="string">&quot;temperature:&quot;</span>, temperature)</span><br><span class="line">        fmt.Println(<span class="string">&quot;stack:&quot;</span>, stack)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperature &gt; temperatures[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]] &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;temperature now:&quot;</span>, temperature, temperatures[stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>]], stack[<span class="built_in">len</span>(stack) <span class="number">-1</span>])</span><br><span class="line">            preindex := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// 上一个位置的index</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) <span class="number">-1</span>] <span class="comment">// 栈顶找到了当前更大的数，</span></span><br><span class="line">            ans[preindex] = i -preindex <span class="comment">// 记录位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i) <span class="comment">// 如果不满足要求，则说明是小的数，需要添加到栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右向左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    lens := <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, lens)</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;  <span class="comment">// 单调递增栈（从栈底到栈顶）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := lens<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        temperature := temperatures[i]</span><br><span class="line">        <span class="comment">// 弹出所有小于等于当前温度的索引</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperature &gt;= temperatures[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈不为空，栈顶就是第一个比当前大的温度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[i] = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - i</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/../../imgs/Pasted%20image%2020250615183212.png"><br><img src="/../../imgs/Pasted%20image%2020250615183915.png"><br>单调栈 适用于 上一个更大(更小)元素，或者下一个更大（小）元素</p>
<p>这段代码是一个Go语言编写的函数，名为<code>dailyTemperatures</code>，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表<code>temperatures</code>，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。</p>
<h3 id="代码思想解释："><a href="#代码思想解释：" class="headerlink" title="代码思想解释："></a>代码思想解释：</h3><ol>
<li><p><strong>问题定义</strong>：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。</p>
</li>
<li><p><strong>单调栈的应用</strong>：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个<font color="#ff0000"><strong>索引栈</strong>，<strong>栈内元素代表尚未找到更大温度的天的索引</strong></font>。</p>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>n</code>：记录输入温度数组的长度。</li>
<li><code>ans</code>：初始化一个长度为<code>n</code>的数组，用于存储结果，初始值设为0。</li>
<li><code>st</code>：初始化一个空的切片，用作单调栈。</li>
</ul>
</li>
<li><p><strong>遍历温度数组</strong>：</p>
<ul>
<li>通过<code>range</code>关键字遍历<code>temperatures</code>数组，同时获取索引<code>i</code>和对应的温度值<code>t</code>。</li>
</ul>
</li>
<li><p><strong>维护单调栈</strong>：</p>
<ul>
<li>当前温度<code>t</code>大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作：<ul>
<li>弹出栈顶元素<code>j</code>，即<code>st[len(st)-1]</code>。</li>
<li>计算索引差<code>i - j</code>，并将这个差值赋给<code>ans[j]</code>。</li>
<li>更新栈<code>st</code>，移除栈顶元素。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>压栈操作</strong>：</p>
<ul>
<li>将当前索引<code>i</code>压入栈<code>st</code>中。这表示当前索引的天还没有找到之后的第一个更高温度。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>遍历结束后，返回<code>ans</code>数组，其中每个元素表示对应天之后第一个更高温度的天数。</li>
</ul>
</li>
</ol>
<h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><p>  <a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020250615200522.png"><br><img src="/../../imgs/Pasted%20image%2020250615200607.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    st := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, h := <span class="keyword">range</span> height &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(st) &gt; <span class="number">0</span> &amp;&amp; h &gt;= height[st[<span class="built_in">len</span>(st)<span class="number">-1</span>]] &#123; <span class="comment">// 1. **处理相等高度的情况**：</span></span><br><span class="line">%%     </span><br><span class="line">    - 当遇到相等高度的柱子时，后面的柱子才是有效的右边界</span><br><span class="line">        </span><br><span class="line">    - 使用<span class="string">`&gt;=`</span>可以正确处理这种情况，确保弹出所有小于等于当前高度的柱子</span><br><span class="line">        </span><br><span class="line">    - 如果只用<span class="string">`&gt;`</span>，相等高度的柱子会留在栈中，导致计算错误 %%</span><br><span class="line">            bottomH := height[st[<span class="built_in">len</span>(st)<span class="number">-1</span>]]</span><br><span class="line">            st = st[:<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(st) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            left := st[<span class="built_in">len</span>(st)<span class="number">-1</span>]</span><br><span class="line">            dh := min(height[left], h) - bottomH <span class="comment">// 面积的高</span></span><br><span class="line">            ans += dh * (i - left - <span class="number">1</span>)<span class="comment">// 面积高*宽</span></span><br><span class="line">        &#125;</span><br><span class="line">        st = <span class="built_in">append</span>(st, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 示例分析</span><br><span class="line"></span><br><span class="line">以高度数组<span class="string">`[0,1,0,2,1,0,1,3,2,1,2,1]`</span>为例：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 遇到第二个高度为<span class="number">1</span>的柱子时：</span><br><span class="line">    </span><br><span class="line">    - 弹出之前高度为<span class="number">0</span>的柱子</span><br><span class="line">        </span><br><span class="line">    - 计算它与左边高度<span class="number">1</span>的柱子之间的雨水</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span> 遇到高度为<span class="number">2</span>的柱子时：</span><br><span class="line">    </span><br><span class="line">    - 弹出高度为<span class="number">1</span>的柱子（因为<span class="number">2</span> &gt;= <span class="number">1</span>）</span><br><span class="line">        </span><br><span class="line">    - 计算它与左边更高柱子之间的雨水</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span> 遇到相等高度<span class="number">1</span>的柱子时：</span><br><span class="line">    </span><br><span class="line">    - 前面的<span class="number">1</span>被弹出（因为<span class="number">1</span> &gt;= <span class="number">1</span>）</span><br><span class="line">        </span><br><span class="line">    - 确保新的<span class="number">1</span>作为右边界参与后续计算</span><br></pre></td></tr></table></figure>


<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums)-k+<span class="number">1</span>) <span class="comment">// 预分配空间</span></span><br><span class="line">    q := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 1. 入</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &amp;&amp; x &gt;= nums[q[<span class="built_in">len</span>(q)<span class="number">-1</span>]] &#123;</span><br><span class="line">            q = q[:<span class="built_in">len</span>(q)<span class="number">-1</span>] <span class="comment">// 维护 q 的单调性 从大到小</span></span><br><span class="line">        &#125;</span><br><span class="line">        q = <span class="built_in">append</span>(q, i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 出</span></span><br><span class="line">        <span class="keyword">if</span> q[<span class="number">0</span>] &lt;= i -k&#123; <span class="comment">// 队首已经离开窗口了</span></span><br><span class="line">            q = q[<span class="number">1</span>:] <span class="comment">// Go 的切片是 O(1) 的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 记录答案</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// 由于队首到队尾单调递减，所以窗口最大值就是队首</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, nums[q[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>从「维护单调性」的角度上来说，单调队列和单调栈是一样的，一个弹出队尾元素，另一个弹出栈顶元素。在单调栈的基础上，单调队列多了一个「移除队首」的操作，这类似滑动窗口移动左指针 left 的过程。所以从某种程度上来说，单调队列 &#x3D; 单调栈 + 滑动窗口。<br><img src="/../../imgs/Pasted%20image%2020250615211811.png"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 设计题 Constructor构建</title>
    <url>/2023-05-14-776ea61b62a5.html</url>
    <content><![CDATA[<p>在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ParkingSystem <span class="keyword">struct</span> &#123;</span><br><span class="line">    carNums <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// 记录每种停车位的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(big <span class="type">int</span>, medium <span class="type">int</span>, small <span class="type">int</span>)</span></span> ParkingSystem &#123;</span><br><span class="line">    <span class="keyword">return</span> ParkingSystem&#123;</span><br><span class="line">        carNums: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: big, <span class="number">2</span>: medium, <span class="number">3</span>: small&#125;, <span class="comment">// 初始化 carNums 映射</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。</p>
<p>请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。</p>
<p>具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">int</span>]B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := &amp;A&#123;</span><br><span class="line">        m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]B),</span><br><span class="line">    &#125;</span><br><span class="line">    b := &amp;B&#123;</span><br><span class="line">        m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    a.m[<span class="number">1</span>] = *b <span class="comment">// 给 A 中的第一个元素分配一个新的 B 结构体实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 <strong>nil 引用错误</strong>，我们还在代码中使用了 make 函数创建了一个空映射。</p>
<p>例如, 下边结构体中map 嵌套了另外一个结构体的map,<br>可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Res <span class="keyword">struct</span> &#123;</span><br><span class="line">    big <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ParkingSystem <span class="keyword">struct</span> &#123;<span class="keyword">map</span></span><br><span class="line">    carNums <span class="keyword">map</span>[<span class="type">int</span>]*Res <span class="comment">// map 嵌套map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewParkingSystem</span><span class="params">()</span></span> *ParkingSystem &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ParkingSystem&#123;carNums: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Res)&#125; <span class="comment">// 只用先make 一个空map,指向Res</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ps := NewParkingSystem()</span><br><span class="line">    ps.carNums[<span class="number">1</span>] = &amp;Res&#123;big: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。</p>
<p>然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。</p>
<p>总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>设计题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode　705. 设计哈希集合</title>
    <url>/2023-05-19-2fa443568cc1.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashset/description/">705. 设计哈希集合 - 力扣（Leetcode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020230520225749.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="number">769</span> <span class="comment">// 哈希表的长度 质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []list.List <span class="comment">// 使用链表储存冲突元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashSet &#123; <span class="comment">// 构造函数，返回一个空的哈希集合</span></span><br><span class="line">    <span class="keyword">return</span> MyHashSet&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数：对键值取模得到哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span></span> hash(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span></span> Add(key <span class="type">int</span>) &#123; <span class="comment">// 向哈希集合中添加元素</span></span><br><span class="line">    <span class="keyword">if</span> !s.Contains(key) &#123; <span class="comment">// 如果元素不在集合中</span></span><br><span class="line">        h := s.hash(key) <span class="comment">// 计算哈希值</span></span><br><span class="line">        s.data[h].PushBack(key) <span class="comment">// 将元素加入到链表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span></span> Remove(key <span class="type">int</span>) &#123; <span class="comment">// 从哈希集合中删除元素</span></span><br><span class="line">    h := s.hash(key) <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="type">int</span>) == key &#123; <span class="comment">// 如果元素等于要删除的元素</span></span><br><span class="line">            s.data[h].Remove(e) <span class="comment">// 从链表中删除元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span></span> Contains(key <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="comment">// 判断某个元素是否在哈希集合中</span></span><br><span class="line">    h := s.hash(key) <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="type">int</span>) == key &#123; <span class="comment">// 如果元素等于要查找的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 返回 true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 没有找到元素，返回 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【20240106】leetcode 2807. 在链表中插入最大公约数</title>
    <url>/2024-01-06-2b3ad028343c.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&envId=2024-01-06">2807. 在链表中插入最大公约数 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240106233021.png"></p>
<p>最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。</p>
<p>计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下：</p>
<ol>
<li>用较大的数除以较小的数，得到余数。</li>
<li>将较小的数作为新的被除数，余数作为新的除数。</li>
<li>重复步骤 1 和 2，直到余数为零。</li>
<li>最后的非零余数即为最大公约数。</li>
</ol>
<p>这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。</p>
<p>以下是一个用 Go 语言实现的最大公约数的辗转相除法示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        temp := b</span><br><span class="line">        b = a % b</span><br><span class="line">        a = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num1 := <span class="number">48</span></span><br><span class="line">    num2 := <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    result := gcd(num1, num2)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;最大公约数为:&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>gcd</code> 函数使用了辗转相除法来计算两个整数的最大公约数。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【20240114】LeetCode 83. 删除排序链表中的重复元素</title>
    <url>/2024-01-14-e61755fec3db.html</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>遍历</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>描述你的解题方法</p>
</blockquote>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p>
<blockquote>
<p>添加时间复杂度, 示例： $O(n)$</p>
</blockquote>
<p>空间复杂度:</p>
<blockquote>
<p>添加空间复杂度, 示例： $O(n)$</p>
</blockquote>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">for</span> i := head; i != <span class="literal">nil</span> &amp;&amp; i.Next != <span class="literal">nil</span> ; &#123;</span><br><span class="line">        <span class="keyword">if</span> i.Next.Val == i.Val &#123;</span><br><span class="line">            i.Next = i.Next.Next <span class="comment">// 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123;  i = i.Next不需要</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    current := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &amp;&amp; current.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> current.Next.Val == current.Val &#123;</span><br><span class="line">            <span class="comment">// 保存下一个节点的引用</span></span><br><span class="line">            nextNode := current.Next</span><br><span class="line">            <span class="comment">// 删除当前节点</span></span><br><span class="line">            current.Next = nextNode.Next</span><br><span class="line">            <span class="comment">// 释放内存</span></span><br><span class="line">            nextNode = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非重复元素，继续遍历</span></span><br><span class="line">            current = current.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】 byte和rune 有什么区别</title>
    <url>/2024-11-23-ff51ba651704.html</url>
    <content><![CDATA[<p>byte 和rune 有什么区别？<br>    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：</p>
<p>byte：</p>
<p>byte是uint8的别名，即一个无符号的8位整数。<br>在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。<br>byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。<br>rune：</p>
<p>rune是int32的别名，即一个有符号的32位整数。<br>rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。<br>rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。<br>由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。<br>区别：</p>
<p>大小：byte是8位的，而rune是32位的。<br>用途：byte用于处理字节数据，rune用于处理Unicode字符。<br>范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。<br>编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。<br>在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【BFS DFS通用模板】</title>
    <url>/2024-01-22-759654485d5d.html</url>
    <content><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 通用的深度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node <span class="type">int</span>, visited []<span class="type">bool</span>, graph [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 边界终止条件 </span></span><br><span class="line">	<span class="keyword">if</span> m n &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> visited[node] &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[node] &#123;</span><br><span class="line">        dfs(neighbor, visited, graph)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化节点、访问数组等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有节点</span></span><br><span class="line">    <span class="keyword">for</span> node := <span class="number">0</span>; node &lt; <span class="built_in">len</span>(graph); node++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !visited[node] &#123;</span><br><span class="line">            dfs(node, visited, graph)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的广度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(start <span class="type">int</span>, graph [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    queue := []<span class="type">int</span>&#123;start&#125;</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(graph))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line">        visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将相邻节点入队列</span></span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[node] &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化起始节点、图等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用BFS函数</span></span><br><span class="line">    bfs(start, graph)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(start Node, target Node)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 核心数据结构</span></span><br><span class="line">    q := <span class="built_in">make</span>([]Node, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 避免走回头路</span></span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[Node]<span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将起点加入队列</span></span><br><span class="line">    q = <span class="built_in">append</span>(q, start)</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sz := <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="comment">// 将当前队列中的所有节点向四周扩散</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sz; i++ &#123;</span><br><span class="line">            cur := q[<span class="number">0</span>]</span><br><span class="line">            q = q[<span class="number">1</span>:]</span><br><span class="line">            <span class="comment">// 划重点：这里判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> cur == target &#123;</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 cur 的相邻节点加入队列</span></span><br><span class="line">            <span class="keyword">for</span> _, x := <span class="keyword">range</span> cur.adj() &#123;</span><br><span class="line">                <span class="keyword">if</span> _, ok := visited[x]; !ok &#123;</span><br><span class="line">                    q = <span class="built_in">append</span>(q, x)</span><br><span class="line">                    visited[x] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果走到这里，说明在图中没有找到目标节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】 函数传入slice无法修改到原slice</title>
    <url>/2025-06-15-f16e0f79fc66.html</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, track, used, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>, track []<span class="type">int</span>, used []<span class="type">bool</span>, res *[][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used, res)</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上边的res 代码slice中需要使用指针 我去掉指针不行。</p>
<p>使用闭包函数可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="切片与指针的区别"><a href="#切片与指针的区别" class="headerlink" title="切片与指针的区别"></a>切片与指针的区别</h1><p>Go 中的切片是引用类型，但它们与指针在行为上还是有一些关键区别，这正是为什么在这个回溯算法中需要使用指针的原因。</p>
<h2 id="切片作为引用类型的局限"><a href="#切片作为引用类型的局限" class="headerlink" title="切片作为引用类型的局限"></a>切片作为引用类型的局限</h2><p>虽然切片是引用类型（底层数组的指针+长度+容量），但切片头（slice header）本身是按值传递的。这意味着：</p>
<ol>
<li><strong>可以修改底层数组元素</strong>：函数内部可以修改切片指向的数组元素，这些修改会反映到外部</li>
<li><strong>不能修改切片头</strong>：<font color="#ff0000">对切片本身的修改（如追加元素导致重新分配）不会反映到外部</font></li>
</ol>
<h2 id="具体到代码"><a href="#具体到代码" class="headerlink" title="具体到代码"></a>具体到代码</h2><p>回溯算法中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*res = <span class="built_in">append</span>(*res, temp)  <span class="comment">// 使用指针可以修改外部的res</span></span><br></pre></td></tr></table></figure>

<p>如果改为不使用指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">append</span>(res, temp)  <span class="comment">// 这只修改了函数内部的切片头副本</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么需要指针的详细解释"><a href="#为什么需要指针的详细解释" class="headerlink" title="为什么需要指针的详细解释"></a>为什么需要指针的详细解释</h2><ol>
<li><p><strong>追加操作的特殊性</strong>：</p>
<ul>
<li><code>append</code> 可能会返回一个新的切片头（当容量不足时）</li>
<li>不使用指针时，新切片头只存在于函数内部</li>
</ul>
</li>
<li><p><strong>递归调用的累积效果</strong>：</p>
<ul>
<li>每次递归调用都需要累积结果</li>
<li>不使用指针时，每次递归的修改都会丢失</li>
</ul>
</li>
</ol>
<h2 id="验证示例"><a href="#验证示例" class="headerlink" title="验证示例"></a>验证示例</h2><p>简单例子验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>) <span class="comment">// 不会影响外部</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">99</span>          <span class="comment">// 会影响外部（修改底层数组）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySliceByPtr</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, <span class="number">100</span>) <span class="comment">// 会影响外部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3]</span></span><br><span class="line">    </span><br><span class="line">    modifySliceByPtr(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在需要修改切片本身<font color="#ff0000">（如追加元素）</font>并且希望这些修改在函数外部可见时，必须使用指针。这正是你的回溯算法中需要使用 <code>*[][]int</code> 的原因。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】BFS</title>
    <url>/2025-06-17-e53745bb0899.html</url>
    <content><![CDATA[<h1 id="LeetCode-BFS-练习题单与模板总结-Golang-实现"><a href="#LeetCode-BFS-练习题单与模板总结-Golang-实现" class="headerlink" title="LeetCode BFS 练习题单与模板总结 (Golang 实现)"></a>LeetCode BFS 练习题单与模板总结 (Golang 实现)</h1><p>BFS（广度优先搜索）是一种重要的图遍历算法，特别适合解决最短路径、层次遍历等问题。以下是 Golang 实现的 BFS 模板和分类练习题单。</p>
<h2 id="BFS-通用模板-Golang"><a href="#BFS-通用模板-Golang" class="headerlink" title="BFS 通用模板 (Golang)"></a>BFS 通用模板 (Golang)</h2><h3 id="1-树的-BFS-模板"><a href="#1-树的-BFS-模板" class="headerlink" title="1. 树的 BFS 模板"></a>1. 树的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, levelSize)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-图的-BFS-模板"><a href="#2-图的-BFS-模板" class="headerlink" title="2. 图的 BFS 模板"></a>2. 图的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsGraph</span><span class="params">(start Node)</span></span> []Node &#123;</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[Node]<span class="type">bool</span>)</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    queue := []Node&#123;start&#125;</span><br><span class="line">    result := []Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, node)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> getNeighbors(node) &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-BFS-练习题单-Golang"><a href="#LeetCode-BFS-练习题单-Golang" class="headerlink" title="LeetCode BFS 练习题单 (Golang)"></a>LeetCode BFS 练习题单 (Golang)</h2><h3 id="基础练习"><a href="#基础练习" class="headerlink" title="基础练习"></a>基础练习</h3><ol>
<li><p><strong>二叉树的层次遍历</strong></p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></li>
<li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li>
<li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></li>
</ul>
</li>
<li><p><strong>简单图&#x2F;BFS应用</strong></p>
<ul>
<li><a href="https://leetcode.com/problems/number-of-islands/">200. 岛屿数量</a></li>
<li><a href="https://leetcode.com/problems/flood-fill/">733. 图像渲染</a></li>
<li><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></li>
</ul>
</li>
</ol>
<h3 id="进阶练习"><a href="#进阶练习" class="headerlink" title="进阶练习"></a>进阶练习</h3><ol>
<li><p><strong>最短路径问题</strong></p>
<ul>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li>
<li><a href="https://leetcode.com/problems/open-the-lock/">752. 打开转盘锁</a></li>
<li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></li>
<li><a href="https://leetcode.com/problems/01-matrix/">542. 01 矩阵</a></li>
</ul>
</li>
<li><p><strong>复杂图&#x2F;BFS应用</strong></p>
<ul>
<li><a href="https://leetcode.com/problems/word-ladder/">127. 单词接龙</a></li>
<li><a href="https://leetcode.com/problems/clone-graph/">133. 克隆图</a></li>
<li><a href="https://leetcode.com/problems/minimum-height-trees/">310. 最小高度树</a></li>
</ul>
</li>
<li><p><strong>多源BFS</strong></p>
<ul>
<li><a href="https://leetcode.com/problems/rotting-oranges/">994. 腐烂的橘子</a></li>
<li><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a> (付费题)</li>
</ul>
</li>
</ol>
<h3 id="困难级别挑战"><a href="#困难级别挑战" class="headerlink" title="困难级别挑战"></a>困难级别挑战</h3><ol>
<li><a href="https://leetcode.com/problems/bus-routes/">815. 公交路线</a></li>
<li><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></li>
<li><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></li>
</ol>
<h2 id="Golang-BFS-实现技巧"><a href="#Golang-BFS-实现技巧" class="headerlink" title="Golang BFS 实现技巧"></a>Golang BFS 实现技巧</h2><ol>
<li><p><strong>队列实现</strong>：Golang 中可以用 slice 实现队列，但要注意 dequeue 操作是 O(n)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:] <span class="comment">// 这会创建新的 slice，可能影响性能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能优化</strong>：对于大型队列，可以使用链表或固定大小的循环队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes []*TreeNode</span><br><span class="line">    head  <span class="type">int</span></span><br><span class="line">    tail  <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>visited 记录</strong>：对于图问题，使用 map 记录已访问节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方向数组</strong>：处理网格问题时很有用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="示例题解：200-岛屿数量-Golang"><a href="#示例题解：200-岛屿数量-Golang" class="headerlink" title="示例题解：200. 岛屿数量 (Golang)"></a>示例题解：200. 岛屿数量 (Golang)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                queue := [][]<span class="type">int</span>&#123;&#123;i, j&#125;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    cell := queue[<span class="number">0</span>]</span><br><span class="line">                    queue = queue[<span class="number">1</span>:]</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                        x, y := cell[<span class="number">0</span>]+dir[<span class="number">0</span>], cell[<span class="number">1</span>]+dir[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                            grid[x][y] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, []<span class="type">int</span>&#123;x, y&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】DFS</title>
    <url>/2025-06-17-8ecaae2ca2b5.html</url>
    <content><![CDATA[<h1 id="LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结"><a href="#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结" class="headerlink" title="LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结"></a>LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结</h1><p>DFS（深度优先搜索）是算法面试中的常见题型，下面我将总结 LeetCode 上一些经典的 DFS 题目，并用 Golang 实现，最后提炼出通用的 DFS 解题模板。</p>
<h2 id="经典-DFS-题目分类及-Golang-实现"><a href="#经典-DFS-题目分类及-Golang-实现" class="headerlink" title="经典 DFS 题目分类及 Golang 实现"></a>经典 DFS 题目分类及 Golang 实现</h2><h3 id="1-二叉树遍历类"><a href="#1-二叉树遍历类" class="headerlink" title="1. 二叉树遍历类"></a>1. 二叉树遍历类</h3><h4 id="题目-94-二叉树的中序遍历"><a href="#题目-94-二叉树的中序遍历" class="headerlink" title="题目 94. 二叉树的中序遍历"></a>题目 94. 二叉树的中序遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-排列组合类"><a href="#2-排列组合类" class="headerlink" title="2. 排列组合类"></a>2. 排列组合类</h3><h4 id="题目-46-全排列"><a href="#题目-46-全排列" class="headerlink" title="题目 46. 全排列"></a>题目 46. 全排列</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(path)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-岛屿问题类"><a href="#3-岛屿问题类" class="headerlink" title="3. 岛屿问题类"></a>3. 岛屿问题类</h3><h4 id="题目-200-岛屿数量"><a href="#题目-200-岛屿数量" class="headerlink" title="题目 200. 岛屿数量"></a>题目 200. 岛屿数量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-回溯类问题"><a href="#4-回溯类问题" class="headerlink" title="4. 回溯类问题"></a>4. 回溯类问题</h3><h4 id="题目-39-组合总和"><a href="#题目-39-组合总和" class="headerlink" title="题目 39. 组合总和"></a>题目 39. 组合总和</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            dfs(i, path, sum+candidates[i])</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, []<span class="type">int</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Golang-DFS-通用模板"><a href="#Golang-DFS-通用模板" class="headerlink" title="Golang DFS 通用模板"></a>Golang DFS 通用模板</h2><p>根据以上题目，可以总结出 DFS 的通用模板：</p>
<h3 id="递归回溯模板"><a href="#递归回溯模板" class="headerlink" title="递归回溯模板"></a>递归回溯模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">problemFunction</span><span class="params">(params)</span></span> [][]resultType &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]resultType</span><br><span class="line">    <span class="comment">// 可能需要 visited 数组或其他辅助数据结构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> meetCondition &#123;</span><br><span class="line">            <span class="comment">// 可能需要深拷贝 path</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]resultType, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> _, choice := <span class="keyword">range</span> choices &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不满足条件的选项</span></span><br><span class="line">            <span class="keyword">if</span> !isValid(choice) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, choice)</span><br><span class="line">            markAsVisited(choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(path, updatedParams...)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            markAsUnvisited(choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(initialPath, initialParams...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网格-矩阵DFS模板"><a href="#网格-矩阵DFS模板" class="headerlink" title="网格&#x2F;矩阵DFS模板"></a>网格&#x2F;矩阵DFS模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gridProblem</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != targetValue &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记已访问</span></span><br><span class="line">        grid[i][j] = markedValue</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四个方向扩散</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要8个方向，可以加上对角线方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历整个网格</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == targetValue &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他经典DFS题目推荐"><a href="#其他经典DFS题目推荐" class="headerlink" title="其他经典DFS题目推荐"></a>其他经典DFS题目推荐</h2><ol>
<li><ol start="78">
<li>子集</li>
</ol>
</li>
<li><ol start="17">
<li>电话号码的字母组合</li>
</ol>
</li>
<li><ol start="79">
<li>单词搜索</li>
</ol>
</li>
<li><ol start="207">
<li>课程表 (拓扑排序)</li>
</ol>
</li>
<li><ol start="437">
<li>路径总和 III</li>
</ol>
</li>
<li><ol start="494">
<li>目标和</li>
</ol>
</li>
<li><ol start="695">
<li>岛屿的最大面积</li>
</ol>
</li>
<li><ol start="733">
<li>图像渲染</li>
</ol>
</li>
<li><ol start="113">
<li>路径总和 II</li>
</ol>
</li>
<li><ol start="129">
<li>求根到叶子节点数字和</li>
</ol>
</li>
</ol>
<p>DFS的关键在于理解递归的思想，明确递归的终止条件，以及在递归前后做好状态的保存和恢复（回溯）。掌握这些模板后，可以解决大部分DFS相关问题。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】for range 数组指针遍历</title>
    <url>/2024-12-03-90d19c862e9c.html</url>
    <content><![CDATA[<p>在Go语言中，使用<code>for range</code>遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如<code>[]*Student</code>）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。</p>
<p>这意味着，即使<code>for range</code>对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    students := []*Student&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;Bob&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用for range遍历指针数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        <span class="comment">// 修改指向的结构体的内容</span></span><br><span class="line">        student.Age += <span class="number">1</span> <span class="comment">// 给每个学生的年龄加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的students数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, student.Name, student.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管<code>for range</code>对每个<code>*Student</code>指针进行了拷贝，但通过这个拷贝的指针修改<code>Age</code>字段时，修改的是原始<code>Student</code>结构体的内容。因此，当再次遍历<code>students</code>数组时，你会看到每个学生的年龄都已经增加了。</p>
<p>总结来说，当你使用<code>for range</code>遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】sort.Search二分包</title>
    <url>/2025-06-17-5b0e8e4ea44f.html</url>
    <content><![CDATA[<h1 id="Golang-中二分查找包的使用方法"><a href="#Golang-中二分查找包的使用方法" class="headerlink" title="Golang 中二分查找包的使用方法"></a>Golang 中二分查找包的使用方法</h1><p>Go 标准库中的 <code>sort</code> 包提供了二分查找的功能，主要通过 <code>sort.Search</code> 函数实现。下面详细介绍如何使用这个功能。</p>
<h3 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 初始化边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 防止溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">// 找到目标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 调整左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment">// 调整右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeftBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找右边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRightBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-sort-Search-基本用法"><a href="#1-sort-Search-基本用法" class="headerlink" title="1. sort.Search 基本用法"></a>1. <code>sort.Search</code> 基本用法</h2><p><code>sort.Search</code> 函数的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>它会在 <code>[0, n)</code> 范围内查找满足 <code>f(i)</code> 为 <code>true</code> 的最小索引 <code>i</code>。如果不存在这样的索引，则返回 <code>n</code>。</p>
<h3 id="基本示例：在有序切片中查找元素"><a href="#基本示例：在有序切片中查找元素" class="headerlink" title="基本示例：在有序切片中查找元素"></a>基本示例：在有序切片中查找元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">	target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找目标值的索引</span></span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-查找特定条件的元素"><a href="#2-查找特定条件的元素" class="headerlink" title="2. 查找特定条件的元素"></a>2. 查找特定条件的元素</h2><p><code>sort.Search</code> 的强大之处在于可以查找满足任意条件的第一个元素。</p>
<h3 id="示例：查找第一个大于等于目标值的元素"><a href="#示例：查找第一个大于等于目标值的元素" class="headerlink" title="示例：查找第一个大于等于目标值的元素"></a>示例：查找第一个大于等于目标值的元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;第一个大于等于 %d 的元素是 %d，索引为 %d\n&quot;</span>, target, nums[index], index)</span><br></pre></td></tr></table></figure>

<h3 id="示例：查找第一个满足条件的偶数"><a href="#示例：查找第一个满足条件的偶数" class="headerlink" title="示例：查找第一个满足条件的偶数"></a>示例：查找第一个满足条件的偶数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i]%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第一个偶数是 %d，索引为 %d\n&quot;</span>, nums[index], index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;没有找到偶数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义类型的二分查找"><a href="#3-自定义类型的二分查找" class="headerlink" title="3. 自定义类型的二分查找"></a>3. 自定义类型的二分查找</h2><p>对于自定义类型，需要先实现 <code>sort.Interface</code> 接口，然后才能使用 <code>sort.Search</code>。</p>
<h3 id="示例：自定义结构体切片查找"><a href="#示例：自定义结构体切片查找" class="headerlink" title="示例：自定义结构体切片查找"></a>示例：自定义结构体切片查找</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := ByAge&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先排序</span></span><br><span class="line">    sort.Sort(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找年龄大于等于 33 的第一个人</span></span><br><span class="line">    targetAge := <span class="number">33</span></span><br><span class="line">    index := sort.Search(<span class="built_in">len</span>(people), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &gt;= targetAge</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(people) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;找到 %+v，索引为 %d\n&quot;</span>, people[index], index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有找到满足条件的人&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-查找浮点数近似值"><a href="#4-查找浮点数近似值" class="headerlink" title="4. 查找浮点数近似值"></a>4. 查找浮点数近似值</h2><p><code>sort.Search</code> 也可以用于浮点数近似查找。</p>
<h3 id="示例：查找平方根近似值"><a href="#示例：查找平方根近似值" class="headerlink" title="示例：查找平方根近似值"></a>示例：查找平方根近似值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 设置精度</span></span><br><span class="line">    precision := <span class="number">1e-6</span></span><br><span class="line">    low, high := <span class="number">0.0</span>, x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用二分查找逼近平方根</span></span><br><span class="line">    <span class="keyword">for</span> high-low &gt; precision &#123;</span><br><span class="line">        mid := (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid*mid &lt; x &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (low + high) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;√2 ≈&quot;</span>, sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-查找切片中的插入位置"><a href="#5-查找切片中的插入位置" class="headerlink" title="5. 查找切片中的插入位置"></a>5. 查找切片中的插入位置</h2><p><code>sort.Search</code> 非常适合用来查找元素应该插入的位置。</p>
<h3 id="示例：查找插入位置"><a href="#示例：查找插入位置" class="headerlink" title="示例：查找插入位置"></a>示例：查找插入位置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d 应该插入到索引 %d 的位置\n&quot;</span>, target, index)</span><br><span class="line"><span class="comment">// 输出: 6 应该插入到索引 3 的位置</span></span><br></pre></td></tr></table></figure>

<h2 id="6-标准库中的其他相关函数"><a href="#6-标准库中的其他相关函数" class="headerlink" title="6. 标准库中的其他相关函数"></a>6. 标准库中的其他相关函数</h2><p>除了 <code>sort.Search</code>，标准库还提供了：</p>
<ul>
<li><code>sort.SearchInts(a []int, x int) int</code> - 在已排序的 int 切片中查找 x</li>
<li><code>sort.SearchFloat64s(a []float64, x float64) int</code> - 在已排序的 float64 切片中查找 x</li>
<li><code>sort.SearchStrings(a []string, x string) int</code> - 在已排序的 string 切片中查找 x</li>
</ul>
<h3 id="示例：使用-sort-SearchInts"><a href="#示例：使用-sort-SearchInts" class="headerlink" title="示例：使用 sort.SearchInts"></a>示例：使用 <code>sort.SearchInts</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.SearchInts(nums, target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-性能考虑"><a href="#7-性能考虑" class="headerlink" title="7. 性能考虑"></a>7. 性能考虑</h2><p><code>sort.Search</code> 的时间复杂度是 O(log n)，因为它使用的是二分查找算法。但需要注意：</p>
<ol>
<li>切片必须是已排序的，否则结果不可靠</li>
<li>比较函数 <code>f</code> 应该尽可能简单高效</li>
<li>对于非常大的数据集，考虑内存局部性和缓存效应</li>
</ol>
<h2 id="8-实际应用示例"><a href="#8-实际应用示例" class="headerlink" title="8. 实际应用示例"></a>8. 实际应用示例</h2><h3 id="示例：实现类似-C-的-lower-bound-和-upper-bound"><a href="#示例：实现类似-C-的-lower-bound-和-upper-bound" class="headerlink" title="示例：实现类似 C++ 的 lower_bound 和 upper_bound"></a>示例：实现类似 C++ 的 lower_bound 和 upper_bound</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lowerBound 返回第一个 &gt;= target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upperBound 返回第一个 &gt; target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upperBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    target := <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    lb := lowerBound(nums, target)</span><br><span class="line">    ub := upperBound(nums, target)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;lowerBound: %d, upperBound: %d\n&quot;</span>, lb, ub)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;元素 %d 的出现次数: %d\n&quot;</span>, target, ub-lb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】优先队列</title>
    <url>/2025-06-17-96c1b8914ef4.html</url>
    <content><![CDATA[<h1 id="优先队列在LeetCode上的经典题目及Golang实现"><a href="#优先队列在LeetCode上的经典题目及Golang实现" class="headerlink" title="优先队列在LeetCode上的经典题目及Golang实现"></a>优先队列在LeetCode上的经典题目及Golang实现</h1><p>优先队列（Priority Queue）是一种重要的数据结构，它在很多算法问题中都有广泛应用。以下是LeetCode上一些经典的优先队列题目，以及用Golang实现的解决方案和模板总结。</p>
<h2 id="优先队列的Golang实现"><a href="#优先队列的Golang实现" class="headerlink" title="优先队列的Golang实现"></a>优先队列的Golang实现</h2><p>在Golang中，我们可以使用<code>container/heap</code>包来实现优先队列。首先，我们需要定义一个实现heap.Interface的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个最小堆</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆只需修改Less方法</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 改为大于号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经典题目及实现"><a href="#经典题目及实现" class="headerlink" title="经典题目及实现"></a>经典题目及实现</h2><h3 id="1-合并K个升序链表-LeetCode-23"><a href="#1-合并K个升序链表-LeetCode-23" class="headerlink" title="1. 合并K个升序链表 (LeetCode 23)"></a>1. 合并K个升序链表 (LeetCode 23)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    h := &amp;NodeHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有链表的头节点加入堆</span></span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    current := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := heap.Pop(h).(*ListNode)</span><br><span class="line">        current.Next = node</span><br><span class="line">        current = current.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, node.Next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数组中的第K个最大元素-LeetCode-215"><a href="#2-数组中的第K个最大元素-LeetCode-215" class="headerlink" title="2. 数组中的第K个最大元素 (LeetCode 215)"></a>2. 数组中的第K个最大元素 (LeetCode 215)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := &amp;MinHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.Push(h, num)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-前K个高频元素-LeetCode-347"><a href="#3-前K个高频元素-LeetCode-347" class="headerlink" title="3. 前K个高频元素 (LeetCode 347)"></a>3. 前K个高频元素 (LeetCode 347)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> pq[i].count &lt; pq[j].count &#125; <span class="comment">// 最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; pq[i], pq[j] = pq[j], pq[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 统计频率</span></span><br><span class="line">    frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        frequency[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建优先队列</span></span><br><span class="line">    pq := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素加入队列</span></span><br><span class="line">    <span class="keyword">for</span> value, count := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">        heap.Push(pq, &amp;Item&#123;value: value, count: count&#125;)</span><br><span class="line">        <span class="keyword">if</span> pq.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(pq)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集结果</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        result[i] = heap.Pop(pq).(*Item).value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-数据流的中位数-LeetCode-295"><a href="#4-数据流的中位数-LeetCode-295" class="headerlink" title="4. 数据流的中位数 (LeetCode 295)"></a>4. 数据流的中位数 (LeetCode 295)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxHeap *MaxHeap <span class="comment">// 存储较小的一半</span></span><br><span class="line">    minHeap *MinHeap <span class="comment">// 存储较大的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        maxHeap: &amp;MaxHeap&#123;&#125;,</span><br><span class="line">        minHeap: &amp;MinHeap&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入maxHeap</span></span><br><span class="line">    heap.Push(this.maxHeap, num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平衡两个堆</span></span><br><span class="line">    heap.Push(this.minHeap, heap.Pop(this.maxHeap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;</span><br><span class="line">        heap.Push(this.maxHeap, heap.Pop(this.minHeap))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>]+(*this.minHeap)[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列解题模板"><a href="#优先队列解题模板" class="headerlink" title="优先队列解题模板"></a>优先队列解题模板</h2><p>基于以上题目，可以总结出优先队列的通用解题模板：</p>
<ol>
<li><p><strong>定义堆类型</strong>：</p>
<ul>
<li>实现heap.Interface接口（Len, Less, Swap, Push, Pop方法）</li>
<li>根据需求决定是最小堆还是最大堆（通过Less方法控制）</li>
</ul>
</li>
<li><p><strong>初始化堆</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h := &amp;CustomHeap&#123;&#125;</span><br><span class="line">heap.Init(h)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用堆</strong>：</p>
<ul>
<li>添加元素：<code>heap.Push(h, element)</code></li>
<li>弹出元素：<code>heap.Pop(h)</code></li>
<li>访问堆顶元素（不弹出）：对于最小堆是<code>h[0]</code>，注意要先检查长度</li>
</ul>
</li>
<li><p><strong>常见模式</strong>：</p>
<ul>
<li>维护一个大小为K的堆（求前K大&#x2F;小元素）</li>
<li>使用两个堆维护动态数据流的中位数</li>
<li>在贪心算法中使用优先队列选择最优解</li>
</ul>
</li>
</ol>
<h2 id="其他经典优先队列题目"><a href="#其他经典优先队列题目" class="headerlink" title="其他经典优先队列题目"></a>其他经典优先队列题目</h2><ol>
<li>滑动窗口最大值 (LeetCode 239)</li>
<li>任务调度器 (LeetCode 621)</li>
<li>最接近原点的K个点 (LeetCode 973)</li>
<li>重构字符串 (LeetCode 767)</li>
<li>网络延迟时间 (LeetCode 743)</li>
</ol>
<p>优先队列是解决许多复杂问题的有力工具，特别是在需要动态获取最大&#x2F;最小元素或前K个元素的场景中。掌握其实现和应用模式对算法面试非常有帮助。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【Golang】滑动窗口</title>
    <url>/2025-06-17-d8f0a4d6b8c7.html</url>
    <content><![CDATA[<h1 id="Golang-滑动窗口模板与套路详解"><a href="#Golang-滑动窗口模板与套路详解" class="headerlink" title="Golang 滑动窗口模板与套路详解"></a>Golang 滑动窗口模板与套路详解</h1><p>针对 LeetCode 1004（最大连续1的个数 III）这类问题，以下是专门为 Golang 开发者准备的滑动窗口实现模板、适用场景和常见变种：</p>
<h2 id="Golang-滑动窗口模板（1004-类型）"><a href="#Golang-滑动窗口模板（1004-类型）" class="headerlink" title="Golang 滑动窗口模板（1004 类型）"></a>Golang 滑动窗口模板（1004 类型）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, maxLen, zeroCount := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        <span class="comment">// 1. 右指针移动：更新窗口状态</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span> &#123;</span><br><span class="line">            zeroCount++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 左指针移动：当窗口不合法时收缩</span></span><br><span class="line">        <span class="keyword">for</span> zeroCount &gt; k &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span> &#123;</span><br><span class="line">                zeroCount--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 更新结果（此时窗口合法）</span></span><br><span class="line">        <span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心套路与技巧（Golang-实现）"><a href="#核心套路与技巧（Golang-实现）" class="headerlink" title="核心套路与技巧（Golang 实现）"></a>核心套路与技巧（Golang 实现）</h2><ol>
<li><p><strong>双指针初始化</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">maxLen := <span class="number">0</span></span><br><span class="line">counter := <span class="number">0</span> <span class="comment">// 根据问题定义计数器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右指针移动逻辑</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">    <span class="comment">// 更新计数器</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[right]) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口收缩条件</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> counter &gt; k &#123; <span class="comment">// k 是允许的阈值</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[left]) &#123;</span><br><span class="line">        counter--</span><br><span class="line">    &#125;</span><br><span class="line">    left++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果更新</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">    maxLen = windowSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Golang-常见变种实现"><a href="#Golang-常见变种实现" class="headerlink" title="Golang 常见变种实现"></a>Golang 常见变种实现</h2><h3 id="1-替换后的最长重复字符（LeetCode-424）"><a href="#1-替换后的最长重复字符（LeetCode-424）" class="headerlink" title="1. 替换后的最长重复字符（LeetCode 424）"></a>1. 替换后的最长重复字符（LeetCode 424）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">characterReplacement</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    left, maxCount, maxLen := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        count[ch-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">        <span class="keyword">if</span> count[ch-<span class="string">&#x27;A&#x27;</span>] &gt; maxCount &#123;</span><br><span class="line">            maxCount = count[ch-<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：窗口大小 - 最大计数 &gt; k</span></span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>)-maxCount &gt; k &#123;</span><br><span class="line">            count[s[left]-<span class="string">&#x27;A&#x27;</span>]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-水果成篮（LeetCode-904）"><a href="#2-水果成篮（LeetCode-904）" class="headerlink" title="2. 水果成篮（LeetCode 904）"></a>2. 水果成篮（LeetCode 904）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    basket := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxFruits := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, fruit := <span class="keyword">range</span> fruits &#123;</span><br><span class="line">        basket[fruit]++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：水果种类超过2种</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(basket) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            basket[fruits[left]]--</span><br><span class="line">            <span class="keyword">if</span> basket[fruits[left]] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(basket, fruits[left])</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxFruits &#123;</span><br><span class="line">            maxFruits = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxFruits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-最小覆盖子串（LeetCode-76）"><a href="#3-最小覆盖子串（LeetCode-76）" class="headerlink" title="3. 最小覆盖子串（LeetCode 76）"></a>3. 最小覆盖子串（LeetCode 76）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> t &#123;</span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left, valid := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    start, length := <span class="number">0</span>, math.MaxInt32</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="keyword">if</span> _, exists := need[c]; exists &#123;</span><br><span class="line">            window[c]++</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当窗口满足条件时尝试收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> right-left+<span class="number">1</span> &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 收缩窗口</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _, exists := need[d]; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> length == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : start+length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口适用场景总结"><a href="#滑动窗口适用场景总结" class="headerlink" title="滑动窗口适用场景总结"></a>滑动窗口适用场景总结</h2><table>
<thead>
<tr>
<th>问题特征</th>
<th>示例题目</th>
<th>Golang 实现要点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>有限修改连续序列</strong></td>
<td>1004, 424, 2024</td>
<td>使用计数器跟踪修改需求</td>
</tr>
<tr>
<td><strong>不同元素数量限制</strong></td>
<td>904, 340</td>
<td>使用 map 跟踪元素种类</td>
</tr>
<tr>
<td><strong>最短满足条件子串</strong></td>
<td>209, 76</td>
<td>收缩时更新最小值</td>
</tr>
<tr>
<td><strong>固定窗口大小</strong></td>
<td>643, 1343</td>
<td>维护固定大小的窗口</td>
</tr>
<tr>
<td><strong>无重复字符</strong></td>
<td>3, 159</td>
<td>使用 map 或 set 检测重复</td>
</tr>
</tbody></table>
<h2 id="Golang-实现技巧"><a href="#Golang-实现技巧" class="headerlink" title="Golang 实现技巧"></a>Golang 实现技巧</h2><ol>
<li><p><strong>计数器选择</strong>：</p>
<ul>
<li>简单计数：<code>int</code> 变量</li>
<li>字符频率：<code>[26]int</code> 或 <code>[128]int</code></li>
<li>通用元素：<code>map[type]int</code></li>
</ul>
</li>
<li><p><strong>边界处理</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理空输入情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>避免不必要的内存分配（预分配 map 大小）</li>
<li>使用数组代替 map 当键范围有限时</li>
<li>减少循环内部的计算</li>
</ul>
</li>
<li><p><strong>复杂条件处理</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用辅助函数判断窗口合法性</span></span><br><span class="line"><span class="keyword">for</span> !isValid(window, condition) &#123;</span><br><span class="line">    <span class="comment">// 收缩窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>掌握这些 Golang 实现的滑动窗口模式和变种，能高效解决 LeetCode 上大部分滑动窗口问题。关键是根据问题特征选择合适的计数器类型和窗口收缩条件。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【go】初始化双向列表List</title>
    <url>/2024-01-22-93119ce81a1c.html</url>
    <content><![CDATA[<p>在Go语言中，两种方法都可以用于初始化一个<code>list.List</code>。</p>
<ol>
<li><p><code>queue := &amp;list.List&#123;&#125;</code>: 这是使用结构体字面量的方式，创建一个 <code>list.List</code> 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。</p>
</li>
<li><p><code>queue := list.New()</code>: 这是使用 <code>list</code> 包中的 <code>New</code> 函数来创建一个新的 <code>list.List</code>。<code>New</code> 函数返回一个指向新创建的 <code>list.List</code> 实例的指针。同样，这种方式也创建了一个空的链表。</p>
</li>
</ol>
<p>两种方式都是有效的</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting</title>
    <url>/2024-11-23-cf0eba4d8369.html</url>
    <content><![CDATA[<p>确实，如果我们按照缩写的逻辑来看，<code>Itos</code>（Integer to String）可能更直观地表达了<code>Itoa</code>函数的功能，即把整数转换为字符串。</p>
<p>然而，<code>Itoa</code>这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，<code>Itoa</code>这个术语已经被广泛接受和使用。以下是一些可能的原因：</p>
<ol>
<li><p><strong>历史原因</strong>：<code>Itoa</code>这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，<code>Itoa</code>（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。</p>
</li>
<li><p><strong>约定俗成</strong>：在编程社区中，<code>Itoa</code>已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。</p>
</li>
<li><p><strong>ASCII与字符串的关系</strong>：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字<code>123</code>的ASCII表示和字符串表示都是<code>&quot;123&quot;</code>。因此，<code>Itoa</code>这个名字仍然适用。</p>
</li>
<li><p><strong>简洁性</strong>：<code>Itoa</code>这个名称比较简洁，易于记忆。如果使用<code>Itos</code>，虽然直观，但可能不如<code>Itoa</code>简洁。</p>
</li>
</ol>
<p><code>Itoa</code>这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管<code>Itos</code>可能更直观地表示整数到字符串的转换，但<code>Itoa</code>已经成为一个广泛接受和使用的术语。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刨根问底</tag>
      </tags>
  </entry>
  <entry>
    <title>【刨根问底】创建slice是否填第二个参数0的区别</title>
    <url>/2024-11-23-b80d94088ccd.html</url>
    <content><![CDATA[<p>在Go语言中，创建切片（slice）时使用<code>make</code>函数有两种常见的方式，它们之间有细微的差别：</p>
<ol>
<li><p><code>slice := make([]string, 0)</code></p>
<p> 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是<code>[]string</code>），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。</p>
</li>
<li><p><code>slice := make([]string)</code></p>
<p> 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，<code>make</code>函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。</p>
</li>
</ol>
<p>两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用<code>make([]string)</code>（或者等价的<code>make([]string, 0)</code>）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。</p>
<p>总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【基础知识】Golang  sort.Slice 复杂排序</title>
    <url>/2024-11-24-24291296f81a.html</url>
    <content><![CDATA[<p>在 Go 语言中，你可以使用 <code>sort.Slice</code> 对 <code>slice</code> 按照复杂条件进行排序。 <code>sort.Slice</code> 函数接受一个 <code>slice</code> 和一个比较函数，该比较函数定义了两个元素之间的排序关系。</p>
<p>以下是实现复杂条件排序的步骤和示例：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Slice(slice, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 slice[i] 和 slice[j]</span></span><br><span class="line">    <span class="keyword">return</span> 条件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-示例：对结构体切片进行多条件排序"><a href="#2-示例：对结构体切片进行多条件排序" class="headerlink" title="2. 示例：对结构体切片进行多条件排序"></a>2. 示例：对结构体切片进行多条件排序</h3><p>假设有一个包含多个 <code>Person</code> 的切片，我们希望按以下规则排序：</p>
<ol>
<li>年龄从小到大排序。</li>
<li>如果年龄相同，则按名字的字母顺序排序。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 sort.Slice 按多个条件排序</span></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 优先按年龄排序</span></span><br><span class="line">		<span class="keyword">if</span> people[i].Age != people[j].Age &#123;</span><br><span class="line">			<span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果年龄相同，则按名字排序</span></span><br><span class="line">		<span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-更复杂条件：按多个字段权重排序"><a href="#3-更复杂条件：按多个字段权重排序" class="headerlink" title="3. 更复杂条件：按多个字段权重排序"></a>3. 更复杂条件：按多个字段权重排序</h3><p>如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Price <span class="type">float64</span></span><br><span class="line">	Rating <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	products := []Product&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Laptop&quot;</span>, <span class="number">1000</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Phone&quot;</span>, <span class="number">800</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Tablet&quot;</span>, <span class="number">800</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Watch&quot;</span>, <span class="number">400</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序</span></span><br><span class="line">	sort.Slice(products, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 按价格降序</span></span><br><span class="line">		<span class="keyword">if</span> products[i].Price != products[j].Price &#123;</span><br><span class="line">			<span class="keyword">return</span> products[i].Price &gt; products[j].Price</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果价格相同，按评分降序</span></span><br><span class="line">		<span class="keyword">if</span> products[i].Rating != products[j].Rating &#123;</span><br><span class="line">			<span class="keyword">return</span> products[i].Rating &gt; products[j].Rating</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果评分也相同，按名称升序</span></span><br><span class="line">		<span class="keyword">return</span> products[i].Name &lt; products[j].Name</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(products)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li>如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。</li>
<li><code>sort.Slice</code> 是不稳定的。如果需要稳定排序，可以使用 <code>sort.SliceStable</code>。</li>
<li>对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。</li>
</ul>
<p>通过 <code>sort.Slice</code> 的灵活性，可以轻松实现各种复杂条件的排序逻辑。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>【基础知识】符号整数和非符号整数</title>
    <url>/2024-11-23-dce4118b03a7.html</url>
    <content><![CDATA[<p><code>uint8</code> <code>uint16</code>和<code>uint32</code>是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。</p>
<ol>
<li><p><code>unit8</code> : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255</p>
</li>
<li><p>**<code>uint16</code>**：</p>
<ul>
<li><code>uint16</code>是一个16位的无符号整数。</li>
<li>它可以存储的数字数量是 2^16。</li>
<li>计算得出：216&#x3D;65536216&#x3D;65536。</li>
<li>因此，<code>uint16</code>能存储的数字范围是从0到65535。</li>
</ul>
</li>
<li><p>**<code>uint32</code>**：</p>
<ul>
<li><code>uint32</code>是一个32位的无符号整数。</li>
<li>它可以存储的数字数量是 2^32。</li>
<li>计算得出：232&#x3D;4294967296232&#x3D;4294967296。</li>
<li>因此，<code>uint32</code>能存储的数字范围是从0到4294967295。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>uint16</code>能存储的数字数量是 216216，即65536个数字。</li>
<li><code>uint32</code>能存储的数字数量是 232232，即4294967296个数字。</li>
</ul>
<p><code>int32</code>是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。</p>
<p>具体来说：</p>
<ul>
<li>对于正数，<strong>最高位是0</strong>，剩下的31位可以表示 231231 个不同的正数值。</li>
<li>对于负数，<strong>最高位是1</strong>，剩下的31位可以表示 231231 个不同的负数值。</li>
<li>由于0既不是正数也不是负数，它单独占用了一个数值。</li>
</ul>
<p>因此，<code>int32</code>的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说<code>int32</code>的范围是31次方而不是32次方的原因。<br><img src="/../../imgs/Pasted%20image%2020241123132832.png"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Go 的 container list 包：双向链表的便捷工具</title>
    <url>/2023-10-09-5ecfb18fa495.html</url>
    <content><![CDATA[<p>Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。</p>
<h2 id="导入-container-list-包"><a href="#导入-container-list-包" class="headerlink" title="导入 container&#x2F;list 包"></a>导入 container&#x2F;list 包</h2><p>要使用 container&#x2F;list 包，首先需要导入它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><p>创建一个新的链表非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myList := list.New()</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 myList 的新链表。</p>
<h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myList.PushBack(<span class="number">42</span>)</span><br><span class="line">myList.PushFront(<span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>要访问链表中的元素，你可以使用 Front 和 Back 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">firstElement := myList.Front().Value</span><br><span class="line">lastElement := myList.Back().Value</span><br></pre></td></tr></table></figure>

<h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><p>遍历链表可以使用 for 循环来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element := myList.Front(); element != <span class="literal">nil</span>; element = element.Next() &#123;</span><br><span class="line">    <span class="comment">// 处理 element.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>要删除链表中的元素，可以使用 Remove 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elementToRemove := myList.Front()</span><br><span class="line">myList.Remove(elementToRemove)</span><br></pre></td></tr></table></figure>

<h1 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h1><h2 id="1-类型断言"><a href="#1-类型断言" class="headerlink" title="1. 类型断言"></a>1. 类型断言</h2><p>链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value := element.Value.(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>如果断言失败，会导致运行时错误。</p>
<h2 id="2-InsertAfter-和-InsertBefore"><a href="#2-InsertAfter-和-InsertBefore" class="headerlink" title="2. InsertAfter 和 InsertBefore"></a>2. InsertAfter 和 InsertBefore</h2><p>这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。</p>
<h1 id="示例：浏览器历史记录"><a href="#示例：浏览器历史记录" class="headerlink" title="示例：浏览器历史记录"></a>示例：浏览器历史记录</h1><p>下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span></span><br><span class="line"><span class="comment"> * Author: Lei Qi</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Date: 2023/10/10 上午12:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Browser <span class="keyword">struct</span> &#123;</span><br><span class="line">	history  *list.List</span><br><span class="line">	current  *list.Element</span><br><span class="line">	maxLen   <span class="type">int</span></span><br><span class="line">	homepage <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBrowser</span><span class="params">(maxLen <span class="type">int</span>, homepage <span class="type">string</span>)</span></span> *Browser &#123;</span><br><span class="line">	history := list.New()</span><br><span class="line">	current := history.PushBack(homepage)</span><br><span class="line">	<span class="keyword">return</span> &amp;Browser&#123;</span><br><span class="line">		history:  history,</span><br><span class="line">		current:  current,</span><br><span class="line">		maxLen:   maxLen,</span><br><span class="line">		homepage: homepage,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GetCurrentPage() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.current.Value.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GoBack() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.current.Prev() != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.current = b.current.Prev()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GoForward() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.current.Next() != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.current = b.current.Next()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 清除当前页面之后的历史记录</span></span><br><span class="line">	<span class="keyword">for</span> e := b.current.Next(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		b.history.Remove(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将新页面添加到历史记录中</span></span><br><span class="line">	b.current = b.history.InsertAfter(newPageURL, b.current)</span><br><span class="line">	<span class="comment">// 限制浏览器历史记录的最大长度</span></span><br><span class="line">	<span class="keyword">for</span> b.history.Len() &gt; b.maxLen &#123;</span><br><span class="line">		front := b.history.Front()</span><br><span class="line">		<span class="keyword">if</span> front != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.history.Remove(front)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	browser := NewBrowser(<span class="number">5</span>, <span class="string">&quot;初始页面&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 浏览新页面</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面1&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 浏览更多新页面</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面2&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面3&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面4&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面5&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后退和前进</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;后退:&quot;</span>, browser.GoBack())</span><br><span class="line">	fmt.Println(<span class="string">&quot;后退:&quot;</span>, browser.GoBack())</span><br><span class="line">	fmt.Println(<span class="string">&quot;前进:&quot;</span>, browser.GoForward())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>回溯总结</title>
    <url>/2025-06-03-fc6703ad881e.html</url>
    <content><![CDATA[<h2 id="子集型回溯"><a href="#子集型回溯" class="headerlink" title="子集型回溯"></a>子集型回溯</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p>
<p><img src="/../../imgs/Pasted%20image%2020250605230846.png"><br><img src="/../../imgs/Pasted%20image%2020250605230928.png"><br>方法一：输入的视角（选或不选）<br>对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2<br>n<br>  个不同的子集。</p>
<p>dfs 中的 i 表示当前考虑到 nums[i] 选或不选。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// 子集构造完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path)) <span class="comment">// 复制 path</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不选 nums[i]</span></span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选 nums[i]</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：<strong>答案的视角（枚举选哪个）</strong><br>枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。</p>
<p>dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。</p>
<p>如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。</p>
<p>注意：不需要在回溯中判断 i&#x3D;n 的边界情况，因为此时不会进入循环，if i &#x3D;&#x3D; n: return 这句话写不写都一样.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="131">
<li>分割回文串 <a href="https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/">https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</a></li>
</ol>
<p>从答案的角度，枚举选哪个，需要使用for循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := left, right;i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> (ans [][]<span class="type">string</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑 s[i:] 怎么分割</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// s 分割完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 枚举子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome(s, i, j) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[i:j+<span class="number">1</span>]) <span class="comment">// 分割！</span></span><br><span class="line">                <span class="comment">// 考虑剩余的 s[j+1:] 怎么分割</span></span><br><span class="line">                dfs(j + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="132">
<li>电话号码的字母组合 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</a></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    m []<span class="type">string</span></span><br><span class="line">    path []<span class="type">byte</span></span><br><span class="line">    res []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 将index 和 字符串对应起来</span></span><br><span class="line">	m = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">	path, res = <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>),<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">	backTracking(digits,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(digits <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 终止条件 ，遍历完digits</span></span><br><span class="line">	<span class="keyword">if</span> start == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        tmp := <span class="type">string</span>(path)</span><br><span class="line">		res = <span class="built_in">append</span>(res,tmp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到 digit</span></span><br><span class="line">	digitNum := <span class="type">int</span>(digits[start] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	<span class="comment">// 遍历 digit 对应的map 字符串</span></span><br><span class="line">	str := m[digitNum]</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(str);i++ &#123; <span class="comment">// i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始</span></span><br><span class="line">		path = <span class="built_in">append</span>(path,str[i])</span><br><span class="line">		backTracking(digits,start+<span class="number">1</span>)</span><br><span class="line">		path =path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合型回溯"><a href="#组合型回溯" class="headerlink" title="组合型回溯"></a>组合型回溯</h2><p><img src="/../../imgs/Pasted%20image%2020250611222518.png"></p>
<ol>
<li>左边选或者不选  K&#x3D;3  右边k &#x3D; 2, 因为是组合，等于是重复的就能再出现了，再选了2 之后，只能选1 了， 不能再选其他的了。<br><img src="/../../imgs/Pasted%20image%2020250611223356.png"><br>倒序的不等式简单点，正序的不等式为 n - i + 1 &lt; d 直接return</li>
</ol>
<p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 倒序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 组合</span></span><br><span class="line">	<span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line">		<span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// base case</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">			tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">			<span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">			res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">			<span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line">			<span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			path = <span class="built_in">append</span>(path, i)</span><br><span class="line">			dfs(i - <span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(n)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 组合</span></span><br><span class="line">	<span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line">		<span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// base case</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">			tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">			<span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">			res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := start; i &lt;= n; i++ &#123; <span class="comment">// 倒序方便</span></span><br><span class="line">			<span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line">			<span class="keyword">if</span> n-i+<span class="number">1</span> &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			path = <span class="built_in">append</span>(path, i)</span><br><span class="line">			dfs(i + <span class="number">1</span>)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>组合3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode216</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到一个合法组合</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) == k &amp;&amp; sum == n &#123;</span><br><span class="line">			tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">			<span class="built_in">copy</span>(tmp, path)</span><br><span class="line">			res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 剪枝：剩余数字不足以填满 path 或无法达到 sum</span></span><br><span class="line">		<span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 确保剩余数字足够填满 path</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> sum+i &gt; n &#123; <span class="comment">// 提前终止，避免无效递归  如果 sum + i &gt; n，说明当前 i 太大，不能选它。但 更小的 i 仍然可能满足 sum + i &lt;= n，所以不能直接 break（否则会漏掉可能的解）。</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			path = <span class="built_in">append</span>(path, i)</span><br><span class="line">			dfs(i<span class="number">-1</span>, sum+i)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dfs(<span class="number">9</span>, <span class="number">0</span>) <span class="comment">// 数字范围是 1~9</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p>
<p>思路<a href="https://labuladong.online/algo/practice-in-action/generate-parentheses/">题解</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态数据 回退操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">//n 对括号 只要最后左右总和一样，</span></span><br><span class="line">	m := n * <span class="number">2</span></span><br><span class="line">	res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span></span><br><span class="line">	path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == m &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 选左边</span></span><br><span class="line">		<span class="keyword">if</span> open &lt; n &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">			dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 选右边</span></span><br><span class="line">		<span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 右边要小于左边才能加</span></span><br><span class="line">			path = <span class="built_in">append</span>(path, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">			dfs(i+<span class="number">1</span>, open)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 入口函数需要添加</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定长度+索引，不用回退</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    m := n * <span class="number">2</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == m &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, <span class="type">string</span>(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> open &lt; n &#123; <span class="comment">// 可以填左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 可以填右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在你提供的这个实现中，不需要显式的回退操作（如 <code>path = path[:len(path)-1]</code>），是因为它采用了 <strong>固定长度的 <code>[]byte</code> 数组</strong> 和 <strong>索引覆盖</strong> 的方式，这与常见的回溯算法实现有所不同。下面详细解释为什么可以省略回退操作：</p>
<hr>
<h3 id="关键原因分析"><a href="#关键原因分析" class="headerlink" title="关键原因分析"></a><strong>关键原因分析</strong></h3><h4 id="1-使用固定长度的-byte-数组"><a href="#1-使用固定长度的-byte-数组" class="headerlink" title="1. 使用固定长度的 []byte 数组"></a>1. <strong>使用固定长度的 <code>[]byte</code> 数组</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)  <span class="comment">// 长度为 m 的固定数组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组 <code>path</code> 的长度在初始化时就固定为 <code>m</code>（<code>=n*2</code>），不会动态增长。</li>
<li>每个递归层级直接通过索引 <code>i</code> 修改 <code>path[i]</code> 的位置，<strong>不会影响其他层级的存储</strong>。</li>
</ul>
<h4 id="2-索引覆盖写入"><a href="#2-索引覆盖写入" class="headerlink" title="2. 索引覆盖写入"></a>2. <strong>索引覆盖写入</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 或 path[i] = &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每次写入都会<strong>精确覆盖 <code>path[i]</code> 的位置</strong>，而不会追加元素。</li>
<li>递归返回时，<strong>上层调用会覆盖当前层写入的值</strong>，因此不需要手动回退。</li>
</ul>
<h4 id="3-递归的自然回溯"><a href="#3-递归的自然回溯" class="headerlink" title="3. 递归的自然回溯"></a>3. <strong>递归的自然回溯</strong></h4><ul>
<li>当递归从深层返回时，<strong>上层调用会继续修改 <code>path</code> 的后续位置</strong>，覆盖之前的值。</li>
<li>例如：<ul>
<li>第一层递归写入 <code>path[0] = &#39;(&#39;</code>，然后进入第二层。</li>
<li>第二层写入 <code>path[1] = &#39;(&#39;</code> 或 <code>path[1] = &#39;)&#39;</code>。</li>
<li>当第二层递归返回后，第一层可能会写入 <code>path[1] = &#39;)&#39;</code>，覆盖之前的值。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="对比需要回退操作的实现"><a href="#对比需要回退操作的实现" class="headerlink" title="对比需要回退操作的实现"></a><strong>对比需要回退操作的实现</strong></h3><h4 id="需要回退的版本（动态-append）"><a href="#需要回退的版本（动态-append）" class="headerlink" title="需要回退的版本（动态 append）"></a><strong>需要回退的版本（动态 <code>append</code>）</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)  <span class="comment">// 修改切片长度</span></span><br><span class="line">dfs(...)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 必须回退</span></span><br></pre></td></tr></table></figure>
<ul>
<li>动态 <code>append</code> 会改变切片长度，必须显式回退以恢复状态。</li>
</ul>
<h4 id="不需要回退的版本（固定数组-索引覆盖）"><a href="#不需要回退的版本（固定数组-索引覆盖）" class="headerlink" title="不需要回退的版本（固定数组 + 索引覆盖）"></a><strong>不需要回退的版本（固定数组 + 索引覆盖）</strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 直接覆盖，不改变长度</span></span><br><span class="line">dfs(...)</span><br><span class="line"><span class="comment">// 无需回退，上层调用会覆盖 path[i]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>固定数组的长度不变，通过索引直接修改值，递归返回后自然被覆盖。</li>
</ul>
<hr>
<h3 id="为什么这种写法是正确的？"><a href="#为什么这种写法是正确的？" class="headerlink" title="为什么这种写法是正确的？"></a><strong>为什么这种写法是正确的？</strong></h3><ol>
<li><p><strong>隐式回溯</strong>：</p>
<ul>
<li>每一层递归的 <code>path[i]</code> 写入是独立的，递归返回后会被上层调用覆盖。</li>
<li>例如：<ul>
<li>路径 <code>&quot;(())&quot;</code> 的生成过程：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path[<span class="number">0</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第一层</span></span><br><span class="line">path[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第二层</span></span><br><span class="line">path[<span class="number">2</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第三层</span></span><br><span class="line">path[<span class="number">3</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第四层</span></span><br></pre></td></tr></table></figure></li>
<li>如果第二层尝试 <code>path[1] = &#39;)&#39;</code>，它会覆盖之前的 <code>&#39;(&#39;</code>，但通过条件 <code>i-open &lt; open</code> 保证了合法性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>条件保证合法性</strong>：</p>
<ul>
<li><code>open &lt; n</code> 确保左括号不超过 <code>n</code> 个。</li>
<li><code>i-open &lt; open</code> 确保右括号数不超过左括号数。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong>不需要回退</strong>：因为使用了固定长度的 <code>[]byte</code> 数组，通过索引直接覆盖写入，递归返回时上层调用会自然覆盖当前层的修改。</li>
<li><strong>更高效</strong>：避免了动态切片的扩容和回退操作，减少了内存分配。</li>
<li><strong>更简洁</strong>：代码更紧凑，但需要理解索引覆盖的隐式回溯逻辑。</li>
</ul>
<p>这种写法是回溯算法的一种优化技巧，适用于结果长度固定的场景（如括号生成、排列问题等）。</p>
<h2 id="排列型回溯"><a href="#排列型回溯" class="headerlink" title="排列型回溯"></a>排列型回溯</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构和操作的对比：Python vs. Go vs. C++</title>
    <url>/2023-10-19-86483682723b.html</url>
    <content><![CDATA[<h1 id="Python示例"><a href="#Python示例" class="headerlink" title="Python示例"></a>Python示例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">sub_list = my_list[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">reversed_list = my_list[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">my_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双向链表（使用collections.deque）</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">my_linked_list = deque()</span><br><span class="line">my_linked_list.append(<span class="number">1</span>)</span><br><span class="line">my_linked_list.append(<span class="number">2</span>)</span><br><span class="line">my_linked_list.append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大堆和最小堆（需要使用第三方库heapq）</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">max_heap = []</span><br><span class="line">min_heap = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二叉树（使用类或结构体）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串操作</span></span><br><span class="line">my_string = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring = my_string[<span class="number">7</span>:<span class="number">12</span>]</span><br><span class="line">my_int = <span class="number">42</span></span><br><span class="line">my_str = <span class="built_in">str</span>(my_int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度拷贝和浅拷贝（使用copy模块）</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">original_list = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line">shallow_copy = copy.copy(original_list)</span><br><span class="line">deep_copy = copy.deepcopy(original_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">my_list.pop(<span class="number">1</span>)  <span class="comment"># 删除第二个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找小写字母</span></span><br><span class="line"><span class="keyword">if</span> my_string.islower():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;String contains only lowercase letters&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用循环遍历字典</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字典是否包含键</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Dictionary contains &#x27;name&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Go示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组和切片</span></span><br><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">subSlice := mySlice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">reversedSlice := reverseSlice(mySlice)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line">myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表（使用container/list）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line">myList := list.New()</span><br><span class="line">myList.PushBack(<span class="number">1</span>)</span><br><span class="line">myList.PushBack(<span class="number">2</span>)</span><br><span class="line">myList.PushBack(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆和最小堆（需要使用heap包）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">maxHeap := &amp;MaxHeap&#123;&#125;</span><br><span class="line">minHeap := &amp;MinHeap&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树（使用结构体或指针）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串操作</span></span><br><span class="line">myString := <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring := myString[<span class="number">7</span>:<span class="number">12</span>]</span><br><span class="line">myInt := <span class="number">42</span></span><br><span class="line">myStr := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, myInt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度拷贝和浅拷贝（使用复制切片或递归）</span></span><br><span class="line">originalSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">shallowCopy := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(originalSlice))</span><br><span class="line"><span class="built_in">copy</span>(shallowCopy, originalSlice)</span><br><span class="line">deepCopy := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), originalSlice...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">index := <span class="number">1</span></span><br><span class="line">mySlice = <span class="built_in">append</span>(mySlice[:index], mySlice[index+<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找小写字母</span></span><br><span class="line">containsLowercase := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> myString &#123;</span><br><span class="line">    <span class="keyword">if</span> unicode.IsLower(char) &#123;</span><br><span class="line">        containsLowercase = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历切片</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> mySlice &#123;</span><br><span class="line">    fmt.Println(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用循环遍历字典</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字典是否包含键</span></span><br><span class="line"><span class="keyword">if</span> _, exists := myMap[<span class="string">&quot;name&quot;</span>]; exists &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Map contains &#x27;name&#x27;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组和向量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">subVector</span><span class="params">(myVector.begin() + <span class="number">1</span>, myVector.begin() + <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">reversedVector</span><span class="params">(myVector.rbegin(), myVector.rend())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典（使用std::map）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line">myMap[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">myMap[<span class="string">&quot;age&quot;</span>] = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表（使用std::list）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆和最小堆（使用std::priority_queue）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树（使用结构体或指针）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串操作</span></span><br><span class="line">std::string myString = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">std::string substring = myString.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> myInt = <span class="number">42</span>;</span><br><span class="line">std::string myStr = std::<span class="built_in">to_string</span>(myInt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度拷贝和浅拷贝</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; originalVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; shallowCopy = originalVector;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">deepCopy</span><span class="params">(originalVector)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找小写字母</span></span><br><span class="line"><span class="type">bool</span> containsLowercase = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : myString) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">        containsLowercase = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历向量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : myVector) &#123;</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用循环遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字典是否包含键</span></span><br><span class="line"><span class="keyword">if</span> (myMap.<span class="built_in">find</span>(<span class="string">&quot;name&quot;</span>) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map contains &#x27;name&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>数组双指针刷题总结</title>
    <url>/2023-06-22-079d0af75447.html</url>
    <content><![CDATA[<p>双指针技巧分为<strong>快慢指针</strong>和<strong>左右指针</strong></p>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><ul>
<li>原地修改数组<ul>
<li>遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++</li>
</ul>
</li>
<li>去除有序数组&#x2F;链表中去重<ul>
<li>和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast]</li>
</ul>
</li>
</ul>
<h1 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h1><p>1.二分查找<br>    * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界<br>2.<strong>N sum 之和</strong><br>    * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大<br>3.反转字符串<br>    * 终止条件是i&gt;j<br>4.回文串判断<br>     * 判断条件s[i] &#x3D;&#x3D; s[j]</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>设计题 总结</title>
    <url>/2024-04-05-d9f9294c39ef.html</url>
    <content><![CDATA[<p>举个简单的例子：<br><strong>设计题 - 实现浏览器历史记录</strong><br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p>
<ul>
<li>和当前页相同，则直接返回</li>
<li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span></span><br><span class="line"><span class="comment"> * Author: Lei Qi</span></span><br><span class="line"><span class="comment"> * Description: 浏览器实现</span></span><br><span class="line"><span class="comment"> * Date: 2023/10/10 上午12:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Browser <span class="keyword">struct</span> &#123;</span><br><span class="line">	history  *list.List</span><br><span class="line">	current  *list.Element</span><br><span class="line">	maxLen   <span class="type">int</span></span><br><span class="line">	homepage <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBrowser</span><span class="params">(maxLen <span class="type">int</span>, homepage <span class="type">string</span>)</span></span> *Browser &#123;</span><br><span class="line">	history := list.New()</span><br><span class="line">	current := history.PushBack(homepage)</span><br><span class="line">	<span class="keyword">return</span> &amp;Browser&#123;</span><br><span class="line">		history:  history,</span><br><span class="line">		current:  current,</span><br><span class="line">		maxLen:   maxLen,</span><br><span class="line">		homepage: homepage,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GetCurrentPage() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.current.Value.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GoBack() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.current.Prev() != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.current = b.current.Prev()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> GoForward() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.current.Next() != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.current = b.current.Next()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.GetCurrentPage() == newPageURL &#123;</span><br><span class="line">		<span class="keyword">return</span> newPageURL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清除当前页面之后的历史记录</span></span><br><span class="line">	<span class="keyword">for</span> e := b.current.Next(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		b.history.Remove(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将新页面添加到历史记录中</span></span><br><span class="line">	b.current = b.history.InsertAfter(newPageURL, b.current)</span><br><span class="line">	<span class="comment">// 限制浏览器历史记录的最大长度</span></span><br><span class="line">	<span class="keyword">for</span> b.history.Len() &gt; b.maxLen &#123;</span><br><span class="line">		front := b.history.Front()</span><br><span class="line">		<span class="keyword">if</span> front != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.history.Remove(front)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.GetCurrentPage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	browser := NewBrowser(<span class="number">5</span>, <span class="string">&quot;初始页面&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 浏览新页面</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面1&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 浏览更多新页面</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面2&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面3&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面4&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="string">&quot;新页面5&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后退和前进</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;后退:&quot;</span>, browser.GoBack())</span><br><span class="line">	fmt.Println(<span class="string">&quot;后退:&quot;</span>, browser.GoBack())</span><br><span class="line">	fmt.Println(<span class="string">&quot;前进:&quot;</span>, browser.GoForward())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p>
<h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p>
<p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p>
<h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p>
<p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p>
<h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p>
<p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p>
<h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p>
<h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p>
<p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面，我们来按照难度多练习几道题目</p>
<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ol>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></li>
</ol>
<p><img src="/../../imgs/Pasted%20image%2020240405184827.png"></p>
<p> <strong>思路：</strong>input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	inputStack  []<span class="type">int</span></span><br><span class="line">	outputStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyQueue &#123;</span><br><span class="line">	<span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">		inputStack:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		outputStack: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	this.inputStack = <span class="built_in">append</span>(this.inputStack, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.outputStack) != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">		topTmp := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>] <span class="comment">//</span></span><br><span class="line">		this.outputStack = this.outputStack[:<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">return</span> topTmp</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(this.inputStack) != <span class="number">0</span> &#123;</span><br><span class="line">			this.outputStack = <span class="built_in">append</span>(this.outputStack, this.inputStack[<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>])</span><br><span class="line">			this.inputStack = this.inputStack[:<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	top := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>] <span class="comment">//</span></span><br><span class="line">	this.outputStack = this.outputStack[:<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Peek() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.outputStack) != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">		topTmp := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>] <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> topTmp</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(this.inputStack) != <span class="number">0</span> &#123;</span><br><span class="line">			this.outputStack = <span class="built_in">append</span>(this.outputStack, this.inputStack[<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>])</span><br><span class="line">			this.inputStack = this.inputStack[:<span class="built_in">len</span>(this.inputStack)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	top := this.outputStack[<span class="built_in">len</span>(this.outputStack)<span class="number">-1</span>] <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.inputStack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.outputStack) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a><img src="/../../imgs/Pasted%20image%2020240405184932.png"></li>
</ol>
<p><strong>思路：</strong>用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	inputQueue  []<span class="type">int</span></span><br><span class="line">	outputQueue []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyStack &#123;</span><br><span class="line">	<span class="keyword">return</span> MyStack&#123;</span><br><span class="line">		inputQueue:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		outputQueue: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	this.inputQueue = <span class="built_in">append</span>(this.inputQueue, x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(this.inputQueue) != <span class="number">1</span> &#123;</span><br><span class="line">		this.outputQueue = <span class="built_in">append</span>(this.outputQueue, this.inputQueue[<span class="number">0</span>])</span><br><span class="line">		this.inputQueue = this.inputQueue[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	top := this.inputQueue[<span class="number">0</span>]</span><br><span class="line">	this.inputQueue = this.outputQueue</span><br><span class="line">    this.outputQueue = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(this.inputQueue) != <span class="number">1</span> &#123;</span><br><span class="line">		this.outputQueue = <span class="built_in">append</span>(this.outputQueue, this.inputQueue[<span class="number">0</span>])</span><br><span class="line">		this.inputQueue = this.inputQueue[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	top := this.inputQueue[<span class="number">0</span>]</span><br><span class="line">	this.inputQueue = <span class="built_in">append</span>(this.outputQueue, this.inputQueue...)</span><br><span class="line">    this.outputQueue = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">len</span>(this.inputQueue) == <span class="number">0</span>) &amp;&amp; (<span class="built_in">len</span>(this.outputQueue) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406201421.png"><br>思路：简单题，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    nums  []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="type">int</span>)</span></span> NumArray &#123;</span><br><span class="line">    <span class="keyword">return</span> NumArray&#123;nums: nums&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span></span> SumRange(left <span class="type">int</span>, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i:= left; i&lt;= right; i++ &#123;</span><br><span class="line">        sum += this.nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.SumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用前缀和<br><img src="/../../imgs/Pasted%20image%2020240406201959.png"><br>怎么求 preSum 数组<br>利用前面提到的递推式:<br><img src="/../../imgs/Pasted%20image%2020240406201929.png"></p>
<p>遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，<strong>即preSum[0]为nums[0]（前提是nums有元素）</strong>。</p>
<p>预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。</p>
<p>需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。</p>
<p>后面会给出简化的写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    preSum []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="type">int</span>)</span></span> NumArray &#123;</span><br><span class="line">    preSum := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    preSum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        preSum[ i] = preSum[ i<span class="number">-1</span>] + nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NumArray&#123;preSum&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span></span> SumRange(left <span class="type">int</span>, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> left == <span class="number">0</span> &#123; <span class="comment">// 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(this.preSum) == <span class="number">0</span> &#123; <span class="comment">// 但如果nums根本没有长度，直接返回0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> this.preSum[right]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> this.preSum[right] - this.preSum[left<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.SumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用多一位长度的前缀和<br>之所以上面处理东西多，是因为<code>preSum[i]</code>的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index</p>
<p>要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]<br>即：</p>
<p><img src="/../../imgs/Pasted%20image%2020240406202142.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    preSum []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="type">int</span>)</span></span> NumArray &#123;</span><br><span class="line">    preSum := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        preSum[index + <span class="number">1</span>] = preSum[index] + value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NumArray&#123;preSum&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span></span> SumRange(left <span class="type">int</span>, right <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.preSum[right + <span class="number">1</span>] - this.preSum[left]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.SumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406204841.png"><br><strong>暴力解法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 排序后的nums</span></span><br><span class="line">	index      <span class="type">int</span></span><br><span class="line">	sortedNums []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> KthLargest &#123;</span><br><span class="line">	<span class="keyword">return</span> KthLargest&#123;k, nums&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *KthLargest)</span></span> Add(val <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	this.sortedNums = <span class="built_in">append</span>(this.sortedNums, val)</span><br><span class="line">	sort.Ints(this.sortedNums)</span><br><span class="line">	revert(this.sortedNums)</span><br><span class="line">	<span class="keyword">return</span> this.sortedNums[this.index<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revert</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(k, nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>优先队列</strong><br>我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。</p>
<p>在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    sort.IntSlice</span><br><span class="line">    k <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> KthLargest &#123;</span><br><span class="line">    kl := KthLargest&#123;k: k&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        kl.Add(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span></span> Push(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    kl.IntSlice = <span class="built_in">append</span>(kl.IntSlice, v.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    a := kl.IntSlice</span><br><span class="line">    v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    kl.IntSlice = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span></span> Add(val <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    heap.Push(kl, val)</span><br><span class="line">    <span class="keyword">if</span> kl.Len() &gt; kl.k &#123;</span><br><span class="line">        heap.Pop(kl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kl.IntSlice[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146 LRU缓存"></a>146 LRU缓存</h1><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p>
<p><img src="/../../imgs/Pasted%20image%2020240512220224.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">	keysList []<span class="type">int</span> <span class="comment">// 实现最新时间 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间</span></span><br><span class="line">	keysMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// 存放key value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	<span class="comment">//return</span></span><br><span class="line">	<span class="keyword">return</span> LRUCache&#123;capacity, <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果key存在于缓存中，则返回关键字的值，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ele, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		<span class="keyword">return</span> ele</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 关键字存在 则更新值为value</span></span><br><span class="line">	<span class="comment">// 不存在，则插入value</span></span><br><span class="line">	<span class="comment">// 如果插入超过数量capacity 则删除最久没有使用的关键字【list]</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		this.keysMap[key] = value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		this.updateListKey(key)</span><br><span class="line">		this.keysMap[key] = value</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(this.keysList) &gt; this.capacity &#123;</span><br><span class="line">			<span class="built_in">delete</span>(this.keysMap, this.keysList[<span class="number">0</span>]) <span class="comment">// 这里删除key 从list队列中获取</span></span><br><span class="line">			this.keysList = this.keysList[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> updateListKey(key <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.keysList); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> key == this.keysList[i] &#123;</span><br><span class="line">			this.keysList = <span class="built_in">append</span>(this.keysList[:i], this.keysList[i+<span class="number">1</span>:]...) <span class="comment">// 删除该key, 然后放在末尾</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	this.keysList = <span class="built_in">append</span>(this.keysList, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355 设计推特"></a>355 设计推特</h1><p><a href="https://leetcode.cn/problems/design-twitter/">355. 设计推特</a><br><img src="/../../imgs/Pasted%20image%2020240512221227.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Twitter <span class="keyword">struct</span> &#123;</span><br><span class="line">	userMap <span class="keyword">map</span>[<span class="type">int</span>]*User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	userId    <span class="type">int</span></span><br><span class="line">	followees <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span></span><br><span class="line">	tweets    []*Tweet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tweet <span class="keyword">struct</span> &#123;</span><br><span class="line">	tweetId <span class="type">int</span></span><br><span class="line">	time    <span class="type">int</span></span><br><span class="line">	userId  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推特数目，用于时间排序</span></span><br><span class="line"><span class="keyword">var</span> tweetCount <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Twitter &#123;</span><br><span class="line">	<span class="keyword">return</span> Twitter&#123;userMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*User)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> PostTweet(userId <span class="type">int</span>, tweetId <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 新建tweet  将自己设置为关注</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;</span><br><span class="line">		t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="built_in">make</span>([]*Tweet, <span class="number">0</span>), followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">		tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;</span><br><span class="line">		t.userMap[userId].tweets = <span class="built_in">append</span>(t.userMap[userId].tweets, tweet)</span><br><span class="line">		t.userMap[userId].followees[userId] = <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;</span><br><span class="line">		t.userMap[userId].tweets = <span class="built_in">append</span>(t.userMap[userId].tweets, tweet)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将tweetId 和时间做一个新增</span></span><br><span class="line">	tweetCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> Follow(followerId <span class="type">int</span>, followeeId <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果关注人不存在则新建</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;</span><br><span class="line">        t.userMap[followerId] = &amp;User&#123;</span><br><span class="line">            userId:        followerId,</span><br><span class="line">            followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次新建user的时候 将自己加入自己关注</span></span><br><span class="line">        t.userMap[followerId].followees[followerId] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被关注人不存在则新建</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;</span><br><span class="line">        t.userMap[followeeId] = &amp;User&#123;</span><br><span class="line">            userId:        followeeId,</span><br><span class="line">            followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次新建user的时候 将自己加入自己关注</span></span><br><span class="line">        t.userMap[followeeId].followees[followeeId] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.userMap[followerId].followees[followeeId] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> Unfollow(followerId <span class="type">int</span>, followeeId <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;</span><br><span class="line">		<span class="built_in">delete</span>(t.userMap[followerId].followees, followeeId)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">	resTop10 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	tweeters := []*Tweet&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := t.userMap[userId]; ok &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> followeeId, _ := <span class="keyword">range</span> t.userMap[userId].followees &#123;</span><br><span class="line">			tweeters = <span class="built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(tweeters, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">		resTop10 = <span class="built_in">append</span>(resTop10, tweeters[i].tweetId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resTop10</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果关注人不存在则新建</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;</span><br><span class="line">        t.userMap[followerId] = &amp;User&#123;</span><br><span class="line">            userId:        followerId,</span><br><span class="line">            followees: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次新建user的时候 将自己加入自己关注</span></span><br><span class="line">        t.userMap[followerId].followees[followerId] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>上边代码为什么需要使用 <code>&amp;User</code> 而不是直接使用 map 中的值：</strong></p>
<ul>
<li><p>当 key 不存在时，map 返回的是零值（对于 <code>*User</code> 就是 <code>nil</code>）</p>
</li>
<li><p>你不能对 <code>nil</code> 指针进行赋值操作</p>
</li>
<li><p>因此必须先创建一个新的 <code>User</code> 实例（使用 <code>&amp;User&#123;&#125;</code>），然后存入 map</p>
</li>
</ul>
<p>这种模式在 Go 中很常见，特别是在需要”如果不存在则初始化”的场景中。</p>
<h1 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221416.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TrieNode 代表Trie中的每个节点</span></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*TrieNode</span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 代表整个前缀树</span></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 初始化一个Trie对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 将word插入到trie中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.children[index] = &amp;TrieNode&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span> <span class="comment">// 标记单词结束的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search 在trie中搜索word</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果路径中的节点不存在，说明word不在trie中</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isEnd <span class="comment">// 检查最后一个节点是否标记为单词结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StartsWith 返回trie中是否有任何单词以prefix为前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果路径中的节点不存在，说明没有以prefix为前缀的word</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 所有的char都在路径中，说明trie有以prefix为前缀的word</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221549.png"></p>
<p>一次AC</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WordDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">	wordMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> WordDictionary &#123;</span><br><span class="line">	<span class="keyword">return</span> WordDictionary&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span></span> AddWord(word <span class="type">string</span>) &#123;</span><br><span class="line">	this.wordMap[word] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := this.wordMap[word]; ok &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(word, <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> key, _ := <span class="keyword">range</span> this.wordMap &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="built_in">len</span>(word) &#123;</span><br><span class="line">				flag := <span class="literal">true</span></span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(word); i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> key[i] == word[i] || word[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">						</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						flag = <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> flag == <span class="literal">true</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AddWord(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="284-窥视迭代器"><a href="#284-窥视迭代器" class="headerlink" title="284. 窥视迭代器"></a><a href="https://leetcode.cn/problems/peeking-iterator/">284. 窥视迭代器</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221905.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   Below is the interface for Iterator, which is already defined for you.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   type Iterator struct &#123;</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   func (this *Iterator) hasNext() bool &#123;</span></span><br><span class="line"><span class="comment"> *		// Returns true if the iteration has more elements.</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   func (this *Iterator) next() int &#123;</span></span><br><span class="line"><span class="comment"> *		// Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PeekingIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    iter     *Iterator</span><br><span class="line">    _hasNext <span class="type">bool</span></span><br><span class="line">    _next    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(iter *Iterator)</span></span> *PeekingIterator &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;PeekingIterator&#123;iter, iter.hasNext(), iter.next()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *PeekingIterator)</span></span> hasNext() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> it._hasNext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *PeekingIterator)</span></span> next() <span class="type">int</span> &#123;</span><br><span class="line">    ret := it._next</span><br><span class="line">    it._hasNext = it.iter.hasNext()</span><br><span class="line">    <span class="keyword">if</span> it._hasNext &#123;</span><br><span class="line">        it._next = it.iter.next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *PeekingIterator)</span></span> peek() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> it._next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="535-TinyURL-的加密与解密"><a href="#535-TinyURL-的加密与解密" class="headerlink" title="535. TinyURL 的加密与解密"></a><a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222106.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过自增id 的方式来实现encode</span></span><br><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">	dataId <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	nums   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Codec &#123;</span><br><span class="line">	<span class="keyword">return</span> Codec&#123;<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span></span> encode(longUrl <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	this.nums++</span><br><span class="line">	this.dataId[this.nums] = longUrl</span><br><span class="line">	res := <span class="string">&quot;http://tinyurl.com/&quot;</span> + strconv.Itoa(this.nums)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span></span> decode(shortUrl <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	index := strings.Split(shortUrl, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">	tmp := index[<span class="built_in">len</span>(index)<span class="number">-1</span>]</span><br><span class="line">	idx, _ := strconv.Atoi(tmp)</span><br><span class="line">	long := this.dataId[idx]</span><br><span class="line">	<span class="keyword">return</span> long</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * url := obj.encode(longUrl);</span></span><br><span class="line"><span class="comment"> * ans := obj.decode(url);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222241.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 如何确定结构体里应设置什么变量？</span></span><br><span class="line">	<span class="comment">// 总的List 包含 有多少个节点，以及头节点是什么</span></span><br><span class="line">	Size      <span class="type">int</span></span><br><span class="line">	dummyHead *ListNode </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line">	<span class="comment">// Constructor 该如何写？如何才能符合题目要求？</span></span><br><span class="line">	<span class="keyword">return</span> MyLinkedList&#123;<span class="number">0</span>, &amp;ListNode&#123;<span class="number">0</span>,<span class="literal">nil</span>&#125;&#125; <span class="comment">// 这个虚拟头节点不应该删掉吗？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.Size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dummyHead := &amp;ListNode&#123;0, this.head&#125;</span></span><br><span class="line">	cur := this.dummyHead.Next</span><br><span class="line">	<span class="keyword">for</span> index != <span class="number">0</span> &amp;&amp; cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		index--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="type">int</span>) &#123;</span><br><span class="line">	this.AddAtIndex(<span class="number">0</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="type">int</span>) &#123;</span><br><span class="line">	this.AddAtIndex(this.Size, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="type">int</span>, val <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= this.Size &#123;</span><br><span class="line">		cur := this.dummyHead <span class="comment">//cur 等于虚拟头节点，插入节点的前驱</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">			cur = cur.Next</span><br><span class="line">		&#125;</span><br><span class="line">		newNode := &amp;ListNode&#123;val, cur.Next&#125;</span><br><span class="line">		cur.Next = newNode</span><br><span class="line">		this.Size++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">		this.AddAtIndex(<span class="number">0</span>, val)</span><br><span class="line">		this.Size++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index &gt; this.Size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 这个return 到哪里了？ 代表结束这个程序吗？</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; this.Size &#123;</span><br><span class="line">		cur := this.dummyHead <span class="comment">//cur 等于虚拟头节点，插入节点的前驱</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">			cur = cur.Next</span><br><span class="line">		&#125;</span><br><span class="line">		cur.Next = cur.Next.Next</span><br><span class="line">		this.Size--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(index);</span></span><br><span class="line"><span class="comment"> * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/Pasted%20image%2020240512222402.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> StockSpanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack [][<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">    idx   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> StockSpanner &#123;</span><br><span class="line">    <span class="keyword">return</span> StockSpanner&#123;[][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, math.MaxInt32&#125;&#125;, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockSpanner)</span></span> Next(price <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    s.idx++</span><br><span class="line">    <span class="keyword">for</span> price &gt;= s.stack[<span class="built_in">len</span>(s.stack)<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">        s.stack = s.stack[:<span class="built_in">len</span>(s.stack)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    s.stack = <span class="built_in">append</span>(s.stack, [<span class="number">2</span>]<span class="type">int</span>&#123;s.idx, price&#125;)</span><br><span class="line">    <span class="keyword">return</span> s.idx - s.stack[<span class="built_in">len</span>(s.stack)<span class="number">-2</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222459.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> StockSpanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack [][<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">    idx   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> StockSpanner &#123;</span><br><span class="line">    <span class="keyword">return</span> StockSpanner&#123;[][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, math.MaxInt32&#125;&#125;, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockSpanner)</span></span> Next(price <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    s.idx++</span><br><span class="line">    <span class="keyword">for</span> price &gt;= s.stack[<span class="built_in">len</span>(s.stack)<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">        s.stack = s.stack[:<span class="built_in">len</span>(s.stack)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    s.stack = <span class="built_in">append</span>(s.stack, [<span class="number">2</span>]<span class="type">int</span>&#123;s.idx, price&#125;)</span><br><span class="line">    <span class="keyword">return</span> s.idx - s.stack[<span class="built_in">len</span>(s.stack)<span class="number">-2</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/design-underground-system/">1396. 设计地铁系统</a><br><img src="/../../imgs/Pasted%20image%2020240512222605.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">	startTime <span class="type">int</span></span><br><span class="line">	endTime <span class="type">int</span></span><br><span class="line">	startStationName <span class="type">string</span></span><br><span class="line">	endStatationName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UndergroundSystem <span class="keyword">struct</span> &#123;</span><br><span class="line">	userMap <span class="keyword">map</span>[<span class="type">int</span>]*user</span><br><span class="line">	pathMap <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span> <span class="comment">// 存放对应路程的用时，用于计算平均时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> UndergroundSystem &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">return</span> UndergroundSystem&#123;<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*user),<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> CheckIn(id <span class="type">int</span>, stationName <span class="type">string</span>, t <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//userMap 添加</span></span><br><span class="line">	this.userMap[id] = &amp;user&#123;id:id&#125; <span class="comment">// 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址</span></span><br><span class="line">	this.userMap[id].startTime = t</span><br><span class="line">	this.userMap[id].startStationName = stationName</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> CheckOut(id <span class="type">int</span>, stationName <span class="type">string</span>, t <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//出站时，更新user.end* ;append pathmap</span></span><br><span class="line">	useTime := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> _,ok := this.userMap[id] ;ok &#123;</span><br><span class="line">		this.userMap[id].endTime = t</span><br><span class="line">		this.userMap[id].endStatationName = stationName</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mapKey := this.userMap[id].startStationName +<span class="string">&quot;-&gt;&quot;</span> + this.userMap[id].endStatationName</span><br><span class="line">	useTime = this.userMap[id].endTime - this.userMap[id].startTime</span><br><span class="line">	this.pathMap[mapKey] = <span class="built_in">append</span>(this.pathMap[mapKey],useTime)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UndergroundSystem)</span></span> GetAverageTime(startStation <span class="type">string</span>, endStation <span class="type">string</span>) <span class="type">float64</span> &#123;</span><br><span class="line">	mapKey := startStation +<span class="string">&quot;-&gt;&quot;</span> + endStation</span><br><span class="line">	<span class="keyword">return</span> average(this.pathMap[mapKey])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">average</span><span class="params">(s []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum +=v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(sum)/<span class="type">float64</span>(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.CheckIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj.CheckOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="1476-子矩形查询"><a href="#1476-子矩形查询" class="headerlink" title="1476. 子矩形查询"></a><a href="https://leetcode.cn/problems/subrectangle-queries/">1476. 子矩形查询</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222653.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SubrectangleQueries <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 需要什么数据结构呢？ 1. 一个二维数组</span></span><br><span class="line">	rectangle [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(rectangle [][]<span class="type">int</span>)</span></span> SubrectangleQueries &#123;</span><br><span class="line">	<span class="keyword">return</span> SubrectangleQueries&#123;rectangle: rectangle&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubrectangleQueries)</span></span> UpdateSubrectangle(row1 <span class="type">int</span>, col1 <span class="type">int</span>, row2 <span class="type">int</span>, col2 <span class="type">int</span>, newValue <span class="type">int</span>)  &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=row1;i &lt;= row2;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:= col1; j &lt;= col2; j++ &#123;</span><br><span class="line">			this.rectangle[i][j] = newValue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubrectangleQueries)</span></span> GetValue(row <span class="type">int</span>, col <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.rectangle[row][col]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(rectangle);</span></span><br><span class="line"><span class="comment"> * obj.UpdateSubrectangle(row1,col1,row2,col2,newValue);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.GetValue(row,col);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/seat-reservation-manager/">1845. 座位预约管理系统</a><br><img src="/../../imgs/Pasted%20image%2020240512222738.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SeatManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	seats []<span class="type">int</span></span><br><span class="line">	min <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> SeatManager &#123;</span><br><span class="line">	set:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> SeatManager&#123;seats:set,min:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Reserve() <span class="type">int</span> &#123;</span><br><span class="line">	value := this.min</span><br><span class="line">	this.seats[value]=<span class="number">1</span></span><br><span class="line">	length := <span class="built_in">len</span> (this.seats)</span><br><span class="line">	fmt.Println(length)</span><br><span class="line">	i:=value</span><br><span class="line">	<span class="keyword">for</span> ;i&lt;length+<span class="number">1</span>;i++&#123;</span><br><span class="line">		<span class="keyword">if</span> this.seats[i]==<span class="number">1</span>&#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		this.min=i <span class="comment">// 中间变量，更新下次的最小座位号</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value <span class="comment">// 最小的座位号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="type">int</span>)  &#123;</span><br><span class="line">	this.seats[seatNumber] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> seatNumber &lt; this.min&#123;</span><br><span class="line">		this.min=seatNumber</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="1993-树上的操作"><a href="#1993-树上的操作" class="headerlink" title="1993. 树上的操作"></a><a href="https://leetcode.cn/problems/operations-on-tree/">1993. 树上的操作</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222930.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LockingTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    parent []<span class="type">int</span></span><br><span class="line">    lockNodeUser []<span class="type">int</span></span><br><span class="line">    children [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(parent []<span class="type">int</span>)</span></span> LockingTree &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(parent)</span><br><span class="line">    lockNodeUser := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    children := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        lockNodeUser[i] = <span class="number">-1</span></span><br><span class="line">        p := parent[i]</span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">-1</span> &#123;</span><br><span class="line">            children[p] = <span class="built_in">append</span>(children[p], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LockingTree&#123;parent, lockNodeUser, children&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LockingTree)</span></span> Lock(num <span class="type">int</span>, user <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.lockNodeUser[num] == <span class="number">-1</span> &#123;</span><br><span class="line">        this.lockNodeUser[num] = user</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LockingTree)</span></span> Unlock(num <span class="type">int</span>, user <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.lockNodeUser[num] == user &#123;</span><br><span class="line">        this.lockNodeUser[num] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LockingTree)</span></span> Upgrade(num <span class="type">int</span>, user <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    res := this.lockNodeUser[num] == <span class="number">-1</span> &amp;&amp; !this.hasLockedAncestor(num) &amp;&amp; this.checkAndUnlockDescendant(num)</span><br><span class="line">    <span class="keyword">if</span> res &#123;</span><br><span class="line">        this.lockNodeUser[num] = user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LockingTree)</span></span> hasLockedAncestor(num <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    num = this.parent[num]</span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.lockNodeUser[num] != <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        num = this.parent[num]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LockingTree)</span></span> checkAndUnlockDescendant(num <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    res := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> this.lockNodeUser[num] != <span class="number">-1</span> &#123;</span><br><span class="line">        res = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.lockNodeUser[num] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> this.children[num] &#123;</span><br><span class="line">        <span class="keyword">if</span> this.checkAndUnlockDescendant(child) &#123;</span><br><span class="line">            res = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2241-设计一个-ATM-机器"><a href="#2241-设计一个-ATM-机器" class="headerlink" title="2241. 设计一个 ATM 机器"></a><a href="https://leetcode.cn/problems/design-an-atm-machine/">2241. 设计一个 ATM 机器</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223036.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ATM <span class="keyword">struct</span> &#123;</span><br><span class="line">	orderList []<span class="type">int</span></span><br><span class="line">	amountMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// map 是多余的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> ATM &#123;</span><br><span class="line">	<span class="keyword">return</span> ATM&#123;</span><br><span class="line">		<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>),</span><br><span class="line">		<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),<span class="comment">// 初始化 使用make 多练习多学习，保持手感。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> price [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ATM)</span></span> Deposit(banknotesCount []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i , count := <span class="keyword">range</span> banknotesCount&#123;</span><br><span class="line">		this.orderList[i] += count</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ATM)</span></span> Withdraw(amount <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//使用整除法</span></span><br><span class="line">	ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">4</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		ans[i] = min(amount/price[i],this.orderList[i])</span><br><span class="line">		amount -= ans[i]*price[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> amount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> idx,v := <span class="keyword">range</span> ans &#123;</span><br><span class="line">		this.orderList[idx] -= v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans <span class="comment">// 注意试着返回是需要钞票的数量，不是钞票的剩余数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2353-设计食物评分系统"><a href="#2353-设计食物评分系统" class="headerlink" title="2353. 设计食物评分系统"></a><a href="https://leetcode.cn/problems/design-a-food-rating-system/">2353. 设计食物评分系统</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223102.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FoodRatings <span class="keyword">struct</span> &#123;</span><br><span class="line">    Map <span class="keyword">map</span>[<span class="type">string</span>]*FoodHeap</span><br><span class="line">    NameMap <span class="keyword">map</span>[<span class="type">string</span>]*Food</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name, C <span class="type">string</span></span><br><span class="line">    Rating, Idx <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现堆</span></span><br><span class="line"><span class="keyword">type</span> FoodHeap []*Food</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h FoodHeap)</span></span> String() <span class="type">string</span>  &#123;</span><br><span class="line">    res := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> h &#123;</span><br><span class="line">        res = fmt.Sprintf(<span class="string">&quot;%s -&gt; (%v, %v)&quot;</span>, res, f.Name, f.Rating)    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h FoodHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h FoodHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; </span><br><span class="line">    h[i], h[i].Idx, h[j], h[j].Idx = h[j], h[j].Idx, h[i], h[i].Idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆 如果分数相同，Name 字典序小的更大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h FoodHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> h[j].Rating == h[i].Rating &#123;</span><br><span class="line">        <span class="keyword">return</span> h[i].Name &lt; h[j].Name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[j].Rating &lt; h[i].Rating</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *FoodHeap)</span></span> Push(f <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">    food := f.(*Food)</span><br><span class="line">    food.Idx = h.Len()</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *FoodHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125;   &#123; a := *h; v := a[<span class="built_in">len</span>(a) - <span class="number">1</span>]; *h = a[:<span class="built_in">len</span>(a) - <span class="number">1</span>]; <span class="keyword">return</span> v &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以烹饪方式对评分归类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(foods []<span class="type">string</span>, cuisines []<span class="type">string</span>, ratings []<span class="type">int</span>)</span></span> FoodRatings &#123;</span><br><span class="line">    f := FoodRatings&#123;</span><br><span class="line">        Map: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*FoodHeap),</span><br><span class="line">        NameMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Food, <span class="built_in">len</span>(foods)),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        food *Food</span><br><span class="line">        h *FoodHeap</span><br><span class="line">        has <span class="type">bool</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> foods &#123;</span><br><span class="line">        food = &amp;Food &#123;</span><br><span class="line">            foods[idx],</span><br><span class="line">            cuisines[idx],</span><br><span class="line">            ratings[idx],</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        f.NameMap[foods[idx]] = food</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> h, has = f.Map[cuisines[idx]]; !has &#123;</span><br><span class="line">            h = &amp;FoodHeap&#123;&#125;</span><br><span class="line">            f.Map[cuisines[idx]] = h</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        heap.Push(h, food)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FoodRatings)</span></span> ChangeRating(food <span class="type">string</span>, newRating <span class="type">int</span>)  &#123;</span><br><span class="line">    f := this.NameMap[food]</span><br><span class="line">    h := this.Map[f.C]</span><br><span class="line">    f.Rating = newRating</span><br><span class="line">    </span><br><span class="line">    heap.Fix(h, f.Idx)        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FoodRatings)</span></span> HighestRated(cuisine <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">    h := this.Map[cuisine]</span><br><span class="line">    <span class="keyword">if</span> h.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cuisine + <span class="string">&quot;No exist&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*h)[<span class="number">0</span>].Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="LCR-184-设计自助结算系统"><a href="#LCR-184-设计自助结算系统" class="headerlink" title="LCR 184. 设计自助结算系统"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">LCR 184. 设计自助结算系统</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223239.png"></p>
<blockquote>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    q1 []<span class="type">int</span></span><br><span class="line">    max []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MaxQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MaxQueue&#123;</span><br><span class="line">        <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Max_value() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.max) == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.max[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Push_back(value <span class="type">int</span>)  &#123;</span><br><span class="line">    this.q1 = <span class="built_in">append</span>(this.q1,value)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.max) != <span class="number">0</span> &amp;&amp; value &gt; this.max[<span class="built_in">len</span>(this.max)<span class="number">-1</span>]&#123;</span><br><span class="line">        this.max = this.max[:<span class="built_in">len</span>(this.max)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    this.max = <span class="built_in">append</span>(this.max,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Pop_front() <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.q1) != <span class="number">0</span>&#123;</span><br><span class="line">        n = this.q1[<span class="number">0</span>]</span><br><span class="line">        this.q1 = this.q1[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> this.max[<span class="number">0</span>] == n&#123;</span><br><span class="line">            this.max = this.max[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Max_value();</span></span><br><span class="line"><span class="comment"> * obj.Push_back(value);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">作者：Sakura</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solutions/135149/golang-shuang-dui-lie-by-sakura-151/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>链表总结</title>
    <url>/2023-06-24-42b41b131ba0.html</url>
    <content><![CDATA[<h1 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h1><ul>
<li>虚拟头节点</li>
<li>拉拉链 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    p := dummy</span><br><span class="line">    p1 := l1</span><br><span class="line">    p2 := l2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> &amp;&amp; p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span> p1.Val &gt; p2.Val &#123;</span><br><span class="line">            p.Next = p2</span><br><span class="line">            p2 = p2.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.Next = p1</span><br><span class="line">            p1 = p1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        p.Next = p1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        p.Next = p2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表的拆分"><a href="#链表的拆分" class="headerlink" title="链表的拆分"></a>链表的拆分</h1><ul>
<li>初始化两个链表，分别添加</li>
<li>合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next</li>
<li>合并</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(head *ListNode, x <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头结点</span></span><br><span class="line">    dummy1 := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头结点</span></span><br><span class="line">    dummy2 := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">// p1, p2 指针负责生成结果链表</span></span><br><span class="line">    p1, p2 := dummy1, dummy2</span><br><span class="line">    <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">    <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">    p := head</span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Val &gt;= x &#123;</span><br><span class="line">            p2.Next = p</span><br><span class="line">            p2 = p2.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1.Next = p</span><br><span class="line">            p1 = p1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        temp := p.Next</span><br><span class="line">        p.Next = <span class="literal">nil</span></span><br><span class="line">        p = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接两个链表</span></span><br><span class="line">    p1.Next = dummy2.Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy1.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="k-链表合并"><a href="#k-链表合并" class="headerlink" title="k 链表合并"></a>k 链表合并</h1><ul>
<li>最小堆 go语言的实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    p := dummy</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    pq := <span class="built_in">make</span>(PriorityQueue, <span class="number">0</span>)</span><br><span class="line">    heap.Init(&amp;pq)</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> _, head := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(&amp;pq, head)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        node := heap.Pop(&amp;pq).(*ListNode)</span><br><span class="line">        p.Next = node</span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(&amp;pq, node.Next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i].Val &lt; pq[j].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    node := x.(*ListNode)</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    node := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="倒数K链表"><a href="#倒数K链表" class="headerlink" title="倒数K链表"></a>倒数K链表</h1><ul>
<li>n 是包含nil 的</li>
<li>一个fast 去探路，先走k步</li>
<li>slow 和fast 一起走</li>
<li>当fast为nil 时，到达k ,赋值为next.next 即可<br><img src="/../../imgs/Pasted%20image%2020230625002218.png"></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">-1</span>, head&#125;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    x := findFromEnd(dummy, n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.Next = x.Next.Next</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    p1 := head</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        p1 = p1.Next</span><br><span class="line">    &#125;</span><br><span class="line">    p2 := head</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        p1 = p1.Next</span><br><span class="line">        p2 = p2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="倒数K链表移除"><a href="#倒数K链表移除" class="headerlink" title="倒数K链表移除"></a>倒数K链表移除</h1><p>复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    dummy := &amp;ListNode&#123;<span class="number">-1</span>, head&#125;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    x := findFromEnd(dummy, n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 代码见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移除中间链表"><a href="#移除中间链表" class="headerlink" title="移除中间链表"></a>移除中间链表</h1><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode）</a></p>
<ul>
<li>slow 走一步，fast走两步</li>
<li>fast nil，slow 为中间<br><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="comment">// for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步</span></span><br><span class="line">    <span class="keyword">for</span> fast!= <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>&#123; <span class="comment">// 应该修改为这个，slow 会停在中点右边第二个部分</span></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断链表是否成环"><a href="#判断链表是否成环" class="headerlink" title="判断链表是否成环"></a>判断链表是否成环</h1><ul>
<li>slow 走一步，fast走两步</li>
<li>fast 和slow 相遇则成环，fast 遇到nil 则不成环。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>labuladong</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>闭包介绍</title>
    <url>/2025-05-28-3ec80348e81b.html</url>
    <content><![CDATA[<h3 id="为什么闭包能共享变量-pre？"><a href="#为什么闭包能共享变量-pre？" class="headerlink" title="为什么闭包能共享变量 pre？"></a>为什么闭包能共享变量 <code>pre</code>？</h3><p>在提供的代码中，闭包能够共享变量 <code>pre</code> 的关键在于 <strong>词法作用域（Lexical Scoping）</strong> 和 <strong>闭包捕获变量</strong> 的特性：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    pre := math.MinInt64 <span class="comment">// 外层函数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问并修改外层的 pre 变量</span></span><br><span class="line">        <span class="keyword">if</span> node.Val &lt;= pre &#123; ... &#125;</span><br><span class="line">        pre = node.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ol>
<li><p><strong>词法作用域</strong>：</p>
<ul>
<li>Go 中函数可以访问定义时所在作用域的所有变量</li>
<li><code>dfs</code> 匿名函数定义在 <code>isValidBST</code> 函数体内，自然能访问 <code>pre</code></li>
</ul>
</li>
<li><p><strong>闭包捕获变量</strong>：</p>
<ul>
<li>闭包不会复制变量值，而是<strong>捕获变量的引用</strong></li>
<li>所有递归调用的 <code>dfs</code> 都指向<strong>同一个 <code>pre</code> 变量</strong></li>
<li>修改 <code>pre</code> 会影响所有闭包实例</li>
</ul>
</li>
<li><p><strong>递归共享状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[pre=MinInt64] --&gt; B[dfs-根节点]</span><br><span class="line">B --&gt; C[dfs-左子节点]</span><br><span class="line">C --&gt; D[dfs-左孙节点]</span><br><span class="line">D --&gt;|更新pre| C</span><br><span class="line">C --&gt;|更新pre| B</span><br><span class="line">B --&gt;|更新pre| E[dfs-右子节点]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="闭包名称的含义与起源"><a href="#闭包名称的含义与起源" class="headerlink" title="闭包名称的含义与起源"></a>闭包名称的含义与起源</h3><h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><p>“闭包”（Closure）一词来源于 <strong>函数”闭合”（close over）其定义环境</strong> 的概念：</p>
<ul>
<li>最早由 Peter J. Landin 在 1964 年提出</li>
<li>源自数学中的 <strong>λ演算（Lambda Calculus）</strong> 和 <strong>闭包属性（Closure Property）</strong></li>
<li>在编译原理中称为 <strong>词法闭包（Lexical Closure）</strong></li>
</ul>
<h4 id="名称含义"><a href="#名称含义" class="headerlink" title="名称含义"></a>名称含义</h4><table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>闭（Close）</strong></td>
<td>函数”封闭”地携带其定义时的环境</td>
</tr>
<tr>
<td><strong>包（-ure）</strong></td>
<td>将函数与其环境”打包”在一起</td>
</tr>
</tbody></table>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol>
<li><strong>环境捕获</strong>：函数记住并访问定义时的作用域</li>
<li><strong>状态持久化</strong>：捕获的变量生命周期与闭包相同</li>
<li><strong>私密状态</strong>：只有闭包能访问捕获的变量</li>
</ol>
<h3 id="闭包在-BST-验证中的优势"><a href="#闭包在-BST-验证中的优势" class="headerlink" title="闭包在 BST 验证中的优势"></a>闭包在 BST 验证中的优势</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pre := math.MinInt64  <span class="comment">// 共享状态</span></span><br><span class="line">dfs := <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 递归过程共享同一个 pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>状态管理简化</strong>：无需指针传递</li>
<li><strong>代码更简洁</strong>：减少参数传递</li>
<li><strong>逻辑更直观</strong>：直接读写共享状态</li>
<li><strong>避免值复制</strong>：高效处理递归状态</li>
</ol>
<h3 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h3><p>闭包本质上是一个 <strong>（函数 + 绑定环境）</strong> 的组合体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span>  <span class="comment">// 函数逻辑</span></span><br><span class="line">    Env <span class="keyword">struct</span> &#123;            <span class="comment">// 捕获的环境</span></span><br><span class="line">        pre <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次递归调用时，都使用同一个 <code>Env</code> 环境，这正是 BST 验证需要的中序遍历状态一致性保证。</p>
<h3 id="闭包-vs-指针参数"><a href="#闭包-vs-指针参数" class="headerlink" title="闭包 vs 指针参数"></a>闭包 vs 指针参数</h3><table>
<thead>
<tr>
<th>特性</th>
<th>闭包</th>
<th>指针参数</th>
</tr>
</thead>
<tbody><tr>
<td>状态共享</td>
<td>自动捕获</td>
<td>需显式传递</td>
</tr>
<tr>
<td>可读性</td>
<td>★★★☆☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>安全性</td>
<td>变量封装</td>
<td>暴露内存地址</td>
</tr>
<tr>
<td>递归适用性</td>
<td>非常适合</td>
<td>需要小心指针传递</td>
</tr>
</tbody></table>
<p>在 BST 验证场景中，闭包方案更简洁安全，避免了指针传递的复杂性，是 Go 语言处理递归状态的首选模式。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>更新网页url后，恢复valine网页评论</title>
    <url>/2025-04-13-8c397fc87827.html</url>
    <content><![CDATA[<p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。<br>具体步骤：登录&gt;选择你创建的应用&gt;数据存储&gt;结构化数据&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p>
<p>修改 对应url 列为当前url<br><img src="/../../imgs/Pasted%20image%2020250413122851.png"><img src="/../../imgs/Pasted%20image%2020250413123508.png"></p>
<p>参考：<br><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>申请域名绑定github pages</title>
    <url>/2024-09-01-ed1bf9078b39.html</url>
    <content><![CDATA[<p>你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！</p>
<h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><ol>
<li>在<a href="https://www.namesilo.com/">Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo</a>完成了域名的购买</li>
<li>完成了GitHub Pages的设置，有了可用的<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>库之后，可以访问 Github Pages</li>
</ol>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-进入我的账户"><a href="#0-进入我的账户" class="headerlink" title="0. 进入我的账户"></a>0. 进入我的账户</h3><p><img src="/../../imgs/Pasted%20image%2020240901102308.png"></p>
<h3 id="1-无论是什么域名服务商，找到DNS-Management页面"><a href="#1-无论是什么域名服务商，找到DNS-Management页面" class="headerlink" title="1. 无论是什么域名服务商，找到DNS Management页面"></a><strong>1. 无论是什么域名服务商，找到DNS Management页面</strong></h3><p>如果是namesilo购买的域名，可以通过以下步骤：<br><img src="/../../imgs/Pasted%20image%2020240901102340.png"><br>点击“domain manager”<br><img src="/../../imgs/Pasted%20image%2020240901102510.png"><br>点击这个蓝色的小球（Manage DNS for this domain）</p>
<h3 id="2-写入-type-A-的DNS记录"><a href="#2-写入-type-A-的DNS记录" class="headerlink" title="2. 写入 type A 的DNS记录"></a><strong>2. 写入 type A 的DNS记录</strong></h3><ul>
<li><strong>如果厂商提供了写入模板</strong>，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 <strong>DNS Templates</strong>。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b84d88c38c06b6081f02cafbd0dac24b_720w.webp"></p>
<p>找到GitHub的template，点击“<strong>Apply Template</strong>”，然后在弹出的窗口里直接点击“<strong>Accept</strong>”，你就会发现4条A记录已经自动写入了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c731fadefaf3d3a2268e6566d6196558_720w.webp"></p>
<ul>
<li><strong>如果厂商不能自动添加</strong>，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图</li>
</ul>
<p>[Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain!</p>
<p><img src="https://pica.zhimg.com/80/v2-1a618fec2900e4f23039c153d8ab03da_720w.webp"></p>
<p>上面圈起来的四个地址就是需要等会儿手动输入的。</p>
<p>不同厂商之间的手动添加方法不一样，但只要记住 <strong>type 后填“A”</strong>，<strong>address&#x2F;points to或其他同义表达后填这四个地址中的一个</strong>，<strong>其他默认</strong>就好了，一共需要添加<strong>四条</strong>，可以复制粘贴。</p>
<p>添加之后会多出四个<img src="/../../imgs/Pasted%20image%2020240901102815.png">### 3. 创建CNAME文件</p>
<p>这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，</p>
<blockquote>
<p>上面的方法 save 之后看到报错不要慌，<a href="https://zhida.zhihu.com/search?q=%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E&zhida_source=entity&is_preview=1">让子弹飞</a>一会儿就好了</p>
</blockquote>
<p><img src="/../../imgs/Pasted%20image%2020240901102714.png"><br><img src="/../../imgs/Pasted%20image%2020240901102745.png"></p>
<p>最终有这些配置即可：<br><img src="/../../imgs/Pasted%20image%2020240901102848.png"></p>
<h3 id="github-填写域名地址"><a href="#github-填写域名地址" class="headerlink" title="github 填写域名地址"></a>github 填写域名地址</h3><p>在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。<br><img src="/../../imgs/Pasted%20image%2020240901103216.png"><br><img src="/../../imgs/Pasted%20image%2020240901103241.png"></p>
<h3 id="即刻访问你自己的域名网站吧！"><a href="#即刻访问你自己的域名网站吧！" class="headerlink" title="即刻访问你自己的域名网站吧！"></a>即刻访问你自己的域名网站吧！</h3><p><img src="/../../imgs/Pasted%20image%2020240901103553.png"></p>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/448781791">将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JetBrians 全家桶设置文件header</title>
    <url>/2023-10-05-7527c8e47a8b.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。</p>
<p>先看下效果图<br><img src="/../../imgs/Pasted%20image%2020231005164404.png"></p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-file-settings"><a href="#1-file-settings" class="headerlink" title="1. file- settings"></a>1. file- settings</h2><p><img src="/../../imgs/Pasted%20image%2020231005164508.png"></p>
<h1 id="找到Copyright-CopyrightProfiles"><a href="#找到Copyright-CopyrightProfiles" class="headerlink" title="找到Copyright - CopyrightProfiles"></a>找到Copyright - CopyrightProfiles</h1><p>点击+ 号，新建一个name 为“copyRight” 的profile</p>
<p><img src="/../../imgs/Pasted%20image%2020231005164618.png"></p>
<p>profile 的内容粘贴下面的问文本, 替换自己的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copyright (c) $originalComment.match(&quot;Copyright \(c\) (\d+)&quot;, 1, &quot;-&quot;, &quot;$today.year&quot;)$today.year YOUR NAME. All rights reserved.  </span><br><span class="line">Author: YOUR NAME  </span><br><span class="line">Description:  </span><br><span class="line">Date: $today</span><br></pre></td></tr></table></figure>
<h1 id="点击Copyright-添加刚才的profile"><a href="#点击Copyright-添加刚才的profile" class="headerlink" title="点击Copyright 添加刚才的profile"></a>点击Copyright 添加刚才的profile</h1><p><img src="/../../imgs/Pasted%20image%2020231005165129.png"></p>
<h2 id="点击应用即可-右键-generate-Copyright-插入"><a href="#点击应用即可-右键-generate-Copyright-插入" class="headerlink" title="点击应用即可 右键-generate-Copyright 插入"></a>点击应用即可 右键-generate-Copyright 插入</h2><p><img src="/../../imgs/Pasted%20image%2020231005164944.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020231005165025.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Linux非root用户通过X11运行图形界面程序-以Rstudio为例</title>
    <url>/2023-09-24-4fe5badbd053.html</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。<br>但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。<br>那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！</p>
<blockquote>
<p><strong>X11</strong>是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。</p>
</blockquote>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ol>
<li>使用mobaxTerm 登录对应服务器，需要显示X11 打开<img src="/../../imgs/Pasted%20image%2020230924203748.png"></li>
<li>创建虚拟环境<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line"> conda create -n rstudio</span><br><span class="line"><span class="comment"># 安装Ｒ</span></span><br><span class="line">conda activate rstudio <span class="comment"># 进入创建好的环境变量</span></span><br><span class="line">conda install r-base</span><br><span class="line"><span class="comment"># 安装Rstudio</span></span><br><span class="line">conda install rstudio-desktop</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p> 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面<br> <img src="/../../imgs/Pasted%20image%2020230924205521.png"><br><strong>画个图试试，顺利出图！开始愉快的coding吧！</strong><br><img src="/../../imgs/Pasted%20image%2020230924205559.png"></p>
<p><strong>已知问题：</strong> 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以通过<strong>X11</strong>来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Obsidian配置代理</title>
    <url>/2025-06-15-980a140fe20b.html</url>
    <content><![CDATA[<p>在 Obsidian 中设置代理（Proxy）需要通过 <strong>系统环境变量</strong> 或 <strong>插件</strong> 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法：</p>
<hr>
<h2 id="方法-1：通过环境变量设置全局代理（推荐）"><a href="#方法-1：通过环境变量设置全局代理（推荐）" class="headerlink" title="方法 1：通过环境变量设置全局代理（推荐）"></a><strong>方法 1：通过环境变量设置全局代理（推荐）</strong></h2><p>Obsidian 是基于 Electron 的应用程序，它会遵循系统的 HTTP&#x2F;HTTPS 代理设置。你可以通过以下方式设置：</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h3><ol>
<li><p><strong>临时设置（仅当前终端窗口有效）</strong><br>在 CMD&#x2F;PowerShell 中运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure>
<p>然后启动 Obsidian：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start <span class="string">&quot;&quot;</span> <span class="string">&quot;C:\path\to\Obsidian.exe&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>永久设置（系统环境变量）我使用的这个</strong>  </p>
<ul>
<li>按 <code>Win + R</code>，输入 <code>sysdm.cpl</code> 打开 <strong>系统属性</strong>。</li>
<li>进入 <strong>高级 → 环境变量</strong>。</li>
<li>在 <strong>用户变量</strong> 或 <strong>系统变量</strong> 中添加：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP_PROXY=http://127.0.0.1:7897</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7897</span><br><span class="line">ALL_PROXY=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure></li>
<li>重启 Obsidian。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="macOS-Linux"><a href="#macOS-Linux" class="headerlink" title="macOS&#x2F;Linux"></a><strong>macOS&#x2F;Linux</strong></h3><ol>
<li><p><strong>临时设置（终端启动）</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure>
<p>然后启动 Obsidian：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open -a Obsidian  <span class="comment"># macOS</span></span><br><span class="line">obsidian &amp;       <span class="comment"># Linux（如果安装正确）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>永久设置（<code>.bashrc</code>&#x2F;<code>.zshrc</code>）</strong><br>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 或 source ~/.zshrc</span></span><br></pre></td></tr></table></figure>
<p>重启 Obsidian。</p>
</li>
</ol>
<hr>
<h2 id="方法-2：使用-Proxy-插件（如果-Obsidian-支持）"><a href="#方法-2：使用-Proxy-插件（如果-Obsidian-支持）" class="headerlink" title="方法 2：使用 Proxy 插件（如果 Obsidian 支持）"></a><strong>方法 2：使用 Proxy 插件（如果 Obsidian 支持）</strong></h2><p>Obsidian 本身没有官方代理插件，但你可以尝试：</p>
<ol>
<li><p><strong>安装 <code>obsidian-proxy</code> 插件（如果存在）</strong>  </p>
<ul>
<li>进入 <code>设置 → 社区插件 → 浏览</code>，搜索 <code>proxy</code>。</li>
<li>安装并配置代理地址。</li>
</ul>
</li>
<li><p><strong>使用第三方工具（如 Proxifier&#x2F;Clash）</strong>  </p>
<ul>
<li>在 Proxifier 中设置 Obsidian 走代理：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规则：Obsidian.exe → SOCKS5 127.0.0.1:7897</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h2 id="方法-3：修改-Electron-启动参数（高级）"><a href="#方法-3：修改-Electron-启动参数（高级）" class="headerlink" title="方法 3：修改 Electron 启动参数（高级）"></a><strong>方法 3：修改 Electron 启动参数（高级）</strong></h2><p>如果 Obsidian 是基于 Electron 的，可以尝试修改启动参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obsidian --proxy-server=<span class="string">&quot;http://127.0.0.1:7897&quot;</span></span><br></pre></td></tr></table></figure>
<p>（需找到 Obsidian 的实际启动方式）</p>
<hr>
<h2 id="验证代理是否生效"><a href="#验证代理是否生效" class="headerlink" title="验证代理是否生效"></a><strong>验证代理是否生效</strong></h2><ol>
<li>在 Obsidian 中安装插件或同步数据，看是否正常访问。</li>
<li>使用 <code>curl -v https://api.obsidian.md</code> 测试代理是否生效。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>持久性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>环境变量</strong></td>
<td>推荐，全局生效</td>
<td>✅ 永久</td>
</tr>
<tr>
<td><strong>终端临时设置</strong></td>
<td>测试用</td>
<td>❌ 临时</td>
</tr>
<tr>
<td><strong>Proxy 插件</strong></td>
<td>如果 Obsidian 支持</td>
<td>⚠️ 依赖插件</td>
</tr>
<tr>
<td><strong>Proxifier&#x2F;Clash</strong></td>
<td>强制代理所有流量</td>
<td>✅ 系统级</td>
</tr>
</tbody></table>
<p>如果你的代理是 <code>http://127.0.0.1:7897</code> 或 <code>socks5://127.0.0.1:7897</code>（如 Clash&#x2F;V2Ray），建议优先使用 <strong>环境变量</strong> 方法。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>WPS设置打开文件自动同步云文档</title>
    <url>/2023-12-30-3a73bdfdd568.html</url>
    <content><![CDATA[<p>不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。<br>WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：</p>
<h1 id="打开首页，设置中心"><a href="#打开首页，设置中心" class="headerlink" title="打开首页，设置中心"></a>打开首页，设置中心</h1><p><img src="/../../imgs/Pasted%20image%2020231230221037.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020231230220856.png"></p>
<h1 id="打开新文件会自动上传更新"><a href="#打开新文件会自动上传更新" class="headerlink" title="打开新文件会自动上传更新"></a>打开新文件会自动上传更新</h1><p><img src="/../../imgs/Pasted%20image%2020231230221311.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Windows设置Clion 下方Terminal为WSL linux 子系统</title>
    <url>/2023-12-30-397a0b919639.html</url>
    <content><![CDATA[<h1 id="终端上的小箭头下的设置"><a href="#终端上的小箭头下的设置" class="headerlink" title="终端上的小箭头下的设置"></a>终端上的小箭头下的设置</h1><p><img src="/../../imgs/Pasted%20image%2020231230235906.png"><br><img src="/../../imgs/Pasted%20image%2020231230234942.png"></p>
<h1 id="找到WSL的地址"><a href="#找到WSL的地址" class="headerlink" title="找到WSL的地址"></a>找到WSL的地址</h1><p><img src="/../../imgs/Pasted%20image%2020231231000039.png"></p>
<p>粘贴到对应地址中<br><img src="/../../imgs/Pasted%20image%2020231231000121.png"></p>
<h1 id="设置成功"><a href="#设置成功" class="headerlink" title="设置成功"></a>设置成功</h1><p>这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>clash在终端设置代理</title>
    <url>/2023-09-12-b926f621cf15.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！</p>
<h1 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h1><p>前置条件：手动开打 clash 等VPN软件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>对应的网址是在settings- static-Host; 对应port 为General-Prot<br><img src="/../../imgs/Pasted%20image%2020230913000142.png"><br><img src="/../../imgs/Pasted%20image%2020230913000136.png"></p>
<h2 id="clash-Verge"><a href="#clash-Verge" class="headerlink" title="clash Verge"></a>clash Verge</h2><p>复制环境变量 去github 执行<br><img src="/../../imgs/Pasted%20image%2020250413120927.png"><br><img src="/../../imgs/Pasted%20image%2020250413120942.png"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7897 all_proxy=socks5://127.0.0.1:7897</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/../../imgs/Pasted%20image%2020250413121036.png"></p>
<h1 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> http_proxy</span><br></pre></td></tr></table></figure>


<h1 id="git-里设置开启代理-alias-命令别名"><a href="#git-里设置开启代理-alias-命令别名" class="headerlink" title="git 里设置开启代理 alias 命令别名"></a>git 里设置开启代理 alias 命令别名</h1><h2 id="新建-bashrc"><a href="#新建-bashrc" class="headerlink" title="新建 .bashrc"></a>新建 .bashrc</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vi .bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以下内容复制进去</span></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . /etc/bash.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:</span></span><br><span class="line"><span class="comment"># export SYSTEMD_PAGER=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"><span class="comment"># 别名设置，其他别名设置也是类似</span></span><br><span class="line"><span class="built_in">alias</span> proxyon=<span class="string">&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">alias</span> proxyoff=<span class="string">&quot;unset http_proxy;unset https_proxy&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p>可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。<br><img src="/../../imgs/Pasted%20image%2020230912235632.png"><br><img src="/../../imgs/Pasted%20image%2020230912235612.png"><br>可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。<br><img src="/../../imgs/Pasted%20image%2020230913000956.png" alt="图 push成功"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>pycharm配置VPN代理</title>
    <url>/2025-06-08-e7d1013a5402.html</url>
    <content><![CDATA[<p>确定本地VPN的代理端口：</p>
<p><img src="/../../imgs/Pasted%20image%2020250609001902.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020250609001826.png"></p>
<p>点击check connetion 输入<a href="http://www.google.com/">http://www.google.com</a><br><img src="/../../imgs/Pasted%20image%2020250609001953.png"><br><img src="/../../imgs/Pasted%20image%2020250609001820.png"></p>
<p>也可以使用requests 包验证, 返回内容，不爆红即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.youtube.com&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/Pasted%20image%2020250609002055.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>ssh 隧道 端口转发</title>
    <url>/2024-04-21-29ab33001840.html</url>
    <content><![CDATA[<p>使用SSH端口转发<br>   如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用<code>-L</code>参数实现，如下所示：<br>   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -L 本地端口:localhost:13579 用户名@物理机IP</span><br></pre></td></tr></table></figure><br>   其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。</p>
<p>例如：<br>我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 13579:localhost:13579 root@110.43.203.19 -p 30005 </span><br><span class="line">// </span><br><span class="line">ssh -p 13579 root@localhost</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>windows新增wsl bash here键快捷方式</title>
    <url>/2024-01-01-38178c63ba17.html</url>
    <content><![CDATA[<p>win + R 输入regedit<br><img src="/../../imgs/Pasted%20image%2020240101182355.png"><br>输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p>
<h1 id="新建wsl-bash-here目录-设置如下默认值"><a href="#新建wsl-bash-here目录-设置如下默认值" class="headerlink" title="新建wsl_bash_here目录, 设置如下默认值"></a>新建wsl_bash_here目录, 设置如下默认值</h1><p><img src="/../../imgs/Pasted%20image%2020240101183252.png"></p>
<h1 id="新建command新建项，输入wsl-exe-的地址"><a href="#新建command新建项，输入wsl-exe-的地址" class="headerlink" title="新建command新建项，输入wsl.exe 的地址"></a>新建command新建项，输入wsl.exe 的地址</h1><p><img src="/../../imgs/Pasted%20image%2020240101183246.png"></p>
<h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>可以看到右侧是有wsl bash here的选项的<br><img src="/../../imgs/Pasted%20image%2020240101183634.png"><br><strong>在当面目录打开wsl 成功</strong><br><img src="/../../imgs/Pasted%20image%2020240101183645.png"><br>原理和添加git bash here 类似, 参考:<br><a href="https://blog.csdn.net/Passerby_Wang/article/details/120881670">手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>快来压缩你的博客图片</title>
    <url>/2023-03-23-4868b6a1c39c.html</url>
    <content><![CDATA[<p>虽然没多大变化 哈哈哈<br><img src="/../../imgs/Pasted%20image%2020230324011438.png"><br>再试试 更大更高清的图片<br><img src="/../../imgs/code-wallpaper-6.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020230325200454.png"><br>实测,效果不太行….<br>但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下<br>待更新…</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>给你的博客 安装上PWA吧</title>
    <url>/2023-03-23-49ace33ca004.html</url>
    <content><![CDATA[<p>TODO:</p>
<ul>
<li>什么是PWA，可以提示添加到主屏幕<br>渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站</li>
<li>安装 hexo-pwa</li>
<li>由于hexo-pwa停止维护，需要解决报错</li>
<li>设置全局_config.yml 文件(非主题)</li>
</ul>
<p><img src="/../../imgs/Pasted%20image%2020230324004739.png"></p>
<p><img src="/../../imgs/ad6c5ebfc9a6401cde512120b6ed719.jpeg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>【Win】键盘下键坏了，使用组合键模拟下方向键</title>
    <url>/2024-01-14-2aaa71f8e7be.html</url>
    <content><![CDATA[<p>使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：</p>
<p>下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。<br><img src="/../../imgs/Pasted%20image%2020240114170655.png"><br>创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!s::Send &#123;Down&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。<br><img src="/../../imgs/Pasted%20image%2020240114170729.png"><br>保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。</p>
<p>运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。</p>
<p>现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <url>/2025-01-13-facf42a009b6.html</url>
    <content><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p>
<h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p>
<h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p>
<h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p>
<p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p>
<h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p>
<h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p>
<h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>免费使用Jetbrain 全家桶-服务器激活码激活软件</title>
    <url>/2023-12-30-6a1e804ab992.html</url>
    <content><![CDATA[<p>众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.</p>
<p>Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。</p>
<ul>
<li><a href="https://search.censys.io/">https://search.censys.io/</a>     搜索：<code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></li>
<li><a href="https://www.shodan.io/">https://www.shodan.io</a>  搜索：<br><code>Location: https://account.jetbrains.com/fls-auth</code></li>
<li><a href="https://fofa.info/">https://fofa.info/</a>     搜索：<code>fls-auth</code></li>
</ul>
<p>随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是<a href="https://search.censys.io/">https://search.censys.io/</a> 网站, 搜索 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services.http.response.headers.location: account.jetbrains.com/fls-auth</span><br></pre></td></tr></table></figure>


<p><img src="/../../imgs/Pasted%20image%2020231230231034.png"><br>例如上边就是 <a href="http://111.231.22.61:1024/">http://111.231.22.61:1024</a></p>
<p><img src="/../../imgs/Pasted%20image%2020231230231326.png"></p>
<h1 id="激活成功"><a href="#激活成功" class="headerlink" title="激活成功"></a>激活成功</h1><p>激活成功，请开始愉快的编码吧！<br><img src="/../../imgs/Pasted%20image%2020231230231349.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>删除ppt所有批注和备注</title>
    <url>/2023-04-24-4faf63eb321c.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230424222537.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020230424222611.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020230424222527.png"><br><img src="/../../imgs/Pasted%20image%2020230424222515.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020230424222511.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>博客设置 obsidian 上传图片</title>
    <url>/2023-03-18-4e4b648f656d.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的<strong>相对路径</strong>就可以读取并显示图片。</p>
<p>而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="1-打开obsidian-文件与链接"><a href="#1-打开obsidian-文件与链接" class="headerlink" title="1. 打开obsidian - 文件与链接"></a>1. 打开obsidian - 文件与链接</h2><h2 id="2-按照下图配置"><a href="#2-按照下图配置" class="headerlink" title="2. 按照下图配置"></a>2. 按照下图配置</h2><p>   *　将内部链接类型 设置为 “基于当前笔记的<strong>相对路径</strong>”<br>     &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用<strong>相对路径</strong></p>
<ul>
<li>取消wiki 链接 </li>
<li>指定图片的默认路径为 <code>source/imgs</code><br>&gt; 如果没有该文件夹，则需要先新建一下。</li>
</ul>
<p><img src="/../../imgs/Pasted%20image%2020230319131458.png"></p>
<h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>网页可以成功显示图片</p>
<p><img src="/../../imgs/Pasted%20image%2020230319134051.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>开机自启WSL</title>
    <url>/2024-08-07-117ef9b8f4c6.html</url>
    <content><![CDATA[<p>在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件</p>
<p><img src="/../../imgs/Pasted%20image%2020240807221008.png"></p>
<p>文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set ws = WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">cmd = &quot;C:\Windows\System32\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;</span><br><span class="line">&#x27;运行命令不显示cmd窗口</span><br><span class="line">ws.Run cmd, 0, false</span><br><span class="line">Set ws = Nothing</span><br><span class="line">WScript.quit</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>查询深度学习环境python torch cuda版本</title>
    <url>/2024-08-08-efa703ec12d7.html</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys模块提供了一系列有关Python运行环境的变量和函数。</span></span><br><span class="line"><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<p><img src="/../../imgs/Pasted%20image%2020240808225509.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>网站无法访问categories？</title>
    <url>/2023-05-21-a827bdd2d159.html</url>
    <content><![CDATA[<p>在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。</p>
<p><img src="/../../imgs/Pasted%20image%2020230521214536.png"></p>
<p>可以显示啦<br><img src="/../../imgs/Pasted%20image%2020230521214912.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>波纹</title>
    <url>/2023-04-08-722322c4ddc3.html</url>
    <content><![CDATA[<p><img src="/../../imgs/IMG_1502-01-01.jpeg"><br>波光粼粼</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>comet 生成临时文件导致磁盘满</title>
    <url>/2025-05-01-d5e22ea4be8d.html</url>
    <content><![CDATA[<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>出现 <code>OSError: [Errno 28] No space left on device</code> 错误的原因是系统磁盘空间不足，尤其是在临时目录（如 <code>/tmp</code>）中。以下是分步解决方案：</p>
<hr>
<h4 id="1-检查磁盘空间"><a href="#1-检查磁盘空间" class="headerlink" title="1. 检查磁盘空间"></a><strong>1. 检查磁盘空间</strong></h4><p>在终端运行以下命令，查看磁盘使用情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>

<h4 id="2-清理临时文件"><a href="#2-清理临时文件" class="headerlink" title="2. 清理临时文件"></a><strong>2. 清理临时文件</strong></h4><p>删除临时目录中的旧文件（确保无重要进程依赖这些文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /tmp/*</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-查找并删除大文件"><a href="#3-查找并删除大文件" class="headerlink" title="3. 查找并删除大文件"></a><strong>3. 查找并删除大文件</strong></h4><p>使用以下命令定位大文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看根目录下各文件夹的大小</span></span><br><span class="line">sudo <span class="built_in">du</span> -sh /* | <span class="built_in">sort</span> -hr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下大于 1GB 的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +1G -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>删除不再需要的大文件（如旧日志、缓存等）。</p>
<hr>
<h4 id="4-清理系统缓存和日志"><a href="#4-清理系统缓存和日志" class="headerlink" title="4. 清理系统缓存和日志"></a><strong>4. 清理系统缓存和日志</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理 APT 缓存（适用于 Ubuntu/Debian）</span></span><br><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧版 Linux 内核（谨慎操作）</span></span><br><span class="line">sudo apt-get autoremove --purge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理系统日志（保留最近7天）</span></span><br><span class="line">sudo journalctl --vacuum-time=7d</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-更改临时目录路径"><a href="#5-更改临时目录路径" class="headerlink" title="5. 更改临时目录路径"></a><strong>5. 更改临时目录路径</strong></h4><p>如果 <code>/tmp</code> 所在分区空间不足，可以将临时目录指向其他分区：</p>
<p><strong>方法一：在代码中设置临时目录</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">tempfile.tempdir = <span class="string">&quot;/path/to/your/large/disk/tmp&quot;</span>  <span class="comment"># 替换为有足够空间的路径</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二：通过环境变量设置</strong><br>在运行脚本前设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> TMPDIR=/path/to/your/large/disk/tmp</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-调整-Comet-ml-的存储路径"><a href="#6-调整-Comet-ml-的存储路径" class="headerlink" title="6. 调整 Comet.ml 的存储路径"></a><strong>6. 调整 Comet.ml 的存储路径</strong></h4><p>在初始化 <code>Experiment</code> 时指定日志和临时文件目录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">experiment = Experiment(</span><br><span class="line">    <span class="string">&quot;H62QCY6dW6Vg9lLl27jZn4C2O&quot;</span>,</span><br><span class="line">    project_name=<span class="string">&quot;IDRsPredictor-transformer&quot;</span>,</span><br><span class="line">    log_code=<span class="literal">True</span>,</span><br><span class="line">    log_dir=<span class="string">&quot;/path/to/large/disk/comet_logs&quot;</span>  <span class="comment"># 指定存储路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>参考：chatGPT</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>Mesh组网：家庭路由和无线连接新方式</title>
    <url>/2023-06-25-a45e5f4edabc.html</url>
    <content><![CDATA[<p>在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><ol>
<li>Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。</li>
</ol>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><ol start="2">
<li><p>Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释：</p>
<ul>
<li>设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。</li>
<li>路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。</li>
<li>中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。</li>
<li>自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。</li>
</ul>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1></li>
<li><p>为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择：</p>
<ul>
<li>扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。</li>
<li>提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。</li>
<li>可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。</li>
<li>鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。</li>
<li>应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。</li>
</ul>
</li>
</ol>
<h1 id="与桥接路由对比"><a href="#与桥接路由对比" class="headerlink" title="与桥接路由对比"></a>与桥接路由对比</h1><ol>
<li><p>Mesh组网：</p>
<ul>
<li>概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。</li>
<li>特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。</li>
<li>优点：<ul>
<li>扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。</li>
<li>鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。</li>
<li>简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。</li>
</ul>
</li>
<li>缺点：<ul>
<li>延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。</li>
<li>多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。</li>
<li>网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。</li>
</ul>
</li>
</ul>
</li>
<li><p>桥接路由：</p>
<ul>
<li>概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。</li>
<li>特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。</li>
<li>优点：<ul>
<li>低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。</li>
<li>单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。</li>
<li>集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。</li>
</ul>
</li>
<li>缺点：<ul>
<li>单点故障：中央路由器的故障可能导致整个网络失去连接。</li>
<li>限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。</li>
<li>扩展性：增加节点时，可能需要重新配置和调整网络结构。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>windows IE代理问题解决</title>
    <url>/2024-04-05-e1116cf34b00.html</url>
    <content><![CDATA[<p>CMD <strong>检查系统代理配置</strong>：</p>
<pre><code>- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。
- 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。
</code></pre>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络概览</title>
    <url>/2024-05-02-82705503428a.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240502152821.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240502153252.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240502153337.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240502153543.png"></p>
<p>【计算机网络】常识</p>
<p>知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；<br>两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线<br>【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；<br>数据链路层；<br>【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；<br>【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；<br>【物理地址MAC】<br>交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）<br>【点对点连接】【全双工通讯】提高了带宽利用率；<br>【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；<br>【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；<br>【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长<br>【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；<br>【IP地址】用于标识不同的网络和网络设备；<br>【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）<br>【默认网关IP】不同网段连接到路由器的IP；<br>【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；<br>设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；<br>【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器<br>【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；<br>【海底光缆】</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>路由器设置桥接</title>
    <url>/2024-02-15-1f66da892e14.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240215213434.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240215213536.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240215213849.png"></p>
<p><img src="/../../imgs/Pasted%20image%2020240215214100.png"><br><img src="/../../imgs/Pasted%20image%2020240215221821.png"><br>设置密码类型和主路由一样<br><img src="/../../imgs/Pasted%20image%2020240215221453.png"></p>
<p>记得关闭DHCP服务器<br><img src="/../../imgs/Pasted%20image%2020240215221417.png"><br><img src="/../../imgs/Pasted%20image%2020240215221130.png"><img src="/../../imgs/Pasted%20image%2020240215221401.png"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-工厂方法模式</title>
    <url>/2023-09-03-c58ee0dac51b.html</url>
    <content><![CDATA[<p>网站链接：<br><a href="https://refactoringguru.cn/design-patterns/factory-method">工厂方法设计模式 (refactoringguru.cn)</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。</p>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂<br><img src="/../../imgs/Pasted%20image%2020230903131943.png"><br><img src="/../../imgs/Pasted%20image%2020230903134040.png"><br><img src="/../../imgs/Pasted%20image%2020230903133944.png"><br>简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间.</p>
<h1 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h1><p><strong>不同的类实现相同的动作,例如运输等</strong><br><img src="/../../imgs/Pasted%20image%2020230903140955.png"></p>
<ol>
<li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p>
</li>
<li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p>
</li>
<li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p>
<p> 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p>
<p> 注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p>
</li>
<li><p><strong>具体创建者</strong> （Concrete Creators） 将会<strong>重写基础工厂</strong>方法， 使其<strong>返回不同类型的产品</strong>。</p>
<p> 注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的<strong>已有对象</strong>。</p>
</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/../../imgs/Pasted%20image%2020230903142906.png"><br>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。</p>
<p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。</p>
<p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p>
<p>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离<a href="https://refactoringguru.cn/design-patterns/abstract-factory">抽象工厂</a>模式更近一步。</p>
<h1 id="简单工厂和工厂模式的区别"><a href="#简单工厂和工厂模式的区别" class="headerlink" title="简单工厂和工厂模式的区别"></a>简单工厂和工厂模式的区别</h1><p><strong>1. 简单工厂设计模式（Simple Factory Design Pattern）：</strong></p>
<p>定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。<br>结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。<br>示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。<br><strong>2. 工厂方法设计模式（Factory Method Design Pattern）：</strong></p>
<p>定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。<br>结构： 工厂方法模式包括<strong>抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。</strong><br>示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。<br>主要区别：</p>
<p>复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。</p>
<p>责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。</p>
<p>扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。</p>
<p>灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。</p>
<p>选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。</p>
<h2 id="UML类图如何看"><a href="#UML类图如何看" class="headerlink" title="UML类图如何看"></a>UML类图如何看</h2><h2 id="看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"><a href="#看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；" class="headerlink" title="看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)</a><br><img src="/../../imgs/Pasted%20image%2020230903222357.png"><br>- 车的类图结构为abstract，表示车是一个抽象类；<br>- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；<br>- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；<br>- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；<br>- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；<br>- 学生与身份证之间为关联关系，使用一根实线表示；<br>- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</h2><p><img src="/../../imgs/Pasted%20image%2020230903132154.png"></p>
<p>首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”</p>
<p><img src="/../../imgs/Pasted%20image%2020230903134233.png"></p>
<p><strong>接口:</strong> </p>
<p><img src="https://res.weread.qq.com/wrepub/CB_85fDPzDPICld6ht6gW5IeD0Q_Image00017.jpg"></p>
<p>‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口.</p>
<p><strong>类和类之间的关系:</strong> 继承的关系，继承关系用空心三角形+实线来表示<br><img src="/../../imgs/Pasted%20image%2020230903134840.png"></p>
<p><strong>聚合:</strong> 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。</p>
<p><img src="/../../imgs/Pasted%20image%2020230903140037.png"><br><strong>合成</strong>（Composition，也有翻译成‘<strong>组合</strong>’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。<br><img src="/../../imgs/Pasted%20image%2020230903140113.png"></p>
<p><strong>依赖</strong><br><img src="/../../imgs/Pasted%20image%2020230903140305.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-抽象工厂</title>
    <url>/2023-09-03-c6ab66461699.html</url>
    <content><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230903231353.png"></p>
<h1 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h1><p><img src="/../../imgs/Pasted%20image%2020230903231449.png"><br>多个工厂模式;</p>
<p>有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)</p>
<p><img src="/../../imgs/Pasted%20image%2020230903231857.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构设计专题</title>
    <url>/2025-03-06-dab119f1439d.html</url>
    <content><![CDATA[<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table>
<thead>
<tr>
<th>LeetCode</th>
<th>力扣</th>
<th>难度</th>
<th>是否完成</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td>
<td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td>
<td>🟠</td>
<td>202050306🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td>
<td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td>
<td>🔴</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td>
<td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td>
<td>🟠</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td>
<td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td>
<td>🟠</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td>
<td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td>
<td>🟢</td>
<td>202050307🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td>
<td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td>
<td>🟠</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td>
<td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td>
<td>🟠</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td>
<td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td>
<td>🔴</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td>
<td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td>
<td>🔴</td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td>
<td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td>
<td>🟠</td>
<td>🔴</td>
</tr>
</tbody></table>
<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请设计 最近 最少使用 约束的数据结构<br><img src="/../../imgs/Pasted%20image%2020250309231207.png"></p>
<p>20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	orderList []<span class="type">int</span></span><br><span class="line">	cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	<span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">		orderList: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, capacity), <span class="comment">// 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</span></span><br><span class="line">		cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, capacity),</span><br><span class="line">		capacity:  capacity,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// key 存在与单独的环境中</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">		this.Update(key)</span><br><span class="line">		<span class="keyword">return</span> this.cacheMaps[key]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Update(key <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 更新key 到最新位置</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.orderList); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> this.orderList[i] == key &#123;</span><br><span class="line">			this.orderList = <span class="built_in">append</span>(this.orderList[:i], <span class="built_in">append</span>(this.orderList[i+<span class="number">1</span>:], this.orderList[i])...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">		<span class="comment">// 更新key</span></span><br><span class="line">		this.cacheMaps[key] = value</span><br><span class="line">		this.Update(key)</span><br><span class="line">	&#125;  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &gt;= this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=&quot;</span>,<span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line">		<span class="comment">// 删除key</span></span><br><span class="line">		oldKey := this.orderList[<span class="number">0</span>]</span><br><span class="line">		this.orderList = this.orderList[<span class="number">1</span>:]</span><br><span class="line">		<span class="built_in">delete</span>(this.cacheMaps, oldKey)</span><br><span class="line">		<span class="comment">// 新建key</span></span><br><span class="line">		this.cacheMaps[key] = value</span><br><span class="line">		this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &lt; this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;&lt;&quot;</span>, <span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line">		<span class="comment">// 新建key</span></span><br><span class="line">		this.cacheMaps[key] = value</span><br><span class="line">		this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="O-1-方法双向列表，map-中直接保存列表元素指针，"><a href="#O-1-方法双向列表，map-中直接保存列表元素指针，" class="headerlink" title="O(1) 方法双向列表，map 中直接保存列表元素指针，"></a>O(1) 方法双向列表，map 中直接保存列表元素指针，</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">	orderList *list.List</span><br><span class="line">	capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   <span class="type">int</span></span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	<span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">		cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element, capacity),</span><br><span class="line">		orderList: list.New(),</span><br><span class="line">		capacity:  capacity,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">		this.orderList.MoveToBack(elem)</span><br><span class="line">		<span class="keyword">return</span> elem.Value.(entry).value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">		<span class="comment">// 更新已存在的键</span></span><br><span class="line">		elem.Value = entry&#123;key: key, value: value&#125;</span><br><span class="line">		this.orderList.MoveToBack(elem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 插入新键</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) == this.capacity &#123;</span><br><span class="line">			<span class="comment">// 删除最久未使用的键</span></span><br><span class="line">			frontElem := this.orderList.Front()</span><br><span class="line">			<span class="built_in">delete</span>(this.cacheMaps, frontElem.Value.(entry).key)</span><br><span class="line">			this.orderList.Remove(frontElem)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 插入新键到链表末尾</span></span><br><span class="line">		newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;)</span><br><span class="line">		this.cacheMaps[key] = newElem</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p><img src="/../../imgs/Pasted%20image%2020250307231252.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1700  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9分钟完成  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStudents</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 栈模拟  </span></span><br><span class="line">    <span class="comment">// 结束条件  </span></span><br><span class="line">    <span class="comment">// 同学中数字都相同，且不等于栈顶元素 [0]  </span></span><br><span class="line">    <span class="keyword">for</span> !isEnd(students, sandwiches) &#123;  </span><br><span class="line">       <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>] &#123;  </span><br><span class="line">          sandwiches = sandwiches[<span class="number">1</span>:]  </span><br><span class="line">          students = students[<span class="number">1</span>:]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          students = <span class="built_in">append</span>(students[<span class="number">1</span>:], students[<span class="number">0</span>])  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(students)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnd</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> students &#123;  </span><br><span class="line">       <span class="keyword">if</span> val == sandwiches[<span class="number">0</span>] &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>速刷记录</category>
      </categories>
  </entry>
  <entry>
    <title>如何画好一个架构图</title>
    <url>/2025-02-19-d829d1f5a9ea.html</url>
    <content><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p>
<h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p>
<ul>
<li>通过不同的颜色白标识不同颜色</li>
</ul>
<p><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p>
<h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p>
<p>使用场景：</p>
<ul>
<li>项目开发和测试</li>
<li>部署发布</li>
<li>子领域项目架构，下方就是个会员中心*</li>
</ul>
<p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p>
<h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p>
<p>使用场景</p>
<ul>
<li>总体架构设计</li>
<li>运维规划和优化</li>
<li>画图技巧</li>
<li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>系统序列图 - 时序图</title>
    <url>/2025-02-19-05250c3f88f5.html</url>
    <content><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>vue3快速实践</title>
    <url>/2024-06-24-1130f46a1ad4.html</url>
    <content><![CDATA[<p><a href="https://cn.vuejs.org/tutorial/#step-7">教程 | Vue.js (vuejs.org)</a></p>
<h1 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h1><p>你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。SFC 是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 <code>.vue</code> 后缀的文件中。</p>
<p>Vue 的核心功能是<strong>声明式渲染</strong>：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。<br>能在改变时触发更新的状态被称作是<strong>响应式</strong>的。我们可以使用 Vue 的 <code>reactive()</code> API 来声明响应式状态。由 <code>reactive()</code> 创建的对象都是 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const counter = reactive(&#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(counter.count) // 0</span><br><span class="line">counter.count++</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>reactive()</code> 只适用于对象 (包括数组和内置类型，如 <code>Map</code> 和 <code>Set</code>)。而另一个 API <code>ref()</code> 则可以接受任何值类型。<code>ref</code> 会返回一个包裹对象，并在 <code>.value</code> 属性下暴露内部值。</p>
<p>在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。</p>
<p>template</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>现在，试着自己创建一些响应式状态，</p>
<h1 id="Attribute-绑定-v-bind"><a href="#Attribute-绑定-v-bind" class="headerlink" title="Attribute 绑定 v-bind"></a>Attribute 绑定 v-bind</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const titleClass = ref(&#x27;title&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../../../../imgs/Pasted%20image%2020240624225914.png"></p>
<h1 id="时间监听-v-on-click"><a href="#时间监听-v-on-click" class="headerlink" title="时间监听 v-on : click"></a>时间监听 v-on : click</h1><p>v-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  // 更新组件状态</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 使此按钮生效 --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/../../../../imgs/Pasted%20image%2020240624225635.png"></p>
<h1 id="表单绑定-v-model"><a href="#表单绑定-v-model" class="headerlink" title="表单绑定 v-model"></a>表单绑定 v-model</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230352.png"><br><code>v-model</code> 会将被绑定的值与 <code>&lt;input&gt;</code> 的值自动同步，这样我们就不必再使用事件处理函数了。</p>
<p><code>v-model</code> 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在<a href="https://cn.vuejs.org/guide/essentials/forms.html">指南 - 表单绑定</a>中讨论了更多的细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const text = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">function onInput(e) &#123;</span><br><span class="line">  text.value = e.target.value</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用v-model 简化</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const text = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230722.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const awesome = ref(true)</span><br><span class="line"></span><br><span class="line">function toggle() &#123;</span><br><span class="line">  awesome.value = !awesome.value # 做取反</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt;</span><br><span class="line">  &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue3 入门</category>
      </categories>
  </entry>
</search>
