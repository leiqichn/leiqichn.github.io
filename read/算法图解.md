---
doc_type: weread-highlights-reviews
bookId: "22806916"
author: 巴尔加瓦
cover: https://cdn.weread.qq.com/weread/cover/52/YueWen_22806916/t7_YueWen_22806916.jpg
reviewCount: 12
noteCount: 175
isbn: 9787115447630
category: 计算机-编程设计
lastReadDate: 2021-09-01
---
# 元数据
> [!abstract] 算法图解
> - ![ 算法图解|200](https://cdn.weread.qq.com/weread/cover/52/YueWen_22806916/t7_YueWen_22806916.jpg)
> - 书名： 算法图解
> - 作者： 巴尔加瓦
> - 简介： 本书示例丰富，图文并茂，以简明易懂的方式阐释了算法，旨在帮助程序员在日常项目中更好地利用算法为软件开发助力。前三章介绍算法基础，包括二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法，具体内容包括：面对具体问题时的解决技巧，比如何时采用贪婪算法或动态规划；散列表的应用；图算法；K最近邻算法。本书适合所有程序员、计算机专业相关师生以及对算法感兴趣的读者。
> - 出版时间 2017-03-01 00:00:00
> - ISBN： 9787115447630
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社

# 高亮划线

## 1.4 小结


- 📌 算法运行时间并不以秒为单位。❑ 算法运行时间是从其增速的角度度量的。❑ 算法运行时间用大O表示法表示。 ^22806916-18-593-704
    - ⏱ 2021-08-25 10:06:33 
## 第6章 广度优先搜索


- 📌 广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以： ^22806916-40-1066-1114
    - ⏱ 2021-08-31 13:14:28 
## 7.6 小结


- 📌 在加权图 ^22806916-53-483-487
    - ⏱ 2019-11-25 10:29:58 

- 📌 正时狄克斯特拉算法 ^22806916-53-532-541
    - ⏱ 2019-11-25 10:30:17 

- 📌 用贝尔曼-福德算 ^22806916-53-589-597
    - ⏱ 2019-11-25 10:30:12 

- 📌 贝尔曼-福德算法 ^22806916-51-3103-3146
    - ⏱ 2019-11-24 23:14:17 
## 第8章 贪婪算法


- 📌 近似算法 ^22806916-57-2324-2328
    - ⏱ 2019-11-25 15:26:54 
## 8.5 小结


- 📌 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 ^22806916-59-421-448
    - ⏱ 2021-08-31 22:56:43 

- 📌 贪婪算法易于实现、运行速度快，是不错的近似算法。 ^22806916-59-588-612
    - ⏱ 2021-08-31 22:57:03 
## 第9章 动态规划


- 📌 ，这是一种解决棘手问题的方法，它将问题分成小问题，并先着手解决这些小问题。 ^22806916-60-546-583
    - ⏱ 2020-09-09 00:48:58 
## 1.3 大O表示法


- 📌 简单查找的运行时间为O(n) ^22806916-17-4930-4972
    - ⏱ 2019-11-22 21:15:08 

- 📌 但大O表示法说的是最糟的情形。 ^22806916-17-5228-5243
    - ⏱ 2019-11-22 21:15:38 

- 📌 (log n)，也叫对数时间，这样的算法包括二分查找。 ^22806916-17-5717-5809
    - ⏱ 2019-11-22 21:17:43 

- 📌 一种速度较快的排序算法 ^22806916-17-5984-5995
    - ⏱ 2019-11-22 21:17:57 

- 📌 速度较慢的排序算法 ^22806916-17-6142-6151
    - ⏱ 2019-11-22 21:18:06 

- 📌 种非常慢的算法 ^22806916-17-6246-6253
    - ⏱ 2019-11-22 21:18:14 
## 2.1 内存的工作原理


- 📌 你将两样东西存放在这里。￼现在你可以去看演出了！这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。 ^22806916-20-888
    - ⏱ 2019-11-22 21:29:26 
## 2.2 数组和链表


- 📌 使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。 ^22806916-21-718-749
    - ⏱ 2021-08-26 11:48:57 

- 📌 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起 ^22806916-21-2057-2094
    - ⏱ 2021-08-26 16:32:53 

- 📌 寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。 ^22806916-21-2313-2394
    - ⏱ 2021-08-26 17:08:56 
 

- 📌 但如果你需要跳跃，链表的效率真的很低。 ^22806916-21-3302-3350
    - ⏱ 2019-11-22 21:36:19 

- 📌 从0而不是1开始。 ^22806916-21-3861-3870
    - ⏱ 2019-11-22 21:36:58 
 

- 📌 后面的元素都向后移。 ^22806916-21-5635-5645
    - ⏱ 2019-11-22 21:41:08 

- 📌 足够的空间 ^22806916-21-5845-5850
    - ⏱ 2019-11-22 21:41:33 

- 📌 整个数组复制到其他地方 ^22806916-21-5856-5867
    - ⏱ 2019-11-22 21:41:27 

- 📌 删除元素呢？链表也是更好的选择 ^22806916-21-5995-6010
    - ⏱ 2019-11-22 21:42:14 

- 📌 但数组用得很多 ^22806916-21-6568-6575
    - ⏱ 2019-11-22 21:44:54 

- 📌 支持随机访问 ^22806916-21-6579-6585
    - ⏱ 2019-11-22 21:44:58 

- 📌 顺序访问意味着从第一个元素开始逐个地读取元素 ^22806916-21-6660-6682
    - ⏱ 2019-11-22 21:45:08 

- 📌 读取链表的第十个元素，得先读取前九个元素 ^22806916-21-6693-6713
    - ⏱ 2019-11-22 21:45:36 
 

- 📌 假设Facebook使用的是一种混合数据：链表数组 ^22806916-21-7947-7972
    - ⏱ 2021-08-27 18:33:32 

- 📌 必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢 ^22806916-21-8485-8520
    - ⏱ 2021-08-27 18:41:37 
## 2.3 选择排序


- 📌 从多到少的顺序排列，从而将你喜欢的乐队排序 ^22806916-22-941-962
    - ⏱ 2021-08-28 14:39:36 

- 📌 需要的总时间为O(n × n)，即O(n2 ^22806916-22-2414-2514
    - ⏱ 2021-08-28 14:41:41 

- 📌 示例代码前面没有列出对乐队进行排序的代码，但下述代码提供了类似的功能：将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。￼现在可以使用这个函数来编写选择排序算法了。￼ ^22806916-22-4143
    - ⏱ 2019-11-22 22:24:18 
## 3.1 递归


- 📌 递归只是让解决方案更清晰，并没有性能上的优势。 ^22806916-25-2574-2597
    - ⏱ 2021-08-29 15:57:36 
## 3.2 基线条件和递归条件


- 📌 Ctrl+C ^22806916-26-1167-1173
    - ⏱ 2019-11-22 23:44:16 

- 📌 基线条件（base case）和递归条件（recursive case） ^22806916-26-1242-1278
    - ⏱ 2019-11-22 23:44:26 
## 3.3 栈


- 📌 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。 ^22806916-27-5443-5480
    - ⏱ 2021-08-29 16:07:51 
## 3.4 小结

 

- 📌 基线条件和递归条件。 ^22806916-28-479-489
    - ⏱ 2021-08-29 16:13:31 

- 📌 调用栈可能很长，这将占用大量的内存。 ^22806916-28-611-629
    - ⏱ 2021-08-29 16:13:53 
## 4.1 分而治之


- 📌 使用D&C策略！D&C算法是递归的。使用D&C解决问题的过程包括两个步骤。 ^22806916-30-1188-1266
    - ⏱ 2019-11-23 11:34:34 

- 📌 基线条件，这种条件必须尽可能简单 ^22806916-30-1272-1288
    - ⏱ 2019-11-23 11:34:40 

- 📌 问题分解（或者说缩小规模），直到符合基线条 ^22806916-30-1325-1346
    - ⏱ 2019-11-23 11:34:45 

- 📌 每次递归调用都必须缩小问题的规模。如何缩小前述问题的规模呢？ ^22806916-30-1796-1826
    - ⏱ 2019-11-23 11:35:28 

- 📌 找出简单的基线条件 ^22806916-30-4486-4495
    - ⏱ 2019-11-23 11:38:38 

- 📌 确定如何缩小问题的规模，使其符合基线条件。 ^22806916-30-4529-4550
    - ⏱ 2019-11-23 11:38:43 

- 📌 解决问题的思路 ^22806916-30-4599-4606
    - ⏱ 2019-11-23 11:38:54 
 

- 📌 基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。 ^22806916-30-7189-7229
    - ⏱ 2021-08-29 16:49:40 
## 4.2 快速排序


- 📌 将数组分解，直到满足基线条件。下面介绍快速排序的工作原理。首先，从数组中选择一个元素，这个元素被称为基准值（pivo ^22806916-31-1580-1670
    - ⏱ 2019-11-23 13:20:07 

- 📌 快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组 ^22806916-31-2818-2866
    - ⏱ 2019-11-23 13:26:09 

- 📌 ) 选择基准值。(2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。(3) 对这两个子数组进行快速排序。 ^22806916-31-3379-3525
    - ⏱ 2019-11-23 13:27:45 
## 4.3 再谈大O表示法


- 📌 快速排序的独特之处在于，其速度取决于选择的基准值 ^22806916-32-428-452
    - ⏱ 2021-08-30 00:23:49 

- 📌 选择排序 ^22806916-19-898-902
    - ⏱ 2019-11-22 21:24:51 

- 📌 还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n) ^22806916-32-980-1101
    - ⏱ 2021-08-30 00:24:59 

- 📌 快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。 ^22806916-32-1118-1235
    - ⏱ 2021-08-30 00:25:06 

- 📌 导致调用栈非常长 ^22806916-32-4284-4292
    - ⏱ 2019-11-23 15:31:08 

- 📌 快速排序是最快的排序算法之一，也是D&C典范。 ^22806916-32-6333-6356
    - ⏱ 2021-08-30 00:32:31 
## 4.4 小结


- 📌 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在 ^22806916-33-612-647
    - ⏱ 2021-08-30 00:42:47 

- 📌 快速排序 ^22806916-19-918-922
    - ⏱ 2019-11-22 21:24:55 
## 第5章 散列表


- 📌 苹果（apple） ^22806916-34-857-873
    - ⏱ 2019-11-23 21:27:26 
## 5.1 散列函数


- 📌 它应将不同的输入映射到不同的数字 ^22806916-35-875-891
    - ⏱ 2021-08-30 00:46:21 

- 📌 刚才你就打造了一个“Maggie”！你结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。 ^22806916-35-3429-3608
    - ⏱ 2021-08-30 00:48:49 

- 📌 散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组 ^22806916-35-3480-3510
    - ⏱ 2019-11-23 21:35:30 

- 📌 散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键映射到值。 ^22806916-35-4621-4667
    - ⏱ 2021-08-30 00:50:16 
## 5.2 应用案例


- 📌 book=dict() ^22806916-35-3737-3926
    - ⏱ 2019-11-23 21:35:57 

- 📌 使用一对大括号 ^22806916-36-1375-1382
    - ⏱ 2019-11-23 21:37:44 

- 📌 这个过程被称为DNS解析（DNS resolution），散列表是提供这种功能的方式之一。 ^22806916-36-2893-2994
    - ⏱ 2021-08-30 00:52:24 

- 📌 如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！ ^22806916-36-4142-4195
    - ⏱ 2021-08-30 00:53:24 

- 📌 常用的加速方式 ^22806916-36-6740-6747
    - ⏱ 2019-11-23 21:42:37 

- 📌 模拟映射关系；❑ 防止重复；❑ 缓存/记住数据，以免服务器再通过处理来生成它 ^22806916-36-7760-7858
    - ⏱ 2019-11-23 21:44:27 
## 5.3 冲突


- 📌 映射到数组的不同位置 ^22806916-35-3123-3133
    - ⏱ 2019-11-23 21:33:58 

- 📌 这个位置已经存储了苹果的价格！怎么办？这种情况被称为冲突 ^22806916-37-1969-2018
    - ⏱ 2019-11-23 21:45:43 
## 5.4 性能


- 📌 不管数组多大，从中获取一个元素所需的时间都是相同的。 ^22806916-38-1567-1593
    - ⏱ 2019-11-23 21:47:51 
## 5.5 小结


- 📌 散列函数 ^22806916-35-395-429
    - ⏱ 2019-11-23 21:31:43 
## 6.1 图简介


- 📌 最短路径问题 ^22806916-41-1872-1878
    - ⏱ 2019-11-24 16:39:12 

- 📌 解决最短路径问题的算法被称为广度优先搜索 ^22806916-41-1984-2032
    - ⏱ 2019-11-24 16:39:33 

- 📌 (1) 使用图来建立问题模型。(2) 使用广度优先搜索解决问题。 ^22806916-41-2228-2289
    - ⏱ 2021-08-31 14:37:04 
## 6.2 图是什么


- 📌 节点和边组成 ^22806916-42-1410-1416
    - ⏱ 2019-11-24 16:48:25 
## 6.3 广度优先搜索


- 📌 二分查找 ^22806916-43-440-444
    - ⏱ 2019-11-24 16:50:11 

- 📌 D&C ^22806916-31-482-489
    - ⏱ 2021-08-29 20:05:16 

- 📌 权重 ^22806916-49-521-530
    - ⏱ 2019-11-24 22:24:49 

- 📌 分而 ^22806916-29-897-899
    - ⏱ 2019-11-23 11:26:44 

- 📌 D&C ^22806916-29-1122-1125
    - ⏱ 2019-11-23 11:32:46 

- 📌 搜遍你的整个人际关系网，直到找到芒果销售商 ^22806916-43-2160-2181
    - ⏱ 2019-11-24 16:58:58 

- 📌 最近的芒果销售商 ^22806916-43-2530-2538
    - ⏱ 2019-11-24 17:00:38 

- 📌 此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。 ^22806916-43-2791-2828
    - ⏱ 2019-11-24 17:01:06 

- 📌 一度关系在二度关系之前加入查找名单。 ^22806916-43-3126-3144
    - ⏱ 2021-08-31 14:48:40 

- 📌 字典 ^22806916-35-3683-3685
    - ⏱ 2019-11-23 21:35:52 

- 📌 数据结构，那就是队列 ^22806916-43-3523-3554
    - ⏱ 2019-11-24 17:03:40 

- 📌 递归 ^22806916-31-3979-3981
    - ⏱ 2019-11-23 13:28:31 

- 📌 出队 ^22806916-45-759-761
    - ⏱ 2019-11-24 17:16:16 

- 📌 为索引 ^22806916-21-4214-4245
    - ⏱ 2019-11-22 21:37:35 

- 📌 队列是一种先进先出（First In First Out, FIFO）的数据结构 ^22806916-43-4315-4383
    - ⏱ 2019-11-24 17:07:45 

- 📌 先进先出 ^22806916-46-784-788
    - ⏱ 2019-11-24 17:37:01 

- 📌 栈是一种后进先出 ^22806916-43-4385-4421
    - ⏱ 2019-11-24 17:07:52 

- 📌 后进先出 ^22806916-46-830-834
    - ⏱ 2019-11-24 17:37:05 

- 📌 单查找 ^22806916-17-5887-5890
    - ⏱ 2019-11-22 21:17:48 

- 📌 缓存 ^22806916-36-6537-6539
    - ⏱ 2019-11-23 21:42:26 
## 6.4 实现图


- 📌 散列表 ^22806916-34-432-435
    - ⏱ 2021-08-30 00:43:29 

- 📌 键映射到值 ^22806916-44-602-607
    - ⏱ 2019-11-24 17:11:49 

- 📌 散列表是无序的，因此添加键—值对的顺序无关紧要。 ^22806916-44-2193-2217
    - ⏱ 2021-08-31 14:53:22 

- 📌 单向的 ^22806916-44-2334-2337
    - ⏱ 2019-11-24 17:14:08 

- 📌 Anuj是Bob的邻居，但Bob不是Anuj的邻居。无向图（undirectedgraph）没有箭头，直接相连的节点互为邻居。 ^22806916-44-2398-2518
    - ⏱ 2021-08-31 14:54:01 
## 6.5 实现算法


- 📌 弹出 ^22806916-45-752-754
    - ⏱ 2019-11-24 17:16:03 

- 📌 deque ^22806916-45-825-830
    - ⏱ 2019-11-24 17:19:51 

- 📌 所以，广度优先搜索的运行时间为O(人数+边数)，这通常写作O(V+E)，其中V为顶点（vertice）数，E为边数。 ^22806916-45-4715-4857
    - ⏱ 2021-08-31 15:07:10 

- 📌 这被称为拓扑排序，使用它可根据图创建一个有序列表。 ^22806916-45-6177-6230
    - ⏱ 2021-08-31 15:09:06 

- 📌 在家谱中，往上指的边不合情理！因为你父亲不可能是你祖父的父亲！ ^22806916-45-6598-6629
    - ⏱ 2021-08-31 15:09:19 

- 📌 特殊的图，其中没有往后指的边 ^22806916-45-6543-6557
    - ⏱ 2019-11-24 17:36:03 
## 6.6 小结


- 📌 最短路径。 ^22806916-46-485-490
    - ⏱ 2019-11-24 17:36:29 

- 📌 双向的 ^22806916-46-695-698
    - ⏱ 2019-11-24 17:36:53 

- 📌 找到的就不是最短路径 ^22806916-46-894-904
    - ⏱ 2019-11-24 17:37:31 

- 📌 务必不要再去检查 ^22806916-46-957-965
    - ⏱ 2019-11-24 17:37:43 
## 第7章 狄克斯特拉算法


- 📌 狄克斯特拉算法，让你能够找出加权图中前往X的最短路径 ^22806916-47-692-746
    - ⏱ 2021-08-31 17:54:46 

- 📌 段数最少 ^22806916-48-4216-4220
    - ⏱ 2019-11-24 22:18:44 

- 📌 狄克斯特拉算法 ^22806916-47-1444-1458
    - ⏱ 2019-11-24 22:03:50 
## 7.1 使用狄克斯特拉算法


- 📌 找出“最便宜”的节点，即可在最短时间内到达的节点 ^22806916-48-1067-1091
    - ⏱ 2021-08-31 20:14:41 

- 📌 邻居的开销 ^22806916-52-6626-6631
    - ⏱ 2019-11-25 11:32:01 

- 📌 每个节点都运行了狄克斯特拉算法（无需对终点这样做 ^22806916-48-3506-3530
    - ⏱ 2021-08-31 20:21:15 

- 📌 数字或权重 ^22806916-48-4241-4246
    - ⏱ 2019-11-24 22:18:51 

- 📌 特拉算法找出的是总权重最小的路径 ^22806916-48-4480-4496
    - ⏱ 2021-08-31 20:21:36 

- 📌 (1) 找出最便宜的节点，即可在最短时间内前往的节点。(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。(3) 重复这个过程，直到对图中的每个节点都这样做了。 ^22806916-48-4763-4914
    - ⏱ 2021-08-31 20:22:01 
## 7.2 术语


- 📌 介绍其他狄克斯特拉算法使用示例前，先来澄清一些术语。狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。[插图]带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。 ^22806916-49-382
    - ⏱ 2019-11-24 22:19:45 

- 📌 加权图（weighted graph） ^22806916-49-764-790
    - ⏱ 2019-11-24 22:25:05 

- 📌 非加权图 ^22806916-53-430-434
    - ⏱ 2019-11-25 10:29:49 

- 📌 非加权图（unweighted graph）。 ^22806916-49-820-850
    - ⏱ 2019-11-24 22:25:11 

- 📌 非加权图中的最短路径，可使用广度优先搜索 ^22806916-49-1088-1129
    - ⏱ 2021-08-31 20:47:12 

- 📌 绕环的路径不可能是最短的路径。 ^22806916-49-2320-2335
    - ⏱ 2019-11-24 22:37:07 

- 📌 两个节点彼此指向对方，其实就是环！ ^22806916-49-2589-2606
    - ⏱ 2019-11-24 22:37:22 

- 📌 狄克斯特拉算法只适用于 ^22806916-49-2989-3000
    - ⏱ 2021-08-31 20:49:29 

- 📌 有向无环图 ^22806916-49-2850-2862
    - ⏱ 2019-11-24 22:37:44 
## 7.3 换钢琴


- 📌 [插图]现在的表中包含低音吉他和架子鼓的开销。这些开销是用海报交换它们时需要支付的额外费用，因此父节点为海报。这意味着，要到达低音吉他，需要沿从海报出发的边前行，对架子鼓来说亦如此。[插图]再次执行第一步：下一个最便宜的节点是黑胶唱片——需要额外支付5美元。再次执行第二步：更新黑胶唱片的各个邻居的开销。 ^22806916-50-3076
    - ⏱ 2019-11-24 22:51:31 

- 📌 最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。 ^22806916-50-6331-6361
    - ⏱ 2021-08-31 20:52:02 
## 7.4 负权边


- 📌 ，不能将狄克斯特拉算法用于包含负权边的图。 ^22806916-51-3005-3054
    - ⏱ 2019-11-24 23:13:59 
## 7.5 实现


- 📌 节点的所有邻居都存储在散列表 ^22806916-52-1001-1015
    - ⏱ 2019-11-25 10:01:49 

- 📌 [插图]如何表示这些边的权重呢？为何不使用另一个散列表呢？graph["start"]={}graph["start"]["a"]=6graph["start"]["b"]=2 ^22806916-52-1176
    - ⏱ 2019-11-24 23:49:29 

- 📌 ["start"]["a"] ^22806916-52-1415-1429
    - ⏱ 2019-11-25 10:58:15 

- 📌 开销指的是从起点出发前往该节点需要多长时间 ^22806916-52-2630-2658
    - ⏱ 2019-11-25 10:12:34 

- 📌 为无穷大。 ^22806916-52-2737-2742
    - ⏱ 2019-11-25 10:06:59 

- 📌 记录处理过的节点 ^22806916-52-3585-3593
    - ⏱ 2019-11-25 11:09:05 

- 📌 起点前往该节点需要多长时间 ^22806916-52-4841-4854
    - ⏱ 2019-11-25 10:19:33 
## 8.1 教室调度问题


- 📌 但这正是贪婪算法的优点——简单易行！ ^22806916-55-2423-2441
    - ⏱ 2021-08-31 20:54:17 

- 📌 是你每步都选择局部最优解 ^22806916-55-2355-2388
    - ⏱ 2019-11-25 13:51:29 
## 8.2 背包问题


- 📌 ，完美是优秀的敌人 ^22806916-56-1861-1870
    - ⏱ 2019-11-25 13:55:50 

- 📌 找到一个能够大致解决问题的算法 ^22806916-56-1878-1893
    - ⏱ 2019-11-25 13:56:40 

- 📌 此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。 ^22806916-56-1989-2031
    - ⏱ 2021-08-31 22:29:40 
## 8.3 集合覆盖问题


- 📌 接近的解 ^22806916-57-2136-2140
    - ⏱ 2019-11-25 15:26:26 

- 📌 其中的键为广播台的名称，值为广播台覆盖的州。 ^22806916-57-4084-4106
    - ⏱ 2021-08-31 22:43:06 

- 📌 你需要遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台。 ^22806916-57-4413-4444
    - ⏱ 2021-08-31 22:44:34 

- 📌 states_covered是一个集合 ^22806916-57-4821-4840
    - ⏱ 2021-08-31 22:47:40 

- 📌 广播台覆盖的所有未覆盖的州。 ^22806916-57-4844-4858
    - ⏱ 2021-08-31 22:47:56 

- 📌 集合类似于列表，只是不能包含重复的元素 ^22806916-57-6397-6416
    - ⏱ 2019-11-26 23:23:38 
## 8.4 NP完全问题


- 📌 但如果要找出经由指定几个点的最短路径，就是旅行商问题——NP完全问题。简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。 ^22806916-58-6385-6455
    - ⏱ 2021-08-31 22:56:15 

- 📌 所有组合 ^22806916-58-6273-6277
    - ⏱ 2019-11-26 23:43:23 
## 9.1 背包问题


- 📌 每增加一件商品，需要计算的集合数都将翻倍！这种算法的运行时间为O(2n)， ^22806916-61-1337-1460
    - ⏱ 2021-08-31 23:20:37 

- 📌 态规划算法的工作原理。动态规划先解决子问题，再逐步解决大问题 ^22806916-61-1896-1926
    - ⏱ 2020-10-07 19:24:58 

- 📌 背包问题，你先解决小背包（子背包）问题 ^22806916-61-1958-1977
    - ⏱ 2021-08-31 23:24:46 

- 📌 你将填充其中的每个单元格，网格填满后，就找到了问题的答案！ ^22806916-61-2683-2712
    - ⏱ 2021-08-31 23:40:56 

- 📌 前面说过，动态规划从小问题着手，逐步解决大问题。 ^22806916-61-4092-4116
    - ⏱ 2021-08-31 23:41:43 

- 📌 你可以合并两个子问题的解来得到更大问题的解。 ^22806916-61-8317-8339
    - ⏱ 2019-11-26 23:56:34 
## 9.2 背包问题FAQ


- 📌 [插图]答案没有变化。也就是说，各行的排列顺序无关紧要。9.2.3 可以逐列而不是逐行填充网格吗自己动手试试吧！就这个问题而言，这没有任何影响，但对于其他问题，可能有影响。9.2.4 增加一件更小的商品将如何呢假设你还可以偷一条项链，它重0.5磅，价值1000美元。前面的网格都假设所有商品的重量为整数，但现在你决定把项链给偷了，因此余下的容量为3.5磅。在3.5磅的容量中，可装入的商品的最大价值是多少呢？不知道！因为你只计算了容量为1磅、2磅、3磅和4磅的背包可装下的商品的最大价值。 ^22806916-62-3101
    - ⏱ 2019-11-26 23:58:13 

- 📌 使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分。 ^22806916-62-4371-4414
    - ⏱ 2021-08-31 23:59:19 

- 📌 但使用贪婪算法可轻松地处理这种情况！ ^22806916-62-4443-4461
    - ⏱ 2021-08-31 23:59:22 

- 📌 但约束条件不是背包的容量，而是有限的时间； ^22806916-62-5515-5536
    - ⏱ 2021-08-31 23:59:49 

- 📌 但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 ^22806916-62-6744-6778
    - ⏱ 2021-09-01 00:00:49 

- 📌 但根据动态规划算法的设计，最多只需合并两个子背包， ^22806916-62-6952-6977
    - ⏱ 2021-09-01 00:01:09 

- 📌 完全可能。假设你还可以偷一颗钻石。这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 ^22806916-62-7306-7387
    - ⏱ 2021-09-01 00:01:28 
## 9.3 最长公共子串


- 📌 可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品 ^22806916-63-671-720
    - ⏱ 2021-08-31 23:56:19 

- 📌 每种动态规划解决方案都涉及网格。 ^22806916-63-885-901
    - ⏱ 2021-09-01 00:01:39 

- 📌 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。 ^22806916-63-1004-1048
    - ⏱ 2021-09-01 00:01:46 

- 📌 单元格中的值是什么？❑ 如何将这个问题划分为子问题？❑ 网格的坐标轴是什么？ ^22806916-63-1768-1866
    - ⏱ 2021-09-01 00:05:29 

- 📌 每个单元格都将包含这两个子串的最长公共子串的长度 ^22806916-63-2145-2169
    - ⏱ 2021-09-01 00:06:00 

- 📌 对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。 ^22806916-63-4767-4832
    - ⏱ 2021-09-01 00:17:15 

- 📌 编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。 ^22806916-63-7098-7152
    - ⏱ 2021-09-01 12:31:46 
## 10.1 橙子还是柚子


- 📌 种办法是看它的邻居。来看看离它最近的三个邻居。 ^22806916-66-1198-1221
    - ⏱ 2021-09-01 12:35:46 
# 读书笔记

## 第4章 快速排序

### 划线评论
- 📌 选择排序  ^11897562-7sV28xzyZ
    - 💭 选择排序 每次选择出最小的放在开头
    - ⏱ 2021-08-29 16:25:20
   
## 2.2 数组和链表

### 划线评论
- 📌 直接跳到第十个元素  ^11897562-7d4JdSztW
    - 💭 666666
    - ⏱ 2019-11-22 21:46:00

### 划线评论
- 📌 执行的插入操作很多，但读取操作很  ^11897562-7d4IS1W32
    - 💭 使用链表
    - ⏱ 2019-11-22 21:40:38

### 划线评论
- 📌 插入元素方  ^11897562-7d4IvzQ7b
    - 💭 优势可以
    - ⏱ 2019-11-22 21:35:06
   
## 3.4 小结

### 划线评论
- 📌 递归指的是调用自己的函数。  ^11897562-7d5yLYWsj
    - 💭 递归就是数学中迭代
    - ⏱ 2019-11-23 10:53:07
   
## 4.1 分而治之

### 划线评论
- 📌 找出列表中最大的数字。  ^11897562-7sViptBl7
    - 💭 def max_(lst):
  if len(lst) == 0:
    return None
  if len(lst) == 1:
    return lst[0]
  else:
    sub_max = max_(lst[1:])
    return lst[0] if lst[0] &gt; sub_max else sub_max

    - ⏱ 2021-08-29 20:33:48

### 划线评论
- 📌 还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗  ^11897562-7sVgndiDX
    - 💭 def recBinSearch(target, items, low, high):
    mid = (low+high) // 2
    guess = items[mid]
    if low &lt;= high:
        if guess == target:
            return mid
        elif guess &gt; target:
            return recBinSearch(target, items, low, mid-1)
        else:
            return recBinSearch(target, items, mid+1, high)
    else:
        return None

def search(items, target):  # items 列表 target 待查询的值
    return recBinSearch(target, items, 0, len(items) - 1)
    - ⏱ 2021-08-29 20:02:42

### 划线评论
- 📌 编写一个递归函数来计算列表包含的元素数。  ^11897562-7sV7Ikeni
    - 💭 // 计算列表元素个数
def lenList(list):
    if list == []:
        return 0
    else:
        return 1+lenList(list[1:])
print(lenList([1,2,3]))
#输出
3


    - ⏱ 2021-08-29 17:50:29

### 划线评论
- 📌 请编写前述sum函数的代码。  ^11897562-7sV7oYjCf
    - 💭 def sum(list):
    if len(list) == 1:
        return list[0]
    return list[0] +sum(list[1:])

print(sum([1,2,4]))
    - ⏱ 2021-08-29 17:45:43

### 划线评论
- 📌 别忘了，递归记录了状态  ^11897562-7d5Cjo9AL
    - 💭 怎么记录的
    - ⏱ 2019-11-23 11:47:09
   
## 4.2 快速排序

### 章节评论 No.1
- 快速排序是把数组中选一个基准，一般是数组中的第一个数，然后分为比这个基准小的子数组和比这个基准大的数组 最后把结果拼接起来就行了 ^11897562-7sVxs7Wvw
    - ⏱ 2021-08-30 00:23:29    
## 7.5 实现

### 划线评论
- 📌 [  ^11897562-7d8Cazr0p
    - 💭 嵌套字典
    - ⏱ 2019-11-25 11:05:00
   
# 本书评论
