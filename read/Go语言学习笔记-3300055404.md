---
doc_type: weread-highlights-reviews
bookId: "3300055404"
author: 雨痕
cover: https://cdn.weread.qq.com/weread/cover/7/cpplatform_ktikkvlm6pmo6x9pr1ju5w/t7_cpplatform_ktikkvlm6pmo6x9pr1ju5w1681438651.jpg
reviewCount: 15
noteCount: 144
isbn: 9787121291609
category: 计算机-计算机综合
lastReadDate: 2024-05-03
---
# 元数据
> [!abstract] Go语言学习笔记
> - ![ Go语言学习笔记|200](https://cdn.weread.qq.com/weread/cover/7/cpplatform_ktikkvlm6pmo6x9pr1ju5w/t7_cpplatform_ktikkvlm6pmo6x9pr1ju5w1681438651.jpg)
> - 书名： Go语言学习笔记
> - 作者： 雨痕
> - 简介： 作为时下流行的一种系统编程语言，Go 简单易学，性能很好，且支持各类主流平台。已有大量项目采用 Go 编写，这其中就包括 Docker 等明星作品，其开发和执行效率早已被证明。 本书经四年多逐步完善，内容覆盖了语言、运行时、性能优化、工具链等各层面知识。且内容经大量读者反馈和校对，没有明显的缺陷和错误。上卷细致解析了语言规范相关细节，便于读者深入理解语言相关功能的使用方法和注意事项。下卷则对运行时源码做出深度剖析，引导读者透彻了解语言功能背后的支持环境和运行体系，诸如内存分配、垃圾回收和并发调度等。 本书不适合编程初学入门，可供有实际编程经验或正在使用Go 工作的人群参考。
> - 出版时间 2016-06-01 00:00:00
> - ISBN： 9787121291609
> - 分类： 计算机-计算机综合
> - 出版社： 电子工业出版社

# 高亮划线

## 第2章 类型


- 📌 如显式提供初始化值，可省略变量类型，由编译器推断。 ^3300055404-7-982-1007
    - ⏱ 2024-04-14 13:30:15 

- 📌 依照惯例，建议以组方式整理多行变量定义。 ^3300055404-7-1279-1299
    - ⏱ 2024-04-14 13:30:48 

- 📌 简短模式(short variable declaration)有些限制： ^3300055404-7-1578-1615
    - ⏱ 2024-04-14 13:31:09 

- 📌 只能用在函数内部。 ^3300055404-7-1730-1739
    - ⏱ 2024-04-14 13:31:32 

- 📌 简短模式并不总是重新定义变量，也可能是部分退化的赋值操作 ^3300055404-7-2195-2223
    - ⏱ 2024-04-14 13:32:12 

- 📌 // 注意: x退化为赋值操作，仅有y是变量定义 ^3300055404-7-2315-2341
    - ⏱ 2024-04-14 13:32:21 

- 📌 退化赋值的前提条件是：最少有一个新变量被定义，且必须是同一作用域。 ^3300055404-7-2532-2565
    - ⏱ 2024-04-14 13:32:42 

- 📌 和Python类似，Go也有个名为“_”的特殊成员(blank identifier)。 ^3300055404-7-5494-5538
    - ⏱ 2024-04-14 13:36:18 

- 📌 使用常量就可用一个易于阅读理解的标识符号来代替“魔法数字” ^3300055404-7-5881-5910
    - ⏱ 2024-04-14 13:36:57 

- 📌 不同于变量在运行期分配存储内存（非优化状态），常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。 ^3300055404-7-9455-9507
    - ⏱ 2024-04-14 13:40:48 

- 📌 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址 ^3300055404-7-9825-9863
    - ⏱ 2024-04-14 13:40:58 

- 📌 标准库strconv可在不同进制（字符串）间转换。 ^3300055404-7-10980-11005
    - ⏱ 2024-04-14 13:42:21 

- 📌 当然，new函数也可为引用类型分配内存，但这是不完整创建。以字典(map)为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。import "fmt"func main() {    p := new(map[string]int)        // 函数new返回指针 ^3300055404-7-13662-13860
    - ⏱ 2024-04-26 00:49:25 

- 📌 通道等类型与具体元素类型或长度等属性有关 ^3300055404-7-16595-16615
    - ⏱ 2024-05-02 16:46:12 

- 📌 相同方法集（方法名、方法签名，不包括顺序）的接口(interface) ^3300055404-7-17147-17182
    - ⏱ 2024-05-02 16:46:37 
 
 
## 第3章 表达式


- 📌 25个保留关键字(keyword) ^3300055404-8-459-476
    - ⏱ 2024-05-02 17:20:56 

- 📌 另有一句话：“硬件的方向是物理，软件的结局是数学。” ^3300055404-8-1273-1299
    - ⏱ 2024-05-02 17:24:50 

- 📌 指针类型支持相等运算符，但不能做加减法运算和类型转换。 ^3300055404-8-5648-5675
    - ⏱ 2024-05-02 17:36:53 

- 📌 Pointer类似C语言中的void*万能指针，可用来转换指针类型 ^3300055404-8-6060-6093
    - ⏱ 2024-05-02 17:37:51 

- 📌 指针没有专门指向成员的“->”运算符，统一使用“.”选择表达式。 ^3300055404-8-6184-6219
    - ⏱ 2024-05-02 17:37:32 

- 📌 左花括号必须在类型尾部，不能另起一行。多个成员初始值以逗号分隔。允许多行，但每行须以逗号或右花括号结束。 ^3300055404-8-7084-7198
    - ⏱ 2024-05-02 17:40:28 

- 📌 if...else...条件表达式值必须是布尔类型，可省略括号，且左花括号不能另起一行。 ^3300055404-8-7952-8026
    - ⏱ 2024-05-02 17:41:37 

- 📌 可定义块局部变量或执行初始化函数。 ^3300055404-8-8268-8285
    - ⏱ 2024-05-02 17:41:49 

- 📌 死代码是指永远不会被执行的代码，可使用专门的工具，或用代码覆盖率(code coverage)测试进行检查。某些比较智能的编译器也可主动清除死代码(dead code elimination, DCE) ^3300055404-8-8940-9041
    - ⏱ 2024-05-02 17:42:21 

- 📌 不同的变化因素被分隔在各自独立单元（函数或模块）内，可避免修改时造成关联错误，减少患“肥胖症”的函数数量 ^3300055404-8-11057-11109
    - ⏱ 2024-05-02 17:46:38 

- 📌 ，最遗憾的是没有条件运算符“a>b?a:b”。有没有lambda无所谓，但没有这个却少了份优雅。加上一大堆err!=nil判断语句，对于有完美主义倾向的代码洁癖患者来说是种折磨。 ^3300055404-8-11308-11400
    - ⏱ 2024-05-02 17:47:17 

- 📌 条件表达式支持非常量值，这要比C更加灵活。相比if表达式，switch值列表要更加简洁 ^3300055404-8-11962-12005
    - ⏱ 2024-05-02 17:47:46 

- 📌 使用goto前，须先定义标签。标签区分大小写，且未使用的标签会引发编译错误。 ^3300055404-8-18225-18263
    - ⏱ 2024-05-02 21:24:59 

- 📌 不能跳转到其他函数，或内层代码块内 ^3300055404-8-18541-18558
    - ⏱ 2024-05-02 21:25:03 

- 📌 break：用于switch、for、select语句，终止整个语句块执行 ^3300055404-8-18950-18987
    - ⏱ 2024-05-02 21:25:36 

- 📌 continue：仅用于for循环，终止后续逻辑，立即进入下一轮循环。 ^3300055404-8-19019-19054
    - ⏱ 2024-05-02 21:25:41 

- 📌 配合标签， ^3300055404-8-19386-19391
    - ⏱ 2024-05-02 21:26:04 
## 第4章 函数


- 📌 不支持有默认值的可选参数，不支持命名实参 ^3300055404-9-4225-4245
    - ⏱ 2024-05-03 11:06:19 

- 📌 必须按签名顺序传递指定类型和数量的实参，就算以“_”命名的参数也不能忽略。 ^3300055404-9-4250-4287
    - ⏱ 2024-05-03 11:06:40 

- 📌 可视作函数局部变量，因此不能在相同层次定义同名变 ^3300055404-9-4538-4562
    - ⏱ 2024-05-03 11:07:02 

- 📌 形参是指函数定义中的参数，实参则是函数调用时所传递的参数。形参类似函数局部变量，而实参则是函数外部对象，可以是常量、变量、表达式或函数等。 ^3300055404-9-4786-4855
    - ⏱ 2024-05-03 11:07:15 

- 📌 变参本质上就是一个切片 ^3300055404-9-7319-7330
    - ⏱ 2024-05-03 15:10:46 
 
 

- 📌 只要改为显式return返回即可。 ^3300055404-9-9944-9961
    - ⏱ 2024-05-03 15:23:23 

- 📌 除遮蔽外，我们还必须对全部返回值命名，否则编译器会搞不清状况 ^3300055404-9-10189-10219
    - ⏱ 2024-05-03 15:24:14 

- 📌 匿名函数是指没有定义名字符号的函数 ^3300055404-9-10631-10648
    - ⏱ 2024-05-03 15:22:28 

- 📌 赋值给变量： ^3300055404-9-10914-10920
    - ⏱ 2024-05-03 15:25:43 

- 📌 作为参数： ^3300055404-9-11068-11073
    - ⏱ 2024-05-03 15:25:46 

- 📌 作为返回值： ^3300055404-9-11231-11237
    - ⏱ 2024-05-03 15:25:50 

- 📌 匿名函数赋值给变量，与为普通函数提供名字标识符有着根本的区别。当然，编译器会为匿名函数生成一个“随机”符号名。 ^3300055404-9-11445-11500
    - ⏱ 2024-05-03 15:26:02 

- 📌 闭包(closure)是在其词法上下文中引用了自由变量的函数 ^3300055404-9-12481-12511
    - ⏱ 2024-05-03 15:28:30 

- 📌 test返回的匿名函数会引用上下文环境变量x ^3300055404-9-12782-12804
    - ⏱ 2024-05-03 15:28:57 

- 📌 。所以说，闭包是函数和引用环境的组合体更加确切。 ^3300055404-9-13266-13290
    - ⏱ 2024-05-03 15:29:47 

- 📌 正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延 ^3300055404-9-13597-13626
    - ⏱ 2024-05-03 15:32:05 

- 📌 for循环复用局部变量i，那么每次添加的匿名函数引用的自然是同一变量 ^3300055404-9-14126-14160
    - ⏱ 2024-05-03 15:34:09 

- 📌 添加操作仅仅是将匿名函数放入列表，并未执行 ^3300055404-9-14161-14182
    - ⏱ 2024-05-03 15:35:12 

- 📌 因此，当main执行这些函数时，它们读取的是环境变量i最后一次循环时的值。不是2 ^3300055404-9-14183-14223
    - ⏱ 2024-05-03 15:34:45 

- 📌 解决方法就是每次用不同的环境变量或传参复制， ^3300055404-9-14259-14281
    - ⏱ 2024-05-03 15:35:34 

- 📌 让各自闭包环境各不相同。 ^3300055404-9-14281-14293
    - ⏱ 2024-05-03 15:35:39 

- 📌 闭包让我们不用传递参数就可读取或修改环境状态，当然也要为此付出额外代价。对于性能要求较高的场合，须慎重使用 ^3300055404-9-15091-15144
    - ⏱ 2024-05-03 15:36:04 

- 📌 参数值在注册时被复制并缓存起来。如对状态敏感，可改用指针或闭包。 ^3300055404-9-15579-15611
    - ⏱ 2024-05-03 15:44:47 

- 📌 延迟调用可修改当前函数命名返回值，但其自身返回值被抛弃。 ^3300055404-9-15996-16024
    - ⏱ 2024-05-03 15:47:59 

- 📌 多个延迟注册按FILO次序执行。 ^3300055404-9-16053-16069
    - ⏱ 2024-05-03 15:48:45 

- 📌 通过插入额外指令来实现延迟调用执行 ^3300055404-9-16231-16248
    - ⏱ 2024-05-03 15:49:09 

- 📌 延迟调用在函数结束时才被执行 ^3300055404-9-16782-16796
    - ⏱ 2024-05-03 15:59:01 

- 📌 与errors.New类似的还有fmt.Errorf，它返回一个格式化内容的错误对象。 ^3300055404-9-19676-19719
    - ⏱ 2024-05-03 16:02:30 

- 📌 另外，recover必须在延迟调用函数中执行才能正常工作。 ^3300055404-9-22617-22646
    - ⏱ 2024-05-03 16:22:33 

- 📌 那么只能将其重构为函数调用。 ^3300055404-9-23045-23059
    - ⏱ 2024-05-03 16:32:42 

- 📌 例如：文件系统没有操作权限，服务端口被占用，数据库未启动等情况。 ^3300055404-9-24039-24071
    - ⏱ 2024-05-03 16:35:45 
## 第5章 数据


- 📌 字符串是不可变字节(byte)序列，其本身是一个复合结构。 ^3300055404-10-453-482
    - ⏱ 2024-05-03 16:36:41 
 

- 📌 字符串默认值不是nil，而是""。 ^3300055404-10-972-989
    - ⏱ 2024-05-03 16:38:26 

- 📌 使用“`”定义不做转义处理的原始字符串(raw string)，支持跨行。 ^3300055404-10-1189-1226
    - ⏱ 2024-05-03 16:38:39 

- 📌 以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。 ^3300055404-10-1868-1902
    - ⏱ 2024-05-03 16:39:28 
 

- 📌 要修改字符串，须将其转换为可变类型（[ ]rune或[ ]byte）， ^3300055404-10-3088-3123
    - ⏱ 2024-05-03 16:46:02 

- 📌 该方法利用了[ ]byte和string头结构“部分相同”，以非安全的指针类型转换来实现类型“变更”，从而避免了底层数组复制。在很多WebFramework中都能看到此类做法，在高并发压力下，此种做法能有效改善执行性能。只是使用unsafe存在一定的风险，须小心谨慎！ ^3300055404-10-4308-4443
    - ⏱ 2024-05-03 16:48:04 

- 📌 用append函数，可将string直接追加到[ ]byte内。 ^3300055404-10-4472-4504
    - ⏱ 2024-05-03 16:49:12 

- 📌 编译器对“s1 + s2 + s3”这类表达式的处理方式和strings.Join类似。 ^3300055404-10-7452-7496
    - ⏱ 2024-05-03 17:52:23 

- 📌 数量较少的字符串格式化拼接，可使用fmt.Sprintf ^3300055404-10-7930-7958
    - ⏱ 2024-05-03 17:52:42 

- 📌 存储Unicode码点 ^3300055404-10-8201-8212
    - ⏱ 2024-05-03 17:52:52 

- 📌 除验证函数外，还可用RuneCountInString代替len返回准确的Unicode字符数量。 ^3300055404-10-9109-9158
    - ⏱ 2024-05-03 17:55:29 

- 📌 对于结构等复合类型，可省略元素初始化类型标签。 ^3300055404-10-10197-10220
    - ⏱ 2024-05-03 17:59:08 

- 📌 在定义多维数组时，仅第一维度允许使用“...”。 ^3300055404-10-10611-10635
    - ⏱ 2024-05-03 17:59:29 

- 📌 内置函数len和cap都返回第一维度长度。 ^3300055404-10-11245-11266
    - ⏱ 2024-05-03 17:59:54 
 

- 📌 可通过unsafe.Pointer转换不同长度的数组指针来实现越界访问，或使用参数gcflags "-B"阻止编译器插入检查指令 ^3300055404-10-12828-12892
    - ⏱ 2024-05-03 18:02:52 

- 📌 Go数组是值类型 ^3300055404-10-13015-13023
    - ⏱ 2024-05-03 18:03:11 

- 📌 切片(slice)本身并非动态数组或数组指针 ^3300055404-10-13865-13887
    - ⏱ 2024-05-03 18:04:28 

- 📌 内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内 ^3300055404-10-13889-13923
    - ⏱ 2024-05-03 18:04:36 

- 📌 切片本身是个只读对象，其工作机制类似数组指针的一种包装。 ^3300055404-10-14048-14076
    - ⏱ 2024-05-03 18:04:48 

- 📌 属性cap表示切片所引用数组片段的真实长度，len用于限定可读的写元素数量。 ^3300055404-10-14656-14694
    - ⏱ 2024-05-03 18:11:46 

- 📌 创建切片对象 ^3300055404-10-15232-15238
    - ⏱ 2024-05-03 18:14:22 

- 📌 须使用make函数或显式初始化语句，它会自动完成底层数组内存分配。 ^3300055404-10-15256-15289
    - ⏱ 2024-05-03 18:14:28 

- 📌 前者仅定义了一个[ ]int类型变量，并未执行初始化操作，而后者则用初始化表达式完成了全部创建过程。 ^3300055404-10-15898-15948
    - ⏱ 2024-05-03 18:15:46 

- 📌 变量b的内部指针被赋值，尽管它指向runtime.zerobase，但它依然完成了初始化操作。 ^3300055404-10-16630-16677
    - ⏱ 2024-05-03 18:16:00 

- 📌 另外，a == nil，仅表示它是个未初始化的切片对象，切片本身依然会分配所需内存。可以直接对nil切片执行slice[:]操作，同样返回nil。 ^3300055404-10-16708-16781
    - ⏱ 2024-05-03 18:16:09 

- 📌 可获取元素地址，但不能向数组那样直接用指针访问元素内容。 ^3300055404-10-17035-17063
    - ⏱ 2024-05-03 18:16:29 

- 📌 如果元素类型也是切片，那么就可实现类似交错数组(jagged array)功能。 ^3300055404-10-17512-17552
    - ⏱ 2024-05-03 18:21:49 

- 📌 并非所有时候都适合用切片代替数组， ^3300055404-10-17957-17974
    - ⏱ 2024-05-03 18:22:41 

- 📌 新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见。 ^3300055404-10-19090-19122
    - ⏱ 2024-05-03 18:24:24 

- 📌 数据被追加到原底层数组。如超出cap限制，则为新切片对象重新分配数组。 ^3300055404-10-21332-21367
    - ⏱ 2024-05-03 18:25:54 

- 📌 是超出切片cap限制，而非底层数组长度限制，因为cap可小于数组长度。 ^3300055404-10-22024-22059
    - ⏱ 2024-05-03 18:27:00 

- 📌 是原cap的2倍，而非原数组的2倍。 ^3300055404-10-22097-22115
    - ⏱ 2024-05-03 18:27:13 

- 📌 并非总是2倍，对于较大的切片，会尝试扩容1/4，以节约内存 ^3300055404-10-22146-22175
    - ⏱ 2024-05-03 18:27:19 

- 📌 正因为存在重新分配底层数组的缘故，在某些场合建议预留足够多的空间，避免中途内存分配和数据复制开销。 ^3300055404-10-22408-22457
    - ⏱ 2024-05-03 18:27:36 

- 📌 还可直接从字符串中复制数据到[ ]byte。 ^3300055404-10-23021-23043
    - ⏱ 2024-05-03 18:28:25 

- 📌 如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收。 ^3300055404-10-23239-23291
    - ⏱ 2024-05-03 18:31:38 

- 📌 字典（哈希表 ^3300055404-10-23381-23387
    - ⏱ 2024-05-03 18:32:56 

- 📌 作为无序键值对集合，字典要求key必须是支持相等运算符(==、!=)的数据类型 ^3300055404-10-23464-23503
    - ⏱ 2024-05-03 18:33:10 

- 📌 make函数或初始化表达语句 ^3300055404-10-23572-23586
    - ⏱ 2024-05-03 18:33:33 

- 📌 访问不存在的键值，默认返回零值，不会引发错误。但推荐使用ok-idiom模式，毕竟通过零值无法判断键值是否存在，或许存储的value本就是零。 ^3300055404-10-24265-24336
    - ⏱ 2024-05-03 18:35:46 

- 📌 字典被设计成“not addressable”，故不能直接修改value成员（结构或数组） ^3300055404-10-24941-24986
    - ⏱ 2024-05-03 22:24:13 

- 📌 能对nil字典进行写操作，但却能读。 ^3300055404-10-25758-25776
    - ⏱ 2024-05-03 22:25:51 

- 📌 / 已初始化，等同make操作 ^3300055404-10-26085-26102
    - ⏱ 2024-05-03 22:26:49 

- 📌 运行时会对字典并发操作做出检测。如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃。 ^3300055404-10-27040-27111
    - ⏱ 2024-05-03 22:27:33 

- 📌 另外，字典不会收缩内存，所以适当替换成新对象是必要的。 ^3300055404-10-30301-30328
    - ⏱ 2024-05-03 22:29:53 

- 📌 / 定义匿名结构类型字段 ^3300055404-10-31468-31482
    - ⏱ 2024-05-03 22:33:02 

- 📌 可使用指针直接操作结构字段，但不能是多级指针。 ^3300055404-10-32293-32316
    - ⏱ 2024-05-03 22:34:08 

- 📌 这只是隐式地以类型名作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段。func main() { ^3300055404-10-34131-34202
    - ⏱ 2024-05-03 22:36:23 

- 📌 不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。 ^3300055404-10-35404-35433
    - ⏱ 2024-05-03 22:38:16 

- 📌 可用接口来实现一些类似操作，但其本质是完全不同的。 ^3300055404-10-36588-36613
    - ⏱ 2024-05-03 22:39:22 
## 第6章 方法


- 📌 方法是与对象实例绑定的特殊函数 ^3300055404-11-452-467
    - ⏱ 2024-05-03 22:42:29 

- 📌 方法是有关联状态的，而函数通常没有。 ^3300055404-11-608-626
    - ⏱ 2024-05-03 22:43:01 

- 📌 可以为当前包，以及除接口和指针以外的任何类型定义方法。 ^3300055404-11-769-796
    - ⏱ 2024-05-03 22:43:45 

- 📌 大对象建议用*T，以减少复制成本。引用类型、字符串、函数等指针包装对象，直接用T。若包含Mutex等同步字段，用*T，避免因复制造成锁操作无效。其他无法确定的情况， ^3300055404-11-3076-3251
    - ⏱ 2024-05-03 22:46:01 

- 📌 类型T方法集包含所有receiver T方法。类型*T方法集包含所有receiver T + *T方法 ^3300055404-11-4236-4318
    - ⏱ 2024-05-03 22:47:50 

- 📌 匿名嵌入S，T方法集包含所有receiver S方法。 ^3300055404-11-4350-4377
    - ⏱ 2024-05-03 22:48:05 

- 📌 匿名嵌入*S，T方法集包含所有receiver S + *S方法。 ^3300055404-11-4408-4441
    - ⏱ 2024-05-03 22:48:11 

- 📌 匿名嵌入S或*S，*T方法集包含所有receiver S + *S方法 ^3300055404-11-4472-4507
    - ⏱ 2024-05-03 22:48:18 

- 📌 很显然，匿名字段就是为方法集准备的。否则，完全没必要为少写个字段名而大费周章 ^3300055404-11-6174-6212
    - ⏱ 2024-05-03 22:49:53 

- 📌 面向对象的三大特征“封装”、“继承”和“多态”，Go仅实现了部分特征，它更倾向于“组合优于继承”这种思想。将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入方式组合到一起，共同实现对外接口。而且其简短一致的调用方式，更是隐藏了内部实现细节。 ^3300055404-11-6242-6372
    - ⏱ 2024-05-03 22:50:26 

- 📌 尽管接口也是多态的一种实现形式，但我认为应该和基于继承体系的多态分离开来。 ^3300055404-11-6496-6533
    - ⏱ 2024-05-03 22:50:47 
## 第7章 接口


- 📌 在某些动态语言里，接口(interface)也被称作协议(protocol)。准备交互的双方， ^3300055404-12-503-550
    - ⏱ 2024-05-03 22:53:31 

- 📌 接口最常见的使用场景，是对包外提供访问，或预留扩展空间。 ^3300055404-12-742-770
    - ⏱ 2024-05-03 22:54:00 

- 📌 不能有字段。不能定义自己的方法。只能声明方法，不能实现。可嵌入其他接口类型。 ^3300055404-12-1207-1338
    - ⏱ 2024-05-03 22:55:06 

- 📌 如果接口没有任何方法声明，那么就是一个空接口(interface{})，它的用途类似面向对象里的根类型Object，可被赋值为任何类型的对象 ^3300055404-12-1918-1988
    - ⏱ 2024-05-03 22:56:14 

- 📌 / 超级转换为子集 ^3300055404-12-3167-3178
    - ⏱ 2024-05-03 22:58:40 

- 📌 除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。 ^3300055404-12-5476-5511
    - ⏱ 2024-05-03 23:00:22 

- 📌 然无法对iface.data赋值。解决方法就是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。 ^3300055404-12-6320-6371
    - ⏱ 2024-05-03 23:02:02 

- 📌 fallthrought。 ^3300055404-12-9495-9508
    - ⏱ 2024-05-03 23:06:00 
## 第8章 并发


- 📌 第8章　并发8.1 并发的含义在开始本章之前，需要了解并发(concurrency)和并行(parallesim)的区别。并发：逻辑上具备同时处理多个任务的能力。并行：物理上在同一时刻执行多个并发任务。我们通常会说程序是并发设计的，也就是说它允许多个任务同时执行，但实际上并不一定真在同一时刻发生。在单核处理器上，它们能以间隔方式切换执行。而并行则依赖多核处理器等物理设备，让多个任务真正在同一时刻执行，它代表了当前程序运行状态。简单点说，并行是并发设计的理想执行模式。Concurrency is not parallelism: Different concurrent designs enable different ways to parallelize.多线程或多进程是并行的基本条件，但单线程也可用协程(coroutine)做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，但它也有自己的优势。除了将因阻塞而浪费的时间找回来外，还免去了线程切换开销，有着不错的执行效率。协程上运行的多个任务本质上是依旧串行的，加上可控自主调度，所以并不需要做同步处理。 ^3300055404-13-355
    - ⏱ 2024-05-03 23:43:56 

- 📌 多线程或多进程是并行的基本条件，但单线程也可用协程(coroutine) ^3300055404-13-924-960
    - ⏱ 2024-05-03 23:44:46 

- 📌 尽管协程在单个线程上通过主动切换来实现多任务并 ^3300055404-13-965-988
    - ⏱ 2024-05-03 23:45:00 

- 📌 即便采用多线程也未必就能并行。Python就因GIL限制，默认只能并发而不能并行，所以很多时候转而使用“多进程+协程”架构 ^3300055404-13-1110-1171
    - ⏱ 2024-05-03 23:45:42 

- 📌 用协程来提高处理器时间片利用率。 ^3300055404-13-1278-1294
    - ⏱ 2024-05-03 23:46:07 

- 📌 。这更像是多线程和协程的综合体，能最大限度提升执行效率， ^3300055404-13-1381-1409
    - ⏱ 2024-05-03 23:46:24 
# 读书笔记

## 上卷 语言详解 基于Go 1.6

### 划线评论
- 📌 阻塞，直到消费者发回结束信号  ^11897562-7QrBfcqvd
    - 💭 这里是啥意思
    - ⏱ 2024-04-14 13:27:06
   
## 第2章 类型

### 划线评论
- 📌 未命名类型转换规则：  ^11897562-7QTcCLgpg
    - 💭 不太懂
    - ⏱ 2024-05-02 16:57:58

### 划线评论
- 📌 被忽视的是struct tag，它也属于类型组成部分  ^11897562-7QTbWRt0c
    - 💭 struct tag `x`
    - ⏱ 2024-05-02 16:47:38

### 划线评论
- 📌 符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用，而小写则仅能在包内使用  ^11897562-7QTbI4U0c
    - 💭 首字母大写为导出成员，可被外包引用。小写只能在包内使用
    - ⏱ 2024-05-02 16:44:00
   
## 第4章 函数

### 划线评论
- 📌 字面量里允许使用十六进制、八进制和UTF编码格式  ^11897562-7QUHCSqjk
    - 💭 例如 s := "你好\x61\142\u0041"
    - ⏱ 2024-05-03 16:38:00

### 划线评论
- 📌 连续调用panic，仅最后一个会被recover捕获。  ^11897562-7QUGztdjC
    - 💭 panic("i am dead") // 这里执行了，但是因为先执行了，所以没有被recover 捕获到，所以不会打印
    - ⏱ 2024-05-03 16:21:53

### 划线评论
- 📌 有关defer更详细的分析，请阅读下卷《源码剖析》  ^11897562-7QUF3UFJZ
    - 💭 在test函数中：

命名返回值z被隐式初始化为int类型的零值，即0。
return 100语句执行，此时z的值被设置为100。
由于return会触发defer语句的执行，所以注册的匿名函数（defer body）被调用。
在匿名函数中，首先执行println("defer:", z)，此时z的值为100，因为在return语句中已经设置了z的值为100。
紧接着，匿名函数中修改了z的值，z += 100将z的值更新为200。重要的是，这个修改是有效的，因为命名返回值在函数结束前就已经存在，并且可以被修改。
匿名函数执行完毕，defer结束。
test函数返回，此时z的最终值为200。
    - ⏱ 2024-05-03 15:58:51

### 划线评论
- 📌 如果是数组，先将其转换为切片。  ^11897562-7QUC2Ehbo
    - 💭 通过a[:] 将原本a数组转化为slice
    - ⏱ 2024-05-03 15:12:44

### 划线评论
- 📌 只能接收一到多个同类型参数，且必须放在列表尾部。  ^11897562-7QUBXuq05
    - 💭 变参为 a... int
    - ⏱ 2024-05-03 15:11:27
   
## 第5章 数据

### 划线评论
- 📌 的是指针，可透过指针修改目标对象  ^11897562-7QV4ngiK0
    - 💭 是的
    - ⏱ 2024-05-03 22:25:20

### 划线评论
- 📌 数组指针可直接用来操作元素。  ^11897562-7QUOoBI1O
    - 💭 slice 不能指针之后取对应元素 
    - ⏱ 2024-05-03 18:21:22

### 划线评论
- 📌 另外，数组必须addressable，否则会引发错误。  ^11897562-7QUNUrp8y
    - 💭 m["a"] 取出了映射 m 中键为 "a" 的值，即一个 [2]int 类型的数组。由于这个值是从映射中取出的，它是不可寻址的。接着，代码尝试对这个值进行切片操作 [:]，这是不允许的，因为切片操作要求操作数是可寻址的。
    - ⏱ 2024-05-03 18:13:56

### 划线评论
- 📌 可基于数组或数组指针创建切片，以开始和结束索引位置确定所引用的数组片段。  ^11897562-7QUNIPbQV
    - 💭 X[2:5:7] cap = max - low
    - ⏱ 2024-05-03 18:11:04

### 划线评论
- 📌 要知道字符串存储的字节数组，不一定就是合法的UTF-8文本。  ^11897562-7QUMJhf8V
    - 💭 utf8.isval
    - ⏱ 2024-05-03 17:55:55

### 划线评论
- 📌 使用for遍历字符串时，分byte和rune两种方式。  ^11897562-7QUI74ANO
    - 💭 使用for循环遍历是 byte, 使用for range 遍历是rune, rune可以显示汉字
    - ⏱ 2024-05-03 16:45:26
   
# 本书评论
