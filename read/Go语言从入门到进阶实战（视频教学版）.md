---
doc_type: weread-highlights-reviews
bookId: "22370672"
author: 徐波
cover: https://cdn.weread.qq.com/weread/cover/69/YueWen_22370672/t7_YueWen_22370672.jpg
reviewCount: 3
noteCount: 175
isbn: 9787111598244
category: 计算机-编程设计
lastReadDate: 2020-06-25
---
# 元数据
> [!abstract] Go语言从入门到进阶实战（视频教学版）
> - ![ Go语言从入门到进阶实战（视频教学版）|200](https://cdn.weread.qq.com/weread/cover/69/YueWen_22370672/t7_YueWen_22370672.jpg)
> - 书名： Go语言从入门到进阶实战（视频教学版）
> - 作者： 徐波
> - 简介： Go语言简单易学，学习曲线平缓，不需要像C/C++语言动辄需要两到三年的学习期。Go语言被称为“互联网时代的C语言”。互联网的短、频、快特性在Go语言中体现得淋漓尽致。一个熟练的开发者只需要短短的一周时间就可以从学习阶段转到开发阶段，并完成一个高并发的服务器开发。面对Go语言的普及和学习热潮，本书使用浅显易懂的语言，介绍了GO语言从基础的语法知识到并发和接口等新特性知识，从而带领读者迅速熟悉这门新时代的编程语言。
> - 出版时间 2018-05-01 00:00:00
> - ISBN： 9787111598244
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社

# 高亮划线

## 1.1 Go语言特性


- 📌 编译型并自带垃圾回收 ^22370672-13-450-460
    - ⏱ 2020-05-30 23:22:09 

- 📌 不需要的表达式括号 ^22370672-13-535-544
    - ⏱ 2020-05-30 23:22:22 

- 📌 goroutine ^22370672-13-633-634
    - ⏱ 2020-05-30 23:22:32 

- 📌 因此熟悉C语言及其派生语言（C++、C#、Objective-C等）的人都会迅速熟悉这门语言 ^22370672-13-8798-8844
    - ⏱ 2020-05-30 23:26:34 

- 📌 其他样式的括号将被视为代码编译错误 ^22370672-13-9655-9672
    - ⏱ 2020-05-30 23:27:10 
## 2.1 变量


- 📌 浮点切片表示由多个浮点类型组成的数据结构。 ^22370672-18-1152-1173
    - ⏱ 2020-05-30 22:34:55 

- 📌 一个返回值为布尔类型的函数变量 ^22370672-18-1211-1226
    - ⏱ 2020-05-30 22:35:09 

- 📌 var关键字 ^22370672-18-1374-1380
    - ⏱ 2020-05-30 22:35:33 

- 📌 的默认为nil ^22370672-18-2307-2312
    - ⏱ 2020-05-30 22:37:50 

- 📌 对应“烫”和“屯”字。 ^22370672-18-2728-2739
    - ⏱ 2020-05-30 22:38:35 

- 📌 编译器会尝试根据等号右边的表达式推导hp变量的类型 ^22370672-18-3309-3334
    - ⏱ 2020-04-30 16:38:51 

- 📌 编译原理里被称做“右值” ^22370672-18-3417-3429
    - ⏱ 2020-05-30 22:39:14 

- 📌 短变量声明并初始化 ^22370672-18-4465-4474
    - ⏱ 2020-04-30 16:39:52 

- 📌 由于使用了“:=”，而不是赋值的“=” ^22370672-18-4714-4733
    - ⏱ 2020-04-30 16:40:05 

- 📌 因此，短变量声明并初始化的格式在开发中使用比较普遍。 ^22370672-18-5397-5423
    - ⏱ 2020-04-30 16:41:54 

- 📌 至少有一个新声明的变量 ^22370672-18-5515-5526
    - ⏱ 2020-05-30 22:49:59 

- 📌 “_”下画线 ^22370672-18-7314-7320
    - ⏱ 2020-05-30 22:50:50 

- 📌 匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。 ^22370672-18-7850-7895
    - ⏱ 2020-05-30 22:51:36 

- 📌 匿名变量也被叫做哑元变量 ^22370672-18-7985-7997
    - ⏱ 2020-05-30 22:51:39 
## 2.2 数据类型


- 📌 整型、浮点型、布尔型、字符串外，还有切片、结构体、函数、map、通道（channel） ^22370672-19-459-502
    - ⏱ 2020-05-30 22:51:58 

- 📌 map和切片是开发中常见的数据容器类型， ^22370672-19-741-761
    - ⏱ 2020-05-30 22:52:32 

- 📌 可以使用fmt包配合动词“%f ^22370672-19-2257-2272
    - ⏱ 2020-05-30 22:53:43 

- 📌 按默认宽度，2位精度输出 ^22370672-19-2620-2632
    - ⏱ 2020-05-30 22:53:51 

- 📌 由math包提供 ^22370672-19-2807-2815
    - ⏱ 2020-05-30 22:54:13 

- 📌 将双引号和反斜杠“\”进行转义。 ^22370672-19-7992-8008
    - ⏱ 2020-05-30 22:59:47 

- 📌 定义多行字符串 ^22370672-19-8577-8584
    - ⏱ 2020-05-30 23:00:32 

- 📌 两个反引号间的字符串将被原样赋值到str变量中。 ^22370672-19-8930-8954
    - ⏱ 2020-05-30 23:05:18 

- 📌 但是所有的转义字符均无效，文本将会原样输出。 ^22370672-19-9008-9030
    - ⏱ 2020-05-30 23:05:39 

- 📌 有代码均不会被编译器识别，而只是作为字符串的一部分。 ^22370672-19-9766-9792
    - ⏱ 2020-05-30 23:05:53 

- 📌 “字符” ^22370672-19-9904-9908
    - ⏱ 2020-05-30 23:06:04 

- 📌 另一种是rune类型，代表一个UTF-8字符。当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 ^22370672-19-10072-10144
    - ⏱ 2020-05-30 23:06:48 

- 📌 “%T”动词 ^22370672-19-10187-10193
    - ⏱ 2020-05-30 23:06:21 

- 📌 相同类型元素的可变长度的序列。 ^22370672-19-11459-11474
    - ⏱ 2020-05-30 23:07:55 

- 📌 切片的元素使用“[]”进行访问 ^22370672-19-11611-11626
    - ⏱ 2020-05-30 23:10:21 

- 📌 量为3的整型切片 ^22370672-19-11841-11849
    - ⏱ 2020-05-30 23:11:21 
## 2.3 转换不同的数据类型


- 📌 前置加括号的方式进行类型转换 ^22370672-20-453-467
    - ⏱ 2020-05-30 23:17:14 
## 2.4 指针


- 📌 指针类型的数据 ^22370672-21-501-508
    - ⏱ 2020-05-30 23:33:04 

- 📌 Go语言的指针类型变量拥有指针的高效访问 ^22370672-21-643-663
    - ⏱ 2020-05-30 23:33:22 

- 📌 指针地址、指针类型和指针取值 ^22370672-21-1254-1268
    - ⏱ 2020-05-30 23:34:01 

- 📌 输出cat和str变量取地址后的指针值，指针值带有“0x”的十六进制前缀。 ^22370672-21-2091-2128
    - ⏱ 2020-05-30 23:35:22 

- 📌 ：每个变量都拥有地址，指针的值就是地址。 ^22370672-21-2422-2442
    - ⏱ 2020-05-30 23:35:41 

- 📌 可以对指针使用“*”操作，也就是指针取值 ^22370672-21-2590-2610
    - ⏱ 2020-05-30 23:35:54 

- 📌 通过指针不仅可以取值 ^22370672-21-4298-4308
    - ⏱ 2020-05-31 16:35:04 

- 📌 a指向的变量 ^22370672-21-5137-5143
    - ⏱ 2020-05-31 16:36:12 

- 📌 “*”操作符作为右值时，意义是取指针的值；作为左值时，也就是放在赋值操作符的左边时，表示a指向的变量。 ^22370672-21-5399-5450
    - ⏱ 2020-05-31 16:36:31 

- 📌 创建指针的另一种方法——new()函数 ^22370672-21-7737-7757
    - ⏱ 2020-05-31 16:41:56 
## 2.5 变量生命期——变量能够使用的代码范围


- 📌 栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出 ^22370672-22-1255-1303
    - ⏱ 2020-05-31 16:43:03 

- 📌 变量和栈有什么关系 ^22370672-22-1369-1378
    - ⏱ 2020-05-31 16:44:15 

- 📌 堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。 ^22370672-22-2645-2701
    - ⏱ 2020-05-31 16:46:06 

- 📌 比如，函数局部变量尽量使用栈 ^22370672-22-2913-2927
    - ⏱ 2020-05-31 16:46:27 

- 📌 Go语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆上的问题。 ^22370672-22-6513-6548
    - ⏱ 2020-05-31 16:52:45 
## 2.6 字符串应用


- 📌 len() ^22370672-23-696-701
    - ⏱ 2020-05-31 17:11:47 

- 📌 每个中文占用3个字节，因此使用len()获得两个中文文字对应的6个字节。 ^22370672-23-1150-1186
    - ⏱ 2020-05-31 17:12:15 

- 📌 RuneCount In String()函数，统计Uncode字符数量。 ^22370672-23-1251-1289
    - ⏱ 2020-05-31 17:12:32 

- 📌 ASCII字符串长度使用len()函数。● Unicode字符串长度使用utf8.Rune Count In String()函数 ^22370672-23-1672-1766
    - ⏱ 2020-05-31 17:14:16 

- 📌 ASCII字符串遍历直接使用下标。● Unicode字符串遍历用for range。 ^22370672-23-3028-3099
    - ⏱ 2020-05-31 17:24:24 

- 📌 直接修改每一个字符元素 ^22370672-23-4504-4515
    - ⏱ 2020-05-31 17:36:52 

- 📌 ，将字符串转为字符串数组 ^22370672-23-4868-4880
    - ⏱ 2020-05-31 17:39:44 

- 📌 如天生线程安全，大家使用的都是只读对象，无须加锁；再者，方便内存共享，而不必使用写时复制 ^22370672-23-5211-5255
    - ⏱ 2020-05-31 17:40:04 

- 📌 代码中实际修改的是[]byte，[]byte在Go语言中是可变的，本身就是一个切片。 ^22370672-23-5324-5366
    - ⏱ 2020-05-31 17:40:13 

- 📌 ，Go语言和大多数其他语言一样，使用“+”对字符串进行连接操作，非常直观。 ^22370672-23-5766-5803
    - ⏱ 2020-05-31 17:41:10 

- 📌 String Builder的机制来进行高效的字符串连接 ^22370672-23-5877-5905
    - ⏱ 2020-05-31 17:41:21 

- 📌 动词以%开头 ^22370672-23-6588-6594
    - ⏱ 2020-05-31 17:42:10 
## 2.7 常量——恒定不变的值


- 📌 常量是恒定不变的值，例如圆周率。 ^22370672-24-453-469
    - ⏱ 2020-05-31 17:47:15 

- 📌 多个变量可以一起声明，类似的，常量 ^22370672-24-736-753
    - ⏱ 2020-05-31 17:50:25 
## 第3章 容器：存储和组织数据的方式


- 📌 创建，删除，维护内存 ^22370672-26-622-632
    - ⏱ 2020-05-31 18:37:20 

- 📌 详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。 ^22370672-26-1038-1073
    - ⏱ 2020-05-31 18:37:50 
## 3.1 数组——固定大小的连续空间


- 📌 Go的数组和切片都是从C语言延续过来的设计。 ^22370672-27-1074-1096
    - ⏱ 2020-05-31 18:40:24 

- 📌 数组的元素数量。 ^22370672-27-1361-1369
    - ⏱ 2020-05-31 18:40:43 
## 3.2 切片（slice）——动态分配大小的连续空间


- 📌 从哪里开始（这个就是切片的地址）及切多大（这个就是切片的大小） ^22370672-28-535-566
    - ⏱ 2020-05-31 18:53:33 

- 📌 理解为装切片的口袋大小 ^22370672-28-571-582
    - ⏱ 2020-05-31 18:53:38 

- 📌 从数组或切片生成新的切片 ^22370672-28-885-897
    - ⏱ 2020-05-31 18:54:01 

- 📌 默认指向一段连续内存区域 ^22370672-28-929-941
    - ⏱ 2020-05-31 18:54:11 

- 📌 ● slice表示目标切片对象。● 开始位置对应目标切片对象的索引。● 结束位置对应目标切片的结束索引 ^22370672-28-1074-1183
    - ⏱ 2020-05-31 18:55:03 

- 📌 a是一个拥有3个整型元素的数组，被初始化数值1到3。使用a[1:2]可以生成一个新的切片。代码运行结果如下 ^22370672-28-1322-1375
    - ⏱ 2020-05-31 18:56:40 

- 📌 取值范围是（0～len(slice)-1） ^22370672-28-1882-1903
    - ⏱ 2020-05-31 18:57:45 

- 📌 切片和数组密不可分。如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者 ^22370672-28-2096-2140
    - ⏱ 2020-05-31 19:04:58 

- 📌 生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的，代 ^22370672-28-3113-3178
    - ⏱ 2020-05-31 19:08:38 

- 📌 把切片的开始和结束位置都设为0时，生成的切片将变空 ^22370672-28-3451-3476
    - ⏱ 2020-05-31 19:08:49 

- 📌 切片的元素类型。● size：就是为这个类型分配多少个元素 ^22370672-28-5320-5379
    - ⏱ 2020-05-31 19:16:53 

- 📌 使用append()函数为切片添加元素 ^22370672-28-6146-6165
    - ⏱ 2020-05-31 19:23:59 

- 📌 使用Go语言内建的copy()函数，可以迅速地将一个切片的数据复制到另外一个切片空间中 ^22370672-28-8690-8733
    - ⏱ 2020-05-31 19:26:30 

- 📌 Go语言中切片元素的删除过程并没有提供任何的语法糖或者方法封装，无论是初学者学习，还是实际使用都是极为麻烦的。 ^22370672-28-12084-12139
    - ⏱ 2020-05-31 19:29:22 
## 3.3 映射（map）——建立事物关联的容器


- 📌 就需要使用到映射，如学号和学生的对应、名字与档案的对应等 ^22370672-29-480-508
    - ⏱ 2020-05-31 20:27:58 

- 📌 map使用散列表（hash）实现。 ^22370672-29-556-573
    - ⏱ 2020-05-31 20:28:07 

- 📌 如果特征值重复，表示元素发生碰撞。 ^22370672-29-817-834
    - ⏱ 2020-05-31 20:28:57 

- 📌 需要手动使用make创建。如果不创建使用map类型，会触发宕机错误。 ^22370672-29-1759-1793
    - ⏱ 2020-05-31 20:30:47 

- 📌 那么返回的将是Value Type的默认值。 ^22370672-29-1961-1983
    - ⏱ 2020-05-31 20:33:21 

- 📌 明确知道查询中某个键是否在map中存在，可以使用一种特殊的写法来实现，看下面的代码： ^22370672-29-2020-2062
    - ⏱ 2020-05-31 20:34:37 

- 📌 ，就像JSON格式一样，冒号的左边是key，右边是值，键值对之间使用逗号分隔。 ^22370672-29-2428-2467
    - ⏱ 2020-05-31 20:34:52 

- 📌 遍历对于Go语言的很多对象来说都是差不多的 ^22370672-29-2820-2841
    - ⏱ 2020-05-31 20:37:07 

- 📌 用for range语法 ^22370672-29-2845-2857
    - ⏱ 2020-05-31 20:37:10 

- 📌 无须将值改为匿名变量形式，忽略值即可。 ^22370672-29-3089-3108
    - ⏱ 2020-05-31 20:37:31 

- 📌 唯一办法就是重新make一个新的map。不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数高效多了。 ^22370672-29-5101-5160
    - ⏱ 2020-05-31 20:41:57 

- 📌 并发的map读写。也就是说使用了两个并发函数不断地对map进行读和写而发生了竞态问题。map内部会对这种并发操作进行检查并提前发现 ^22370672-29-5783-5848
    - ⏱ 2020-05-31 20:43:15 

- 📌 sync.Map。sync.Map和map不同，不是以语言原生形态提供，而是在sync包下的特殊结构。 ^22370672-29-5930-5981
    - ⏱ 2020-05-31 20:43:27 
## 3.4 列表（list）——可以快速增删的非连续空间的容器


- 📌 列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之间的关系。列表有多种实现方法，如单链表、双链表等。 ^22370672-30-465-525
    - ⏱ 2020-05-31 20:48:14 

- 📌 列表使用container/list包来实现 ^22370672-30-1612-1634
    - ⏱ 2020-05-31 20:49:00 

- 📌 遍历双链表需要配合Front()函数获取头元素，遍历时只要元素不为空就可以继续进行 ^22370672-30-4816-4857
    - ⏱ 2020-05-31 20:54:32 

- 📌 使用for语句进行遍历，其中i := l.Front()表示初始赋值，只会在一开始执行一次；每次循环会进行一次i != nil语句判断，如果返回false，表示退出循环，反之则会执行i = i.Next()。 ^22370672-30-5377-5481
    - ⏱ 2020-05-31 20:55:00 
## 4.2 构建循环（for）


- 📌 编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环 ^22370672-33-2733-2781
    - ⏱ 2020-05-31 22:12:28 
## 4.4 键值循环（for range）——直接获得对象的索引和数据


- 📌 直接获得对象的索引和数据 ^22370672-35-418-430
    - ⏱ 2020-05-31 22:22:21 

- 📌 for range遍历数组、切片、字符串、map及通道（channel）。通过for range遍历的返回值有一定的规律： ^22370672-35-468-529
    - ⏱ 2020-05-31 22:22:27 

- 📌 对map遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。 ^22370672-35-2265-2308
    - ⏱ 2020-05-31 22:25:05 

- 📌 那么这里的下画线就是匿名变量。 ^22370672-35-3596-3637
    - ⏱ 2020-05-31 22:27:45 

- 📌 可以理解为一种占位符。● 本身这种变量不会进行空间分配，也不会占用一个变量的名字。● 在for range可以对key使用匿名变量，也可以对value使用匿名变量。 ^22370672-35-3675-3816
    - ⏱ 2020-05-31 22:27:51 
## 4.5 分支选择（switch）——拥有多个条件分支的判断


- 📌 多个条件分支的判断 ^22370672-36-417-426
    - ⏱ 2020-05-31 22:32:33 

- 📌 只能支持数值常量，不能对字符串、表达式等复杂情况进行处理，这么设计的主要原因是性能 ^22370672-36-664-705
    - ⏱ 2020-05-31 22:32:53 

- 📌 每一个case均是字符串格式，且使用了default分支，Go语言规定每个switch只能有一个default分支。 ^22370672-36-1320-1378
    - ⏱ 2020-05-31 22:33:44 
## 4.6 跳转到指定代码标签（goto）


- 📌 使用goto语句跳转到指明的标签处，标签在第23行定义。 ^22370672-37-2623-2651
    - ⏱ 2020-05-31 23:04:49 

- 📌 无须额外的变量就可以快速退出所有的循环。 ^22370672-37-2831-2851
    - ⏱ 2020-05-31 23:05:02 

- 📌 第3行和第9行，发生错误时，跳转错误标签on Exit。● 第17行和第18行，汇总所有流程进行错误打印并退出进程。 ^22370672-37-4575-4663
    - ⏱ 2020-05-31 23:06:04 
## 4.7 跳出指定循环（break）——可以跳出多层循环


- 📌 跳出指定循环（break）——可以跳出多层循环 ^22370672-38-401-424
    - ⏱ 2020-05-31 23:06:35 

- 📌 break语句可以结束for、switch和select的代码块。break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块 ^22370672-38-454-521
    - ⏱ 2020-05-31 23:06:29 
## 4.8 继续下一次循环（continue）


- 📌 continue语句可以结束当前循环，开始下一次的循环迭代过程 ^22370672-39-448-479
    - ⏱ 2020-05-31 23:07:21 
## 第5章 函数（function）


- 📌 函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。 ^22370672-40-462-515
    - ⏱ 2020-05-31 23:15:23 
## 5.1 声明函数


- 📌 变量作为函数的局部变量而存在。 ^22370672-41-1080-1095
    - ⏱ 2020-06-01 10:28:30 

- 📌 最后一个返回参数返回函数执行中可能发生的错误 ^22370672-41-1706-1728
    - ⏱ 2020-06-01 10:31:55 

- 📌 ，conn表示连接对象，err返回错误。 ^22370672-41-1848-1868
    - ⏱ 2020-06-01 10:32:05 

- 📌 Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。 ^22370672-41-2243-2282
    - ⏱ 2020-06-01 10:32:25 

- 📌 纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。 ^22370672-41-2709-2758
    - ⏱ 2020-06-01 10:33:13 

- 📌 对返回值进行命名 ^22370672-41-2869-2877
    - ⏱ 2020-06-01 10:33:25 
## 5.2 函数变量——把函数作为值保存到变量中


- 📌 把函数作为值保存到变量中 ^22370672-42-415-427
    - ⏱ 2020-06-01 10:46:46 

- 📌 这样调用函数变量f时，实际调用的就是fire()函数，代码如下： ^22370672-42-527-559
    - ⏱ 2020-06-01 10:47:20 

- 📌 ， ^22370672-42-1031-1032
    - ⏱ 2020-06-01 10:47:27 
## 5.3 示例：字符串的链式处理——操作与数据分离的设计技巧


- 📌 SQL将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。 ^22370672-43-532-596
    - ⏱ 2020-06-01 10:51:39 

- 📌 strings包中将字符串变为小写就是一种处理函数的形式，strings.To Lower()函数能够将传入的字符串的每一个字符变为小写， ^22370672-43-1061-1130
    - ⏱ 2020-06-01 10:53:31 
## 5.4 匿名函数——没有函数名字的函数


- 📌 “(100)”，表示对匿名函数进行调用，传递参数为100。 ^22370672-44-1052-1081
    - ⏱ 2020-06-01 10:54:47 

- 📌 匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。 ^22370672-44-1386-1422
    - ⏱ 2020-06-01 10:54:55 
## 5.5 函数类型实现接口——把函数作为接口来调用


- 📌 函数和其他类型一样都属于“一等公民 ^22370672-45-459-476
    - ⏱ 2020-06-01 10:55:16 
## 5.6 闭包（Closure）——引用了外部变量的匿名函数


- 📌 闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。因此 ^22370672-46-464-538
    - ⏱ 2020-06-01 10:56:16 
## 第6章 结构体（struct）


- 📌 结构体是类型中带有成员的复合类型。 ^22370672-52-479-496
    - ⏱ 2020-06-01 10:57:42 

- 📌 Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。 ^22370672-52-895-928
    - ⏱ 2020-06-01 10:58:11 

- 📌 Go语言的结构体与“类”都是复合结构体，但Go语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。 ^22370672-52-969-1023
    - ⏱ 2020-06-01 10:58:17 
## 6.1 定义结构体

 

- 📌 关键字type可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过type定义为自定义类型后，使结构体更便于使用。 ^22370672-53-448-530
    - ⏱ 2020-06-02 18:18:18 

- 📌 结构体中的字段名必须唯一。 ^22370672-53-833-846
    - ⏱ 2020-06-02 18:18:40 
## 6.2 实例化结构体——为结构体分配内存并初始化


- 📌 种内存布局的描述 ^22370672-54-467-475
    - ⏱ 2020-06-02 18:24:26 

- 📌 以var的方式声明结构体即可完成实例化。 ^22370672-54-798-818
    - ⏱ 2020-06-02 18:24:46 

- 📌 .”来访问结构体的成员变量，如p.X和p.Y等 ^22370672-54-1160-1183
    - ⏱ 2020-06-02 18:25:04 

- 📌 new关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化 ^22370672-54-1324-1357
    - ⏱ 2020-06-02 18:25:13 

- 📌 ins为结构体的实例，类型为*T，是指针类型。 ^22370672-54-2506-2529
    - ⏱ 2020-06-02 18:26:07 

- 📌 ，定义Command结构体，表示命令行指令 ^22370672-54-3076-3097
    - ⏱ 2020-06-02 18:27:04 

- 📌 命令绑定的目标整型变量：版本号。 ^22370672-54-3208-3224
    - ⏱ 2020-06-02 18:27:16 
## 6.3 初始化结构体的成员变量


- 📌 初始化结构体的成员变量 ^22370672-55-408-419
    - ⏱ 2020-06-02 18:53:40 

- 📌 多个值的列表形式适合填充字段较少的结构体 ^22370672-55-528-548
    - ⏱ 2020-06-02 18:53:50 

- 📌 例 ^22370672-55-2085-2086
    - ⏱ 2020-06-02 18:54:48 

- 📌 使用取地址初始化一个People。 ^22370672-55-2147-2164
    - ⏱ 2020-06-02 18:54:51 

- 📌 每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。 ^22370672-55-2703-2732
    - ⏱ 2020-06-02 18:55:49 

- 📌 段地址结构。地址要求具有一定的顺序。 ^22370672-55-2900-2918
    - ⏱ 2020-06-02 18:55:43 

- 📌 匿名结构体的类型名是结构体包含字段成员的详细描述 ^22370672-55-5462-5486
    - ⏱ 2020-06-02 18:56:33 

- 📌 匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。 ^22370672-55-5487-5523
    - ⏱ 2020-06-02 18:56:39 
## 6.4 构造函数——结构体和类型的一系列初始化操作的函数封装


- 📌 每个类可以添加构造函数，多个构造函数使用函数重载实现 ^22370672-56-650-676
    - ⏱ 2020-06-02 18:58:18 

- 📌 Cat结构体类似于面向对象中的“基类”。Black Cat嵌入Cat结构体，类似于面向对象中的“派生” ^22370672-56-3114-3165
    - ⏱ 2020-06-02 19:02:50 
## 6.5 方法


- 📌 将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效 ^22370672-57-4984-5024
    - ⏱ 2020-06-06 18:00:47 
 

- 📌 小对象由于值复制时的速度较快，所以适合使用非指针接收器 ^22370672-57-6360-6387
    - ⏱ 2020-06-06 18:08:03 

- 📌 使用指针接收器 ^22370672-57-6402-6409
    - ⏱ 2020-06-06 18:08:12 

- 📌 本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。 ^22370672-57-6586-6636
    - ⏱ 2020-06-06 18:08:36 

- 📌 同时可以进行加、减、乘（缩放）、距离、单位化等计算。 ^22370672-57-6764-6790
    - ⏱ 2020-06-06 18:08:45 

- 📌 Go语言可以对任何类型添加方法。给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。 ^22370672-57-13432-13482
    - ⏱ 2020-06-06 18:10:49 

- 📌 可以增加一个Is Zero()方法 ^22370672-57-13759-13776
    - ⏱ 2020-06-06 18:11:11 

- 📌 用http包的New Request()方法可以创建一个HTTP请求 ^22370672-57-15228-15262
    - ⏱ 2020-06-06 18:11:33 
## 6.6 类型内嵌和结构体内嵌


- 📌 声明时没有字段名而只有类型 ^22370672-58-459-472
    - ⏱ 2020-06-06 18:14:47 

- 📌 型内嵌或匿名字段 ^22370672-58-484-492
    - ⏱ 2020-06-06 18:14:52 

- 📌 ，只是字段名就是其类型本身而已 ^22370672-58-942-957
    - ⏱ 2020-06-06 18:15:16 

- 📌 中同种类型的匿名字段只能有一个 ^22370672-58-979-994
    - ⏱ 2020-06-06 18:15:25 

- 📌 人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类 ^22370672-58-4040-4067
    - ⏱ 2020-06-06 18:17:10 
## 第7章 接口（interface）


- 📌 Go语言中使用组合实现对象特性的描述 ^22370672-60-546-564
    - ⏱ 2020-06-07 14:49:54 
## 7.1 声明接口


- 📌 Go语言的接口在命名时 ^22370672-61-818-829
    - ⏱ 2020-06-07 14:57:35 

- 📌 在单词后面添加er ^22370672-61-833-841
    - ⏱ 2020-06-07 14:57:42 

- 📌 字节数组 ^22370672-61-1407-1411
    - ⏱ 2020-06-07 14:58:09 

- 📌 而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。 ^22370672-61-1786-1840
    - ⏱ 2020-06-07 15:03:35 
## 7.3 理解类型与接口的关系


- 📌 Socket能够同时读取和写入数据，这个特性与文件类似。 ^22370672-63-723-751
    - ⏱ 2020-06-13 17:51:28 
## 7.5 示例：使用接口进行数据的排序


- 📌 需要使用者通过sort.Interface接口提供数据的一些特性和操作方法 ^22370672-65-619-656
    - ⏱ 2020-06-25 21:08:06 
# 读书笔记

## 2.6 字符串应用

### 划线评论
- 📌 第4行中，tracer[comma:]从tracer的comma位置开始到tracer字符串的结尾构造一个子字符串，返回给string.Index()进行再索引。得到的pos是相对于tracer[comma:]的结果。  ^11897562-7hKZpImew
    - 💭 这里不太懂

    - ⏱ 2020-05-31 17:27:42
   
## 6.1 定义结构体

### 划线评论
- 📌 结构体  ^11897562-7hO4XvBgI
    - 💭 有点像函数里边的类
    - ⏱ 2020-06-02 18:12:23
   
## 6.5 方法

### 划线评论
- 📌 非指针接收器，Add()方法变得类似于只读的方法，Add()方法内部不会对成员进行任何修改。  ^11897562-7hU9zd8d9
    - 💭 指针型接收器可以对方法内部成员进行更改，而非指针型应该只能进行读取
    - ⏱ 2020-06-06 18:02:46
   
# 本书评论
