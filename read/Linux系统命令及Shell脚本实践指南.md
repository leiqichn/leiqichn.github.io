---
doc_type: weread-highlights-reviews
bookId: "621934"
author: 王军
cover: https://cdn.weread.qq.com/weread/cover/9/YueWen_621934/t7_YueWen_621934.jpg
reviewCount: 4
noteCount: 117
isbn: 9787111445036
category: 计算机-理论知识
lastReadDate: 2020-04-04
---
 此处打印为空，因为Shell尝试打印出变量Dollar的值，但是这个变量并没有声明，所以打印空行￼ #使用转义字符转义$字符￼ [root@localhost ~]# echo \$Dollar￼ $Dollar ￼ #更多的例子￼ #打印乘号。如果不用转义符转义*号，则*号会作为一般的通配符使用，结果是将工作目录中的￼ 所有目录和文件名替换它￼ [root@localhost ~]# echo 8 \* 8 =64￼ 8 * 8 =64￼ ^621934-66-383
    - ⏱ 2020-02-23 21:45:27 

- 📌 进行转义和引用。 ^621934-66-596-604
    - ⏱ 2020-02-24 08:35:17 

- 📌 反斜线“\” ^621934-66-742-748
    - ⏱ 2020-02-24 08:35:36 

- 📌 引用是指将字符串用某种符号括起来，以防止特殊字符被解析为其他意思 ^621934-66-1963-1995
    - ⏱ 2020-02-24 08:37:12 

- 📌 共有4种引用符，分别是双引号、单引号、反引号（在键盘上和波浪号位于同一个键）和转义符。 ^621934-66-2022-2065
    - ⏱ 2020-02-24 08:38:24 

- 📌 引用除$符、反引号、转义符之外的所有字符 ^621934-66-2087-2107
    - ⏱ 2020-02-24 08:38:05 

- 📌 反引号则会将反引号括起的内容解释为系统命令。 ^621934-66-2134-2156
    - ⏱ 2020-02-24 08:38:14 

- 📌 部分引用是指用双引号括起来的引用。在这种引用方式中，$符、反引号（`）、转义符（\）这3种特殊字符依然会被解析为特殊意义。 ^621934-66-2243-2304
    - ⏱ 2020-02-24 08:39:09 

- 📌 输出内容就是单引号所括起来的所有内容，而不会将变量解析为其 ^621934-66-3100-3129
    - ⏱ 2020-02-24 08:40:57 

- 📌 Shell中有两种方式可以完成命令替换，一种是反引号（`），一种是$()，使用方法如下： ^621934-66-4015-4059
    - ⏱ 2020-02-24 08:42:43 

- 📌 因为它们是等价的。但反引号毕竟和单引号看起来类似，有时候会对查看代码造成困难，而使用$()就相对清晰，能有效地避免这种混乱。但是有些情景是必须使用$()的： ^621934-66-5211-5289
    - ⏱ 2020-02-24 08:46:41 
## 13.3 运算符


- 📌 常见的算术运算大多需要结合Shell的内 ^621934-67-775-795
    - ⏱ 2020-02-24 08:48:29 

- 📌 建命令let来使用 ^621934-67-795-804
    - ⏱ 2020-02-24 08:48:36 

- 📌 位运算的左移、右移元素其实就是整数在内存中的“左右移动”，其中左移运算符为<<，右移运算符为>> ^621934-67-1505-1553
    - ⏱ 2020-02-24 08:48:58 

- 📌 按位与运算（&） ^621934-67-2149-2157
    - ⏱ 2020-02-24 08:50:05 

- 📌 按位或运算（|） ^621934-67-2525-2533
    - ⏱ 2020-02-24 08:50:00 

- 📌 按位异或运算（^），是将两个整数写成二进制的形式，然后同位置相比较，只要对应的位置同为0或同为1，结果就为0，否则为1。 ^621934-67-2887-2947
    - ⏱ 2020-02-24 08:50:32 

- 📌 这里有个快捷的计算公式：“~a”的值为“-(a+1)”。 ^621934-67-3277-3305
    - ⏱ 2020-02-24 08:51:05 

- 📌 。前置自增或前置自减操作会首先修改变量的值，然后再将变量的值传递出去；后置自增或后置自减则会首先将变量的值传递出去，然后再修改变量的值 ^621934-67-3529-3596
    - ⏱ 2020-02-24 08:51:55 
## 13.4 其他算术运算


- 📌 用于整数运 ^621934-68-905-910
    - ⏱ 2020-02-24 08:53:48 

- 📌 expr要求操作数和操作符之间使用空格隔开（否则只会打印出字符串），所以特殊的操作符要使用转义符转义（比如*） ^621934-68-924-979
    - ⏱ 2020-02-24 08:53:32 

- 📌 expr支持的算术运算符有加、减、乘、除、余等，如下所示： ^621934-68-1009-1038
    - ⏱ 2020-02-24 08:53:28 

- 📌 ；如果算术表达式中含有其他变量也不需要用$引用13.4.4 算术扩展算术扩展是Shell提供的整数变量的运算机制，是Shell的内建命令之一。其基本语法如下：$((算术表达式))其中的算术表达式由变量和运算符组成，常见的用法是显示输出和变量赋值。若表达式中的变量没有定义，则在计算时，其值会被假设为0（但是并不会真的因此赋0值给该变量）。#显示输出：echo $((算术表达式))#例子：计算2*i+1的值[root@localhost ~]# i=2[root@localhost ~]# echo $((2*i+1)) #注意这里变量i前并没有$符5[root@localhost ~]# echo $((2*(i+1))) #用括号改变运算优先级 ^621934-68-1934
    - ⏱ 2020-02-24 08:56:11 

- 📌 $((算术表 ^621934-68-2137-2143
    - ⏱ 2020-02-24 09:06:19 

- 📌 未定义的变量参与算术表达式求值[root@localhost ~]# echo $( ^621934-68-2569-2613
    - ⏱ 2020-02-24 09:06:07 

- 📌 前面介绍的几种算术运算都只能是基于整数的， ^621934-68-2741-2762
    - ⏱ 2020-02-24 09:06:28 

- 📌 的bc正是 ^621934-68-2820-2825
    - ⏱ 2020-02-24 09:06:36 

- 📌 bc命令，回车后进入bc的交互式界面 ^621934-68-2989-3007
    - ⏱ 2020-02-24 09:06:57 

- 📌 #设置显示的小数位数scale=3 ^621934-68-3281-3302
    - ⏱ 2020-02-24 09:08:29 

- 📌 默认情况下bc并不显示小数部分，必须设置要显示的小数位数。这可以通过设置scale做到，本例中设置为3后再运行除法运算结果就正确了 ^621934-68-3462-3527
    - ⏱ 2020-02-24 09:08:17 

- 📌 往往只需要调用bc的处理结果而不会进入bc的交互界面 ^621934-68-3768-3794
    - ⏱ 2020-02-24 09:08:44 

- 📌 cat cal.bc12*3434/12scale=3;34/12a=1;b=2;a+b#批量计算[root@localhost ~]# cat cal.bc | bc40822.8333 ^621934-68-3917-4064
    - ⏱ 2020-02-24 09:09:11 
## 13.5 特殊字符


- 📌 其中*代表任意长度的字符串。 ^621934-69-625-639
    - ⏱ 2020-02-24 09:10:51 

- 📌 任一单个字符 ^621934-69-702-708
    - ⏱ 2020-02-24 09:11:04 

- 📌 匹配其中的任意一个字 ^621934-69-716-726
    - ⏱ 2020-02-24 09:11:09 

- 📌 -表明起 ^621934-69-753-757
    - ⏱ 2020-02-24 09:11:17 

- 📌 a-c]等同于[abc]， ^621934-69-762-775
    - ⏱ 2020-02-24 09:11:20 

- 📌 而且“#!”必须出现在整个脚本的第一行。 ^621934-69-1314-1334
    - ⏱ 2020-02-24 09:11:59 

- 📌 引用变量原型，又叫变量扩展 ^621934-69-1513-1526
    - ⏱ 2020-02-24 09:12:10 

- 📌 echo {x1,x2,x3}{y1,y2,y3} ^621934-69-1974-1999
    - ⏱ 2020-02-24 09:18:07 

- 📌 匹配不同的文件，文件名的特征是只有其中一部分不同 ^621934-69-2083-2107
    - ⏱ 2020-02-24 09:18:59 

- 📌 file_{A,B}来匹配 ^621934-69-2128-2141
    - ⏱ 2020-02-24 09:18:47 

- 📌 ，语句之间使用回车隔开。 ^621934-69-2346-2358
    - ⏱ 2020-02-24 09:20:56 

- 📌 ，也就是说控制字符是交互式使用的 ^621934-69-2539-2555
    - ⏱ 2020-02-24 09:21:18 

- 📌 $#：变量总数。$*、$@：显示所有参 ^621934-69-3191-3239
    - ⏱ 2020-02-24 09:33:48 

- 📌 $!：最后一个后台进程的ID号 ^621934-69-3315-3330
    - ⏱ 2020-02-24 09:33:54 

- 📌 可以用于执行history中某个命令 ^621934-69-3436-3454
    - ⏱ 2020-02-24 09:34:21 

- 📌 可以用!100代表执行ifconfig。 ^621934-69-3487-3507
    - ⏱ 2020-02-24 09:34:16 
## 第14章 测试和判断


- 📌 expression是一个表达式，可以是算术比较、字符串比较、文本和文件属性比较等。 ^621934-70-1357-1399
    - ⏱ 2020-02-24 09:35:56 

- 📌 测试，再写expression，再以“]”结束测试。 ^621934-70-1416-1442
    - ⏱ 2020-02-24 09:36:04 

- 📌 左边的括号“[”后有个空格，右括号“]”前面也有个空格 ^621934-70-1449-1476
    - ⏱ 2020-02-24 09:36:10 

- 📌 测试该文件“是否存在”，只需要使用-e操作符即可 ^621934-70-1986-2010
    - ⏱ 2020-02-24 09:36:44 

- 📌 $? ^621934-70-2305-2309
    - ⏱ 2020-02-24 09:37:00 

- 📌 文件测试符 ^621934-70-2536-2541
    - ⏱ 2020-02-24 09:37:30 
## 14.2 判断


- 📌 判断选择”，关键字是if、case。 ^621934-71-564-582
    - ⏱ 2020-02-24 09:46:55 

- 📌 then ^621934-71-758-763
    - ⏱ 2020-02-24 09:47:26 

- 📌 使用if/elif/else结构，其语法结构如下： ^621934-71-3431-3456
    - ⏱ 2020-02-24 09:50:32 

- 📌 *[[:lower:]]*) echo-en "Lowercase " ;;         *[[:upper:]]*) echo-en "Uppercase " ;;         *[[:digit:]]*) echo-en "Numerical " ;;         *) echo "unknown inp ^621934-71-5095-5263
    - ⏱ 2020-02-24 09:54:14 
## 第15章 循环


- 📌 Shell中的循环主要有for、while、until、select几种。 ^621934-72-693-730
    - ⏱ 2020-02-24 09:55:02 
## 15.1 for循环


- 📌 {1..5}￼ ^621934-73-2303-2310
    - ⏱ 2020-02-24 11:17:58 

- 📌 命令替换部分还可以使用$()代 ^621934-73-2430-2445
    - ⏱ 2020-02-24 11:24:56 

- 📌 其实列表for循环中in后面的内容可以是任意命令的标准输出 ^621934-73-2995-3024
    - ⏱ 2020-02-24 11:37:09 

- 📌 通过参数的方式给for循环传递变量 ^621934-73-3443-3460
    - ⏱ 2020-02-24 11:37:44 

- 📌 $@ ^621934-73-3827-3829
    - ⏱ 2020-02-24 11:37:59 

- 📌 for ((i=1; i<=10; i++)) ^621934-73-4459-4482
    - ⏱ 2020-02-24 11:39:25 

- 📌 j-lt ^621934-73-5327-5331
    - ⏱ 2020-02-24 11:48:13 

- 📌 而原本用于初始化的expression1和用户改变变量值的expression3则均置为空， ^621934-73-6080-6126
    - ⏱ 2020-02-24 11:49:09 
## 15.2 while循环


- 📌 read ^621934-74-1779-1783
    - ⏱ 2020-02-24 12:00:49 

- 📌 使用重定向符的while只会产生一个Shell，而使用管道的脚本在运行时会产生3个Shell，第一个Shell是cat（由于运行速度很快所以无法使用ps命令抓到），第二个Shell是管道，第三个Shell是while。 ^621934-74-3568-3732
    - ⏱ 2020-02-24 12:03:00 
## 15.3 until循环


- 📌 15.3.1 until循环的语法until循环也是运行前测试，但是until采用的是测试假值的方式，当测试结果为假时才继续执行循环体，直到测试为真时才停止循环。其语法如下：￼ until expression￼ do￼        command￼ done下面的示例使用until同时计算1到100的和以及1到100的奇数和。￼ [root@localhost ~]# cat until01.sh￼ #!/bin/bash￼ sum01=0￼ sum02=0￼ i=1￼ until [[ $i-gt 100 ]]￼ do￼        let "sum01+=i"￼        let "j=i%2"￼        if [[ $j-ne 0 ]]; then￼              let "sum02+=i"￼        fi￼        let "i+=1"￼ done￼ echo $sum01￼ echo $sum02￼ #运行结果￼ [root@localhost ~]# bash until01.sh￼ 5050￼ ^621934-75-385
    - ⏱ 2020-02-24 12:04:26 
## 15.4 select循环


- 📌 select有判断用户输入的功能，所以select经常和case语句合并使用。 ^621934-76-1177-1245
    - ⏱ 2020-02-24 14:26:51 
## 第16章 函数


- 📌 使用函数最大的好处是可避免出现大量重复代码，同时增强了脚本的可读性： ^621934-79-645-679
    - ⏱ 2020-02-24 12:39:55 

- 📌 获取上一个命令返回值的方式是使用$? ^621934-79-2679-2697
    - ⏱ 2020-02-24 12:42:35 
## 16.2 带参数的函数


- 📌 除了在脚本运行时给脚本传入位置参数外，还可以使用内置命令set命令给脚本指定位置参数的值（又叫重置）。一旦使用set设置了传入参数的值，脚本将忽略运行时传入的位置参 ^621934-80-2133-2215
    - ⏱ 2020-02-24 12:48:18 
## 16.4 递归函数


- 📌 递归函数的典型特征为：在函数体中继续调用函数自身。 ^621934-82-705-759
    - ⏱ 2020-02-24 12:54:11 

- 📌 所以递归函数一定要有结束递归的条件，当满足该条件时，递归就会终止。典型的递归函数的结构如下所示： ^621934-82-809-870
    - ⏱ 2020-02-24 12:54:20 
## 第17章 重定向


- 📌 所谓“重定向”，就是将原本应该从标准输入设备（键盘）输入的数据，改由其他文件或设备输入；或将原本应该输出到标准输出设备（显示器）的内容，改而输出到其他文件或设备上。 ^621934-83-685-767
    - ⏱ 2020-02-24 15:55:16 
## 17.2 I/O重定向


- 📌 标识符为1的内容重定向到指 ^621934-84-3162-3175
    - ⏱ 2020-02-24 16:06:41 

- 📌 如果命令由于各种原因出错时所产生的错误输出，其文件标识符为2， ^621934-84-3402-3433
    - ⏱ 2020-02-24 16:06:47 

- 📌 这样错误输出就不会出现在显示器上了。如下所示： ^621934-84-3479-3502
    - ⏱ 2020-02-24 16:07:02 

- 📌 标识输出重定向的作用是将一个标识的输出重定向到另一个标识的输入 ^621934-84-5123-5154
    - ⏱ 2020-02-24 16:10:23 

- 📌 2>&1 ^621934-84-5252-5299
    - ⏱ 2020-02-24 16:10:51 

- 📌 简单地说管道就是将一个命令的输出作为另一个命令的输入 ^621934-84-8568-8594
    - ⏱ 2020-02-24 16:14:00 

- 📌 exec是Shell的内建命令，执行这个命令时系统不会启动新的Shell，而是用要被执行的命令替换当前的Shell进程 ^621934-84-8742-8801
    - ⏱ 2020-02-24 16:27:43 
 

- 📌 Here Document又称此处文档，用于在命令或脚本中按行输入文本 ^621934-84-12631-12666
    - ⏱ 2020-02-24 16:45:57 
# 读书笔记

## 第13章 Shell编程基础

### 划线评论
- 📌 若干个数组进行拼接操作  ^11897562-7fmauuERz
    - 💭 括号括起即可
    - ⏱ 2020-02-23 21:22:55

### 划线评论
- 📌 #  ^11897562-7fmarxFKu
    - 💭 使用井号 相当于python 的len
    - ⏱ 2020-02-23 21:22:11
   
## 15.1 for循环

### 划线评论
- 📌 let "sum01+=i"  ^11897562-7fn59a3ck
    - 💭 计算器
    - ⏱ 2020-02-24 11:47:59
   
## 17.2 I/O重定向

### 划线评论
- 📌 Here Document  ^11897562-7fnoEaPuy
    - 💭 不懂
    - ⏱ 2020-02-24 16:45:44
   
# 本书评论
