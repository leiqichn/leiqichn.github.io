<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-06-15T16:10:28.248Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Obsidian配置代理</title>
    <link href="https://leiqi.top/2025-06-15-980a140fe20b.html"/>
    <id>https://leiqi.top/2025-06-15-980a140fe20b.html</id>
    <published>2025-06-15T16:07:58.000Z</published>
    <updated>2025-06-15T16:10:28.248Z</updated>
    
    <content type="html"><![CDATA[<p>在 Obsidian 中设置代理（Proxy）需要通过 <strong>系统环境变量</strong> 或 <strong>插件</strong> 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法：</p><hr><h2 id="方法-1：通过环境变量设置全局代理（推荐）"><a href="#方法-1：通过环境变量设置全局代理（推荐）" class="headerlink" title="方法 1：通过环境变量设置全局代理（推荐）"></a><strong>方法 1：通过环境变量设置全局代理（推荐）</strong></h2><p>Obsidian 是基于 Electron 的应用程序，它会遵循系统的 HTTP&#x2F;HTTPS 代理设置。你可以通过以下方式设置：</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h3><ol><li><p><strong>临时设置（仅当前终端窗口有效）</strong><br>在 CMD&#x2F;PowerShell 中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后启动 Obsidian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start <span class="string">&quot;&quot;</span> <span class="string">&quot;C:\path\to\Obsidian.exe&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置（系统环境变量）我使用的这个</strong>  </p><ul><li>按 <code>Win + R</code>，输入 <code>sysdm.cpl</code> 打开 <strong>系统属性</strong>。</li><li>进入 <strong>高级 → 环境变量</strong>。</li><li>在 <strong>用户变量</strong> 或 <strong>系统变量</strong> 中添加：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY=http://127.0.0.1:7897</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7897</span><br><span class="line">ALL_PROXY=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure></li><li>重启 Obsidian。</li></ul></li></ol><hr><h3 id="macOS-Linux"><a href="#macOS-Linux" class="headerlink" title="macOS&#x2F;Linux"></a><strong>macOS&#x2F;Linux</strong></h3><ol><li><p><strong>临时设置（终端启动）</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后启动 Obsidian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open -a Obsidian  <span class="comment"># macOS</span></span><br><span class="line">obsidian &amp;       <span class="comment"># Linux（如果安装正确）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置（<code>.bashrc</code>&#x2F;<code>.zshrc</code>）</strong><br>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 或 source ~/.zshrc</span></span><br></pre></td></tr></table></figure><p>重启 Obsidian。</p></li></ol><hr><h2 id="方法-2：使用-Proxy-插件（如果-Obsidian-支持）"><a href="#方法-2：使用-Proxy-插件（如果-Obsidian-支持）" class="headerlink" title="方法 2：使用 Proxy 插件（如果 Obsidian 支持）"></a><strong>方法 2：使用 Proxy 插件（如果 Obsidian 支持）</strong></h2><p>Obsidian 本身没有官方代理插件，但你可以尝试：</p><ol><li><p><strong>安装 <code>obsidian-proxy</code> 插件（如果存在）</strong>  </p><ul><li>进入 <code>设置 → 社区插件 → 浏览</code>，搜索 <code>proxy</code>。</li><li>安装并配置代理地址。</li></ul></li><li><p><strong>使用第三方工具（如 Proxifier&#x2F;Clash）</strong>  </p><ul><li>在 Proxifier 中设置 Obsidian 走代理：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">规则：Obsidian.exe → SOCKS5 127.0.0.1:7897</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="方法-3：修改-Electron-启动参数（高级）"><a href="#方法-3：修改-Electron-启动参数（高级）" class="headerlink" title="方法 3：修改 Electron 启动参数（高级）"></a><strong>方法 3：修改 Electron 启动参数（高级）</strong></h2><p>如果 Obsidian 是基于 Electron 的，可以尝试修改启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obsidian --proxy-server=<span class="string">&quot;http://127.0.0.1:7897&quot;</span></span><br></pre></td></tr></table></figure><p>（需找到 Obsidian 的实际启动方式）</p><hr><h2 id="验证代理是否生效"><a href="#验证代理是否生效" class="headerlink" title="验证代理是否生效"></a><strong>验证代理是否生效</strong></h2><ol><li>在 Obsidian 中安装插件或同步数据，看是否正常访问。</li><li>使用 <code>curl -v https://api.obsidian.md</code> 测试代理是否生效。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>方法</th><th>适用场景</th><th>持久性</th></tr></thead><tbody><tr><td><strong>环境变量</strong></td><td>推荐，全局生效</td><td>✅ 永久</td></tr><tr><td><strong>终端临时设置</strong></td><td>测试用</td><td>❌ 临时</td></tr><tr><td><strong>Proxy 插件</strong></td><td>如果 Obsidian 支持</td><td>⚠️ 依赖插件</td></tr><tr><td><strong>Proxifier&#x2F;Clash</strong></td><td>强制代理所有流量</td><td>✅ 系统级</td></tr></tbody></table><p>如果你的代理是 <code>http://127.0.0.1:7897</code> 或 <code>socks5://127.0.0.1:7897</code>（如 Clash&#x2F;V2Ray），建议优先使用 <strong>环境变量</strong> 方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Obsidian 中设置代理（Proxy）需要通过 &lt;strong&gt;系统环境变量&lt;/strong&gt; 或 &lt;strong&gt;插件&lt;/strong&gt; 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;方法-1：通过</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 函数传入slice无法修改到原slice</title>
    <link href="https://leiqi.top/2025-06-15-f16e0f79fc66.html"/>
    <id>https://leiqi.top/2025-06-15-f16e0f79fc66.html</id>
    <published>2025-06-15T05:53:49.000Z</published>
    <updated>2025-06-15T16:10:28.246Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, track, used, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>, track []<span class="type">int</span>, used []<span class="type">bool</span>, res *[][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used, res)</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上边的res 代码slice中需要使用指针 我去掉指针不行。</p><p>使用闭包函数可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="切片与指针的区别"><a href="#切片与指针的区别" class="headerlink" title="切片与指针的区别"></a>切片与指针的区别</h1><p>Go 中的切片是引用类型，但它们与指针在行为上还是有一些关键区别，这正是为什么在这个回溯算法中需要使用指针的原因。</p><h2 id="切片作为引用类型的局限"><a href="#切片作为引用类型的局限" class="headerlink" title="切片作为引用类型的局限"></a>切片作为引用类型的局限</h2><p>虽然切片是引用类型（底层数组的指针+长度+容量），但切片头（slice header）本身是按值传递的。这意味着：</p><ol><li><strong>可以修改底层数组元素</strong>：函数内部可以修改切片指向的数组元素，这些修改会反映到外部</li><li><strong>不能修改切片头</strong>：<font color="#ff0000">对切片本身的修改（如追加元素导致重新分配）不会反映到外部</font></li></ol><h2 id="具体到代码"><a href="#具体到代码" class="headerlink" title="具体到代码"></a>具体到代码</h2><p>回溯算法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*res = <span class="built_in">append</span>(*res, temp)  <span class="comment">// 使用指针可以修改外部的res</span></span><br></pre></td></tr></table></figure><p>如果改为不使用指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">append</span>(res, temp)  <span class="comment">// 这只修改了函数内部的切片头副本</span></span><br></pre></td></tr></table></figure><h2 id="为什么需要指针的详细解释"><a href="#为什么需要指针的详细解释" class="headerlink" title="为什么需要指针的详细解释"></a>为什么需要指针的详细解释</h2><ol><li><p><strong>追加操作的特殊性</strong>：</p><ul><li><code>append</code> 可能会返回一个新的切片头（当容量不足时）</li><li>不使用指针时，新切片头只存在于函数内部</li></ul></li><li><p><strong>递归调用的累积效果</strong>：</p><ul><li>每次递归调用都需要累积结果</li><li>不使用指针时，每次递归的修改都会丢失</li></ul></li></ol><h2 id="验证示例"><a href="#验证示例" class="headerlink" title="验证示例"></a>验证示例</h2><p>简单例子验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>) <span class="comment">// 不会影响外部</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">99</span>          <span class="comment">// 会影响外部（修改底层数组）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySliceByPtr</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, <span class="number">100</span>) <span class="comment">// 会影响外部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3]</span></span><br><span class="line">    </span><br><span class="line">    modifySliceByPtr(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在需要修改切片本身<font color="#ff0000">（如追加元素）</font>并且希望这些修改在函数外部可见时，必须使用指针。这正是你的回溯算法中需要使用 <code>*[][]int</code> 的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/description/&quot;&gt;46. 全排列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang LeetCode 刷题必备基础和常用模板</title>
    <link href="https://leiqi.top/2025-06-13-e749796f24c2.html"/>
    <id>https://leiqi.top/2025-06-13-e749796f24c2.html</id>
    <published>2025-06-13T16:03:18.000Z</published>
    <updated>2025-06-15T16:10:28.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-LeetCode-刷题必备基础备忘录"><a href="#Golang-LeetCode-刷题必备基础备忘录" class="headerlink" title="Golang LeetCode 刷题必备基础备忘录"></a>Golang LeetCode 刷题必备基础备忘录</h1><h2 id="1-基础数据结构用法"><a href="#1-基础数据结构用法" class="headerlink" title="1. 基础数据结构用法"></a>1. 基础数据结构用法</h2><h3 id="数组-切片-Slice"><a href="#数组-切片-Slice" class="headerlink" title="数组&#x2F;切片 (Slice)"></a>数组&#x2F;切片 (Slice)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// 长度5</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 长度0，容量10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>) <span class="comment">// 追加</span></span><br><span class="line"><span class="built_in">len</span>(slice) <span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">copy</span>(dest, src) <span class="comment">// 复制</span></span><br><span class="line">sort.Ints(slice) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 字节长度(非字符数)</span></span><br><span class="line">utf8.RuneCountInString(s) <span class="comment">// 字符数</span></span><br><span class="line">strings.Contains(s, <span class="string">&quot;ell&quot;</span>) <span class="comment">// true</span></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>) <span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line">strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>) <span class="comment">// &quot;a-b&quot;</span></span><br><span class="line">strconv.Itoa(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line">strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// 123, error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> s &#123; <span class="comment">// r是rune类型(Unicode码点)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %c\n&quot;</span>, i, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 (Map)"></a>映射 (Map)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">val, exists := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// exists为bool表示是否存在</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>) <span class="comment">// 删除键</span></span><br></pre></td></tr></table></figure><h3 id="链表-List"><a href="#链表-List" class="headerlink" title="链表 (List)"></a>链表 (List)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line">l := list.New()</span><br><span class="line">l.PushBack(<span class="number">1</span>)</span><br><span class="line">l.PushFront(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">    fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常用算法模板"><a href="#2-常用算法模板" class="headerlink" title="2. 常用算法模板"></a>2. 常用算法模板</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pivot := nums[<span class="number">0</span>]</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= right; &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot &#123;</span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            left++</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &gt; pivot &#123;</span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums[:left])</span><br><span class="line">    quickSort(nums[right+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-标准库重要包"><a href="#3-标准库重要包" class="headerlink" title="3. 标准库重要包"></a>3. 标准库重要包</h2><h3 id="sort-排序包"><a href="#sort-排序包" class="headerlink" title="sort 排序包"></a><code>sort</code> 排序包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型排序</span></span><br><span class="line">sort.Ints(arr)</span><br><span class="line">sort.Strings(arr)</span><br><span class="line">sort.Float64s(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="container-heap-堆实现"><a href="#container-heap-堆实现" class="headerlink" title="container/heap 堆实现"></a><code>container/heap</code> 堆实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆示例</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x any)        &#123; *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">h := &amp;MinHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">smallest := heap.Pop(h)</span><br></pre></td></tr></table></figure><h3 id="math-数学包"><a href="#math-数学包" class="headerlink" title="math 数学包"></a><code>math</code> 数学包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line">math.Max(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Min(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Abs(<span class="type">float64</span>)</span><br><span class="line">math.Pow(x, y <span class="type">float64</span>)</span><br><span class="line">math.Sqrt(<span class="type">float64</span>)</span><br><span class="line">math.Ceil(<span class="type">float64</span>)</span><br><span class="line">math.Floor(<span class="type">float64</span>)</span><br><span class="line">math.MaxInt32 <span class="comment">// 常量</span></span><br><span class="line">math.MinInt32</span><br></pre></td></tr></table></figure><h2 id="4-并发编程基础"><a href="#4-并发编程基础" class="headerlink" title="4. 并发编程基础"></a>4. 并发编程基础</h2><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 并发执行的代码</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 缓冲通道</span></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// 发送</span></span><br><span class="line">val := &lt;-ch <span class="comment">// 接收</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select多路复用</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-常用技巧"><a href="#5-常用技巧" class="headerlink" title="5. 常用技巧"></a>5. 常用技巧</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n &amp; <span class="number">1</span> <span class="comment">// 判断奇偶</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span> <span class="comment">// 除以2</span></span><br><span class="line">n &lt;&lt; <span class="number">1</span> <span class="comment">// 乘以2</span></span><br><span class="line">a ^ b <span class="comment">// 异或</span></span><br><span class="line">a &amp;^ b <span class="comment">// 位清除</span></span><br></pre></td></tr></table></figure><h3 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a>常用常量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INT_MAX = <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> INT_MIN = ^INT_MAX</span><br></pre></td></tr></table></figure><h3 id="快速输入输出-竞赛用"><a href="#快速输入输出-竞赛用" class="headerlink" title="快速输入输出 (竞赛用)"></a>快速输入输出 (竞赛用)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line">fmt.Fscan(reader, &amp;a, &amp;b)</span><br><span class="line">fmt.Fprintln(writer, a+b)</span><br></pre></td></tr></table></figure><h2 id="6-测试用例写法"><a href="#6-测试用例写法" class="headerlink" title="6. 测试用例写法"></a>6. 测试用例写法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        input <span class="type">int</span></span><br><span class="line">        want <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;case1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;case2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> got := Func(tt.input); got != tt.want &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;Func() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-常见题型解题要点"><a href="#7-常见题型解题要点" class="headerlink" title="7. 常见题型解题要点"></a>7. 常见题型解题要点</h2><ol><li><strong>双指针</strong>：数组&#x2F;链表问题，滑动窗口</li><li><strong>DFS&#x2F;BFS</strong>：树&#x2F;图遍历，回溯问题</li><li><strong>动态规划</strong>：状态转移方程，备忘录</li><li><strong>贪心算法</strong>：局部最优解</li><li><strong>并查集</strong>：连通性问题</li><li><strong>前缀和&#x2F;差分数组</strong>：区间查询&#x2F;更新</li><li><strong>单调栈</strong>：下一个更大&#x2F;小元素问题</li></ol><h2 id="1-双指针技巧"><a href="#1-双指针技巧" class="headerlink" title="1. 双指针技巧"></a>1. 双指针技巧</h2><h3 id="数组-链表问题模板"><a href="#数组-链表问题模板" class="headerlink" title="数组&#x2F;链表问题模板"></a>数组&#x2F;链表问题模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针找链表中点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序数组两数之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        sum := nums[left] + nums[right]</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxLen := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        freq[s[right]]++</span><br><span class="line">        <span class="comment">// 窗口收缩条件</span></span><br><span class="line">        <span class="keyword">for</span> freq[s[right]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            freq[s[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = max(maxLen, right-left+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS-BFS-算法"><a href="#2-DFS-BFS-算法" class="headerlink" title="2. DFS&#x2F;BFS 算法"></a>2. DFS&#x2F;BFS 算法</h2><h3 id="树遍历模板"><a href="#树遍历模板" class="headerlink" title="树遍历模板"></a>树遍历模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    dfs(root.Left)</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    dfs(root.Right)</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">var</span> level []<span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            level = <span class="built_in">append</span>(level, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, level)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h2><h3 id="经典DP模板"><a href="#经典DP模板" class="headerlink" title="经典DP模板"></a>经典DP模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列 (备忘录)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-1背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(weights []<span class="type">int</span>, values []<span class="type">int</span>, W <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(weights)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, W+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= W; w++ &#123;</span><br><span class="line">            <span class="keyword">if</span> weights[i<span class="number">-1</span>] &gt; w &#123;</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-weights[i<span class="number">-1</span>]]+values[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h2><h3 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intervalSchedule</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        start := interval[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = interval[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a>5. 并查集</h2><h3 id="标准实现"><a href="#标准实现" class="headerlink" title="标准实现"></a>标准实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionFind <span class="keyword">struct</span> &#123;</span><br><span class="line">    parent []<span class="type">int</span></span><br><span class="line">    count  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> *UnionFind &#123;</span><br><span class="line">    parent := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> parent &#123;</span><br><span class="line">        parent[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;UnionFind&#123;parent, n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Find(x <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> uf.parent[x] != x &#123;</span><br><span class="line">        uf.parent[x] = uf.parent[uf.parent[x]] <span class="comment">// 路径压缩</span></span><br><span class="line">        x = uf.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Union(x, y <span class="type">int</span>) &#123;</span><br><span class="line">    rootX := uf.Find(x)</span><br><span class="line">    rootY := uf.Find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.parent[rootX] = rootY</span><br><span class="line">    uf.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-前缀和与差分数组"><a href="#6-前缀和与差分数组" class="headerlink" title="6. 前缀和与差分数组"></a>6. 前缀和与差分数组</h2><h3 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="keyword">type</span> PrefixSum <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrefixSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> *PrefixSum &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    prefix := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        prefix[i] = prefix[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PrefixSum&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PrefixSum)</span></span> Query(i, j <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ps.prefix[j+<span class="number">1</span>] - ps.prefix[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="keyword">type</span> NumMatrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> NumMatrix &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NumMatrix&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    prefix := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        prefix[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            prefix[i][j] = prefix[i<span class="number">-1</span>][j] + prefix[i][j<span class="number">-1</span>] - prefix[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NumMatrix&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumMatrix)</span></span> SumRegion(row1 <span class="type">int</span>, col1 <span class="type">int</span>, row2 <span class="type">int</span>, col2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.prefix[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - this.prefix[row1][col2+<span class="number">1</span>] - this.prefix[row2+<span class="number">1</span>][col1] + this.prefix[row1][col1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><h3 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElements</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> res &#123;</span><br><span class="line">        res[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125; <span class="comment">// 存储索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++ &#123;</span><br><span class="line">        num := nums[i%n]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; num &gt; nums[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            res[top] = num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heights = <span class="built_in">append</span>(heights, <span class="number">0</span>) <span class="comment">// 哨兵</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;           <span class="comment">// 哨兵</span></span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(heights); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            h := heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            w := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">            maxArea = max(maxArea, h*w)</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各题型解题要点总结"><a href="#各题型解题要点总结" class="headerlink" title="各题型解题要点总结"></a>各题型解题要点总结</h2><ol><li><p><strong>双指针</strong>：</p><ul><li>数组问题：注意有序数组的特殊性质</li><li>滑动窗口：明确窗口收缩条件，维护窗口状态</li></ul></li><li><p><strong>DFS&#x2F;BFS</strong>：</p><ul><li>树遍历：前中后序选择取决于问题需求</li><li>回溯：注意状态恢复，剪枝优化</li></ul></li><li><p><strong>动态规划</strong>：</p><ul><li>明确状态定义和转移方程</li><li>考虑空间优化（滚动数组）</li></ul></li><li><p><strong>贪心算法</strong>：</p><ul><li>证明贪心选择的正确性</li><li>通常需要先排序</li></ul></li><li><p><strong>并查集</strong>：</p><ul><li>路径压缩和按秩合并优化</li><li>处理连通分量问题</li></ul></li><li><p><strong>前缀和&#x2F;差分</strong>：</p><ul><li>前缀和用于快速区间查询</li><li>差分数组用于快速区间更新</li></ul></li><li><p><strong>单调栈</strong>：</p><ul><li>维护栈内元素的单调性</li><li>用于解决”下一个更大&#x2F;小元素”类问题</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-LeetCode-刷题必备基础备忘录&quot;&gt;&lt;a href=&quot;#Golang-LeetCode-刷题必备基础备忘录&quot; class=&quot;headerlink&quot; title=&quot;Golang LeetCode 刷题必备基础备忘录&quot;&gt;&lt;/a&gt;Golang Leet</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 堆中返回的值为什么是最后一个，不是0位</title>
    <link href="https://leiqi.top/2025-06-12-6ce91bef2b21.html"/>
    <id>https://leiqi.top/2025-06-12-6ce91bef2b21.html</id>
    <published>2025-06-12T17:02:18.000Z</published>
    <updated>2025-06-15T16:10:28.241Z</updated>
    
    <content type="html"><![CDATA[<p>这涉及到 Go 中 <code>sort.Slice</code> 和堆(<code>container/heap</code>) 实现的<strong>关键区别</strong>。虽然它们都使用 <code>Less</code> 函数，但行为完全不同：</p><h3 id="1-sort-Slice-的-Less-函数（排序场景）"><a href="#1-sort-Slice-的-Less-函数（排序场景）" class="headerlink" title="1. sort.Slice 的 Less 函数（排序场景）"></a>1. <code>sort.Slice</code> 的 <code>Less</code> 函数（排序场景）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age <span class="comment">// 升序排序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：直接定义最终排序顺序</li><li><strong>结果</strong>：当 <code>people[i].Age &lt; people[j].Age</code> 时，<code>i</code> 会排在 <code>j</code> 前面 → <strong>升序排列</strong></li><li><strong>内存布局</strong>：切片物理位置就是有序的，索引0是最小值，最后索引是最大值</li></ul><h3 id="2-堆的-Less-函数（堆场景）"><a href="#2-堆的-Less-函数（堆场景）" class="headerlink" title="2. 堆的 Less 函数（堆场景）"></a>2. 堆的 <code>Less</code> 函数（堆场景）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> h[i] &lt; h[j] <span class="comment">// 最小堆定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：定义堆的<strong>父子节点关系</strong>（不是最终排序顺序！）</li><li><strong>堆性质</strong>：在最小堆中，任意父节点 ≤ 子节点</li><li><strong>内存布局</strong>：堆是<strong>半排序</strong>的树状结构（数组实现）：<ul><li>索引0位置是<strong>根节点（最小值）</strong></li><li>最后一个元素位置<strong>不固定</strong>（可能大也可能小）</li></ul></li></ul><h3 id="关键区别：Pop-的实现"><a href="#关键区别：Pop-的实现" class="headerlink" title="关键区别：Pop() 的实现"></a>关键区别：<code>Pop()</code> 的实现</h3><p>堆的 <code>Pop()</code> 操作有特殊处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]  <span class="comment">// 取出最后一个元素</span></span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么取最后一个元素？</strong> 因为在标准库 <code>heap.Pop()</code> 中已经做了前置操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库 heap.Pop() 的伪代码：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := h.Len()</span><br><span class="line">    h.Swap(<span class="number">0</span>, n<span class="number">-1</span>)  <span class="comment">// 关键！交换根节点(最小值)和最后一个节点</span></span><br><span class="line">    down(h, <span class="number">0</span>, n<span class="number">-1</span>) <span class="comment">// 重新堆化</span></span><br><span class="line">    <span class="keyword">return</span> h.Pop()   <span class="comment">// 此时调用用户实现的Pop（取最后元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆操作流程（最小堆为例）"><a href="#堆操作流程（最小堆为例）" class="headerlink" title="堆操作流程（最小堆为例）"></a>堆操作流程（最小堆为例）</h3><ol><li><p><strong>初始化堆</strong>：<code>[3, 1, 5]</code> → 堆化后: <code>[1, 3, 5]</code></p><ul><li>索引0&#x3D;1（最小值）</li><li>最后索引&#x3D;5</li></ul></li><li><p><strong><code>heap.Pop()</code> 内部过程</strong>：</p><ul><li>交换根节点和最后节点: <code>[5, 3, 1]</code></li><li>重新堆化前n-1个元素: <code>[3, 5]</code> → 堆化后 <code>[3, 5]</code></li><li>调用用户 <code>Pop()</code> 返回最后元素 <code>1</code>（最小值）</li></ul></li><li><p><strong>结果</strong>：</p><ul><li>堆变为 <code>[3, 5]</code></li><li>弹出值 <code>1</code>（最小值）</li></ul></li></ol><h3 id="为什么最后位置不是最大值？"><a href="#为什么最后位置不是最大值？" class="headerlink" title="为什么最后位置不是最大值？"></a>为什么最后位置不是最大值？</h3><ul><li>堆的<strong>物理存储不是全排序的</strong>，只保证父≤子</li><li>最后一个元素是<strong>最后一片叶子节点</strong>，可能很小也可能很大</li><li>通过 <code>Swap(0, n-1)</code> 操作，实际弹出的是原根节点（最小值）</li></ul><h3 id="堆的视觉表示"><a href="#堆的视觉表示" class="headerlink" title="堆的视觉表示"></a>堆的视觉表示</h3><p>初始数组：<code>[3, 1, 5]</code><br>堆化后内存布局：<code>[1, 3, 5]</code><br>树状结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1    (根节点=最小值)</span><br><span class="line"> / \</span><br><span class="line">3   5  (5是最后一个叶子节点)</span><br></pre></td></tr></table></figure><p>Pop 时交换根和最后叶子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  5    (临时根)</span><br><span class="line"> / </span><br><span class="line">3    [1被交换到最后位置]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th><code>sort.Slice</code></th><th><code>container/heap</code></th></tr></thead><tbody><tr><td><code>Less</code> 作用</td><td>定义最终排序顺序</td><td>定义父子节点关系</td></tr><tr><td>内存布局</td><td>完全有序</td><td>半有序（树状结构）</td></tr><tr><td>索引0位置</td><td>最小值（升序时）</td><td>根节点（最小值）</td></tr><tr><td>最后索引位置</td><td>最大值（升序时）</td><td>不固定（最后一个叶子节点）</td></tr><tr><td><code>Pop()</code> 行为</td><td>无此操作</td><td>返回交换后的最后一个元素（原根节点）</td></tr></tbody></table><p>因此，在堆实现中：</p><ul><li><code>h[i] &lt; h[j]</code> 定义的是最小堆（根节点最小）</li><li><code>Pop()</code> 返回最小值，因为标准库在调用用户 <code>Pop()</code> 前已交换了根节点和最后节点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这涉及到 Go 中 &lt;code&gt;sort.Slice&lt;/code&gt; 和堆(&lt;code&gt;container/heap&lt;/code&gt;) 实现的&lt;strong&gt;关键区别&lt;/strong&gt;。虽然它们都使用 &lt;code&gt;Less&lt;/code&gt; 函数，但行为完全不同：&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>pycharm配置VPN代理</title>
    <link href="https://leiqi.top/2025-06-08-e7d1013a5402.html"/>
    <id>https://leiqi.top/2025-06-08-e7d1013a5402.html</id>
    <published>2025-06-08T16:18:16.000Z</published>
    <updated>2025-06-15T16:10:28.248Z</updated>
    
    <content type="html"><![CDATA[<p>确定本地VPN的代理端口：</p><p><img src="/../../imgs/Pasted%20image%2020250609001902.png"></p><p><img src="/../../imgs/Pasted%20image%2020250609001826.png"></p><p>点击check connetion 输入<a href="http://www.google.com/">http://www.google.com</a><br><img src="/../../imgs/Pasted%20image%2020250609001953.png"><br><img src="/../../imgs/Pasted%20image%2020250609001820.png"></p><p>也可以使用requests 包验证, 返回内容，不爆红即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.youtube.com&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250609002055.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确定本地VPN的代理端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250609001902.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202025060900</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯总结</title>
    <link href="https://leiqi.top/2025-06-03-fc6703ad881e.html"/>
    <id>https://leiqi.top/2025-06-03-fc6703ad881e.html</id>
    <published>2025-06-03T15:53:20.000Z</published>
    <updated>2025-06-15T16:10:28.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子集型回溯"><a href="#子集型回溯" class="headerlink" title="子集型回溯"></a>子集型回溯</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020250605230846.png"><br><img src="/../../imgs/Pasted%20image%2020250605230928.png"><br>方法一：输入的视角（选或不选）<br>对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2<br>n<br>  个不同的子集。</p><p>dfs 中的 i 表示当前考虑到 nums[i] 选或不选。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// 子集构造完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path)) <span class="comment">// 复制 path</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不选 nums[i]</span></span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选 nums[i]</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：<strong>答案的视角（枚举选哪个）</strong><br>枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。</p><p>dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。</p><p>如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。</p><p>注意：不需要在回溯中判断 i&#x3D;n 的边界情况，因为此时不会进入循环，if i &#x3D;&#x3D; n: return 这句话写不写都一样.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="131"><li>分割回文串 <a href="https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/">https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</a></li></ol><p>从答案的角度，枚举选哪个，需要使用for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := left, right;i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> (ans [][]<span class="type">string</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑 s[i:] 怎么分割</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// s 分割完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 枚举子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome(s, i, j) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[i:j+<span class="number">1</span>]) <span class="comment">// 分割！</span></span><br><span class="line">                <span class="comment">// 考虑剩余的 s[j+1:] 怎么分割</span></span><br><span class="line">                dfs(j + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="132"><li>电话号码的字母组合 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    m []<span class="type">string</span></span><br><span class="line">    path []<span class="type">byte</span></span><br><span class="line">    res []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 将index 和 字符串对应起来</span></span><br><span class="line">m = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">path, res = <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>),<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">backTracking(digits,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(digits <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 终止条件 ，遍历完digits</span></span><br><span class="line"><span class="keyword">if</span> start == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        tmp := <span class="type">string</span>(path)</span><br><span class="line">res = <span class="built_in">append</span>(res,tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到 digit</span></span><br><span class="line">digitNum := <span class="type">int</span>(digits[start] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">// 遍历 digit 对应的map 字符串</span></span><br><span class="line">str := m[digitNum]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(str);i++ &#123; <span class="comment">// i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始</span></span><br><span class="line">path = <span class="built_in">append</span>(path,str[i])</span><br><span class="line">backTracking(digits,start+<span class="number">1</span>)</span><br><span class="line">path =path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合型回溯"><a href="#组合型回溯" class="headerlink" title="组合型回溯"></a>组合型回溯</h2><p><img src="/../../imgs/Pasted%20image%2020250611222518.png"></p><ol><li>左边选或者不选  K&#x3D;3  右边k &#x3D; 2, 因为是组合，等于是重复的就能再出现了，再选了2 之后，只能选1 了， 不能再选其他的了。<br><img src="/../../imgs/Pasted%20image%2020250611223356.png"><br>倒序的不等式简单点，正序的不等式为 n - i + 1 &lt; d 直接return</li></ol><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i - <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(n)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= n; i++ &#123; <span class="comment">// 倒序方便</span></span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> n-i+<span class="number">1</span> &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode216</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个合法组合</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &amp;&amp; sum == n &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝：剩余数字不足以填满 path 或无法达到 sum</span></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 确保剩余数字足够填满 path</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum+i &gt; n &#123; <span class="comment">// 提前终止，避免无效递归  如果 sum + i &gt; n，说明当前 i 太大，不能选它。但 更小的 i 仍然可能满足 sum + i &lt;= n，所以不能直接 break（否则会漏掉可能的解）。</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i<span class="number">-1</span>, sum+i)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">9</span>, <span class="number">0</span>) <span class="comment">// 数字范围是 1~9</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p><p>思路<a href="https://labuladong.online/algo/practice-in-action/generate-parentheses/">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态数据 回退操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//n 对括号 只要最后左右总和一样，</span></span><br><span class="line">m := n * <span class="number">2</span></span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span></span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == m &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选左边</span></span><br><span class="line"><span class="keyword">if</span> open &lt; n &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选右边</span></span><br><span class="line"><span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 右边要小于左边才能加</span></span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 入口函数需要添加</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定长度+索引，不用回退</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    m := n * <span class="number">2</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == m &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, <span class="type">string</span>(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> open &lt; n &#123; <span class="comment">// 可以填左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 可以填右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你提供的这个实现中，不需要显式的回退操作（如 <code>path = path[:len(path)-1]</code>），是因为它采用了 <strong>固定长度的 <code>[]byte</code> 数组</strong> 和 <strong>索引覆盖</strong> 的方式，这与常见的回溯算法实现有所不同。下面详细解释为什么可以省略回退操作：</p><hr><h3 id="关键原因分析"><a href="#关键原因分析" class="headerlink" title="关键原因分析"></a><strong>关键原因分析</strong></h3><h4 id="1-使用固定长度的-byte-数组"><a href="#1-使用固定长度的-byte-数组" class="headerlink" title="1. 使用固定长度的 []byte 数组"></a>1. <strong>使用固定长度的 <code>[]byte</code> 数组</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)  <span class="comment">// 长度为 m 的固定数组</span></span><br></pre></td></tr></table></figure><ul><li>数组 <code>path</code> 的长度在初始化时就固定为 <code>m</code>（<code>=n*2</code>），不会动态增长。</li><li>每个递归层级直接通过索引 <code>i</code> 修改 <code>path[i]</code> 的位置，<strong>不会影响其他层级的存储</strong>。</li></ul><h4 id="2-索引覆盖写入"><a href="#2-索引覆盖写入" class="headerlink" title="2. 索引覆盖写入"></a>2. <strong>索引覆盖写入</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 或 path[i] = &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>每次写入都会<strong>精确覆盖 <code>path[i]</code> 的位置</strong>，而不会追加元素。</li><li>递归返回时，<strong>上层调用会覆盖当前层写入的值</strong>，因此不需要手动回退。</li></ul><h4 id="3-递归的自然回溯"><a href="#3-递归的自然回溯" class="headerlink" title="3. 递归的自然回溯"></a>3. <strong>递归的自然回溯</strong></h4><ul><li>当递归从深层返回时，<strong>上层调用会继续修改 <code>path</code> 的后续位置</strong>，覆盖之前的值。</li><li>例如：<ul><li>第一层递归写入 <code>path[0] = &#39;(&#39;</code>，然后进入第二层。</li><li>第二层写入 <code>path[1] = &#39;(&#39;</code> 或 <code>path[1] = &#39;)&#39;</code>。</li><li>当第二层递归返回后，第一层可能会写入 <code>path[1] = &#39;)&#39;</code>，覆盖之前的值。</li></ul></li></ul><hr><h3 id="对比需要回退操作的实现"><a href="#对比需要回退操作的实现" class="headerlink" title="对比需要回退操作的实现"></a><strong>对比需要回退操作的实现</strong></h3><h4 id="需要回退的版本（动态-append）"><a href="#需要回退的版本（动态-append）" class="headerlink" title="需要回退的版本（动态 append）"></a><strong>需要回退的版本（动态 <code>append</code>）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)  <span class="comment">// 修改切片长度</span></span><br><span class="line">dfs(...)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 必须回退</span></span><br></pre></td></tr></table></figure><ul><li>动态 <code>append</code> 会改变切片长度，必须显式回退以恢复状态。</li></ul><h4 id="不需要回退的版本（固定数组-索引覆盖）"><a href="#不需要回退的版本（固定数组-索引覆盖）" class="headerlink" title="不需要回退的版本（固定数组 + 索引覆盖）"></a><strong>不需要回退的版本（固定数组 + 索引覆盖）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 直接覆盖，不改变长度</span></span><br><span class="line">dfs(...)</span><br><span class="line"><span class="comment">// 无需回退，上层调用会覆盖 path[i]</span></span><br></pre></td></tr></table></figure><ul><li>固定数组的长度不变，通过索引直接修改值，递归返回后自然被覆盖。</li></ul><hr><h3 id="为什么这种写法是正确的？"><a href="#为什么这种写法是正确的？" class="headerlink" title="为什么这种写法是正确的？"></a><strong>为什么这种写法是正确的？</strong></h3><ol><li><p><strong>隐式回溯</strong>：</p><ul><li>每一层递归的 <code>path[i]</code> 写入是独立的，递归返回后会被上层调用覆盖。</li><li>例如：<ul><li>路径 <code>&quot;(())&quot;</code> 的生成过程：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path[<span class="number">0</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第一层</span></span><br><span class="line">path[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第二层</span></span><br><span class="line">path[<span class="number">2</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第三层</span></span><br><span class="line">path[<span class="number">3</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第四层</span></span><br></pre></td></tr></table></figure></li><li>如果第二层尝试 <code>path[1] = &#39;)&#39;</code>，它会覆盖之前的 <code>&#39;(&#39;</code>，但通过条件 <code>i-open &lt; open</code> 保证了合法性。</li></ul></li></ul></li><li><p><strong>条件保证合法性</strong>：</p><ul><li><code>open &lt; n</code> 确保左括号不超过 <code>n</code> 个。</li><li><code>i-open &lt; open</code> 确保右括号数不超过左括号数。</li></ul></li></ol><hr><ul><li><strong>不需要回退</strong>：因为使用了固定长度的 <code>[]byte</code> 数组，通过索引直接覆盖写入，递归返回时上层调用会自然覆盖当前层的修改。</li><li><strong>更高效</strong>：避免了动态切片的扩容和回退操作，减少了内存分配。</li><li><strong>更简洁</strong>：代码更紧凑，但需要理解索引覆盖的隐式回溯逻辑。</li></ul><p>这种写法是回溯算法的一种优化技巧，适用于结果长度固定的场景（如括号生成、排列问题等）。</p><h2 id="排列型回溯"><a href="#排列型回溯" class="headerlink" title="排列型回溯"></a>排列型回溯</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子集型回溯&quot;&gt;&lt;a href=&quot;#子集型回溯&quot; class=&quot;headerlink&quot; title=&quot;子集型回溯&quot;&gt;&lt;/a&gt;子集型回溯&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/letter-combinations-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>闭包介绍</title>
    <link href="https://leiqi.top/2025-05-28-3ec80348e81b.html"/>
    <id>https://leiqi.top/2025-05-28-3ec80348e81b.html</id>
    <published>2025-05-28T15:10:41.000Z</published>
    <updated>2025-06-15T16:10:28.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么闭包能共享变量-pre？"><a href="#为什么闭包能共享变量-pre？" class="headerlink" title="为什么闭包能共享变量 pre？"></a>为什么闭包能共享变量 <code>pre</code>？</h3><p>在提供的代码中，闭包能够共享变量 <code>pre</code> 的关键在于 <strong>词法作用域（Lexical Scoping）</strong> 和 <strong>闭包捕获变量</strong> 的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    pre := math.MinInt64 <span class="comment">// 外层函数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问并修改外层的 pre 变量</span></span><br><span class="line">        <span class="keyword">if</span> node.Val &lt;= pre &#123; ... &#125;</span><br><span class="line">        pre = node.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ol><li><p><strong>词法作用域</strong>：</p><ul><li>Go 中函数可以访问定义时所在作用域的所有变量</li><li><code>dfs</code> 匿名函数定义在 <code>isValidBST</code> 函数体内，自然能访问 <code>pre</code></li></ul></li><li><p><strong>闭包捕获变量</strong>：</p><ul><li>闭包不会复制变量值，而是<strong>捕获变量的引用</strong></li><li>所有递归调用的 <code>dfs</code> 都指向<strong>同一个 <code>pre</code> 变量</strong></li><li>修改 <code>pre</code> 会影响所有闭包实例</li></ul></li><li><p><strong>递归共享状态</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[pre=MinInt64] --&gt; B[dfs-根节点]</span><br><span class="line">B --&gt; C[dfs-左子节点]</span><br><span class="line">C --&gt; D[dfs-左孙节点]</span><br><span class="line">D --&gt;|更新pre| C</span><br><span class="line">C --&gt;|更新pre| B</span><br><span class="line">B --&gt;|更新pre| E[dfs-右子节点]</span><br></pre></td></tr></table></figure></li></ol><h3 id="闭包名称的含义与起源"><a href="#闭包名称的含义与起源" class="headerlink" title="闭包名称的含义与起源"></a>闭包名称的含义与起源</h3><h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><p>“闭包”（Closure）一词来源于 <strong>函数”闭合”（close over）其定义环境</strong> 的概念：</p><ul><li>最早由 Peter J. Landin 在 1964 年提出</li><li>源自数学中的 <strong>λ演算（Lambda Calculus）</strong> 和 <strong>闭包属性（Closure Property）</strong></li><li>在编译原理中称为 <strong>词法闭包（Lexical Closure）</strong></li></ul><h4 id="名称含义"><a href="#名称含义" class="headerlink" title="名称含义"></a>名称含义</h4><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>闭（Close）</strong></td><td>函数”封闭”地携带其定义时的环境</td></tr><tr><td><strong>包（-ure）</strong></td><td>将函数与其环境”打包”在一起</td></tr></tbody></table><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol><li><strong>环境捕获</strong>：函数记住并访问定义时的作用域</li><li><strong>状态持久化</strong>：捕获的变量生命周期与闭包相同</li><li><strong>私密状态</strong>：只有闭包能访问捕获的变量</li></ol><h3 id="闭包在-BST-验证中的优势"><a href="#闭包在-BST-验证中的优势" class="headerlink" title="闭包在 BST 验证中的优势"></a>闭包在 BST 验证中的优势</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre := math.MinInt64  <span class="comment">// 共享状态</span></span><br><span class="line">dfs := <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 递归过程共享同一个 pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>状态管理简化</strong>：无需指针传递</li><li><strong>代码更简洁</strong>：减少参数传递</li><li><strong>逻辑更直观</strong>：直接读写共享状态</li><li><strong>避免值复制</strong>：高效处理递归状态</li></ol><h3 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h3><p>闭包本质上是一个 <strong>（函数 + 绑定环境）</strong> 的组合体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span>  <span class="comment">// 函数逻辑</span></span><br><span class="line">    Env <span class="keyword">struct</span> &#123;            <span class="comment">// 捕获的环境</span></span><br><span class="line">        pre <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次递归调用时，都使用同一个 <code>Env</code> 环境，这正是 BST 验证需要的中序遍历状态一致性保证。</p><h3 id="闭包-vs-指针参数"><a href="#闭包-vs-指针参数" class="headerlink" title="闭包 vs 指针参数"></a>闭包 vs 指针参数</h3><table><thead><tr><th>特性</th><th>闭包</th><th>指针参数</th></tr></thead><tbody><tr><td>状态共享</td><td>自动捕获</td><td>需显式传递</td></tr><tr><td>可读性</td><td>★★★☆☆</td><td>★★☆☆☆</td></tr><tr><td>安全性</td><td>变量封装</td><td>暴露内存地址</td></tr><tr><td>递归适用性</td><td>非常适合</td><td>需要小心指针传递</td></tr></tbody></table><p>在 BST 验证场景中，闭包方案更简洁安全，避免了指针传递的复杂性，是 Go 语言处理递归状态的首选模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么闭包能共享变量-pre？&quot;&gt;&lt;a href=&quot;#为什么闭包能共享变量-pre？&quot; class=&quot;headerlink&quot; title=&quot;为什么闭包能共享变量 pre？&quot;&gt;&lt;/a&gt;为什么闭包能共享变量 &lt;code&gt;pre&lt;/code&gt;？&lt;/h3&gt;&lt;p&gt;在提供的代</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>comet 生成临时文件导致磁盘满</title>
    <link href="https://leiqi.top/2025-05-01-d5e22ea4be8d.html"/>
    <id>https://leiqi.top/2025-05-01-d5e22ea4be8d.html</id>
    <published>2025-05-01T13:50:34.000Z</published>
    <updated>2025-06-15T16:10:28.249Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>出现 <code>OSError: [Errno 28] No space left on device</code> 错误的原因是系统磁盘空间不足，尤其是在临时目录（如 <code>/tmp</code>）中。以下是分步解决方案：</p><hr><h4 id="1-检查磁盘空间"><a href="#1-检查磁盘空间" class="headerlink" title="1. 检查磁盘空间"></a><strong>1. 检查磁盘空间</strong></h4><p>在终端运行以下命令，查看磁盘使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><h4 id="2-清理临时文件"><a href="#2-清理临时文件" class="headerlink" title="2. 清理临时文件"></a><strong>2. 清理临时文件</strong></h4><p>删除临时目录中的旧文件（确保无重要进程依赖这些文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /tmp/*</span><br></pre></td></tr></table></figure><hr><h4 id="3-查找并删除大文件"><a href="#3-查找并删除大文件" class="headerlink" title="3. 查找并删除大文件"></a><strong>3. 查找并删除大文件</strong></h4><p>使用以下命令定位大文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看根目录下各文件夹的大小</span></span><br><span class="line">sudo <span class="built_in">du</span> -sh /* | <span class="built_in">sort</span> -hr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下大于 1GB 的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +1G -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>删除不再需要的大文件（如旧日志、缓存等）。</p><hr><h4 id="4-清理系统缓存和日志"><a href="#4-清理系统缓存和日志" class="headerlink" title="4. 清理系统缓存和日志"></a><strong>4. 清理系统缓存和日志</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 APT 缓存（适用于 Ubuntu/Debian）</span></span><br><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧版 Linux 内核（谨慎操作）</span></span><br><span class="line">sudo apt-get autoremove --purge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理系统日志（保留最近7天）</span></span><br><span class="line">sudo journalctl --vacuum-time=7d</span><br></pre></td></tr></table></figure><hr><h4 id="5-更改临时目录路径"><a href="#5-更改临时目录路径" class="headerlink" title="5. 更改临时目录路径"></a><strong>5. 更改临时目录路径</strong></h4><p>如果 <code>/tmp</code> 所在分区空间不足，可以将临时目录指向其他分区：</p><p><strong>方法一：在代码中设置临时目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">tempfile.tempdir = <span class="string">&quot;/path/to/your/large/disk/tmp&quot;</span>  <span class="comment"># 替换为有足够空间的路径</span></span><br></pre></td></tr></table></figure><p><strong>方法二：通过环境变量设置</strong><br>在运行脚本前设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TMPDIR=/path/to/your/large/disk/tmp</span><br></pre></td></tr></table></figure><hr><h4 id="6-调整-Comet-ml-的存储路径"><a href="#6-调整-Comet-ml-的存储路径" class="headerlink" title="6. 调整 Comet.ml 的存储路径"></a><strong>6. 调整 Comet.ml 的存储路径</strong></h4><p>在初始化 <code>Experiment</code> 时指定日志和临时文件目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">experiment = Experiment(</span><br><span class="line">    <span class="string">&quot;H62QCY6dW6Vg9lLl27jZn4C2O&quot;</span>,</span><br><span class="line">    project_name=<span class="string">&quot;IDRsPredictor-transformer&quot;</span>,</span><br><span class="line">    log_code=<span class="literal">True</span>,</span><br><span class="line">    log_dir=<span class="string">&quot;/path/to/large/disk/comet_logs&quot;</span>  <span class="comment"># 指定存储路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参考：chatGPT</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;出现 &lt;code&gt;OSError: [Errno 28] No space le</summary>
      
    
    
    
    <category term="比赛" scheme="https://leiqi.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Git自动转换为Linux换行符</title>
    <link href="https://leiqi.top/2025-04-28-84ca2c3d5919.html"/>
    <id>https://leiqi.top/2025-04-28-84ca2c3d5919.html</id>
    <published>2025-04-28T13:15:32.000Z</published>
    <updated>2025-06-15T16:10:28.244Z</updated>
    
    <content type="html"><![CDATA[<p>在 Git 中处理不同操作系统（Windows&#x2F;Linux&#x2F;macOS）的换行符（<code>LF</code> 和 <code>CRLF</code>）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：</p><hr><h3 id="1-核心配置：core-autocrlf"><a href="#1-核心配置：core-autocrlf" class="headerlink" title="1. 核心配置：core.autocrlf"></a><strong>1. 核心配置：<code>core.autocrlf</code></strong></h3><p>通过设置 <code>core.autocrlf</code> 属性，让 Git 自动转换换行符：</p><h4 id="不同操作系统的推荐设置"><a href="#不同操作系统的推荐设置" class="headerlink" title="不同操作系统的推荐设置"></a><strong>不同操作系统的推荐设置</strong></h4><ul><li><p><strong>Windows（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时转换为 CRLF</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Linux&#x2F;macOS（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时不转换</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-强制规范：-gitattributes-文件"><a href="#2-强制规范：-gitattributes-文件" class="headerlink" title="2. 强制规范：.gitattributes 文件"></a><strong>2. 强制规范：<code>.gitattributes</code> 文件</strong></h3><p>在项目根目录创建 <code>.gitattributes</code> 文件，<strong>优先级高于全局配置</strong>，适合团队协作。</p><h4 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 所有文本文件使用 LF 换行符</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># 排除二进制文件（避免误处理）</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br><span class="line">*.zip binary</span><br><span class="line"></span><br><span class="line"># 指定特定文件类型（可选）</span><br><span class="line">*.sh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure><ul><li><code>text=auto</code>：Git 自动识别文本文件。</li><li><code>eol=lf</code> 或 <code>eol=crlf</code>：强制统一换行符。</li></ul><hr><h3 id="3-修复已存在的换行符问题"><a href="#3-修复已存在的换行符问题" class="headerlink" title="3. 修复已存在的换行符问题"></a><strong>3. 修复已存在的换行符问题</strong></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol><li><p>删除缓存并重置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached -r .  <span class="comment"># 清除缓存</span></span><br><span class="line">git reset --hard      <span class="comment"># 重置文件</span></span><br></pre></td></tr></table></figure></li><li><p>重新添加文件并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;fix: normalize line endings&quot;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-检查换行符状态"><a href="#4-检查换行符状态" class="headerlink" title="4. 检查换行符状态"></a><strong>4. 检查换行符状态</strong></h3><h4 id="检查文件换行符："><a href="#检查文件换行符：" class="headerlink" title="检查文件换行符："></a><strong>检查文件换行符</strong>：</h4><ul><li><p><strong>Linux&#x2F;macOS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file yourfile.txt</span><br><span class="line"><span class="comment"># 输出中包含 &quot;LF&quot; 或 &quot;CRLF&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Windows（PowerShell）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> yourfile.txt <span class="literal">-Encoding</span> Byte | <span class="built_in">Select-String</span> <span class="string">&quot;0D 0A&quot;</span></span><br><span class="line"><span class="comment"># 存在 &quot;0D 0A&quot; 表示 CRLF</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="查看-Git-换行符转换日志："><a href="#查看-Git-换行符转换日志：" class="headerlink" title="查看 Git 换行符转换日志："></a><strong>查看 Git 换行符转换日志</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --eol</span><br></pre></td></tr></table></figure><hr><h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a><strong>常见问题解决</strong></h3><ul><li><p>**警告 <code>LF will be replaced by CRLF</code>**：<br>正常提示，表示 Git 正在按配置转换换行符。</p></li><li><p><strong>文件被标记为已修改（仅换行符变化）</strong>：<br>运行以下命令清除差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.whitespace cr-at-eol</span><br><span class="line">git add --renormalize .</span><br></pre></td></tr></table></figure></li><li><p><strong>混合换行符导致冲突</strong>：<br>使用 <code>.gitattributes</code> 强制统一换行符，并重新提交文件。</p></li></ul><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol><li><strong>团队协作</strong>：在项目中添加 <code>.gitattributes</code> 文件，统一换行符规则。</li><li><strong>编辑器配置</strong>：设置 IDE（如 VSCode）默认使用 <code>LF</code>（<a href="https://stackoverflow.com/a/44788470">配置示例</a>）。</li><li><strong>Windows 用户</strong>：安装 Git 时选择 <code>Checkout as-is, commit Unix-style line endings</code>。</li></ol><hr><p>通过上述配置，Git 会自动处理换行符，避免跨平台协作时的混乱！ 🛠️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Git 中处理不同操作系统（Windows&amp;#x2F;Linux&amp;#x2F;macOS）的换行符（&lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt;）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>更新网页url后，恢复valine网页评论</title>
    <link href="https://leiqi.top/2025-04-13-8c397fc87827.html"/>
    <id>https://leiqi.top/2025-04-13-8c397fc87827.html</id>
    <published>2025-04-13T04:28:35.000Z</published>
    <updated>2025-06-15T16:10:28.247Z</updated>
    
    <content type="html"><![CDATA[<p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。<br>具体步骤：登录&gt;选择你创建的应用&gt;数据存储&gt;结构化数据&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><p>修改 对应url 列为当前url<br><img src="/../../imgs/Pasted%20image%2020250413122851.png"><img src="/../../imgs/Pasted%20image%2020250413123508.png"></p><p>参考：<br><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。&lt;br&gt;具体步骤：登录&amp;gt;选择你创建的应用&amp;gt;数据存储&amp;gt;结构化数据&amp;gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构设计专题</title>
    <link href="https://leiqi.top/2025-03-06-dab119f1439d.html"/>
    <id>https://leiqi.top/2025-03-06-dab119f1439d.html</id>
    <published>2025-03-06T14:56:44.000Z</published>
    <updated>2025-06-15T16:10:28.250Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th><th>是否完成</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td><td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td><td>🟠</td><td>202050306🟢</td></tr><tr><td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td><td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td><td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td><td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td><td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td><td>🟢</td><td>202050307🟢</td></tr><tr><td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td><td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td><td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td><td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td><td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td><td>🟠</td><td>🔴</td></tr></tbody></table><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请设计 最近 最少使用 约束的数据结构<br><img src="/../../imgs/Pasted%20image%2020250309231207.png"></p><p>20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">orderList []<span class="type">int</span></span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">orderList: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, capacity), <span class="comment">// 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</span></span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, capacity),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// key 存在与单独的环境中</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.Update(key)</span><br><span class="line"><span class="keyword">return</span> this.cacheMaps[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Update(key <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 更新key 到最新位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.orderList); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this.orderList[i] == key &#123;</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList[:i], <span class="built_in">append</span>(this.orderList[i+<span class="number">1</span>:], this.orderList[i])...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.Update(key)</span><br><span class="line">&#125;  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &gt;= this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=&quot;</span>,<span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line">oldKey := this.orderList[<span class="number">0</span>]</span><br><span class="line">this.orderList = this.orderList[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, oldKey)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &lt; this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;&lt;&quot;</span>, <span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-1-方法双向列表，map-中直接保存列表元素指针，"><a href="#O-1-方法双向列表，map-中直接保存列表元素指针，" class="headerlink" title="O(1) 方法双向列表，map 中直接保存列表元素指针，"></a>O(1) 方法双向列表，map 中直接保存列表元素指针，</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">orderList *list.List</span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element, capacity),</span><br><span class="line">orderList: list.New(),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(entry).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新已存在的键</span></span><br><span class="line">elem.Value = entry&#123;key: key, value: value&#125;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入新键</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) == this.capacity &#123;</span><br><span class="line"><span class="comment">// 删除最久未使用的键</span></span><br><span class="line">frontElem := this.orderList.Front()</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, frontElem.Value.(entry).key)</span><br><span class="line">this.orderList.Remove(frontElem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入新键到链表末尾</span></span><br><span class="line">newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;)</span><br><span class="line">this.cacheMaps[key] = newElem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p><img src="/../../imgs/Pasted%20image%2020250307231252.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1700  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9分钟完成  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStudents</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 栈模拟  </span></span><br><span class="line">    <span class="comment">// 结束条件  </span></span><br><span class="line">    <span class="comment">// 同学中数字都相同，且不等于栈顶元素 [0]  </span></span><br><span class="line">    <span class="keyword">for</span> !isEnd(students, sandwiches) &#123;  </span><br><span class="line">       <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>] &#123;  </span><br><span class="line">          sandwiches = sandwiches[<span class="number">1</span>:]  </span><br><span class="line">          students = students[<span class="number">1</span>:]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          students = <span class="built_in">append</span>(students[<span class="number">1</span>:], students[<span class="number">0</span>])  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(students)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnd</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> students &#123;  </span><br><span class="line">       <span class="keyword">if</span> val == sandwiches[<span class="number">0</span>] &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据结构设计&quot;&gt;&lt;a href=&quot;#数据结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据结构设计&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://labuladong.online/algo/intro/quick-learning-plan/#%</summary>
      
    
    
    
    <category term="速刷记录" scheme="https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>系统序列图 - 时序图</title>
    <link href="https://leiqi.top/2025-02-19-05250c3f88f5.html"/>
    <id>https://leiqi.top/2025-02-19-05250c3f88f5.html</id>
    <published>2025-02-19T12:07:47.000Z</published>
    <updated>2025-06-15T16:10:28.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219200803.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>如何画好一个架构图</title>
    <link href="https://leiqi.top/2025-02-19-d829d1f5a9ea.html"/>
    <id>https://leiqi.top/2025-02-19-d829d1f5a9ea.html</id>
    <published>2025-02-19T11:39:54.000Z</published>
    <updated>2025-06-15T16:10:28.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p><h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p><ul><li>通过不同的颜色白标识不同颜色</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p><h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p><p>使用场景：</p><ul><li>项目开发和测试</li><li>部署发布</li><li>子领域项目架构，下方就是个会员中心*</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p><h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p><p>使用场景</p><ul><li>总体架构设计</li><li>运维规划和优化</li><li>画图技巧</li><li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li></ul><p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务架构&quot;&gt;&lt;a href=&quot;#业务架构&quot; class=&quot;headerlink&quot; title=&quot;业务架构&quot;&gt;&lt;/a&gt;业务架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219195041.png&quot;&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <link href="https://leiqi.top/2025-01-13-1b5c01477594.html"/>
    <id>https://leiqi.top/2025-01-13-1b5c01477594.html</id>
    <published>2025-01-13T15:40:59.000Z</published>
    <updated>2025-06-15T16:10:28.241Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *</span><br></pre></td></tr></table></figure><p>解释一下这个命令：</p><ul><li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li><li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li><li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul><li><code>s</code> 表示替换操作。</li><li><code>hide: true</code> 是要被替换的字符串。</li><li><code>hide: false</code> 是替换后的字符串。</li><li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li></ul></li><li><code>*</code> 表示当前文件夹下的所有文件。</li></ul><p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure><p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Linux 中，可以使用以下命令来实现这个需求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-06-15T16:10:28.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】for range 数组指针遍历</title>
    <link href="https://leiqi.top/2024-12-03-90d19c862e9c.html"/>
    <id>https://leiqi.top/2024-12-03-90d19c862e9c.html</id>
    <published>2024-12-03T16:55:24.000Z</published>
    <updated>2025-06-15T16:10:28.246Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，使用<code>for range</code>遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如<code>[]*Student</code>）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。</p><p>这意味着，即使<code>for range</code>对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    students := []*Student&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;Bob&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用for range遍历指针数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        <span class="comment">// 修改指向的结构体的内容</span></span><br><span class="line">        student.Age += <span class="number">1</span> <span class="comment">// 给每个学生的年龄加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的students数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, student.Name, student.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管<code>for range</code>对每个<code>*Student</code>指针进行了拷贝，但通过这个拷贝的指针修改<code>Age</code>字段时，修改的是原始<code>Student</code>结构体的内容。因此，当再次遍历<code>students</code>数组时，你会看到每个学生的年龄都已经增加了。</p><p>总结来说，当你使用<code>for range</code>遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，使用&lt;code&gt;for range&lt;/code&gt;遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如&lt;code&gt;[]*Student&lt;/code&gt;）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 浮点数次方</title>
    <link href="https://leiqi.top/2024-12-03-3d026e7b5bec.html"/>
    <id>https://leiqi.top/2024-12-03-3d026e7b5bec.html</id>
    <published>2024-12-03T15:46:08.000Z</published>
    <updated>2025-06-15T16:10:28.240Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，计算一个数的几次方可以通过标准库中的<code>math</code>包来实现。<code>math</code>包提供了一个<code>Pow</code>函数，用于计算x的y次方。</p><h3 id="使用math-Pow函数"><a href="#使用math-Pow函数" class="headerlink" title="使用math.Pow函数"></a>使用<code>math.Pow</code>函数</h3><p><code>math.Pow</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pow</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>这个函数接受两个<code>float64</code>类型的参数：<code>x</code>是底数，<code>y</code>是指数，返回<code>x</code>的<code>y</code>次方的结果。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用<code>math.Pow</code>函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算2的3次方</span></span><br><span class="line">    result := math.Pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;2的3次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算3的2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;3的2次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算10的-2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">10</span>, <span class="number">-2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;10的-2次方是: %v\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2的3次方是: 8</span><br><span class="line">3的2次方是: 9</span><br><span class="line">10的-2次方是: 0.01</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>math.Pow</code>函数的参数和返回值都是<code>float64</code>类型，因此如果你需要计算整数的次方，可能需要先将整数转换为<code>float64</code>，然后再进行计算。</li><li>如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，计算一个数的几次方可以通过标准库中的&lt;code&gt;math&lt;/code&gt;包来实现。&lt;code&gt;math&lt;/code&gt;包提供了一个&lt;code&gt;Pow&lt;/code&gt;函数，用于计算x的y次方。&lt;/p&gt;
&lt;h3 id=&quot;使用math-Pow函数&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【基础知识】Golang  sort.Slice 复杂排序</title>
    <link href="https://leiqi.top/2024-11-24-24291296f81a.html"/>
    <id>https://leiqi.top/2024-11-24-24291296f81a.html</id>
    <published>2024-11-24T04:47:52.000Z</published>
    <updated>2025-06-15T16:10:28.246Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，你可以使用 <code>sort.Slice</code> 对 <code>slice</code> 按照复杂条件进行排序。 <code>sort.Slice</code> 函数接受一个 <code>slice</code> 和一个比较函数，该比较函数定义了两个元素之间的排序关系。</p><p>以下是实现复杂条件排序的步骤和示例：</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(slice, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 slice[i] 和 slice[j]</span></span><br><span class="line">    <span class="keyword">return</span> 条件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-示例：对结构体切片进行多条件排序"><a href="#2-示例：对结构体切片进行多条件排序" class="headerlink" title="2. 示例：对结构体切片进行多条件排序"></a>2. 示例：对结构体切片进行多条件排序</h3><p>假设有一个包含多个 <code>Person</code> 的切片，我们希望按以下规则排序：</p><ol><li>年龄从小到大排序。</li><li>如果年龄相同，则按名字的字母顺序排序。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sort.Slice 按多个条件排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 优先按年龄排序</span></span><br><span class="line"><span class="keyword">if</span> people[i].Age != people[j].Age &#123;</span><br><span class="line"><span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果年龄相同，则按名字排序</span></span><br><span class="line"><span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-更复杂条件：按多个字段权重排序"><a href="#3-更复杂条件：按多个字段权重排序" class="headerlink" title="3. 更复杂条件：按多个字段权重排序"></a>3. 更复杂条件：按多个字段权重排序</h3><p>如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Price <span class="type">float64</span></span><br><span class="line">Rating <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">products := []Product&#123;</span><br><span class="line">&#123;<span class="string">&quot;Laptop&quot;</span>, <span class="number">1000</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Phone&quot;</span>, <span class="number">800</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Tablet&quot;</span>, <span class="number">800</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Watch&quot;</span>, <span class="number">400</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序</span></span><br><span class="line">sort.Slice(products, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 按价格降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Price != products[j].Price &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Price &gt; products[j].Price</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果价格相同，按评分降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Rating != products[j].Rating &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Rating &gt; products[j].Rating</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果评分也相同，按名称升序</span></span><br><span class="line"><span class="keyword">return</span> products[i].Name &lt; products[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(products)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li>如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。</li><li><code>sort.Slice</code> 是不稳定的。如果需要稳定排序，可以使用 <code>sort.SliceStable</code>。</li><li>对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。</li></ul><p>通过 <code>sort.Slice</code> 的灵活性，可以轻松实现各种复杂条件的排序逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，你可以使用 &lt;code&gt;sort.Slice&lt;/code&gt; 对 &lt;code&gt;slice&lt;/code&gt; 按照复杂条件进行排序。 &lt;code&gt;sort.Slice&lt;/code&gt; 函数接受一个 &lt;code&gt;slice&lt;/code&gt; 和一个比较函数，该比较函数定义</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】创建slice是否填第二个参数0的区别</title>
    <link href="https://leiqi.top/2024-11-23-b80d94088ccd.html"/>
    <id>https://leiqi.top/2024-11-23-b80d94088ccd.html</id>
    <published>2024-11-23T05:10:49.000Z</published>
    <updated>2025-06-15T16:10:28.246Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，创建切片（slice）时使用<code>make</code>函数有两种常见的方式，它们之间有细微的差别：</p><ol><li><p><code>slice := make([]string, 0)</code></p><p> 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是<code>[]string</code>），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。</p></li><li><p><code>slice := make([]string)</code></p><p> 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，<code>make</code>函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。</p></li></ol><p>两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用<code>make([]string)</code>（或者等价的<code>make([]string, 0)</code>）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。</p><p>总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，创建切片（slice）时使用&lt;code&gt;make&lt;/code&gt;函数有两种常见的方式，它们之间有细微的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;slice := make([]string, 0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 这种方式明确指定了切片的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting</title>
    <link href="https://leiqi.top/2024-11-23-cf0eba4d8369.html"/>
    <id>https://leiqi.top/2024-11-23-cf0eba4d8369.html</id>
    <published>2024-11-23T05:05:23.000Z</published>
    <updated>2025-06-15T16:10:28.246Z</updated>
    
    <content type="html"><![CDATA[<p>确实，如果我们按照缩写的逻辑来看，<code>Itos</code>（Integer to String）可能更直观地表达了<code>Itoa</code>函数的功能，即把整数转换为字符串。</p><p>然而，<code>Itoa</code>这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，<code>Itoa</code>这个术语已经被广泛接受和使用。以下是一些可能的原因：</p><ol><li><p><strong>历史原因</strong>：<code>Itoa</code>这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，<code>Itoa</code>（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。</p></li><li><p><strong>约定俗成</strong>：在编程社区中，<code>Itoa</code>已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。</p></li><li><p><strong>ASCII与字符串的关系</strong>：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字<code>123</code>的ASCII表示和字符串表示都是<code>&quot;123&quot;</code>。因此，<code>Itoa</code>这个名字仍然适用。</p></li><li><p><strong>简洁性</strong>：<code>Itoa</code>这个名称比较简洁，易于记忆。如果使用<code>Itos</code>，虽然直观，但可能不如<code>Itoa</code>简洁。</p></li></ol><p><code>Itoa</code>这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管<code>Itos</code>可能更直观地表示整数到字符串的转换，但<code>Itoa</code>已经成为一个广泛接受和使用的术语。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确实，如果我们按照缩写的逻辑来看，&lt;code&gt;Itos&lt;/code&gt;（Integer to String）可能更直观地表达了&lt;code&gt;Itoa&lt;/code&gt;函数的功能，即把整数转换为字符串。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;Itoa&lt;/code&gt;这个名称的由来实际上与历史</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
    <category term="刨根问底" scheme="https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
</feed>
