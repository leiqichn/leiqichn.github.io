<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2023-05-30T16:12:29.664Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 104.二叉树的深度</title>
    <link href="https://leiqichn.github.io/2023-05-30-b1879d2b65d1.html"/>
    <id>https://leiqichn.github.io/2023-05-30-b1879d2b65d1.html</id>
    <published>2023-05-30T15:33:48.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>个人网站：<a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531000419.png"></p><p>二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。</p><p>所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(root *treenode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxdepth(root.left), maxdepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>可以使用模板层序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>queue := list.New()<br>queue.PushBack(root)<br><br><span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>size := queue.Len()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br><span class="hljs-comment">// 切掉第一个元素</span><br>first := queue.Remove(queue.Front()).(*TreeNode) <span class="hljs-comment">//注意层序遍历是切掉前边一个</span><br><span class="hljs-keyword">if</span> first.Left != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Left)<br>&#125;<br><span class="hljs-keyword">if</span> first.Right != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Right)<br>&#125;<br>&#125;<br>depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人网站：&lt;a href=&quot;https://leiqicn.gitee.io/categories/leetcode/&quot;&gt;https://leiqicn.gitee.io/categories/leetcode/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetco</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="https://leiqichn.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://leiqichn.github.io/tags/BFS/"/>
    
    <category term="层序遍历" scheme="https://leiqichn.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 122买动态股票的最佳时机II</title>
    <link href="https://leiqichn.github.io/2023-05-27-5cebfed1675b.html"/>
    <id>https://leiqichn.github.io/2023-05-27-5cebfed1675b.html</id>
    <published>2023-05-27T15:51:57.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230527235217.png"></p><p>每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。</p><p>相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。</p><p>下面是代码解释：</p><p>首先定义变量 sum 记录当前总利润。<br>然后从第二个价格开始遍历，计算当日价格与前一天价格之差。<br>如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。<br>最后返回累计的总利润。<br>这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-comment">// 累加每次大于0的交易</span><br>        <span class="hljs-keyword">if</span> prices[i] - prices[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            sum += prices[i] - prices[i<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/&quot;&gt;122. 买卖股票的最佳时机 II - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1091.二进制矩阵中的最短路径</title>
    <link href="https://leiqichn.github.io/2023-05-26-5abcbf266873.html"/>
    <id>https://leiqichn.github.io/2023-05-26-5abcbf266873.html</id>
    <published>2023-05-26T15:35:54.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230526235236.png"><br>DFS 超时版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">int</span><br>y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(grid)<br><span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>res := <span class="hljs-number">0</span><br>dirs := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-keyword">var</span> help <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span><br><br>help = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 判断是否越界或已经访问过当前节点</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= n || grid[i][j] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> i == n<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span> &#123;<br><span class="hljs-comment">// 当到达终点时，更新res</span><br><span class="hljs-keyword">if</span> tmp+<span class="hljs-number">1</span> &lt; res || res == <span class="hljs-number">0</span> &#123;<br>res = tmp + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 将当前点标记为已访问</span><br>grid[i][j] = <span class="hljs-number">1</span><br>tmp++<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dirs &#123;<br>x := i + item[<span class="hljs-number">0</span>]<br>y := j + item[<span class="hljs-number">1</span>]<br>help(x, y, tmp)<br>&#125;<br><span class="hljs-comment">// 回溯操作，将当前点复原为未访问状态</span><br>grid[i][j] = <span class="hljs-number">0</span><br>&#125;<br><br>help(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BFS，最短路径使用BFS </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x,y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// queue 维护</span><br>m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[point]<span class="hljs-type">int</span>)<br>queue := <span class="hljs-built_in">make</span>([]point,<span class="hljs-number">0</span>)<br>step := <span class="hljs-number">1</span><br>start := point&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;<br>end := point&#123;m<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>&#125;<br>dirs := []point&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;<br><span class="hljs-comment">// 起点为1 则直接返回</span><br>    <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>queue = <span class="hljs-built_in">append</span>(queue,start)<br>visited[start] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 将当前队列中的所有节点向四周扩散</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; size; i++&#123;<br>cur := queue[<span class="hljs-number">0</span>] <span class="hljs-comment">// 当前cur</span><br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 切掉当前点</span><br><span class="hljs-comment">// 判断是否是终点</span><br><span class="hljs-keyword">if</span> cur == end &#123;<br><span class="hljs-keyword">return</span> step<br>&#125;<br><span class="hljs-comment">// 遍历八个方向 判断是否符合边界条件</span><br><span class="hljs-keyword">for</span> _, dir :=<span class="hljs-keyword">range</span> dirs&#123;<br>newX := cur.x + dir.x<br>newY := cur.y + dir.y<br>newPoint := point&#123;newX,newY&#125;<br><span class="hljs-keyword">if</span> newX &gt;=<span class="hljs-number">0</span> &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=<span class="hljs-number">0</span> &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==<span class="hljs-number">0</span> &amp;&amp; grid[newX][newY]==<span class="hljs-number">0</span> &#123;<br>visited[point&#123;newX,newY&#125;] = <span class="hljs-number">1</span><br>queue =<span class="hljs-built_in">append</span>(queue,newPoint)<br>&#125;<br>&#125;<br><br>&#125;<br>step++<br>&#125;<br><span class="hljs-comment">// 只能为0 的路径才可以更新到queue  边界控制</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>&gt; <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solutions/1076268/bfszui-duan-lu-jing-wen-ti-bfsdfsde-si-k-ngc5/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a>### 解题思路</strong></p><blockquote><p>典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。</p></blockquote><p><strong>&gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？</strong></p><blockquote><p>1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</p></blockquote><p><strong>&gt; ### BFS解法中的visited为什么可以全局使用？</strong></p><blockquote><p>BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/&quot;&gt;1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="二维数组最短路径" scheme="https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 53.最大子数和</title>
    <link href="https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html"/>
    <id>https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html</id>
    <published>2023-05-25T15:08:24.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p><strong>个人网站：</strong> <a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><img src="https://pic.leetcode.cn/1685028457-IOzjjG-image.png" alt="image.png"><br>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>方法1  算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。</p></blockquote><blockquote><p>方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums<a href="dp%5B0%5D">0</a>; 遍历顺序，从idx &#x3D; 1 开始遍历。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 方法1 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br>res := math.MinInt32<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>count += nums[i]<br><span class="hljs-keyword">if</span> count &gt; res &#123;<br>res = count<br>&#125;<br><br><span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span> &#123;<br>count = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-comment">// 方法2 使用了类似动态规划的思想</span><br><span class="hljs-comment">// 定义 nums[i] 当前元素，nums[i-1] 前序列之和</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>max := nums[<span class="hljs-number">0</span>] <span class="hljs-comment">//初始化最大值为前边一个元素</span><br><span class="hljs-comment">// 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。</span><br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span> ;i &lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] + nums[i] &gt; nums[i+<span class="hljs-number">1</span>] &#123;<br>nums[i+<span class="hljs-number">1</span>] = nums[i+<span class="hljs-number">1</span>] + nums[i]<br>&#125;<br><span class="hljs-comment">// 超过最大值，则更新</span><br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] &gt;  max &#123;<br>max = nums[i+<span class="hljs-number">1</span>]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/maximum-subarray/description/&quot;&gt;53. 最大子数组和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;个人</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="贪心" scheme="https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>go语言-回调函数（钩子）</title>
    <link href="https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html"/>
    <id>https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html</id>
    <published>2023-05-25T13:56:41.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。</p><p>以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printWithCallback</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span>) &#123;<br>    text := <span class="hljs-string">&quot;Hello, world!&quot;</span><br>    fmt.Println(text)<br>    callback(text)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    callback := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Printed: %s\n&quot;</span>, text)<br>    &#125;<br>    printWithCallback(callback)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。</p><p>当程序运行起来后，会输出如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Hello, world!<br>Printed: Hello, world!<br></code></pre></td></tr></table></figure><p>这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。</p><p>对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeElapsedCallback</span><span class="hljs-params">(start time.Time)</span></span> &#123;<br>    elapsed := time.Now().Sub(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(time.Time)</span></span>) &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    callback(start)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation(TimeElapsedCallback)<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。</p><p>在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容：</p><p>Time elapsed: 1.001201ms<br>以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。</p><h2 id="回调函数的不同"><a href="#回调函数的不同" class="headerlink" title="回调函数的不同"></a>回调函数的不同</h2><p>以下是不使用回调函数的方式实现计算程序执行时间的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    elapsed := time.Since(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation()<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。</p><p>在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。</p><p>当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。</p><p>使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。</p><p>而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。</p><p>钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。</p><h2 id="以下是使用回调函数的优点："><a href="#以下是使用回调函数的优点：" class="headerlink" title="以下是使用回调函数的优点："></a>以下是使用回调函数的优点：</h2><p>灵活性：可以轻松地将自定义代码插入到已有的代码流程中。<br>可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。<br>易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。<br>总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。&lt;/p&gt;
&lt;p&gt;以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 376.摆动序列</title>
    <link href="https://leiqichn.github.io/2023-05-23-7b5e53100757.html"/>
    <id>https://leiqichn.github.io/2023-05-23-7b5e53100757.html</id>
    <published>2023-05-23T17:05:07.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230524010708.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> count, preDiff, curDiff <span class="hljs-type">int</span><br>    count = <span class="hljs-number">1</span> <span class="hljs-comment">// 初始化计数为1，至少有一个数字是有效的</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 如果数组长度小于2，直接返回计数值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br>        curDiff = nums[i+<span class="hljs-number">1</span>] - nums[i] <span class="hljs-comment">// 计算当前数字之间的差值</span><br><br>        <span class="hljs-comment">// 根据差值的正负和前一个差值的正负进行判断</span><br>        <span class="hljs-comment">// 如果满足摆动序列的条件，更新前一个差值和计数值</span><br>        <span class="hljs-keyword">if</span> (curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>) &#123;<br>            preDiff = curDiff<br>            count++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 返回最终的计数值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/wiggle-subsequence/description/&quot;&gt;376. 摆动序列 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20ima</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 226. 翻转二叉树</title>
    <link href="https://leiqichn.github.io/2023-05-23-d59f64e0619b.html"/>
    <id>https://leiqichn.github.io/2023-05-23-d59f64e0619b.html</id>
    <published>2023-05-23T15:06:25.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523230644.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 定义将二叉树翻转</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点</span><br>    root.Right,root.Left = root.Left,root.Right <br>    <span class="hljs-comment">// 将右子树翻转</span><br>    invertTree(root.Right)<br>    <span class="hljs-comment">// 将左子树翻转</span><br>    invertTree(root.Left)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree/description/&quot;&gt;226. 翻转二叉树 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20im</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 144. 二叉树的前序遍历</title>
    <link href="https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html"/>
    <id>https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html</id>
    <published>2023-05-23T14:49:08.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230523224940.png"></p><p>记得提前判断是否为空，否则会报找不到内存指针的错误<br><img src="/../../imgs/Pasted%20image%2020230523225147.png"></p><p>注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。<a href="leetcode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">leetcode 102. 二叉树的层序遍历</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := list.New()<br>res :=  []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<span class="hljs-comment">//防止为空</span><br><span class="hljs-keyword">return</span> res<br>&#125;<br>stack.PushBack(root)<br><span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &#123;<br>top := stack.Remove(stack.Back()).(*TreeNode)<br>res = <span class="hljs-built_in">append</span>(res,top.Val)<br><span class="hljs-keyword">if</span> top.Right !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Left)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  res <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-preorder-traversal/description/&quot;&gt;144. 二叉树的前序遍历 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 102. 二叉树的层序遍历</title>
    <link href="https://leiqichn.github.io/2023-05-23-a419f5d1c6af.html"/>
    <id>https://leiqichn.github.io/2023-05-23-a419f5d1c6af.html</id>
    <published>2023-05-23T14:46:19.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523224632.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<span class="hljs-comment">//防止为空</span><br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    queue := &amp;list.List&#123;&#125;<br>    queue.PushBack(root)<br><br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        length := queue.Len()               <span class="hljs-comment">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）     </span><br>        <span class="hljs-keyword">var</span> levelQueue []<span class="hljs-type">int</span><br>        fmt.Println(length)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue.Remove(queue.Front()).(*TreeNode)    <span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(node.Right)<br>            &#125;<br>            levelQueue = <span class="hljs-built_in">append</span>(levelQueue, node.Val)    <span class="hljs-comment">//将值加入本层切片中</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, levelQueue)          <span class="hljs-comment">//放入结果集</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/description/&quot;&gt;102. 二叉树的层序遍历 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1845.座位预约管理系统</title>
    <link href="https://leiqichn.github.io/2023-05-22-97adde03f66a.html"/>
    <id>https://leiqichn.github.io/2023-05-22-97adde03f66a.html</id>
    <published>2023-05-22T16:06:33.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523000703.png"></p><h3 id="超时版本"><a href="#超时版本" class="headerlink" title="超时版本"></a>超时版本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> seat <span class="hljs-keyword">struct</span> &#123;<br>seatId <span class="hljs-type">int</span><br>isFree <span class="hljs-type">int</span> <span class="hljs-comment">// 空</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats   <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*seat<br>isFrees []<span class="hljs-type">int</span> <span class="hljs-comment">// 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br><span class="hljs-keyword">var</span> a = SeatManager&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*seat, n), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>id := i + <span class="hljs-number">1</span><br>a.seats[id] = &amp;seat&#123;id, <span class="hljs-number">1</span>&#125;<br>a.isFrees[i] = id <span class="hljs-comment">// 初始化</span><br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>sort.Ints(this.isFrees)<br>top := this.isFrees[<span class="hljs-number">0</span>]<br>this.seats[top].isFree = <span class="hljs-number">0</span><br>this.isFrees = this.isFrees[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-comment">// 遍历 或者使用map</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>) &#123;<br>this.seats[seatNumber].isFree = <span class="hljs-number">1</span><br>this.isFrees = <span class="hljs-built_in">append</span>(this.isFrees,seatNumber)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过版本"><a href="#通过版本" class="headerlink" title="通过版本"></a>通过版本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats []<span class="hljs-type">int</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>set:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> SeatManager&#123;seats:set,min:<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>value := this.min<br>this.seats[value]=<span class="hljs-number">1</span><br>length := <span class="hljs-built_in">len</span> (this.seats)<br>fmt.Println(length)<br>i:=value<br><span class="hljs-keyword">for</span> ;i&lt;length+<span class="hljs-number">1</span>;i++&#123;<br><span class="hljs-keyword">if</span> this.seats[i]==<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>this.min=i <span class="hljs-comment">// 中间变量，更新下次的最小座位号</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> value <span class="hljs-comment">// 最小的座位号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>)  &#123;<br>this.seats[seatNumber]=<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> seatNumber &lt; this.min&#123;<br>this.min=seatNumber<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/seat-reservation-manager/description/&quot;&gt;1845. 座位预约管理系统 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/P</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 455.分发饼干</title>
    <link href="https://leiqichn.github.io/2023-05-21-c1aa51f444e0.html"/>
    <id>https://leiqichn.github.io/2023-05-21-c1aa51f444e0.html</id>
    <published>2023-05-21T15:10:15.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/assign-cookies/description/">455. 分发饼干 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230521231054.png"></p><p><a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a> 欢迎关注我的博客，定时更新golang 刷题笔记</p><p>贪心的策略：</p><blockquote><p>贪心算法一般分为如下四步：<br> 将问题分解为若干个子问题<br>找出适合的贪心策略<br>求解每一个子问题的最优解<br>将局部最优解堆叠成全局最优解</p></blockquote><p>排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;<br>如果没有越界并且饼干大于等于胃口，则childIdx ++；res++</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值</span><br>    sort.Ints(g)<br>    sort.Ints(s)<br>    j := <span class="hljs-number">0</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 用小饼干 来满足最小的胃口</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 判断越界 饼干大于胃口</span><br>        <span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; s[i] &gt;= g[j]  &#123; <span class="hljs-comment">// len不越界的条件需要在前边</span><br><br>            res++<br>            j++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/assign-cookies/description/&quot;&gt;455. 分发饼干 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>网站无法访问categories？</title>
    <link href="https://leiqichn.github.io/2023-05-21-a827bdd2d159.html"/>
    <id>https://leiqichn.github.io/2023-05-21-a827bdd2d159.html</id>
    <published>2023-05-21T13:45:30.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。</p><p><img src="/../../imgs/Pasted%20image%2020230521214536.png"></p><p>可以显示啦<br><img src="/../../imgs/Pasted%20image%2020230521214912.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230521214536.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以显示啦</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 706. 设计哈希映射 Golang</title>
    <link href="https://leiqichn.github.io/2023-05-20-e3f31d125f9b.html"/>
    <id>https://leiqichn.github.io/2023-05-20-e3f31d125f9b.html</id>
    <published>2023-05-20T14:58:30.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashmap/description/">706. 设计哈希映射 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230520230121.png"><br>使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List</p><h2 id="使用结构体（非指针）"><a href="#使用结构体（非指针）" class="headerlink" title="使用结构体（非指针）"></a>使用结构体（非指针）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 链地址法</span><br><span class="hljs-keyword">var</span> base = <span class="hljs-number">769</span><br><br><span class="hljs-comment">// base := 769</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-type">int</span><br>v <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyHashMap <span class="hljs-keyword">struct</span> &#123;<br>hashMaps []list.List<br>&#125;<br><br><span class="hljs-comment">// hash集合可以使用数组链表；</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashMap &#123;<br><span class="hljs-keyword">return</span> MyHashMap&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-comment">// func　(this *MyHashMap) hash(key int, value int)&#123;</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et := e.Value.(entry); et.k == key &#123;<br>e.Value = entry&#123;key, value&#125; <span class="hljs-comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123;<br><span class="hljs-keyword">return</span> et.v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Remove(key <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123;<br>this.hashMaps[hash].Remove(e)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> * param_2 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="使用结构体指针"><a href="#使用结构体指针" class="headerlink" title="使用结构体指针"></a>使用结构体指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 链地址法</span><br><span class="hljs-keyword">var</span> base = <span class="hljs-number">769</span><br><br><span class="hljs-comment">// base := 769</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-type">int</span><br>v <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyHashMap <span class="hljs-keyword">struct</span> &#123;<br>hashMaps []list.List<br>&#125;<br><br><span class="hljs-comment">// hash集合可以使用数组链表；</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashMap &#123;<br><span class="hljs-keyword">return</span> MyHashMap&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et := e.Value.(*entry); et.k == key &#123; <span class="hljs-comment">// 注意list 的元素类型是空接口，需要断言类型</span><br>et.v = value  <span class="hljs-comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; <span class="hljs-comment">// 可以缩写为if et := e.Value.(entry); et.k == key  用于断言，并找key</span><br><span class="hljs-keyword">return</span> et.v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Remove(key <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123;<br>this.hashMaps[hash].Remove(e)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> * param_2 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Remove(key);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/design-hashmap/description/&quot;&gt;706. 设计哈希映射 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode　705. 设计哈希集合</title>
    <link href="https://leiqichn.github.io/2023-05-19-2fa443568cc1.html"/>
    <id>https://leiqichn.github.io/2023-05-19-2fa443568cc1.html</id>
    <published>2023-05-19T15:06:26.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashset/description/">705. 设计哈希集合 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230520225749.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> base = <span class="hljs-number">769</span> <span class="hljs-comment">// 哈希表的长度 质数</span><br><br><span class="hljs-keyword">type</span> MyHashSet <span class="hljs-keyword">struct</span> &#123;<br>    data []list.List <span class="hljs-comment">// 使用链表储存冲突元素</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashSet &#123; <span class="hljs-comment">// 构造函数，返回一个空的哈希集合</span><br>    <span class="hljs-keyword">return</span> MyHashSet&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-comment">// 哈希函数：对键值取模得到哈希值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> hash(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> key % base<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Add(key <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 向哈希集合中添加元素</span><br>    <span class="hljs-keyword">if</span> !s.Contains(key) &#123; <span class="hljs-comment">// 如果元素不在集合中</span><br>        h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>        s.data[h].PushBack(key) <span class="hljs-comment">// 将元素加入到链表中</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Remove(key <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 从哈希集合中删除元素</span><br>    h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span> e := s.data[h].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123; <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">if</span> e.Value.(<span class="hljs-type">int</span>) == key &#123; <span class="hljs-comment">// 如果元素等于要删除的元素</span><br>            s.data[h].Remove(e) <span class="hljs-comment">// 从链表中删除元素</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Contains(key <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 判断某个元素是否在哈希集合中</span><br>    h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span> e := s.data[h].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123; <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">if</span> e.Value.(<span class="hljs-type">int</span>) == key &#123; <span class="hljs-comment">// 如果元素等于要查找的元素</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 返回 true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没有找到元素，返回 false</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/design-hashset/description/&quot;&gt;705. 设计哈希集合 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20i</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1396.设计地铁系统</title>
    <link href="https://leiqichn.github.io/2023-05-18-0a0f1bd6a4a5.html"/>
    <id>https://leiqichn.github.io/2023-05-18-0a0f1bd6a4a5.html</id>
    <published>2023-05-18T15:31:58.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-underground-system/description/">1396. 设计地铁系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230518233218.png"></p><p>设计题：</p><p>设计数据结构</p><ul><li>user<ul><li>startTime int  </li><li>endTime int</li><li>startStationName string</li><li>endStatationName string</li></ul></li><li>UndergroundSystem<ul><li>userMap map[int]*user</li><li>pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间</li></ul></li></ul><p>注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;<br>id <span class="hljs-type">int</span><br>startTime <span class="hljs-type">int</span><br>endTime <span class="hljs-type">int</span><br>startStationName <span class="hljs-type">string</span><br>endStatationName <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UndergroundSystem <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user<br>pathMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span> <span class="hljs-comment">// 存放对应路程的用时，用于计算平均时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> UndergroundSystem &#123;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">return</span> UndergroundSystem&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckIn(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//userMap 添加</span><br>this.userMap[id] = &amp;user&#123;id:id&#125; <span class="hljs-comment">// 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址</span><br>this.userMap[id].startTime = t<br>this.userMap[id].startStationName = stationName<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckOut(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//出站时，更新user.end* ;append pathmap</span><br>useTime := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> _,ok := this.userMap[id] ;ok &#123;<br>this.userMap[id].endTime = t<br>this.userMap[id].endStatationName = stationName<br>&#125;<br><br>mapKey := this.userMap[id].startStationName +<span class="hljs-string">&quot;-&gt;&quot;</span> + this.userMap[id].endStatationName<br>useTime = this.userMap[id].endTime - this.userMap[id].startTime<br>this.pathMap[mapKey] = <span class="hljs-built_in">append</span>(this.pathMap[mapKey],useTime)<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> GetAverageTime(startStation <span class="hljs-type">string</span>, endStation <span class="hljs-type">string</span>) <span class="hljs-type">float64</span> &#123;<br>mapKey := startStation +<span class="hljs-string">&quot;-&gt;&quot;</span> + endStation<br><span class="hljs-keyword">return</span> average(this.pathMap[mapKey])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">average</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s &#123;<br>sum +=v<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(sum)/<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(s))<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your UndergroundSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.CheckIn(id,stationName,t);</span><br><span class="hljs-comment"> * obj.CheckOut(id,stationName,t);</span><br><span class="hljs-comment"> * param_3 := obj.GetAverageTime(startStation,endStation);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/design-underground-system/description/&quot;&gt;1396. 设计地铁系统 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pa</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="设计题" scheme="https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 设计题 Constructor构建</title>
    <link href="https://leiqichn.github.io/2023-05-14-776ea61b62a5.html"/>
    <id>https://leiqichn.github.io/2023-05-14-776ea61b62a5.html</id>
    <published>2023-05-14T14:13:21.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<br>    carNums <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 记录每种停车位的数量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(big <span class="hljs-type">int</span>, medium <span class="hljs-type">int</span>, small <span class="hljs-type">int</span>)</span></span> ParkingSystem &#123;<br>    <span class="hljs-keyword">return</span> ParkingSystem&#123;<br>        carNums: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: big, <span class="hljs-number">2</span>: medium, <span class="hljs-number">3</span>: small&#125;, <span class="hljs-comment">// 初始化 carNums 映射</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。</p><p>请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。</p><p>具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]B<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := &amp;A&#123;<br>        m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]B),<br>    &#125;<br>    b := &amp;B&#123;<br>        m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    a.m[<span class="hljs-number">1</span>] = *b <span class="hljs-comment">// 给 A 中的第一个元素分配一个新的 B 结构体实例</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 <strong>nil 引用错误</strong>，我们还在代码中使用了 make 函数创建了一个空映射。</p><p>例如, 下边结构体中map 嵌套了另外一个结构体的map,<br>可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Res <span class="hljs-keyword">struct</span> &#123;<br>    big <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<span class="hljs-keyword">map</span><br>    carNums <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Res <span class="hljs-comment">// map 嵌套map</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewParkingSystem</span><span class="hljs-params">()</span></span> *ParkingSystem &#123;<br>    <span class="hljs-keyword">return</span> &amp;ParkingSystem&#123;carNums: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Res)&#125; <span class="hljs-comment">// 只用先make 一个空map,指向Res</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ps := NewParkingSystem()<br>    ps.carNums[<span class="hljs-number">1</span>] = &amp;Res&#123;big: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。</p><p>然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。</p><p>总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法：&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="设计题" scheme="https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Go语言-copy</title>
    <link href="https://leiqichn.github.io/2023-05-11-27c67ecef2a3.html"/>
    <id>https://leiqichn.github.io/2023-05-11-27c67ecef2a3.html</id>
    <published>2023-05-11T16:27:16.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []Type)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。</p><p>使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个包含元素的数组</span><br>a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 定义要删除的元素下标</span><br>index := <span class="hljs-number">2</span><br><span class="hljs-comment">// 利用 append 函数和 copy 函数删除指定下标的元素</span><br><span class="hljs-built_in">copy</span>(a[index:], a[index+<span class="hljs-number">1</span>:])<br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br><span class="hljs-comment">// 打印删除后的数组</span><br>fmt.Println(a) <span class="hljs-comment">// 输出 [1 2 4 5]</span><br></code></pre></td></tr></table></figure><p>上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。</p><p>在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。</p><p>在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。</p><p>在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">copy</span>(a[index:], a[index+<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言-byte和rune 有什么区别 byte rune 转为int</title>
    <link href="https://leiqichn.github.io/2023-05-11-257639a12a8e.html"/>
    <id>https://leiqichn.github.io/2023-05-11-257639a12a8e.html</id>
    <published>2023-05-11T16:06:34.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。</p><p>byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。<br>rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。<br>因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。</p><p>将 byte 或 rune 转换为 int 可以使用类型转换操作符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">b := <span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>i := <span class="hljs-type">int</span>(b) - <span class="hljs-type">int</span>(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">// 将 byte &#x27;0&#x27; 转换为 int 0</span><br><span class="hljs-comment">// 上边可以简写为</span><br>i := b - <span class="hljs-string">&#x27;0&#x27;</span><br>r := <span class="hljs-type">rune</span>(<span class="hljs-string">&#x27;中&#x27;</span>)<br>i := <span class="hljs-type">int</span>(r)             <span class="hljs-comment">// 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点）</span><br></code></pre></td></tr></table></figure><p>将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">10</span><br>b := <span class="hljs-type">byte</span>(i)   <span class="hljs-comment">// 溢出！编译器会忽略高位部分，直接取低位部分的字节</span><br>r := <span class="hljs-type">rune</span>(i)<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0xFFFF</span> &#123;<br>    r = <span class="hljs-type">rune</span>(b) <span class="hljs-comment">// 类型断言</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。&lt;/p&gt;
&lt;p&gt;byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。&lt;br&gt;rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 200.岛屿数量</title>
    <link href="https://leiqichn.github.io/2023-05-10-fbf700fba68e.html"/>
    <id>https://leiqichn.github.io/2023-05-10-fbf700fba68e.html</id>
    <published>2023-05-10T17:02:51.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230511010424.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br>r := <span class="hljs-built_in">len</span>(grid)<br>c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">byte</span>, r)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br>visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, c)<br>&#125;<br><br><span class="hljs-comment">// 遍历二维slice</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; c; j++ &#123;<br><span class="hljs-comment">// 每个位置</span><br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                dfs(grid, i, j, visited)<br>                res++<br>            &#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>, visited [][]<span class="hljs-type">byte</span>)</span></span> &#123;<br>r := <span class="hljs-built_in">len</span>(grid)<br>c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">// 边界判断</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= r || j &gt;= c &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 判断值，是海水直接返回</span><br><span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">// 判断是否走过</span><br><span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 改变状态为海水,并修改为走过</span><br>grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    visited[i][j] = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-comment">//单层递归逻辑，四面八方递归</span><br>dfs(grid, i+<span class="hljs-number">1</span>, j, visited)<br>dfs(grid, i, j+<span class="hljs-number">1</span>, visited)<br>dfs(grid, i<span class="hljs-number">-1</span>, j, visited)<br>dfs(grid, i, j<span class="hljs-number">-1</span>, visited)<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用方向二维数组来遍历</p><p>可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>, visited [][]<span class="hljs-type">byte</span>)</span></span> &#123;<br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 定义方向变化值dirs</span><br>    dirs := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;<br><br>    <span class="hljs-comment">// 边界判断</span><br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= r || j &gt;= c &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 判断值，是海水直接返回</span><br>    <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否走过</span><br>    <span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 改变状态为海水,并修改为走过</span><br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    visited[i][j] = <span class="hljs-string">&#x27;1&#x27;</span><br><br>    <span class="hljs-comment">// 循环遍历dirs，对四个方向进行递归</span><br>    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>        new_i, new_j := i + d[<span class="hljs-number">0</span>], j + d[<span class="hljs-number">1</span>]<br>        dfs(grid, new_i, new_j, visited)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。</p><p>需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/number-of-islands/description/&quot;&gt;200. 岛屿数量 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20imag</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="图遍历，岛屿问题" scheme="https://leiqichn.github.io/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>结构体指针作为map key 结构体值改变对map有影响吗</title>
    <link href="https://leiqichn.github.io/2023-05-10-7dfabb45bbc2.html"/>
    <id>https://leiqichn.github.io/2023-05-10-7dfabb45bbc2.html</id>
    <published>2023-05-10T16:37:20.000Z</published>
    <updated>2023-05-30T16:12:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：<strong>go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？</strong><br>接下来让我们一起看看：</p><p>当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据</p><p>例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><br>x := <span class="hljs-number">1</span><br>p := &amp;x<br><br>m[p] = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-comment">// 添加数据</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br><br>*p = <span class="hljs-number">2</span> <span class="hljs-comment">// 修改变量x的值</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。</p><p>接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。</p><p>总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：&lt;strong&gt;go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？&lt;/strong&gt;&lt;br&gt;接下来让我们一起看看：&lt;/p&gt;
&lt;p&gt;当将指针作为 Map 的 Ke</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
</feed>
