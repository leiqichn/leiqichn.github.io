<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-02-20T15:57:04.932Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统序列图 - 时序图</title>
    <link href="https://leiqi.top/2025-02-19-05250c3f88f5.html"/>
    <id>https://leiqi.top/2025-02-19-05250c3f88f5.html</id>
    <published>2025-02-19T12:07:47.000Z</published>
    <updated>2025-02-20T15:57:04.932Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219200803.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>如何画好一个架构图</title>
    <link href="https://leiqi.top/2025-02-19-d829d1f5a9ea.html"/>
    <id>https://leiqi.top/2025-02-19-d829d1f5a9ea.html</id>
    <published>2025-02-19T11:39:54.000Z</published>
    <updated>2025-02-20T15:57:04.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p><h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p><ul><li>通过不同的颜色白标识不同颜色</li><li><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></li></ul><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p><h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p><p>使用场景：</p><ul><li>项目开发和测试</li><li>部署发布</li><li>子领域项目架构，下方就是个会员中心*</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p><h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p><p>使用场景</p><ul><li>总体架构设计</li><li>运维规划和优化</li><li>画图技巧</li><li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li></ul><p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务架构&quot;&gt;&lt;a href=&quot;#业务架构&quot; class=&quot;headerlink&quot; title=&quot;业务架构&quot;&gt;&lt;/a&gt;业务架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219195041.png&quot;&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <link href="https://leiqi.top/2025-01-13-1b5c01477594.html"/>
    <id>https://leiqi.top/2025-01-13-1b5c01477594.html</id>
    <published>2025-01-13T15:40:59.000Z</published>
    <updated>2025-02-20T15:57:04.925Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;s/hide: true/hide: false/g&#x27;</span> *<br></code></pre></td></tr></table></figure><p>解释一下这个命令：</p><ul><li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li><li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li><li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul><li><code>s</code> 表示替换操作。</li><li><code>hide: true</code> 是要被替换的字符串。</li><li><code>hide: false</code> 是替换后的字符串。</li><li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li></ul></li><li><code>*</code> 表示当前文件夹下的所有文件。</li></ul><p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt<br></code></pre></td></tr></table></figure><p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> sed -i <span class="hljs-string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +<br></code></pre></td></tr></table></figure><p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Linux 中，可以使用以下命令来实现这个需求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-02-20T15:57:04.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】for range 数组指针遍历</title>
    <link href="https://leiqi.top/2024-12-03-90d19c862e9c.html"/>
    <id>https://leiqi.top/2024-12-03-90d19c862e9c.html</id>
    <published>2024-12-03T16:55:24.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，使用<code>for range</code>遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如<code>[]*Student</code>）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。</p><p>这意味着，即使<code>for range</code>对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    students := []*Student&#123;<br>        &#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">20</span>&#125;,<br>        &#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>, Age: <span class="hljs-number">22</span>&#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 使用for range遍历指针数组</span><br>    <span class="hljs-keyword">for</span> _, student := <span class="hljs-keyword">range</span> students &#123;<br>        <span class="hljs-comment">// 修改指向的结构体的内容</span><br>        student.Age += <span class="hljs-number">1</span> <span class="hljs-comment">// 给每个学生的年龄加1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 打印修改后的students数组</span><br>    <span class="hljs-keyword">for</span> _, student := <span class="hljs-keyword">range</span> students &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Name: %s, Age: %d\n&quot;</span>, student.Name, student.Age)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，尽管<code>for range</code>对每个<code>*Student</code>指针进行了拷贝，但通过这个拷贝的指针修改<code>Age</code>字段时，修改的是原始<code>Student</code>结构体的内容。因此，当再次遍历<code>students</code>数组时，你会看到每个学生的年龄都已经增加了。</p><p>总结来说，当你使用<code>for range</code>遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，使用&lt;code&gt;for range&lt;/code&gt;遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如&lt;code&gt;[]*Student&lt;/code&gt;）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 浮点数次方</title>
    <link href="https://leiqi.top/2024-12-03-3d026e7b5bec.html"/>
    <id>https://leiqi.top/2024-12-03-3d026e7b5bec.html</id>
    <published>2024-12-03T15:46:08.000Z</published>
    <updated>2025-02-20T15:57:04.924Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，计算一个数的几次方可以通过标准库中的<code>math</code>包来实现。<code>math</code>包提供了一个<code>Pow</code>函数，用于计算x的y次方。</p><h3 id="使用math-Pow函数"><a href="#使用math-Pow函数" class="headerlink" title="使用math.Pow函数"></a>使用<code>math.Pow</code>函数</h3><p><code>math.Pow</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pow</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><p>这个函数接受两个<code>float64</code>类型的参数：<code>x</code>是底数，<code>y</code>是指数，返回<code>x</code>的<code>y</code>次方的结果。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用<code>math.Pow</code>函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 计算2的3次方</span><br>    result := math.Pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;2的3次方是: %v\n&quot;</span>, result)<br><br>    <span class="hljs-comment">// 计算3的2次方</span><br>    result = math.Pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;3的2次方是: %v\n&quot;</span>, result)<br><br>    <span class="hljs-comment">// 计算10的-2次方</span><br>    result = math.Pow(<span class="hljs-number">10</span>, <span class="hljs-number">-2</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;10的-2次方是: %v\n&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>的<span class="hljs-number">3</span>次方是: <span class="hljs-number">8</span><br><span class="hljs-attribute">3</span>的<span class="hljs-number">2</span>次方是: <span class="hljs-number">9</span><br><span class="hljs-attribute">10</span>的-<span class="hljs-number">2</span>次方是: <span class="hljs-number">0</span>.<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>math.Pow</code>函数的参数和返回值都是<code>float64</code>类型，因此如果你需要计算整数的次方，可能需要先将整数转换为<code>float64</code>，然后再进行计算。</li><li>如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，计算一个数的几次方可以通过标准库中的&lt;code&gt;math&lt;/code&gt;包来实现。&lt;code&gt;math&lt;/code&gt;包提供了一个&lt;code&gt;Pow&lt;/code&gt;函数，用于计算x的y次方。&lt;/p&gt;
&lt;h3 id=&quot;使用math-Pow函数&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【基础知识】Golang  sort.Slice 复杂排序</title>
    <link href="https://leiqi.top/2024-11-24-24291296f81a.html"/>
    <id>https://leiqi.top/2024-11-24-24291296f81a.html</id>
    <published>2024-11-24T04:47:52.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，你可以使用 <code>sort.Slice</code> 对 <code>slice</code> 按照复杂条件进行排序。 <code>sort.Slice</code> 函数接受一个 <code>slice</code> 和一个比较函数，该比较函数定义了两个元素之间的排序关系。</p><p>以下是实现复杂条件排序的步骤和示例：</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Slice(slice, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 比较 slice[i] 和 slice[j]</span><br>    <span class="hljs-keyword">return</span> 条件<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-示例：对结构体切片进行多条件排序"><a href="#2-示例：对结构体切片进行多条件排序" class="headerlink" title="2. 示例：对结构体切片进行多条件排序"></a>2. 示例：对结构体切片进行多条件排序</h3><p>假设有一个包含多个 <code>Person</code> 的切片，我们希望按以下规则排序：</p><ol><li>年龄从小到大排序。</li><li>如果年龄相同，则按名字的字母顺序排序。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>people := []Person&#123;<br>&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">30</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Dave&quot;</span>, <span class="hljs-number">25</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 使用 sort.Slice 按多个条件排序</span><br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 优先按年龄排序</span><br><span class="hljs-keyword">if</span> people[i].Age != people[j].Age &#123;<br><span class="hljs-keyword">return</span> people[i].Age &lt; people[j].Age<br>&#125;<br><span class="hljs-comment">// 如果年龄相同，则按名字排序</span><br><span class="hljs-keyword">return</span> people[i].Name &lt; people[j].Name<br>&#125;)<br><br>fmt.Println(people)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-更复杂条件：按多个字段权重排序"><a href="#3-更复杂条件：按多个字段权重排序" class="headerlink" title="3. 更复杂条件：按多个字段权重排序"></a>3. 更复杂条件：按多个字段权重排序</h3><p>如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span><br>Price <span class="hljs-type">float64</span><br>Rating <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>products := []Product&#123;<br>&#123;<span class="hljs-string">&quot;Laptop&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Phone&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Tablet&quot;</span>, <span class="hljs-number">800</span>, <span class="hljs-number">5</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Watch&quot;</span>, <span class="hljs-number">400</span>, <span class="hljs-number">4</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序</span><br>sort.Slice(products, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 按价格降序</span><br><span class="hljs-keyword">if</span> products[i].Price != products[j].Price &#123;<br><span class="hljs-keyword">return</span> products[i].Price &gt; products[j].Price<br>&#125;<br><span class="hljs-comment">// 如果价格相同，按评分降序</span><br><span class="hljs-keyword">if</span> products[i].Rating != products[j].Rating &#123;<br><span class="hljs-keyword">return</span> products[i].Rating &gt; products[j].Rating<br>&#125;<br><span class="hljs-comment">// 如果评分也相同，按名称升序</span><br><span class="hljs-keyword">return</span> products[i].Name &lt; products[j].Name<br>&#125;)<br><br>fmt.Println(products)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li>如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。</li><li><code>sort.Slice</code> 是不稳定的。如果需要稳定排序，可以使用 <code>sort.SliceStable</code>。</li><li>对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。</li></ul><p>通过 <code>sort.Slice</code> 的灵活性，可以轻松实现各种复杂条件的排序逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，你可以使用 &lt;code&gt;sort.Slice&lt;/code&gt; 对 &lt;code&gt;slice&lt;/code&gt; 按照复杂条件进行排序。 &lt;code&gt;sort.Slice&lt;/code&gt; 函数接受一个 &lt;code&gt;slice&lt;/code&gt; 和一个比较函数，该比较函数定义</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】创建slice是否填第二个参数0的区别</title>
    <link href="https://leiqi.top/2024-11-23-b80d94088ccd.html"/>
    <id>https://leiqi.top/2024-11-23-b80d94088ccd.html</id>
    <published>2024-11-23T05:10:49.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，创建切片（slice）时使用<code>make</code>函数有两种常见的方式，它们之间有细微的差别：</p><ol><li><p><code>slice := make([]string, 0)</code></p><p> 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是<code>[]string</code>），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。</p></li><li><p><code>slice := make([]string)</code></p><p> 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，<code>make</code>函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。</p></li></ol><p>两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用<code>make([]string)</code>（或者等价的<code>make([]string, 0)</code>）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。</p><p>总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，创建切片（slice）时使用&lt;code&gt;make&lt;/code&gt;函数有两种常见的方式，它们之间有细微的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;slice := make([]string, 0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 这种方式明确指定了切片的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting</title>
    <link href="https://leiqi.top/2024-11-23-cf0eba4d8369.html"/>
    <id>https://leiqi.top/2024-11-23-cf0eba4d8369.html</id>
    <published>2024-11-23T05:05:23.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p>确实，如果我们按照缩写的逻辑来看，<code>Itos</code>（Integer to String）可能更直观地表达了<code>Itoa</code>函数的功能，即把整数转换为字符串。</p><p>然而，<code>Itoa</code>这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，<code>Itoa</code>这个术语已经被广泛接受和使用。以下是一些可能的原因：</p><ol><li><p><strong>历史原因</strong>：<code>Itoa</code>这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，<code>Itoa</code>（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。</p></li><li><p><strong>约定俗成</strong>：在编程社区中，<code>Itoa</code>已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。</p></li><li><p><strong>ASCII与字符串的关系</strong>：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字<code>123</code>的ASCII表示和字符串表示都是<code>&quot;123&quot;</code>。因此，<code>Itoa</code>这个名字仍然适用。</p></li><li><p><strong>简洁性</strong>：<code>Itoa</code>这个名称比较简洁，易于记忆。如果使用<code>Itos</code>，虽然直观，但可能不如<code>Itoa</code>简洁。</p></li></ol><p><code>Itoa</code>这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管<code>Itos</code>可能更直观地表示整数到字符串的转换，但<code>Itoa</code>已经成为一个广泛接受和使用的术语。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确实，如果我们按照缩写的逻辑来看，&lt;code&gt;Itos&lt;/code&gt;（Integer to String）可能更直观地表达了&lt;code&gt;Itoa&lt;/code&gt;函数的功能，即把整数转换为字符串。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;Itoa&lt;/code&gt;这个名称的由来实际上与历史</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
    <category term="刨根问底" scheme="https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>【基础知识】符号整数和非符号整数</title>
    <link href="https://leiqi.top/2024-11-23-dce4118b03a7.html"/>
    <id>https://leiqi.top/2024-11-23-dce4118b03a7.html</id>
    <published>2024-11-23T04:47:02.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p><code>uint8</code> <code>uint16</code>和<code>uint32</code>是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。</p><ol><li><p><code>unit8</code> : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255</p></li><li><p>**<code>uint16</code>**：</p><ul><li><code>uint16</code>是一个16位的无符号整数。</li><li>它可以存储的数字数量是 2^16。</li><li>计算得出：216&#x3D;65536216&#x3D;65536。</li><li>因此，<code>uint16</code>能存储的数字范围是从0到65535。</li></ul></li><li><p>**<code>uint32</code>**：</p><ul><li><code>uint32</code>是一个32位的无符号整数。</li><li>它可以存储的数字数量是 2^32。</li><li>计算得出：232&#x3D;4294967296232&#x3D;4294967296。</li><li>因此，<code>uint32</code>能存储的数字范围是从0到4294967295。</li></ul></li></ol><p>总结：</p><ul><li><code>uint16</code>能存储的数字数量是 216216，即65536个数字。</li><li><code>uint32</code>能存储的数字数量是 232232，即4294967296个数字。</li></ul><p><code>int32</code>是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。</p><p>具体来说：</p><ul><li>对于正数，<strong>最高位是0</strong>，剩下的31位可以表示 231231 个不同的正数值。</li><li>对于负数，<strong>最高位是1</strong>，剩下的31位可以表示 231231 个不同的负数值。</li><li>由于0既不是正数也不是负数，它单独占用了一个数值。</li></ul><p>因此，<code>int32</code>的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说<code>int32</code>的范围是31次方而不是32次方的原因。<br><img src="/../../imgs/Pasted%20image%2020241123132832.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;uint8&lt;/code&gt; &lt;code&gt;uint16&lt;/code&gt;和&lt;code&gt;uint32&lt;/code&gt;是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unit8&lt;/code&gt; : 是8位无</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 byte和rune 有什么区别</title>
    <link href="https://leiqi.top/2024-11-23-ff51ba651704.html"/>
    <id>https://leiqi.top/2024-11-23-ff51ba651704.html</id>
    <published>2024-11-23T04:38:13.000Z</published>
    <updated>2025-02-20T15:57:04.930Z</updated>
    
    <content type="html"><![CDATA[<p>byte 和rune 有什么区别？<br>    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：</p><p>byte：</p><p>byte是uint8的别名，即一个无符号的8位整数。<br>在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。<br>byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。<br>rune：</p><p>rune是int32的别名，即一个有符号的32位整数。<br>rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。<br>rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。<br>由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。<br>区别：</p><p>大小：byte是8位的，而rune是32位的。<br>用途：byte用于处理字节数据，rune用于处理Unicode字符。<br>范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。<br>编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。<br>在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;byte 和rune 有什么区别？&lt;br&gt;    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：&lt;/p&gt;
&lt;p&gt;byte：&lt;/p&gt;
&lt;p&gt;byte是uint8的别名，即一个无符号的8位整数。&lt;br&gt;在Go语言中</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>申请域名绑定github pages</title>
    <link href="https://leiqi.top/2024-09-01-ed1bf9078b39.html"/>
    <id>https://leiqi.top/2024-09-01-ed1bf9078b39.html</id>
    <published>2024-09-01T02:17:17.000Z</published>
    <updated>2025-02-20T15:57:04.931Z</updated>
    
    <content type="html"><![CDATA[<p>你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！</p><h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><ol><li>在<a href="https://www.namesilo.com/">Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo</a>完成了域名的购买</li><li>完成了GitHub Pages的设置，有了可用的<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>库之后，可以访问 Github Pages</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-进入我的账户"><a href="#0-进入我的账户" class="headerlink" title="0. 进入我的账户"></a>0. 进入我的账户</h3><p><img src="/../../imgs/Pasted%20image%2020240901102308.png"></p><h3 id="1-无论是什么域名服务商，找到DNS-Management页面"><a href="#1-无论是什么域名服务商，找到DNS-Management页面" class="headerlink" title="1. 无论是什么域名服务商，找到DNS Management页面"></a><strong>1. 无论是什么域名服务商，找到DNS Management页面</strong></h3><p>如果是namesilo购买的域名，可以通过以下步骤：<br><img src="/../../imgs/Pasted%20image%2020240901102340.png"><br>点击“domain manager”<br><img src="/../../imgs/Pasted%20image%2020240901102510.png"><br>点击这个蓝色的小球（Manage DNS for this domain）</p><h3 id="2-写入-type-A-的DNS记录"><a href="#2-写入-type-A-的DNS记录" class="headerlink" title="2. 写入 type A 的DNS记录"></a><strong>2. 写入 type A 的DNS记录</strong></h3><ul><li><strong>如果厂商提供了写入模板</strong>，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 <strong>DNS Templates</strong>。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-b84d88c38c06b6081f02cafbd0dac24b_720w.webp"></p><p>找到GitHub的template，点击“<strong>Apply Template</strong>”，然后在弹出的窗口里直接点击“<strong>Accept</strong>”，你就会发现4条A记录已经自动写入了。</p><p><img src="https://pic1.zhimg.com/80/v2-c731fadefaf3d3a2268e6566d6196558_720w.webp"></p><ul><li><strong>如果厂商不能自动添加</strong>，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图</li></ul><p>[Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain!</p><p><img src="https://pica.zhimg.com/80/v2-1a618fec2900e4f23039c153d8ab03da_720w.webp"></p><p>上面圈起来的四个地址就是需要等会儿手动输入的。</p><p>不同厂商之间的手动添加方法不一样，但只要记住 <strong>type 后填“A”</strong>，<strong>address&#x2F;points to或其他同义表达后填这四个地址中的一个</strong>，<strong>其他默认</strong>就好了，一共需要添加<strong>四条</strong>，可以复制粘贴。</p><p>添加之后会多出四个<img src="/../../imgs/Pasted%20image%2020240901102815.png">### 3. 创建CNAME文件</p><p>这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，</p><blockquote><p>上面的方法 save 之后看到报错不要慌，<a href="https://zhida.zhihu.com/search?q=%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E&zhida_source=entity&is_preview=1">让子弹飞</a>一会儿就好了</p></blockquote><p><img src="/../../imgs/Pasted%20image%2020240901102714.png"><br><img src="/../../imgs/Pasted%20image%2020240901102745.png"></p><p>最终有这些配置即可：<br><img src="/../../imgs/Pasted%20image%2020240901102848.png"></p><h3 id="github-填写域名地址"><a href="#github-填写域名地址" class="headerlink" title="github 填写域名地址"></a>github 填写域名地址</h3><p>在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。<br><img src="/../../imgs/Pasted%20image%2020240901103216.png"><br><img src="/../../imgs/Pasted%20image%2020240901103241.png"></p><h3 id="即刻访问你自己的域名网站吧！"><a href="#即刻访问你自己的域名网站吧！" class="headerlink" title="即刻访问你自己的域名网站吧！"></a>即刻访问你自己的域名网站吧！</h3><p><img src="/../../imgs/Pasted%20image%2020240901103553.png"></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/448781791">将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！&lt;/p&gt;
&lt;h2 id=&quot;前置需求&quot;&gt;&lt;a href=&quot;#前置需求&quot; class=&quot;headerlink&quot; title=&quot;前置需求&quot;&gt;&lt;/a&gt;前置需求&lt;/h2&gt;&lt;o</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>git stash</title>
    <link href="https://leiqi.top/2024-08-21-f4ccab39149e.html"/>
    <id>https://leiqi.top/2024-08-21-f4ccab39149e.html</id>
    <published>2024-08-21T16:26:46.000Z</published>
    <updated>2025-02-20T15:57:04.927Z</updated>
    
    <content type="html"><![CDATA[<p>当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：</p><p>放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。</p><p>bash<br>git checkout – .obsidian&#x2F;workspace.json<br>再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。</p><p>bash<br>git pull<br>如果不想放弃这些更改，而是想将它们保存起来，可以使用 git stash 命令：</p><p>保存更改：使用 git stash 将更改保存到一个临时区域。</p><p>git stash<br>拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply<br></code></pre></td></tr></table></figure><p>请注意，使用 git stash apply 可能不会总是成功，在这种情况下，可能需要手动解决冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：&lt;/p&gt;
&lt;p&gt;放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。&lt;/p&gt;</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode  1.两数之和</title>
    <link href="https://leiqi.top/2024-08-21-64c0a1f316e6.html"/>
    <id>https://leiqi.top/2024-08-21-64c0a1f316e6.html</id>
    <published>2024-08-21T15:53:21.000Z</published>
    <updated>2025-02-20T15:57:04.928Z</updated>
    
    <content type="html"><![CDATA[<p>有两种思路：</p><ol><li>使用暴力遍历， 复杂度的是 O(n ^2)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j:= i+<span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] + nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, j&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用哈希表，是O(n)<br>  使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>maps := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br><span class="hljs-keyword">for</span> idx, num := <span class="hljs-keyword">range</span> nums &#123;<br>maps[num] = idx<br>&#125;<br><br><span class="hljs-keyword">for</span> idx, num := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; <span class="hljs-comment">// 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意</span><br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;idx, idx2&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用暴力遍历， 复杂度的是 O(n ^2)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>docker容器打包成本地压缩镜像并load</title>
    <link href="https://leiqi.top/2024-08-11-a8e2c27fed87.html"/>
    <id>https://leiqi.top/2024-08-11-a8e2c27fed87.html</id>
    <published>2024-08-11T03:59:34.000Z</published>
    <updated>2025-02-20T15:57:04.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器打包成镜像和压缩"><a href="#docker容器打包成镜像和压缩" class="headerlink" title="docker容器打包成镜像和压缩"></a>docker容器打包成镜像和压缩</h1><p>（1）将容器保存成新的镜像<br>相当于加了一层，使用docker commit</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo docker commit -<span class="hljs-keyword">a</span> <span class="hljs-string">&#x27;run_code&#x27;</span> b4293c3b9202  myimage:v2<br></code></pre></td></tr></table></figure><p>（2）将镜像打包</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">docker save -o mask_detection_v5.tar myimage:v5<br></code></pre></td></tr></table></figure><p>(3) 将镜像包压缩</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo tar -zcvf myimage<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> myimage.tar<br></code></pre></td></tr></table></figure><p><strong>还有一种容器的打包和压缩一步到位的方法</strong>：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker save myimage:v5 <span class="hljs-string">| gzip &gt; myimage.tar.gz</span><br></code></pre></td></tr></table></figure><p>docker镜像压缩包解压及镜像载入</p><p>一步加载压缩的镜像命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load &lt; myimage.tar.gz<br><br></code></pre></td></tr></table></figure><p>（1）压缩包解压</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> -zxvf myimage.tar.gz<br></code></pre></td></tr></table></figure><p>得到.tar格式的镜像包</p><p>（2）镜像载入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo docker load -<span class="hljs-selector-tag">i</span> myimage<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure><p>载入后查看已经加载的镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo docker images</span><br></code></pre></td></tr></table></figure><h1 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 交互式运行</span><br>docker run -it myimage:v1 bash<br><br></code></pre></td></tr></table></figure><h1 id="进入已经运行的容器"><a href="#进入已经运行的容器" class="headerlink" title="进入已经运行的容器"></a>进入已经运行的容器</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>docker <span class="hljs-built_in">exec</span> -it [imagesID] bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;a href=&quot;#docker容器打包成镜像和压缩&quot; class=&quot;headerlink&quot; title=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;/a&gt;docker容器打包成镜像和压缩&lt;/h1&gt;&lt;p&gt;（1）将容器保存成新的镜像&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://leiqi.top/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>查询深度学习环境python torch cuda版本</title>
    <link href="https://leiqi.top/2024-08-08-efa703ec12d7.html"/>
    <id>https://leiqi.top/2024-08-08-efa703ec12d7.html</id>
    <published>2024-08-08T14:55:03.000Z</published>
    <updated>2025-02-20T15:57:04.932Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment">#sys模块提供了一系列有关Python运行环境的变量和函数。</span><br><span class="hljs-built_in">print</span>(sys.version)<br><span class="hljs-built_in">print</span>(torch.__version__)<br><span class="hljs-built_in">print</span>(torch.cuda.is_available())<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240808225509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>开机自启WSL</title>
    <link href="https://leiqi.top/2024-08-07-117ef9b8f4c6.html"/>
    <id>https://leiqi.top/2024-08-07-117ef9b8f4c6.html</id>
    <published>2024-08-07T14:09:47.000Z</published>
    <updated>2025-02-20T15:57:04.932Z</updated>
    
    <content type="html"><![CDATA[<p>在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件</p><p><img src="/../../imgs/Pasted%20image%2020240807221008.png"></p><p>文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Set</span> ws = WScript.CreateObject(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)<br>cmd = <span class="hljs-string">&quot;C:\Windows\System32\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;</span><br><span class="hljs-comment">&#x27;运行命令不显示cmd窗口</span><br>ws.Run cmd, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span><br><span class="hljs-keyword">Set</span> ws = <span class="hljs-literal">Nothing</span><br>WScript.quit<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240807221008.pn</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git更新仓库地址</title>
    <link href="https://leiqi.top/2024-07-23-764a3cd05cde.html"/>
    <id>https://leiqi.top/2024-07-23-764a3cd05cde.html</id>
    <published>2024-07-23T15:34:45.000Z</published>
    <updated>2025-02-20T15:57:04.928Z</updated>
    
    <content type="html"><![CDATA[<p>使用如下命令</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">https</span>://<span class="hljs-string">gitee</span>.<span class="hljs-string">com</span>/<span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用如下命令&lt;/p&gt;
&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>设置github 同步到gitee</title>
    <link href="https://leiqi.top/2024-07-21-3ee37da7ed1c.html"/>
    <id>https://leiqi.top/2024-07-21-3ee37da7ed1c.html</id>
    <published>2024-07-21T14:15:47.000Z</published>
    <updated>2025-02-20T15:57:04.928Z</updated>
    
    <content type="html"><![CDATA[<ol><li>复制自己电脑的<strong>私钥</strong>到github</li><li>复制自己电脑的<strong>公钥</strong>到gitee<img src="/../../imgs/Pasted%20image%2020240721222254.png"></li><li>获取gitee 的私人令牌</li><li>创建.github&#x2F;workflows&#x2F;xxx.ymal<br><img src="/../../imgs/Pasted%20image%2020240721221805.png"></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">to</span> <span class="hljs-string">Gitee</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">wearerequired/git-mirror-action@master</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span><br>          <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 注意替换为你的 GitHub 源仓库地址</span><br>          <span class="hljs-attr">source-repo:</span> <span class="hljs-string">git@github.com:leiqichn/novelBigModel.git</span><br>          <span class="hljs-comment"># 注意替换为你的 Gitee 目标仓库地址</span><br>          <span class="hljs-attr">destination-repo:</span> <span class="hljs-string">git@gitee.com:leiqichn/novelBigModel.git</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;复制自己电脑的&lt;strong&gt;私钥&lt;/strong&gt;到github&lt;/li&gt;
&lt;li&gt;复制自己电脑的&lt;strong&gt;公钥&lt;/strong&gt;到gitee&lt;img src=&quot;/../../imgs/Pasted%20image%2020240721222254.pn</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang 使用new创建slice</title>
    <link href="https://leiqi.top/2024-07-21-01f71b57e534.html"/>
    <id>https://leiqi.top/2024-07-21-01f71b57e534.html</id>
    <published>2024-07-21T06:14:35.000Z</published>
    <updated>2025-02-20T15:57:04.924Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。</p><p>然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s *[]<span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个指向int类型slice的指针</span><br>s = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 分配一个int类型的slice，并将其地址赋给s</span><br></code></pre></td></tr></table></figure><p>但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length, capacity) <span class="hljs-comment">// 创建一个长度为 length，容量为 capacity 的int类型slice</span><br></code></pre></td></tr></table></figure><p>如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*s = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length, capacity) <span class="hljs-comment">// 通过解引用指针并使用make来初始化slice</span><br></code></pre></td></tr></table></figure><p>在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 sli</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
</feed>
