<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-06-11T16:26:39.057Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pycharm配置VPN代理</title>
    <link href="https://leiqi.top/2025-06-08-e7d1013a5402.html"/>
    <id>https://leiqi.top/2025-06-08-e7d1013a5402.html</id>
    <published>2025-06-08T16:18:16.000Z</published>
    <updated>2025-06-11T16:26:39.057Z</updated>
    
    <content type="html"><![CDATA[<p>确定本地VPN的代理端口：</p><p><img src="/../../imgs/Pasted%20image%2020250609001902.png"></p><p><img src="/../../imgs/Pasted%20image%2020250609001826.png"></p><p>点击check connetion 输入<a href="http://www.google.com/">http://www.google.com</a><br><img src="/../../imgs/Pasted%20image%2020250609001953.png"><br><img src="/../../imgs/Pasted%20image%2020250609001820.png"></p><p>也可以使用requests 包验证, 返回内容，不爆红即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.youtube.com&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250609002055.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确定本地VPN的代理端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250609001902.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202025060900</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯总结</title>
    <link href="https://leiqi.top/2025-06-03-fc6703ad881e.html"/>
    <id>https://leiqi.top/2025-06-03-fc6703ad881e.html</id>
    <published>2025-06-03T15:53:20.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子集型回溯"><a href="#子集型回溯" class="headerlink" title="子集型回溯"></a>子集型回溯</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020250605230846.png"><br><img src="/../../imgs/Pasted%20image%2020250605230928.png"><br>方法一：输入的视角（选或不选）<br>对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2<br>n<br>  个不同的子集。</p><p>dfs 中的 i 表示当前考虑到 nums[i] 选或不选。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// 子集构造完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path)) <span class="comment">// 复制 path</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不选 nums[i]</span></span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选 nums[i]</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：<strong>答案的视角（枚举选哪个）</strong><br>枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。</p><p>dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。</p><p>如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。</p><p>注意：不需要在回溯中判断 i&#x3D;n 的边界情况，因为此时不会进入循环，if i &#x3D;&#x3D; n: return 这句话写不写都一样.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="131"><li>分割回文串 <a href="https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/">https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</a></li></ol><p>从答案的角度，枚举选哪个，需要使用for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := left, right;i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> (ans [][]<span class="type">string</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑 s[i:] 怎么分割</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// s 分割完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 枚举子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome(s, i, j) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[i:j+<span class="number">1</span>]) <span class="comment">// 分割！</span></span><br><span class="line">                <span class="comment">// 考虑剩余的 s[j+1:] 怎么分割</span></span><br><span class="line">                dfs(j + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="132"><li>电话号码的字母组合 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    m []<span class="type">string</span></span><br><span class="line">    path []<span class="type">byte</span></span><br><span class="line">    res []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 将index 和 字符串对应起来</span></span><br><span class="line">m = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">path, res = <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>),<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">backTracking(digits,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(digits <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 终止条件 ，遍历完digits</span></span><br><span class="line"><span class="keyword">if</span> start == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        tmp := <span class="type">string</span>(path)</span><br><span class="line">res = <span class="built_in">append</span>(res,tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到 digit</span></span><br><span class="line">digitNum := <span class="type">int</span>(digits[start] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">// 遍历 digit 对应的map 字符串</span></span><br><span class="line">str := m[digitNum]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(str);i++ &#123; <span class="comment">// i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始</span></span><br><span class="line">path = <span class="built_in">append</span>(path,str[i])</span><br><span class="line">backTracking(digits,start+<span class="number">1</span>)</span><br><span class="line">path =path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合型回溯"><a href="#组合型回溯" class="headerlink" title="组合型回溯"></a>组合型回溯</h2><p><img src="/../../imgs/Pasted%20image%2020250611222518.png"></p><ol><li>左边选或者不选  K&#x3D;3  右边k &#x3D; 2, 因为是组合，等于是重复的就能再出现了，再选了2 之后，只能选1 了， 不能再选其他的了。<br><img src="/../../imgs/Pasted%20image%2020250611223356.png"><br>倒序的不等式简单点，正序的不等式为 n - i + 1 &lt; d 直接return</li></ol><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i - <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(n)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= n; i++ &#123; <span class="comment">// 倒序方便</span></span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> n-i+<span class="number">1</span> &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode216</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个合法组合</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &amp;&amp; sum == n &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝：剩余数字不足以填满 path 或无法达到 sum</span></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 确保剩余数字足够填满 path</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum+i &gt; n &#123; <span class="comment">// 提前终止，避免无效递归  如果 sum + i &gt; n，说明当前 i 太大，不能选它。但 更小的 i 仍然可能满足 sum + i &lt;= n，所以不能直接 break（否则会漏掉可能的解）。</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i<span class="number">-1</span>, sum+i)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">9</span>, <span class="number">0</span>) <span class="comment">// 数字范围是 1~9</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p><p>思路<a href="https://labuladong.online/algo/practice-in-action/generate-parentheses/">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态数据 回退操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//n 对括号 只要最后左右总和一样，</span></span><br><span class="line">m := n * <span class="number">2</span></span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span></span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == m &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选左边</span></span><br><span class="line"><span class="keyword">if</span> open &lt; n &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选右边</span></span><br><span class="line"><span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 右边要小于左边才能加</span></span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 入口函数需要添加</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定长度+索引，不用回退</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    m := n * <span class="number">2</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == m &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, <span class="type">string</span>(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> open &lt; n &#123; <span class="comment">// 可以填左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 可以填右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你提供的这个实现中，不需要显式的回退操作（如 <code>path = path[:len(path)-1]</code>），是因为它采用了 <strong>固定长度的 <code>[]byte</code> 数组</strong> 和 <strong>索引覆盖</strong> 的方式，这与常见的回溯算法实现有所不同。下面详细解释为什么可以省略回退操作：</p><hr><h3 id="关键原因分析"><a href="#关键原因分析" class="headerlink" title="关键原因分析"></a><strong>关键原因分析</strong></h3><h4 id="1-使用固定长度的-byte-数组"><a href="#1-使用固定长度的-byte-数组" class="headerlink" title="1. 使用固定长度的 []byte 数组"></a>1. <strong>使用固定长度的 <code>[]byte</code> 数组</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)  <span class="comment">// 长度为 m 的固定数组</span></span><br></pre></td></tr></table></figure><ul><li>数组 <code>path</code> 的长度在初始化时就固定为 <code>m</code>（<code>=n*2</code>），不会动态增长。</li><li>每个递归层级直接通过索引 <code>i</code> 修改 <code>path[i]</code> 的位置，<strong>不会影响其他层级的存储</strong>。</li></ul><h4 id="2-索引覆盖写入"><a href="#2-索引覆盖写入" class="headerlink" title="2. 索引覆盖写入"></a>2. <strong>索引覆盖写入</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 或 path[i] = &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>每次写入都会<strong>精确覆盖 <code>path[i]</code> 的位置</strong>，而不会追加元素。</li><li>递归返回时，<strong>上层调用会覆盖当前层写入的值</strong>，因此不需要手动回退。</li></ul><h4 id="3-递归的自然回溯"><a href="#3-递归的自然回溯" class="headerlink" title="3. 递归的自然回溯"></a>3. <strong>递归的自然回溯</strong></h4><ul><li>当递归从深层返回时，<strong>上层调用会继续修改 <code>path</code> 的后续位置</strong>，覆盖之前的值。</li><li>例如：<ul><li>第一层递归写入 <code>path[0] = &#39;(&#39;</code>，然后进入第二层。</li><li>第二层写入 <code>path[1] = &#39;(&#39;</code> 或 <code>path[1] = &#39;)&#39;</code>。</li><li>当第二层递归返回后，第一层可能会写入 <code>path[1] = &#39;)&#39;</code>，覆盖之前的值。</li></ul></li></ul><hr><h3 id="对比需要回退操作的实现"><a href="#对比需要回退操作的实现" class="headerlink" title="对比需要回退操作的实现"></a><strong>对比需要回退操作的实现</strong></h3><h4 id="需要回退的版本（动态-append）"><a href="#需要回退的版本（动态-append）" class="headerlink" title="需要回退的版本（动态 append）"></a><strong>需要回退的版本（动态 <code>append</code>）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)  <span class="comment">// 修改切片长度</span></span><br><span class="line">dfs(...)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 必须回退</span></span><br></pre></td></tr></table></figure><ul><li>动态 <code>append</code> 会改变切片长度，必须显式回退以恢复状态。</li></ul><h4 id="不需要回退的版本（固定数组-索引覆盖）"><a href="#不需要回退的版本（固定数组-索引覆盖）" class="headerlink" title="不需要回退的版本（固定数组 + 索引覆盖）"></a><strong>不需要回退的版本（固定数组 + 索引覆盖）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 直接覆盖，不改变长度</span></span><br><span class="line">dfs(...)</span><br><span class="line"><span class="comment">// 无需回退，上层调用会覆盖 path[i]</span></span><br></pre></td></tr></table></figure><ul><li>固定数组的长度不变，通过索引直接修改值，递归返回后自然被覆盖。</li></ul><hr><h3 id="为什么这种写法是正确的？"><a href="#为什么这种写法是正确的？" class="headerlink" title="为什么这种写法是正确的？"></a><strong>为什么这种写法是正确的？</strong></h3><ol><li><p><strong>隐式回溯</strong>：</p><ul><li>每一层递归的 <code>path[i]</code> 写入是独立的，递归返回后会被上层调用覆盖。</li><li>例如：<ul><li>路径 <code>&quot;(())&quot;</code> 的生成过程：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path[<span class="number">0</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第一层</span></span><br><span class="line">path[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第二层</span></span><br><span class="line">path[<span class="number">2</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第三层</span></span><br><span class="line">path[<span class="number">3</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第四层</span></span><br></pre></td></tr></table></figure></li><li>如果第二层尝试 <code>path[1] = &#39;)&#39;</code>，它会覆盖之前的 <code>&#39;(&#39;</code>，但通过条件 <code>i-open &lt; open</code> 保证了合法性。</li></ul></li></ul></li><li><p><strong>条件保证合法性</strong>：</p><ul><li><code>open &lt; n</code> 确保左括号不超过 <code>n</code> 个。</li><li><code>i-open &lt; open</code> 确保右括号数不超过左括号数。</li></ul></li></ol><hr><ul><li><strong>不需要回退</strong>：因为使用了固定长度的 <code>[]byte</code> 数组，通过索引直接覆盖写入，递归返回时上层调用会自然覆盖当前层的修改。</li><li><strong>更高效</strong>：避免了动态切片的扩容和回退操作，减少了内存分配。</li><li><strong>更简洁</strong>：代码更紧凑，但需要理解索引覆盖的隐式回溯逻辑。</li></ul><p>这种写法是回溯算法的一种优化技巧，适用于结果长度固定的场景（如括号生成、排列问题等）。</p><h2 id="排列型回溯"><a href="#排列型回溯" class="headerlink" title="排列型回溯"></a>排列型回溯</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子集型回溯&quot;&gt;&lt;a href=&quot;#子集型回溯&quot; class=&quot;headerlink&quot; title=&quot;子集型回溯&quot;&gt;&lt;/a&gt;子集型回溯&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/letter-combinations-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>闭包介绍</title>
    <link href="https://leiqi.top/2025-05-28-3ec80348e81b.html"/>
    <id>https://leiqi.top/2025-05-28-3ec80348e81b.html</id>
    <published>2025-05-28T15:10:41.000Z</published>
    <updated>2025-06-11T16:26:39.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么闭包能共享变量-pre？"><a href="#为什么闭包能共享变量-pre？" class="headerlink" title="为什么闭包能共享变量 pre？"></a>为什么闭包能共享变量 <code>pre</code>？</h3><p>在提供的代码中，闭包能够共享变量 <code>pre</code> 的关键在于 <strong>词法作用域（Lexical Scoping）</strong> 和 <strong>闭包捕获变量</strong> 的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    pre := math.MinInt64 <span class="comment">// 外层函数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问并修改外层的 pre 变量</span></span><br><span class="line">        <span class="keyword">if</span> node.Val &lt;= pre &#123; ... &#125;</span><br><span class="line">        pre = node.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ol><li><p><strong>词法作用域</strong>：</p><ul><li>Go 中函数可以访问定义时所在作用域的所有变量</li><li><code>dfs</code> 匿名函数定义在 <code>isValidBST</code> 函数体内，自然能访问 <code>pre</code></li></ul></li><li><p><strong>闭包捕获变量</strong>：</p><ul><li>闭包不会复制变量值，而是<strong>捕获变量的引用</strong></li><li>所有递归调用的 <code>dfs</code> 都指向<strong>同一个 <code>pre</code> 变量</strong></li><li>修改 <code>pre</code> 会影响所有闭包实例</li></ul></li><li><p><strong>递归共享状态</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[pre=MinInt64] --&gt; B[dfs-根节点]</span><br><span class="line">B --&gt; C[dfs-左子节点]</span><br><span class="line">C --&gt; D[dfs-左孙节点]</span><br><span class="line">D --&gt;|更新pre| C</span><br><span class="line">C --&gt;|更新pre| B</span><br><span class="line">B --&gt;|更新pre| E[dfs-右子节点]</span><br></pre></td></tr></table></figure></li></ol><h3 id="闭包名称的含义与起源"><a href="#闭包名称的含义与起源" class="headerlink" title="闭包名称的含义与起源"></a>闭包名称的含义与起源</h3><h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><p>“闭包”（Closure）一词来源于 <strong>函数”闭合”（close over）其定义环境</strong> 的概念：</p><ul><li>最早由 Peter J. Landin 在 1964 年提出</li><li>源自数学中的 <strong>λ演算（Lambda Calculus）</strong> 和 <strong>闭包属性（Closure Property）</strong></li><li>在编译原理中称为 <strong>词法闭包（Lexical Closure）</strong></li></ul><h4 id="名称含义"><a href="#名称含义" class="headerlink" title="名称含义"></a>名称含义</h4><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>闭（Close）</strong></td><td>函数”封闭”地携带其定义时的环境</td></tr><tr><td><strong>包（-ure）</strong></td><td>将函数与其环境”打包”在一起</td></tr></tbody></table><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol><li><strong>环境捕获</strong>：函数记住并访问定义时的作用域</li><li><strong>状态持久化</strong>：捕获的变量生命周期与闭包相同</li><li><strong>私密状态</strong>：只有闭包能访问捕获的变量</li></ol><h3 id="闭包在-BST-验证中的优势"><a href="#闭包在-BST-验证中的优势" class="headerlink" title="闭包在 BST 验证中的优势"></a>闭包在 BST 验证中的优势</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre := math.MinInt64  <span class="comment">// 共享状态</span></span><br><span class="line">dfs := <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 递归过程共享同一个 pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>状态管理简化</strong>：无需指针传递</li><li><strong>代码更简洁</strong>：减少参数传递</li><li><strong>逻辑更直观</strong>：直接读写共享状态</li><li><strong>避免值复制</strong>：高效处理递归状态</li></ol><h3 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h3><p>闭包本质上是一个 <strong>（函数 + 绑定环境）</strong> 的组合体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span>  <span class="comment">// 函数逻辑</span></span><br><span class="line">    Env <span class="keyword">struct</span> &#123;            <span class="comment">// 捕获的环境</span></span><br><span class="line">        pre <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次递归调用时，都使用同一个 <code>Env</code> 环境，这正是 BST 验证需要的中序遍历状态一致性保证。</p><h3 id="闭包-vs-指针参数"><a href="#闭包-vs-指针参数" class="headerlink" title="闭包 vs 指针参数"></a>闭包 vs 指针参数</h3><table><thead><tr><th>特性</th><th>闭包</th><th>指针参数</th></tr></thead><tbody><tr><td>状态共享</td><td>自动捕获</td><td>需显式传递</td></tr><tr><td>可读性</td><td>★★★☆☆</td><td>★★☆☆☆</td></tr><tr><td>安全性</td><td>变量封装</td><td>暴露内存地址</td></tr><tr><td>递归适用性</td><td>非常适合</td><td>需要小心指针传递</td></tr></tbody></table><p>在 BST 验证场景中，闭包方案更简洁安全，避免了指针传递的复杂性，是 Go 语言处理递归状态的首选模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么闭包能共享变量-pre？&quot;&gt;&lt;a href=&quot;#为什么闭包能共享变量-pre？&quot; class=&quot;headerlink&quot; title=&quot;为什么闭包能共享变量 pre？&quot;&gt;&lt;/a&gt;为什么闭包能共享变量 &lt;code&gt;pre&lt;/code&gt;？&lt;/h3&gt;&lt;p&gt;在提供的代</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>comet 生成临时文件导致磁盘满</title>
    <link href="https://leiqi.top/2025-05-01-d5e22ea4be8d.html"/>
    <id>https://leiqi.top/2025-05-01-d5e22ea4be8d.html</id>
    <published>2025-05-01T13:50:34.000Z</published>
    <updated>2025-06-11T16:26:39.057Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>出现 <code>OSError: [Errno 28] No space left on device</code> 错误的原因是系统磁盘空间不足，尤其是在临时目录（如 <code>/tmp</code>）中。以下是分步解决方案：</p><hr><h4 id="1-检查磁盘空间"><a href="#1-检查磁盘空间" class="headerlink" title="1. 检查磁盘空间"></a><strong>1. 检查磁盘空间</strong></h4><p>在终端运行以下命令，查看磁盘使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><h4 id="2-清理临时文件"><a href="#2-清理临时文件" class="headerlink" title="2. 清理临时文件"></a><strong>2. 清理临时文件</strong></h4><p>删除临时目录中的旧文件（确保无重要进程依赖这些文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /tmp/*</span><br></pre></td></tr></table></figure><hr><h4 id="3-查找并删除大文件"><a href="#3-查找并删除大文件" class="headerlink" title="3. 查找并删除大文件"></a><strong>3. 查找并删除大文件</strong></h4><p>使用以下命令定位大文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看根目录下各文件夹的大小</span></span><br><span class="line">sudo <span class="built_in">du</span> -sh /* | <span class="built_in">sort</span> -hr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下大于 1GB 的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +1G -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>删除不再需要的大文件（如旧日志、缓存等）。</p><hr><h4 id="4-清理系统缓存和日志"><a href="#4-清理系统缓存和日志" class="headerlink" title="4. 清理系统缓存和日志"></a><strong>4. 清理系统缓存和日志</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 APT 缓存（适用于 Ubuntu/Debian）</span></span><br><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧版 Linux 内核（谨慎操作）</span></span><br><span class="line">sudo apt-get autoremove --purge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理系统日志（保留最近7天）</span></span><br><span class="line">sudo journalctl --vacuum-time=7d</span><br></pre></td></tr></table></figure><hr><h4 id="5-更改临时目录路径"><a href="#5-更改临时目录路径" class="headerlink" title="5. 更改临时目录路径"></a><strong>5. 更改临时目录路径</strong></h4><p>如果 <code>/tmp</code> 所在分区空间不足，可以将临时目录指向其他分区：</p><p><strong>方法一：在代码中设置临时目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">tempfile.tempdir = <span class="string">&quot;/path/to/your/large/disk/tmp&quot;</span>  <span class="comment"># 替换为有足够空间的路径</span></span><br></pre></td></tr></table></figure><p><strong>方法二：通过环境变量设置</strong><br>在运行脚本前设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TMPDIR=/path/to/your/large/disk/tmp</span><br></pre></td></tr></table></figure><hr><h4 id="6-调整-Comet-ml-的存储路径"><a href="#6-调整-Comet-ml-的存储路径" class="headerlink" title="6. 调整 Comet.ml 的存储路径"></a><strong>6. 调整 Comet.ml 的存储路径</strong></h4><p>在初始化 <code>Experiment</code> 时指定日志和临时文件目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">experiment = Experiment(</span><br><span class="line">    <span class="string">&quot;H62QCY6dW6Vg9lLl27jZn4C2O&quot;</span>,</span><br><span class="line">    project_name=<span class="string">&quot;IDRsPredictor-transformer&quot;</span>,</span><br><span class="line">    log_code=<span class="literal">True</span>,</span><br><span class="line">    log_dir=<span class="string">&quot;/path/to/large/disk/comet_logs&quot;</span>  <span class="comment"># 指定存储路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参考：chatGPT</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;出现 &lt;code&gt;OSError: [Errno 28] No space le</summary>
      
    
    
    
    <category term="比赛" scheme="https://leiqi.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Git自动转换为Linux换行符</title>
    <link href="https://leiqi.top/2025-04-28-84ca2c3d5919.html"/>
    <id>https://leiqi.top/2025-04-28-84ca2c3d5919.html</id>
    <published>2025-04-28T13:15:32.000Z</published>
    <updated>2025-06-11T16:26:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>在 Git 中处理不同操作系统（Windows&#x2F;Linux&#x2F;macOS）的换行符（<code>LF</code> 和 <code>CRLF</code>）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：</p><hr><h3 id="1-核心配置：core-autocrlf"><a href="#1-核心配置：core-autocrlf" class="headerlink" title="1. 核心配置：core.autocrlf"></a><strong>1. 核心配置：<code>core.autocrlf</code></strong></h3><p>通过设置 <code>core.autocrlf</code> 属性，让 Git 自动转换换行符：</p><h4 id="不同操作系统的推荐设置"><a href="#不同操作系统的推荐设置" class="headerlink" title="不同操作系统的推荐设置"></a><strong>不同操作系统的推荐设置</strong></h4><ul><li><p><strong>Windows（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时转换为 CRLF</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Linux&#x2F;macOS（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时不转换</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-强制规范：-gitattributes-文件"><a href="#2-强制规范：-gitattributes-文件" class="headerlink" title="2. 强制规范：.gitattributes 文件"></a><strong>2. 强制规范：<code>.gitattributes</code> 文件</strong></h3><p>在项目根目录创建 <code>.gitattributes</code> 文件，<strong>优先级高于全局配置</strong>，适合团队协作。</p><h4 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 所有文本文件使用 LF 换行符</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># 排除二进制文件（避免误处理）</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br><span class="line">*.zip binary</span><br><span class="line"></span><br><span class="line"># 指定特定文件类型（可选）</span><br><span class="line">*.sh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure><ul><li><code>text=auto</code>：Git 自动识别文本文件。</li><li><code>eol=lf</code> 或 <code>eol=crlf</code>：强制统一换行符。</li></ul><hr><h3 id="3-修复已存在的换行符问题"><a href="#3-修复已存在的换行符问题" class="headerlink" title="3. 修复已存在的换行符问题"></a><strong>3. 修复已存在的换行符问题</strong></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol><li><p>删除缓存并重置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached -r .  <span class="comment"># 清除缓存</span></span><br><span class="line">git reset --hard      <span class="comment"># 重置文件</span></span><br></pre></td></tr></table></figure></li><li><p>重新添加文件并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;fix: normalize line endings&quot;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-检查换行符状态"><a href="#4-检查换行符状态" class="headerlink" title="4. 检查换行符状态"></a><strong>4. 检查换行符状态</strong></h3><h4 id="检查文件换行符："><a href="#检查文件换行符：" class="headerlink" title="检查文件换行符："></a><strong>检查文件换行符</strong>：</h4><ul><li><p><strong>Linux&#x2F;macOS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file yourfile.txt</span><br><span class="line"><span class="comment"># 输出中包含 &quot;LF&quot; 或 &quot;CRLF&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Windows（PowerShell）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> yourfile.txt <span class="literal">-Encoding</span> Byte | <span class="built_in">Select-String</span> <span class="string">&quot;0D 0A&quot;</span></span><br><span class="line"><span class="comment"># 存在 &quot;0D 0A&quot; 表示 CRLF</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="查看-Git-换行符转换日志："><a href="#查看-Git-换行符转换日志：" class="headerlink" title="查看 Git 换行符转换日志："></a><strong>查看 Git 换行符转换日志</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --eol</span><br></pre></td></tr></table></figure><hr><h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a><strong>常见问题解决</strong></h3><ul><li><p>**警告 <code>LF will be replaced by CRLF</code>**：<br>正常提示，表示 Git 正在按配置转换换行符。</p></li><li><p><strong>文件被标记为已修改（仅换行符变化）</strong>：<br>运行以下命令清除差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.whitespace cr-at-eol</span><br><span class="line">git add --renormalize .</span><br></pre></td></tr></table></figure></li><li><p><strong>混合换行符导致冲突</strong>：<br>使用 <code>.gitattributes</code> 强制统一换行符，并重新提交文件。</p></li></ul><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol><li><strong>团队协作</strong>：在项目中添加 <code>.gitattributes</code> 文件，统一换行符规则。</li><li><strong>编辑器配置</strong>：设置 IDE（如 VSCode）默认使用 <code>LF</code>（<a href="https://stackoverflow.com/a/44788470">配置示例</a>）。</li><li><strong>Windows 用户</strong>：安装 Git 时选择 <code>Checkout as-is, commit Unix-style line endings</code>。</li></ol><hr><p>通过上述配置，Git 会自动处理换行符，避免跨平台协作时的混乱！ 🛠️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Git 中处理不同操作系统（Windows&amp;#x2F;Linux&amp;#x2F;macOS）的换行符（&lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt;）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>更新网页url后，恢复valine网页评论</title>
    <link href="https://leiqi.top/2025-04-13-8c397fc87827.html"/>
    <id>https://leiqi.top/2025-04-13-8c397fc87827.html</id>
    <published>2025-04-13T04:28:35.000Z</published>
    <updated>2025-06-11T16:26:39.056Z</updated>
    
    <content type="html"><![CDATA[<p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。<br>具体步骤：登录&gt;选择你创建的应用&gt;数据存储&gt;结构化数据&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><p>修改 对应url 列为当前url<br><img src="/../../imgs/Pasted%20image%2020250413122851.png"><img src="/../../imgs/Pasted%20image%2020250413123508.png"></p><p>参考：<br><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。&lt;br&gt;具体步骤：登录&amp;gt;选择你创建的应用&amp;gt;数据存储&amp;gt;结构化数据&amp;gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构设计专题</title>
    <link href="https://leiqi.top/2025-03-06-dab119f1439d.html"/>
    <id>https://leiqi.top/2025-03-06-dab119f1439d.html</id>
    <published>2025-03-06T14:56:44.000Z</published>
    <updated>2025-06-11T16:26:39.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th><th>是否完成</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td><td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td><td>🟠</td><td>202050306🟢</td></tr><tr><td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td><td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td><td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td><td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td><td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td><td>🟢</td><td>202050307🟢</td></tr><tr><td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td><td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td><td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td><td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td><td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td><td>🟠</td><td>🔴</td></tr></tbody></table><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请设计 最近 最少使用 约束的数据结构<br><img src="/../../imgs/Pasted%20image%2020250309231207.png"></p><p>20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">orderList []<span class="type">int</span></span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">orderList: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, capacity), <span class="comment">// 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</span></span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, capacity),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// key 存在与单独的环境中</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.Update(key)</span><br><span class="line"><span class="keyword">return</span> this.cacheMaps[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Update(key <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 更新key 到最新位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.orderList); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this.orderList[i] == key &#123;</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList[:i], <span class="built_in">append</span>(this.orderList[i+<span class="number">1</span>:], this.orderList[i])...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.Update(key)</span><br><span class="line">&#125;  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &gt;= this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=&quot;</span>,<span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line">oldKey := this.orderList[<span class="number">0</span>]</span><br><span class="line">this.orderList = this.orderList[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, oldKey)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &lt; this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;&lt;&quot;</span>, <span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-1-方法双向列表，map-中直接保存列表元素指针，"><a href="#O-1-方法双向列表，map-中直接保存列表元素指针，" class="headerlink" title="O(1) 方法双向列表，map 中直接保存列表元素指针，"></a>O(1) 方法双向列表，map 中直接保存列表元素指针，</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">orderList *list.List</span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element, capacity),</span><br><span class="line">orderList: list.New(),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(entry).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新已存在的键</span></span><br><span class="line">elem.Value = entry&#123;key: key, value: value&#125;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入新键</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) == this.capacity &#123;</span><br><span class="line"><span class="comment">// 删除最久未使用的键</span></span><br><span class="line">frontElem := this.orderList.Front()</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, frontElem.Value.(entry).key)</span><br><span class="line">this.orderList.Remove(frontElem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入新键到链表末尾</span></span><br><span class="line">newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;)</span><br><span class="line">this.cacheMaps[key] = newElem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p><img src="/../../imgs/Pasted%20image%2020250307231252.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1700  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9分钟完成  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStudents</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 栈模拟  </span></span><br><span class="line">    <span class="comment">// 结束条件  </span></span><br><span class="line">    <span class="comment">// 同学中数字都相同，且不等于栈顶元素 [0]  </span></span><br><span class="line">    <span class="keyword">for</span> !isEnd(students, sandwiches) &#123;  </span><br><span class="line">       <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>] &#123;  </span><br><span class="line">          sandwiches = sandwiches[<span class="number">1</span>:]  </span><br><span class="line">          students = students[<span class="number">1</span>:]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          students = <span class="built_in">append</span>(students[<span class="number">1</span>:], students[<span class="number">0</span>])  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(students)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnd</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> students &#123;  </span><br><span class="line">       <span class="keyword">if</span> val == sandwiches[<span class="number">0</span>] &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据结构设计&quot;&gt;&lt;a href=&quot;#数据结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据结构设计&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://labuladong.online/algo/intro/quick-learning-plan/#%</summary>
      
    
    
    
    <category term="速刷记录" scheme="https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>系统序列图 - 时序图</title>
    <link href="https://leiqi.top/2025-02-19-05250c3f88f5.html"/>
    <id>https://leiqi.top/2025-02-19-05250c3f88f5.html</id>
    <published>2025-02-19T12:07:47.000Z</published>
    <updated>2025-06-11T16:26:39.057Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219200803.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>如何画好一个架构图</title>
    <link href="https://leiqi.top/2025-02-19-d829d1f5a9ea.html"/>
    <id>https://leiqi.top/2025-02-19-d829d1f5a9ea.html</id>
    <published>2025-02-19T11:39:54.000Z</published>
    <updated>2025-06-11T16:26:39.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p><h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p><ul><li>通过不同的颜色白标识不同颜色</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p><h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p><p>使用场景：</p><ul><li>项目开发和测试</li><li>部署发布</li><li>子领域项目架构，下方就是个会员中心*</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p><h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p><p>使用场景</p><ul><li>总体架构设计</li><li>运维规划和优化</li><li>画图技巧</li><li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li></ul><p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务架构&quot;&gt;&lt;a href=&quot;#业务架构&quot; class=&quot;headerlink&quot; title=&quot;业务架构&quot;&gt;&lt;/a&gt;业务架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219195041.png&quot;&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <link href="https://leiqi.top/2025-01-13-1b5c01477594.html"/>
    <id>https://leiqi.top/2025-01-13-1b5c01477594.html</id>
    <published>2025-01-13T15:40:59.000Z</published>
    <updated>2025-06-11T16:26:39.050Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *</span><br></pre></td></tr></table></figure><p>解释一下这个命令：</p><ul><li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li><li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li><li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul><li><code>s</code> 表示替换操作。</li><li><code>hide: true</code> 是要被替换的字符串。</li><li><code>hide: false</code> 是替换后的字符串。</li><li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li></ul></li><li><code>*</code> 表示当前文件夹下的所有文件。</li></ul><p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure><p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Linux 中，可以使用以下命令来实现这个需求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-06-11T16:26:39.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】for range 数组指针遍历</title>
    <link href="https://leiqi.top/2024-12-03-90d19c862e9c.html"/>
    <id>https://leiqi.top/2024-12-03-90d19c862e9c.html</id>
    <published>2024-12-03T16:55:24.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，使用<code>for range</code>遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如<code>[]*Student</code>）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。</p><p>这意味着，即使<code>for range</code>对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    students := []*Student&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;Bob&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用for range遍历指针数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        <span class="comment">// 修改指向的结构体的内容</span></span><br><span class="line">        student.Age += <span class="number">1</span> <span class="comment">// 给每个学生的年龄加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的students数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, student.Name, student.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管<code>for range</code>对每个<code>*Student</code>指针进行了拷贝，但通过这个拷贝的指针修改<code>Age</code>字段时，修改的是原始<code>Student</code>结构体的内容。因此，当再次遍历<code>students</code>数组时，你会看到每个学生的年龄都已经增加了。</p><p>总结来说，当你使用<code>for range</code>遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，使用&lt;code&gt;for range&lt;/code&gt;遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如&lt;code&gt;[]*Student&lt;/code&gt;）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 浮点数次方</title>
    <link href="https://leiqi.top/2024-12-03-3d026e7b5bec.html"/>
    <id>https://leiqi.top/2024-12-03-3d026e7b5bec.html</id>
    <published>2024-12-03T15:46:08.000Z</published>
    <updated>2025-06-11T16:26:39.049Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，计算一个数的几次方可以通过标准库中的<code>math</code>包来实现。<code>math</code>包提供了一个<code>Pow</code>函数，用于计算x的y次方。</p><h3 id="使用math-Pow函数"><a href="#使用math-Pow函数" class="headerlink" title="使用math.Pow函数"></a>使用<code>math.Pow</code>函数</h3><p><code>math.Pow</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pow</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>这个函数接受两个<code>float64</code>类型的参数：<code>x</code>是底数，<code>y</code>是指数，返回<code>x</code>的<code>y</code>次方的结果。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用<code>math.Pow</code>函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算2的3次方</span></span><br><span class="line">    result := math.Pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;2的3次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算3的2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;3的2次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算10的-2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">10</span>, <span class="number">-2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;10的-2次方是: %v\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2的3次方是: 8</span><br><span class="line">3的2次方是: 9</span><br><span class="line">10的-2次方是: 0.01</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>math.Pow</code>函数的参数和返回值都是<code>float64</code>类型，因此如果你需要计算整数的次方，可能需要先将整数转换为<code>float64</code>，然后再进行计算。</li><li>如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，计算一个数的几次方可以通过标准库中的&lt;code&gt;math&lt;/code&gt;包来实现。&lt;code&gt;math&lt;/code&gt;包提供了一个&lt;code&gt;Pow&lt;/code&gt;函数，用于计算x的y次方。&lt;/p&gt;
&lt;h3 id=&quot;使用math-Pow函数&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【基础知识】Golang  sort.Slice 复杂排序</title>
    <link href="https://leiqi.top/2024-11-24-24291296f81a.html"/>
    <id>https://leiqi.top/2024-11-24-24291296f81a.html</id>
    <published>2024-11-24T04:47:52.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，你可以使用 <code>sort.Slice</code> 对 <code>slice</code> 按照复杂条件进行排序。 <code>sort.Slice</code> 函数接受一个 <code>slice</code> 和一个比较函数，该比较函数定义了两个元素之间的排序关系。</p><p>以下是实现复杂条件排序的步骤和示例：</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(slice, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 slice[i] 和 slice[j]</span></span><br><span class="line">    <span class="keyword">return</span> 条件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-示例：对结构体切片进行多条件排序"><a href="#2-示例：对结构体切片进行多条件排序" class="headerlink" title="2. 示例：对结构体切片进行多条件排序"></a>2. 示例：对结构体切片进行多条件排序</h3><p>假设有一个包含多个 <code>Person</code> 的切片，我们希望按以下规则排序：</p><ol><li>年龄从小到大排序。</li><li>如果年龄相同，则按名字的字母顺序排序。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sort.Slice 按多个条件排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 优先按年龄排序</span></span><br><span class="line"><span class="keyword">if</span> people[i].Age != people[j].Age &#123;</span><br><span class="line"><span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果年龄相同，则按名字排序</span></span><br><span class="line"><span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-更复杂条件：按多个字段权重排序"><a href="#3-更复杂条件：按多个字段权重排序" class="headerlink" title="3. 更复杂条件：按多个字段权重排序"></a>3. 更复杂条件：按多个字段权重排序</h3><p>如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Price <span class="type">float64</span></span><br><span class="line">Rating <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">products := []Product&#123;</span><br><span class="line">&#123;<span class="string">&quot;Laptop&quot;</span>, <span class="number">1000</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Phone&quot;</span>, <span class="number">800</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Tablet&quot;</span>, <span class="number">800</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Watch&quot;</span>, <span class="number">400</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序</span></span><br><span class="line">sort.Slice(products, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 按价格降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Price != products[j].Price &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Price &gt; products[j].Price</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果价格相同，按评分降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Rating != products[j].Rating &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Rating &gt; products[j].Rating</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果评分也相同，按名称升序</span></span><br><span class="line"><span class="keyword">return</span> products[i].Name &lt; products[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(products)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li>如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。</li><li><code>sort.Slice</code> 是不稳定的。如果需要稳定排序，可以使用 <code>sort.SliceStable</code>。</li><li>对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。</li></ul><p>通过 <code>sort.Slice</code> 的灵活性，可以轻松实现各种复杂条件的排序逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，你可以使用 &lt;code&gt;sort.Slice&lt;/code&gt; 对 &lt;code&gt;slice&lt;/code&gt; 按照复杂条件进行排序。 &lt;code&gt;sort.Slice&lt;/code&gt; 函数接受一个 &lt;code&gt;slice&lt;/code&gt; 和一个比较函数，该比较函数定义</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】创建slice是否填第二个参数0的区别</title>
    <link href="https://leiqi.top/2024-11-23-b80d94088ccd.html"/>
    <id>https://leiqi.top/2024-11-23-b80d94088ccd.html</id>
    <published>2024-11-23T05:10:49.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，创建切片（slice）时使用<code>make</code>函数有两种常见的方式，它们之间有细微的差别：</p><ol><li><p><code>slice := make([]string, 0)</code></p><p> 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是<code>[]string</code>），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。</p></li><li><p><code>slice := make([]string)</code></p><p> 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，<code>make</code>函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。</p></li></ol><p>两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用<code>make([]string)</code>（或者等价的<code>make([]string, 0)</code>）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。</p><p>总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，创建切片（slice）时使用&lt;code&gt;make&lt;/code&gt;函数有两种常见的方式，它们之间有细微的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;slice := make([]string, 0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 这种方式明确指定了切片的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting</title>
    <link href="https://leiqi.top/2024-11-23-cf0eba4d8369.html"/>
    <id>https://leiqi.top/2024-11-23-cf0eba4d8369.html</id>
    <published>2024-11-23T05:05:23.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p>确实，如果我们按照缩写的逻辑来看，<code>Itos</code>（Integer to String）可能更直观地表达了<code>Itoa</code>函数的功能，即把整数转换为字符串。</p><p>然而，<code>Itoa</code>这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，<code>Itoa</code>这个术语已经被广泛接受和使用。以下是一些可能的原因：</p><ol><li><p><strong>历史原因</strong>：<code>Itoa</code>这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，<code>Itoa</code>（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。</p></li><li><p><strong>约定俗成</strong>：在编程社区中，<code>Itoa</code>已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。</p></li><li><p><strong>ASCII与字符串的关系</strong>：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字<code>123</code>的ASCII表示和字符串表示都是<code>&quot;123&quot;</code>。因此，<code>Itoa</code>这个名字仍然适用。</p></li><li><p><strong>简洁性</strong>：<code>Itoa</code>这个名称比较简洁，易于记忆。如果使用<code>Itos</code>，虽然直观，但可能不如<code>Itoa</code>简洁。</p></li></ol><p><code>Itoa</code>这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管<code>Itos</code>可能更直观地表示整数到字符串的转换，但<code>Itoa</code>已经成为一个广泛接受和使用的术语。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确实，如果我们按照缩写的逻辑来看，&lt;code&gt;Itos&lt;/code&gt;（Integer to String）可能更直观地表达了&lt;code&gt;Itoa&lt;/code&gt;函数的功能，即把整数转换为字符串。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;Itoa&lt;/code&gt;这个名称的由来实际上与历史</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
    <category term="刨根问底" scheme="https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>【基础知识】符号整数和非符号整数</title>
    <link href="https://leiqi.top/2024-11-23-dce4118b03a7.html"/>
    <id>https://leiqi.top/2024-11-23-dce4118b03a7.html</id>
    <published>2024-11-23T04:47:02.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p><code>uint8</code> <code>uint16</code>和<code>uint32</code>是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。</p><ol><li><p><code>unit8</code> : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255</p></li><li><p>**<code>uint16</code>**：</p><ul><li><code>uint16</code>是一个16位的无符号整数。</li><li>它可以存储的数字数量是 2^16。</li><li>计算得出：216&#x3D;65536216&#x3D;65536。</li><li>因此，<code>uint16</code>能存储的数字范围是从0到65535。</li></ul></li><li><p>**<code>uint32</code>**：</p><ul><li><code>uint32</code>是一个32位的无符号整数。</li><li>它可以存储的数字数量是 2^32。</li><li>计算得出：232&#x3D;4294967296232&#x3D;4294967296。</li><li>因此，<code>uint32</code>能存储的数字范围是从0到4294967295。</li></ul></li></ol><p>总结：</p><ul><li><code>uint16</code>能存储的数字数量是 216216，即65536个数字。</li><li><code>uint32</code>能存储的数字数量是 232232，即4294967296个数字。</li></ul><p><code>int32</code>是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。</p><p>具体来说：</p><ul><li>对于正数，<strong>最高位是0</strong>，剩下的31位可以表示 231231 个不同的正数值。</li><li>对于负数，<strong>最高位是1</strong>，剩下的31位可以表示 231231 个不同的负数值。</li><li>由于0既不是正数也不是负数，它单独占用了一个数值。</li></ul><p>因此，<code>int32</code>的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说<code>int32</code>的范围是31次方而不是32次方的原因。<br><img src="/../../imgs/Pasted%20image%2020241123132832.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;uint8&lt;/code&gt; &lt;code&gt;uint16&lt;/code&gt;和&lt;code&gt;uint32&lt;/code&gt;是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unit8&lt;/code&gt; : 是8位无</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 byte和rune 有什么区别</title>
    <link href="https://leiqi.top/2024-11-23-ff51ba651704.html"/>
    <id>https://leiqi.top/2024-11-23-ff51ba651704.html</id>
    <published>2024-11-23T04:38:13.000Z</published>
    <updated>2025-06-11T16:26:39.055Z</updated>
    
    <content type="html"><![CDATA[<p>byte 和rune 有什么区别？<br>    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：</p><p>byte：</p><p>byte是uint8的别名，即一个无符号的8位整数。<br>在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。<br>byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。<br>rune：</p><p>rune是int32的别名，即一个有符号的32位整数。<br>rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。<br>rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。<br>由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。<br>区别：</p><p>大小：byte是8位的，而rune是32位的。<br>用途：byte用于处理字节数据，rune用于处理Unicode字符。<br>范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。<br>编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。<br>在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;byte 和rune 有什么区别？&lt;br&gt;    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：&lt;/p&gt;
&lt;p&gt;byte：&lt;/p&gt;
&lt;p&gt;byte是uint8的别名，即一个无符号的8位整数。&lt;br&gt;在Go语言中</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>申请域名绑定github pages</title>
    <link href="https://leiqi.top/2024-09-01-ed1bf9078b39.html"/>
    <id>https://leiqi.top/2024-09-01-ed1bf9078b39.html</id>
    <published>2024-09-01T02:17:17.000Z</published>
    <updated>2025-06-11T16:26:39.056Z</updated>
    
    <content type="html"><![CDATA[<p>你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！</p><h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><ol><li>在<a href="https://www.namesilo.com/">Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo</a>完成了域名的购买</li><li>完成了GitHub Pages的设置，有了可用的<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>库之后，可以访问 Github Pages</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-进入我的账户"><a href="#0-进入我的账户" class="headerlink" title="0. 进入我的账户"></a>0. 进入我的账户</h3><p><img src="/../../imgs/Pasted%20image%2020240901102308.png"></p><h3 id="1-无论是什么域名服务商，找到DNS-Management页面"><a href="#1-无论是什么域名服务商，找到DNS-Management页面" class="headerlink" title="1. 无论是什么域名服务商，找到DNS Management页面"></a><strong>1. 无论是什么域名服务商，找到DNS Management页面</strong></h3><p>如果是namesilo购买的域名，可以通过以下步骤：<br><img src="/../../imgs/Pasted%20image%2020240901102340.png"><br>点击“domain manager”<br><img src="/../../imgs/Pasted%20image%2020240901102510.png"><br>点击这个蓝色的小球（Manage DNS for this domain）</p><h3 id="2-写入-type-A-的DNS记录"><a href="#2-写入-type-A-的DNS记录" class="headerlink" title="2. 写入 type A 的DNS记录"></a><strong>2. 写入 type A 的DNS记录</strong></h3><ul><li><strong>如果厂商提供了写入模板</strong>，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 <strong>DNS Templates</strong>。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-b84d88c38c06b6081f02cafbd0dac24b_720w.webp"></p><p>找到GitHub的template，点击“<strong>Apply Template</strong>”，然后在弹出的窗口里直接点击“<strong>Accept</strong>”，你就会发现4条A记录已经自动写入了。</p><p><img src="https://pic1.zhimg.com/80/v2-c731fadefaf3d3a2268e6566d6196558_720w.webp"></p><ul><li><strong>如果厂商不能自动添加</strong>，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图</li></ul><p>[Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain!</p><p><img src="https://pica.zhimg.com/80/v2-1a618fec2900e4f23039c153d8ab03da_720w.webp"></p><p>上面圈起来的四个地址就是需要等会儿手动输入的。</p><p>不同厂商之间的手动添加方法不一样，但只要记住 <strong>type 后填“A”</strong>，<strong>address&#x2F;points to或其他同义表达后填这四个地址中的一个</strong>，<strong>其他默认</strong>就好了，一共需要添加<strong>四条</strong>，可以复制粘贴。</p><p>添加之后会多出四个<img src="/../../imgs/Pasted%20image%2020240901102815.png">### 3. 创建CNAME文件</p><p>这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，</p><blockquote><p>上面的方法 save 之后看到报错不要慌，<a href="https://zhida.zhihu.com/search?q=%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E&zhida_source=entity&is_preview=1">让子弹飞</a>一会儿就好了</p></blockquote><p><img src="/../../imgs/Pasted%20image%2020240901102714.png"><br><img src="/../../imgs/Pasted%20image%2020240901102745.png"></p><p>最终有这些配置即可：<br><img src="/../../imgs/Pasted%20image%2020240901102848.png"></p><h3 id="github-填写域名地址"><a href="#github-填写域名地址" class="headerlink" title="github 填写域名地址"></a>github 填写域名地址</h3><p>在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。<br><img src="/../../imgs/Pasted%20image%2020240901103216.png"><br><img src="/../../imgs/Pasted%20image%2020240901103241.png"></p><h3 id="即刻访问你自己的域名网站吧！"><a href="#即刻访问你自己的域名网站吧！" class="headerlink" title="即刻访问你自己的域名网站吧！"></a>即刻访问你自己的域名网站吧！</h3><p><img src="/../../imgs/Pasted%20image%2020240901103553.png"></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/448781791">将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！&lt;/p&gt;
&lt;h2 id=&quot;前置需求&quot;&gt;&lt;a href=&quot;#前置需求&quot; class=&quot;headerlink&quot; title=&quot;前置需求&quot;&gt;&lt;/a&gt;前置需求&lt;/h2&gt;&lt;o</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>git stash</title>
    <link href="https://leiqi.top/2024-08-21-d34ebab44074.html"/>
    <id>https://leiqi.top/2024-08-21-d34ebab44074.html</id>
    <published>2024-08-21T16:26:46.000Z</published>
    <updated>2025-06-11T16:26:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：</p><p>放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- .obsidian/workspace.json</span><br></pre></td></tr></table></figure><p>再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>如果不想放弃这些更改，而是想将它们暂时保存起来，可以使用 git stash 命令：</p><p>保存更改：使用 git stash 将更改保存到一个临时区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p><code>git stash</code> 是 Git 中用于临时保存工作目录和暂存区改动的工具，适用于需要切换分支或处理其他任务但不想提交未完成工作的场景。</p><hr><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h3><ol><li><p><strong>保存当前改动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash                   <span class="comment"># 默认保存，消息为自动生成</span></span><br><span class="line">git stash push -m <span class="string">&quot;备注&quot;</span>    <span class="comment"># 保存并添加自定义备注</span></span><br></pre></td></tr></table></figure><ul><li><strong>选项</strong>：<ul><li><code>-u</code> 或 <code>--include-untracked</code>：包含未被跟踪的文件（新增但未 <code>git add</code> 的文件）。</li><li><code>-a</code> 或 <code>--all</code>：包含所有文件（包括被 <code>.gitignore</code> 忽略的文件）。</li><li><code>--keep-index</code>：仅保存工作区未暂存的改动，保留暂存区内容。</li></ul></li></ul></li><li><p><strong>查看保存的 stash 列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><ul><li>输出示例：<code>stash@&#123;0&#125;: On main: 备注</code></li></ul></li><li><p><strong>恢复改动</strong></p><ul><li><strong>恢复最近一次的 stash 并删除记录</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li><li><strong>恢复指定 stash 但不删除记录</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;n&#125;  <span class="comment"># n 为 stash 编号，如 stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>删除 stash</strong></p><ul><li><strong>删除指定 stash</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure></li><li><strong>清空所有 stash</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a><strong>高级用法</strong></h3><ol><li><p><strong>从 stash 创建分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash branch 分支名 stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><ul><li>基于指定 stash 创建新分支，并自动应用改动（适用于 stash 与当前分支冲突时）。</li></ul></li><li><p><strong>查看 stash 的改动详情</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash show stash@&#123;n&#125;    <span class="comment"># 显示简略差异</span></span><br><span class="line">git stash show -p stash@&#123;n&#125; <span class="comment"># 显示完整差异（类似 git diff）</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul><li><strong>默认行为</strong>：<ul><li><code>git stash</code> 会保存 <strong>工作区未提交的修改</strong> 和 <strong>暂存区的修改</strong>。</li><li>恢复时，已暂存的改动会重新回到暂存区，未暂存的改动保留在工作区。</li></ul></li><li><strong>未跟踪文件</strong>：<ul><li>默认不保存未被跟踪的文件（需用 <code>-u</code> 或 <code>--include-untracked</code>）。</li></ul></li><li><strong>冲突处理</strong>：<ul><li>如果恢复时发生冲突，需手动解决后执行 <code>git add</code> 和 <code>git restore --staged</code> 或提交。</li></ul></li></ul><hr><h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h3><ol><li><p><strong>临时切换分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash -m <span class="string">&quot;保存功能 A 的进度&quot;</span></span><br><span class="line">git checkout 其他分支</span><br><span class="line"><span class="comment"># 处理其他任务后返回</span></span><br><span class="line">git checkout 原分支</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li><li><p><strong>保存包含未跟踪文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u -m <span class="string">&quot;包含新文件&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>恢复指定 stash</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash list              <span class="comment"># 查看列表</span></span><br><span class="line">git stash apply stash@&#123;2&#125;  <span class="comment"># 应用第三个 stash</span></span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：&lt;/p&gt;
&lt;p&gt;放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。&lt;/p&gt;</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
    <category term="git" scheme="https://leiqi.top/tags/git/"/>
    
  </entry>
  
</feed>
