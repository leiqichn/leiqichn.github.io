<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="http://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="http://leiqichn.github.io/"/>
  <updated>2023-03-28T15:23:47.568Z</updated>
  <id>http://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 222.完全二叉树的节点个数</title>
    <link href="http://leiqichn.github.io/2023-03-28-b21cc0774662.html"/>
    <id>http://leiqichn.github.io/2023-03-28-b21cc0774662.html</id>
    <published>2023-03-28T10:10:45.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-222-完全二叉树的节点个数"><a href="#leetcode-222-完全二叉树的节点个数" class="headerlink" title="leetcode 222.完全二叉树的节点个数"></a>leetcode 222.完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（Leetcode）</a></p><p>给出一个完全二叉树，求出该树的节点个数。<br><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p>示例 1：<br><img src="/../../imgs/Pasted%20image%2020230328221334.png"></p><ul><li>输入：root &#x3D; [1,2,3,4,5,6]</li><li>输出：6</li></ul><p>示例 2：</p><ul><li>输入：root &#x3D; []</li><li>输出：0</li></ul><p>示例 3：</p><ul><li>输入：root &#x3D; [1]</li><li>输出：1</li></ul><p>提示：</p><ul><li>树中节点的数目范围是[0, 5 * 10^4]</li><li>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4</li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>使用普通二叉树的思想来求，使用层序遍历 或者递归<br>  增加一个变量来存<strong>node</strong> 的个数</li><li>利用<strong>完全二叉树</strong>的性质，他只有最后一层没有填满，并且是从左到右依次填满的。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>思路1：普通二叉树</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    count := <span class="hljs-number">1</span> <span class="hljs-comment">//记录res, 递归算root=1</span><br>    <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        count += countNodes(root.Right)<br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        count += countNodes(root.Left)<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    q := list.New()<br>    q.PushBack(root)<br>    res := <span class="hljs-number">0</span> <span class="hljs-comment">// 记录res, 这里root 加入到了队列，所以res=0 而不是1</span><br>    <span class="hljs-keyword">for</span> q.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        n := q.Len()<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>            node := q.Remove(q.Front()).(*TreeNode)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                q.PushBack(node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                q.PushBack(node.Right)<br>            &#125;<br>            res++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2：完全二叉树</strong></p><ol><li>确定递归函数的参数和返回值 ： 输入根节点，返回int 节点数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br></code></pre></td></tr></table></figure></li><li>递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</li><li>单层递归逻辑：<br> 需要先求左子右树的节点数量（我们转化为满二叉树，使用公式计算）然后加上root<br> 结果等于 leftTreeNum + rightTreeNum + 1  （leftTreeNum为左子满二叉树，rightTreeNum为右子满二叉树，1是root）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <br>    leftH, rightH := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    leftNode := root.Left<br>    rightNode := root.Right<br>    <span class="hljs-keyword">for</span> leftNode != <span class="hljs-literal">nil</span> &#123;<br>        leftNode = leftNode.Left<br>        leftH++<br>    &#125;<br>    <span class="hljs-keyword">for</span> rightNode != <span class="hljs-literal">nil</span> &#123;<br>        rightNode = rightNode.Right<br>        rightH++<br>    &#125;<br>    <span class="hljs-comment">// 递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</span><br>    <span class="hljs-keyword">if</span> leftH == rightH &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftH) - <span class="hljs-number">1</span>  <span class="hljs-comment">// 2左移 即为平方</span><br>    &#125;<br>    leftTreeNum := countNodes(root.Left) <span class="hljs-comment">// 左</span><br>    rightTreeNum := countNodes(root.Right) <span class="hljs-comment">// 右</span><br>    res := leftTreeNum + rightTreeNum + <span class="hljs-number">1</span> <span class="hljs-comment">// 中</span><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode-222-完全二叉树的节点个数&quot;&gt;&lt;a href=&quot;#leetcode-222-完全二叉树的节点个数&quot; class=&quot;headerlink&quot; title=&quot;leetcode 222.完全二叉树的节点个数&quot;&gt;&lt;/a&gt;leetcode 222.完全二叉</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="二叉树" scheme="http://leiqichn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>快来压缩你的博客图片</title>
    <link href="http://leiqichn.github.io/2023-03-24-92a37bba7a46.html"/>
    <id>http://leiqichn.github.io/2023-03-24-92a37bba7a46.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没多大变化 哈哈哈<br><img src="/../../imgs/Pasted%20image%2020230324011438.png"><br>再试试 更大更高清的图片<br><img src="/../../imgs/code-wallpaper-6.png"></p><p><img src="/../../imgs/Pasted%20image%2020230325200454.png"><br>实测,效果不太行….<br>但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下<br>待更新…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然没多大变化 哈哈哈&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230324011438.png&quot;&gt;&lt;br&gt;再试试 更大更高清的图片&lt;br&gt;&lt;img src=&quot;/../../imgs/code-wallpaper-6.png&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给你的博客 安装上PWA吧</title>
    <link href="http://leiqichn.github.io/2023-03-24-554b8cbb674b.html"/>
    <id>http://leiqichn.github.io/2023-03-24-554b8cbb674b.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<p>TODO:</p><ul><li>什么是PWA，可以提示添加到主屏幕<br>渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站</li><li>安装 hexo-pwa</li><li>由于hexo-pwa停止维护，需要解决报错</li><li>设置全局_config.yml 文件(非主题)</li></ul><p><img src="/../../imgs/Pasted%20image%2020230324004739.png"></p><p><img src="/../../imgs/ad6c5ebfc9a6401cde512120b6ed719.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是PWA，可以提示添加到主屏幕&lt;br&gt;渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站&lt;/li&gt;
&lt;li&gt;安装 hexo-pwa&lt;/li&gt;
&lt;li&gt;由于hexo-pwa停止维护，需要解决报错&lt;/li&gt;
&lt;li&gt;设置全局_con</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 命令 将前台任务挂到后台运行</title>
    <link href="http://leiqichn.github.io/2023-03-19-aaf910b916ec.html"/>
    <id>http://leiqichn.github.io/2023-03-19-aaf910b916ec.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用<code>bg</code>  挂后台的命令。</p><p><strong>第一步：ctrl + z</strong></p><p><strong>第二步：jobs  查看任务id</strong></p><p><strong>第三步： bg %任务id</strong></p><p><img src="/../../imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用&lt;code</summary>
      
    
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/categories/Linux/"/>
    
    
    <category term="linux命令" scheme="http://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>博客设置 obsidian 上传图片</title>
    <link href="http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html"/>
    <id>http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的<strong>相对路径</strong>就可以读取并显示图片。</p><p>而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="1-打开obsidian-文件与链接"><a href="#1-打开obsidian-文件与链接" class="headerlink" title="1. 打开obsidian - 文件与链接"></a>1. 打开obsidian - 文件与链接</h2><h2 id="2-按照下图配置"><a href="#2-按照下图配置" class="headerlink" title="2. 按照下图配置"></a>2. 按照下图配置</h2><p>   *　将内部链接类型 设置为 “基于当前笔记的<strong>相对路径</strong>”<br>     &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用<strong>相对路径</strong></p><ul><li>取消wiki 链接 </li><li>指定图片的默认路径为 <code>source/imgs</code><br>&gt; 如果没有该文件夹，则需要先新建一下。</li></ul><p><img src="/../../imgs/Pasted%20image%2020230319131458.png"></p><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>网页可以成功显示图片</p><p><img src="/../../imgs/Pasted%20image%2020230319134051.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>排版测试</title>
    <link href="http://leiqichn.github.io/2023-03-18-16129b89df14.html"/>
    <id>http://leiqichn.github.io/2023-03-18-16129b89df14.html</id>
    <published>2023-03-18T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<p>网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。</p><h1 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><h4 id="hello-world-1"><a href="#hello-world-1" class="headerlink" title="hello world"></a>hello world</h4><p><img src="https://gitee.com/LeiQiCN/upload-img/raw/master/Image/unnamed.png" alt="unnamed.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。&lt;/p&gt;
&lt;h1 id=&quot;HELLO-WORLD&quot;&gt;&lt;a href=&quot;#HELLO-WORLD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORLD&quot;&gt;&lt;/a&gt;HELLO </summary>
      
    
    
    
    <category term="Test" scheme="http://leiqichn.github.io/categories/Test/"/>
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://leiqichn.github.io/2023-03-14-2c94ed65547e.html"/>
    <id>http://leiqichn.github.io/2023-03-14-2c94ed65547e.html</id>
    <published>2023-03-14T00:00:00.000Z</published>
    <updated>2023-03-28T15:23:47.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h1><p><a href="https://leiqichn.github.io/">国外链接</a><br><a href="https://leiqicn.gitee.io/">国内链接</a><br>大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客链接&quot;&gt;&lt;a href=&quot;#博客链接&quot; class=&quot;headerlink&quot; title=&quot;博客链接&quot;&gt;&lt;/a&gt;博客链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leiqichn.github.io/&quot;&gt;国外链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="关于我" scheme="http://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
    
    <category term="about" scheme="http://leiqichn.github.io/tags/about/"/>
    
  </entry>
  
</feed>
