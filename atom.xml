<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2024-07-06T13:15:37.728Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3快速实践</title>
    <link href="https://leiqichn.github.io/2024-06-24-1130f46a1ad4.html"/>
    <id>https://leiqichn.github.io/2024-06-24-1130f46a1ad4.html</id>
    <published>2024-06-24T14:32:19.000Z</published>
    <updated>2024-07-06T13:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/tutorial/#step-7">教程 | Vue.js (vuejs.org)</a></p><h1 id="Attribute-绑定-v-bind"><a href="#Attribute-绑定-v-bind" class="headerlink" title="Attribute 绑定 v-bind"></a>Attribute 绑定 v-bind</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const titleClass = ref(&#x27;title&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br>.title &#123;<br>  color: red;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p><img src="/../../../../imgs/Pasted%20image%2020240624225914.png"></p><h1 id="时间监听-v-on-click"><a href="#时间监听-v-on-click" class="headerlink" title="时间监听 v-on : click"></a>时间监听 v-on : click</h1><p>v-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br><br>function increment() &#123;<br>  // 更新组件状态<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;!-- 使此按钮生效 --&gt;<br><br>  &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../../../imgs/Pasted%20image%2020240624225635.png"></p><h1 id="表单绑定-v-model"><a href="#表单绑定-v-model" class="headerlink" title="表单绑定 v-model"></a>表单绑定 v-model</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230352.png"><br><code>v-model</code> 会将被绑定的值与 <code>&lt;input&gt;</code> 的值自动同步，这样我们就不必再使用事件处理函数了。</p><p><code>v-model</code> 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在<a href="https://cn.vuejs.org/guide/essentials/forms.html">指南 - 表单绑定</a>中讨论了更多的细节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const text = ref(&#x27;&#x27;)<br><br>function onInput(e) &#123;<br>  text.value = e.target.value<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br><br><br># 使用v-model 简化<br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const text = ref(&#x27;&#x27;)<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230722.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const awesome = ref(true)<br><br>function toggle() &#123;<br>  awesome.value = !awesome.value # 做取反<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt;<br>  &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/tutorial/#step-7&quot;&gt;教程 | Vue.js (vuejs.org)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Attribute-绑定-v-bind&quot;&gt;&lt;a href=&quot;#Attribute-绑定-v-bin</summary>
      
    
    
    
    <category term="vue3 入门" scheme="https://leiqichn.github.io/categories/vue3-%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>jupyter</title>
    <link href="https://leiqichn.github.io/2024-06-21-02cd02e81f22.html"/>
    <id>https://leiqichn.github.io/2024-06-21-02cd02e81f22.html</id>
    <published>2024-06-21T14:26:04.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pip install notebook</p><p>用于启动 Jupyter Notebook 服务的一系列命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">jupyter-notebook stop 8888<br>JUPYTER_TOKEN=$(&lt; /dev/urandom <span class="hljs-built_in">tr</span> -dc A-Za-z0-9 | <span class="hljs-built_in">head</span> -c16; <span class="hljs-built_in">echo</span>)<br><span class="hljs-built_in">nohup</span> jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=<span class="hljs-variable">$JUPYTER_TOKEN</span> &amp;<br>jupyter-notebook list<br></code></pre></td></tr></table></figure><p>这里是每条命令的简要说明：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jupyter-notebook stop <span class="hljs-number">8888</span>：停止端口为 <span class="hljs-number">8888</span> 的 Jupyter Notebook 服务。<br>JUPYTER_TOKEN=<span class="hljs-constructor">$(&lt; <span class="hljs-operator">/</span><span class="hljs-params">dev</span><span class="hljs-operator">/</span><span class="hljs-params">urandom</span> <span class="hljs-params">tr</span> -<span class="hljs-params">dc</span> A-Za-<span class="hljs-params">z0</span>-9 | <span class="hljs-params">head</span> -<span class="hljs-params">c16</span>; <span class="hljs-params">echo</span>)</span>：生成一个随机的 <span class="hljs-number">16</span> 位的 token，用于 Jupyter Notebook 的安全认证。<br>nohup jupyter-notebook --ip <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> --port <span class="hljs-number">8888</span> --no-browser --allow-root --<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NotebookApp</span>.</span></span>token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。<br>jupyter-notebook <span class="hljs-built_in">list</span>：列出当前运行的 Jupyter Notebook 服务。<br><br></code></pre></td></tr></table></figure><h1 id="conda-对应版本"><a href="#conda-对应版本" class="headerlink" title="conda　对应版本"></a>conda　对应版本</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;pip install notebook&lt;/p&gt;
&lt;p&gt;用于启动 Jupyter Notebook 服务的一系列命令&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 每日温度 单调栈</title>
    <link href="https://leiqichn.github.io/2024-05-20-1fbf9ee2486f.html"/>
    <id>https://leiqichn.github.io/2024-05-20-1fbf9ee2486f.html</id>
    <published>2024-05-20T16:16:04.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240521001833.png"><br>栈里边存放的是还没有找到后边更大值的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    st := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, t := <span class="hljs-keyword">range</span> temperatures &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(st) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]] &#123;<br>            j := st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]<br>            st = st[:<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]<br>            ans[j] = i - j<br>        &#125;<br>        st = <span class="hljs-built_in">append</span>(st, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125; <br><br></code></pre></td></tr></table></figure><p>这段代码是一个Go语言编写的函数，名为<code>dailyTemperatures</code>，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表<code>temperatures</code>，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。</p><h3 id="代码思想解释："><a href="#代码思想解释：" class="headerlink" title="代码思想解释："></a>代码思想解释：</h3><ol><li><p><strong>问题定义</strong>：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。</p></li><li><p><strong>单调栈的应用</strong>：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个索引栈，栈内元素代表尚未找到更大温度的天的索引。</p></li><li><p><strong>初始化</strong>：</p><ul><li><code>n</code>：记录输入温度数组的长度。</li><li><code>ans</code>：初始化一个长度为<code>n</code>的数组，用于存储结果，初始值设为0。</li><li><code>st</code>：初始化一个空的切片，用作单调栈。</li></ul></li><li><p><strong>遍历温度数组</strong>：</p><ul><li>通过<code>range</code>关键字遍历<code>temperatures</code>数组，同时获取索引<code>i</code>和对应的温度值<code>t</code>。</li></ul></li><li><p><strong>维护单调栈</strong>：</p><ul><li>当前温度<code>t</code>大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作：<ul><li>弹出栈顶元素<code>j</code>，即<code>st[len(st)-1]</code>。</li><li>计算索引差<code>i - j</code>，并将这个差值赋给<code>ans[j]</code>。</li><li>更新栈<code>st</code>，移除栈顶元素。</li></ul></li></ul></li><li><p><strong>压栈操作</strong>：</p><ul><li>将当前索引<code>i</code>压入栈<code>st</code>中。这表示当前索引的天还没有找到之后的第一个更高温度。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>遍历结束后，返回<code>ans</code>数组，其中每个元素表示对应天之后第一个更高温度的天数。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked&quot;&gt;739. 每日温度 - 力扣（LeetCode）</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现优先队列</title>
    <link href="https://leiqichn.github.io/2024-05-18-dfe0612e31db.html"/>
    <id>https://leiqichn.github.io/2024-05-18-dfe0612e31db.html</id>
    <published>2024-05-18T16:39:54.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。</p><h3 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1. 优先队列"></a>1. 优先队列</h3><p>优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。</p><h3 id="2-最大堆"><a href="#2-最大堆" class="headerlink" title="2. 最大堆"></a>2. 最大堆</h3><p>最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。</p><h3 id="3-最小堆"><a href="#3-最小堆" class="headerlink" title="3. 最小堆"></a>3. 最小堆</h3><p>最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="定义堆的元素类型"><a href="#定义堆的元素类型" class="headerlink" title="定义堆的元素类型"></a>定义堆的元素类型</h4><p>首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntHeap []<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h4 id="实现heap-Interface接口"><a href="#实现heap-Interface接口" class="headerlink" title="实现heap.Interface接口"></a>实现heap.Interface接口</h4><p>要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j] &#125; <span class="hljs-comment">// 对于最小堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>old := *h<br>n := <span class="hljs-built_in">len</span>(old)<br>x := old[n<span class="hljs-number">-1</span>]<br>*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用heap-Init初始化堆"><a href="#使用heap-Init初始化堆" class="headerlink" title="使用heap.Init初始化堆"></a>使用heap.Init初始化堆</h4><p>在使用堆之前，你需要调用heap.Init来初始化它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> h IntHeap <span class="hljs-comment">// 先声明h</span><br><br>heap.Init(&amp;h) <span class="hljs-comment">// 再使用heap.Init(&amp;h) 初始化h指针</span><br></code></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用heap.Push来添加元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">heap.Push(&amp;h, <span class="hljs-number">10</span>)<br>heap.Push(&amp;&amp;h, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用heap.Pop来移除并获取堆顶元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">top := heap.Pop(&amp;h)<br>fmt.Printf(<span class="hljs-string">&quot;top element: %v\n&quot;</span>, top)<br></code></pre></td></tr></table></figure><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。</p><h3 id="转换为最大堆"><a href="#转换为最大堆" class="headerlink" title="转换为最大堆"></a>转换为最大堆</h3><p>如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j] &#125; <span class="hljs-comment">// 对于最大堆</span><br></code></pre></td></tr></table></figure><p>以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=problem-list-v2&envId=IAmiWIlN">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240520000338.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2024 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * Date: 2024/5/20 上午12:00</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> leetcode215<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/heap&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>h := heapify(nums) <span class="hljs-comment">// 转化为heap 类型</span><br><span class="hljs-keyword">var</span> res any<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>res = heap.Pop(&amp;h)<br>&#125;<br><span class="hljs-keyword">return</span> res.(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> BigHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-keyword">return</span> h[i] &gt; h[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>tmp := h[i]<br>h[i] = h[j]<br>h[j] = tmp<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BigHeap)</span></span> Push(x any) &#123; <span class="hljs-comment">// 使用any 或者interface</span><br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-comment">// 删除元素待定</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BigHeap)</span></span> Pop() any &#123;<br>x := (*h)[h.Len()<span class="hljs-number">-1</span>]<br>*h = (*h)[:h.Len()<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 将 nums 转换成 BigHeap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapify</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> BigHeap &#123;<br><br>    h := BigHeap(nums) <span class="hljs-comment">// bigHeap 本身就是slice 的别名，所以可以转换</span><br>    <span class="hljs-comment">// 或者使用下边两行</span><br>h := <span class="hljs-built_in">make</span>(BigHeap, <span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 新建BigHeap，长度为lenNums</span><br><span class="hljs-built_in">copy</span>(h, nums)                 <span class="hljs-comment">// 将num copy 到 BigHeap 中去</span><br>heap.Init(&amp;h)                 <span class="hljs-comment">// 需要输入指针</span><br><span class="hljs-keyword">return</span> h<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240521004343.png"></p><p>涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//方法一：小顶堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    map_num:=<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">//记录每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> _,item:=<span class="hljs-keyword">range</span> nums&#123;<br>        map_num[item]++<br>    &#125;<br>    h:=&amp;IHeap&#123;&#125;<br>    heap.Init(h)<br>    <span class="hljs-comment">//所有元素入堆，堆的长度为k</span><br>    <span class="hljs-keyword">for</span> key,value:=<span class="hljs-keyword">range</span> map_num&#123;<br>        heap.Push(h,[<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key,value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len()&gt;k&#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    res:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,k)<br><br>    <span class="hljs-comment">//按顺序返回堆中的元素</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;<br>        res[k-i<span class="hljs-number">-1</span>]=heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">//构建小顶堆</span><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len()<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less (i,j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>]&lt;h[j][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i,j <span class="hljs-type">int</span>) &#123;<br>    h[i],h[j]=h[j],h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;)&#123;<br>    *h=<span class="hljs-built_in">append</span>(*h,x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    old:=*h<br>    n:=<span class="hljs-built_in">len</span>(old)<br>    x:=old[n<span class="hljs-number">-1</span>]<br>    *h=old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&amp;#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。&lt;/p&gt;
&lt;h3 id=&quot;1-优先队列&quot;&gt;&lt;a href=&quot;#1-优先队列&quot; class=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 355设计推特</title>
    <link href="https://leiqichn.github.io/2024-05-10-b1491b9671d6.html"/>
    <id>https://leiqichn.github.io/2024-05-10-b1491b9671d6.html</id>
    <published>2024-05-10T15:26:56.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/design-twitter/description/">355. 设计推特</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Twitter <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>userId    <span class="hljs-type">int</span><br>followees <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br>tweets    []*Tweet<br>&#125;<br><br><span class="hljs-keyword">type</span> Tweet <span class="hljs-keyword">struct</span> &#123;<br>tweetId <span class="hljs-type">int</span><br>time    <span class="hljs-type">int</span><br>userId  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 推特时间排序</span><br><span class="hljs-keyword">var</span> tweetCount <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Twitter &#123;<br><span class="hljs-keyword">return</span> Twitter&#123;userMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> PostTweet(userId <span class="hljs-type">int</span>, tweetId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 新建tweet  将自己设置为关注</span><br><br><span class="hljs-comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span><br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;<br>t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="hljs-built_in">make</span>([]*Tweet, <span class="hljs-number">0</span>), followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)&#125;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br>t.userMap[userId].followees[userId] = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br><br>&#125;<br><br><span class="hljs-comment">// 将tweetId 时间做一个新增</span><br>tweetCount++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Follow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 如果关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;<br>        t.userMap[followerId] = &amp;User&#123;<br>            userId:        followerId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followerId].followees[followerId] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果被关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;<br>        t.userMap[followeeId] = &amp;User&#123;<br>            userId:        followeeId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followeeId].followees[followeeId] = <span class="hljs-literal">true</span><br>    &#125;<br>    t.userMap[followerId].followees[followeeId] = <span class="hljs-literal">true</span><br><br>&#125;<br><br><span class="hljs-comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Unfollow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;<br><span class="hljs-built_in">delete</span>(t.userMap[followerId].followees, followeeId)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>resTop10 := []<span class="hljs-type">int</span>&#123;&#125;<br>tweeters := []*Tweet&#123;&#125;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; ok &#123;<br><br><span class="hljs-keyword">for</span> followeeId, _ := <span class="hljs-keyword">range</span> t.userMap[userId].followees &#123;<br>tweeters = <span class="hljs-built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)<br>&#125;<br><br>&#125;<br>sort.Slice(tweeters, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="hljs-number">10</span> ; i++ &#123;<br>resTop10 = <span class="hljs-built_in">append</span>(resTop10, tweeters[i].tweetId)<br>&#125;<br><br><span class="hljs-keyword">return</span> resTop10<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/design-twitter/description/&quot;&gt;355. 设计推特&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题思考</title>
    <link href="https://leiqichn.github.io/2024-05-08-9a58f8b87168.html"/>
    <id>https://leiqichn.github.io/2024-05-08-9a58f8b87168.html</id>
    <published>2024-05-08T17:20:58.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>设计数据结构和算法时，通常需要遵循以下步骤来解决问题：</p><ol><li><p><strong>理解问题</strong>：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。</p></li><li><p><strong>确定需求</strong>：明确需要哪些<strong>数据结构</strong>来存储信息，以及如何使用这些数据结构来满足题目的需求。</p></li><li><p><strong>设计数据结构</strong>：</p><ul><li>确定实体类型：例如，用户（User）、推文（Tweet）等。</li><li>确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。</li></ul></li><li><p><strong>定义方法</strong>：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。</p></li><li><p><strong>实现逻辑</strong>：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。</p></li><li><p><strong>考虑边界条件和错误处理</strong>：确保你的代码可以处理各种边界情况和潜在的错误。</p></li><li><p><strong>优化</strong>：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。</p></li></ol><p>对于LeetCode题目 <strong>设计推特</strong>，思考过程如下：</p><ol><li><p><strong>理解题目</strong>：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。</p></li><li><p><strong>确定需求</strong>：</p><ul><li>需要存储用户信息，包括用户ID、关注列表和推文列表。</li><li>需要存储推文信息，包括推文ID和时间戳。</li></ul></li><li><p><strong>设计数据结构</strong>：</p><ul><li><code>Twitter</code>：包含用户映射，用于快速访问用户信息。</li><li><code>User</code>：包含用户ID、关注列表和推文列表。</li><li><code>Tweet</code>：包含推文ID和时间戳。</li></ul></li><li><p><strong>定义方法</strong>：</p><ul><li><code>Constructor</code>：初始化<code>Twitter</code>实例。</li><li><code>PostTweet</code>：实现用户发布推文的逻辑。</li><li><code>Follow</code>：实现用户关注其他用户的逻辑。</li><li><code>Unfollow</code>：实现用户取消关注的逻辑。</li><li><code>GetNewsFeed</code>：实现获取用户信息流的逻辑。</li></ul></li><li><p><strong>实现逻辑</strong>：</p><ul><li>对于<code>PostTweet</code>，检查用户是否存在，如果不存在则创建用户，然后添加推文。</li><li>对于<code>Follow</code>和<code>Unfollow</code>，更新用户的<code>followees</code>映射。</li><li>对于<code>GetNewsFeed</code>，收集并排序推文，然后返回结果。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>确保在添加推文或关注用户时，处理用户不存在的情况。</li><li>在获取信息流时，处理用户没有推文或关注任何人的情况。</li></ul></li><li><p><strong>优化</strong>：</p><ul><li>考虑是否可以使用更高效的数据结构或算法来提高性能。</li></ul></li></ol><p>在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计数据结构和算法时，通常需要遵循以下步骤来解决问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;理解问题&lt;/strong&gt;：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;确定需求&lt;/strong&gt;：明确</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用递归</title>
    <link href="https://leiqichn.github.io/2024-05-08-23291165e2d9.html"/>
    <id>https://leiqichn.github.io/2024-05-08-23291165e2d9.html</id>
    <published>2024-05-08T15:15:21.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traversal(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义：返回nums root 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traversal</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,left <span class="hljs-type">int</span> , right <span class="hljs-type">int</span>)</span></span> *TreeNode&#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right)/<span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;nums[mid],<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.Left =  traversal(nums,left,mid<span class="hljs-number">-1</span>) <span class="hljs-comment">// 把后边 root 节点添加到当前root left 左节点上</span><br>    root.Right = traversal(nums,mid+<span class="hljs-number">1</span>,right) <span class="hljs-comment">// 把后边 root 节点添加到当前root right 左节点上</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤：</p><ol><li><p><strong>识别重复模式</strong>：</p><ul><li>确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。</li></ul></li><li><p><strong>定义递归函数</strong>：</p><ul><li>根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。</li></ul></li><li><p><strong>确定基本情况</strong>：</p><ul><li>找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。</li></ul></li><li><p><strong>分解问题</strong>：</p><ul><li>将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。</li></ul></li><li><p><strong>递归工作</strong>：</p><ul><li>描述递归如何工作，包括如何从子问题的解中构建出原问题的解。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>确定如何将子问题的解合并为原问题的解。</li></ul></li><li><p><strong>编写伪代码</strong>：</p><ul><li>在编写实际代码之前，先用伪代码描述递归逻辑。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。</li></ul></li><li><p><strong>优化性能</strong>：</p><ul><li>如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。</li></ul></li><li><p><strong>测试和调试</strong>：</p><ul><li>编写测试用例来验证递归逻辑，并调试任何出现的问题。</li></ul></li></ol><p>以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成：</p><ul><li><p><strong>重复模式</strong>：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。</p></li><li><p><strong>定义递归函数</strong>：<code>traversal</code> 函数接收一个数组和两个索引，表示当前考虑的子数组。</p></li><li><p><strong>确定基本情况</strong>：如果左索引大于右索引，说明子数组为空，返回 <code>nil</code>。</p></li><li><p><strong>分解问题</strong>：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 <code>traversal</code> 函数。</p></li><li><p><strong>递归工作</strong>：递归地构建左子树和右子树，然后将它们连接到当前根节点。</p></li><li><p><strong>合并结果</strong>：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。</p></li><li><p><strong>编写伪代码</strong>：在脑中或纸上概述递归调用的流程。</p></li><li><p><strong>考虑边界条件</strong>：确保数组索引不会超出数组边界。</p></li><li><p><strong>优化性能</strong>：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。</p></li><li><p><strong>测试和调试</strong>：通过在不同的数组输入上测试函数来确保其正确性。</p></li></ul><p>通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中debug 无法显示全局变量解决</title>
    <link href="https://leiqichn.github.io/2024-05-07-c105be0dd846.html"/>
    <id>https://leiqichn.github.io/2024-05-07-c105be0dd846.html</id>
    <published>2024-05-07T16:22:44.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240508002347.png">实际只会有局部变量，没有全局变量test</p><p><img src="/../../imgs/Pasted%20image%2020240508002425.png"></p><p>解决方法：</p><p>右键  选择+ New Watch ； 或者 按按键 Insert </p><p>添加变量 test 即可</p><p><img src="/../../imgs/Pasted%20image%2020240508002502.png"><img src="/../../imgs/Pasted%20image%2020240508002708.png"></p><h1 id="添加成功"><a href="#添加成功" class="headerlink" title="添加成功"></a>添加成功</h1><p><img src="/../../imgs/Pasted%20image%2020240508002737.png"><br>之后每次单步执行都会显示变量结果：<br><img src="/../../imgs/Pasted%20image%2020240508002814.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240508002347.png&quot;&gt;实际只会有局部变量，没有全局变量test&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240508002</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 中格式化打印单个字符</title>
    <link href="https://leiqichn.github.io/2024-05-03-ec16a5fd018e.html"/>
    <id>https://leiqichn.github.io/2024-05-03-ec16a5fd018e.html</id>
    <published>2024-05-03T08:58:56.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，<code>fmt.Printf</code> 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。</p><p><code>%c</code> 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 <code>fmt.Printf</code> 中使用 <code>%c</code>，并且传入一个整数（<code>int</code> 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> codePoint <span class="hljs-type">int</span> = <span class="hljs-number">65</span> <span class="hljs-comment">// ASCII码中A的码点</span><br>    fmt.Printf(<span class="hljs-string">&quot;%c\n&quot;</span>, codePoint) <span class="hljs-comment">// 输出: A</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>codePoint</code> 的值为 <code>65</code>，它是大写字母 “A” 在ASCII编码中的码点。<code>fmt.Printf(&quot;%c\n&quot;, codePoint)</code> 将这个整数值格式化为字符 “A” 并输出。</p><p>在处理字节数组 <code>[]byte</code> 并想要将每个字节转换为对应的字符时，<code>%c</code> 非常有用，因为Go的 <code>string</code> 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;hello&quot;</span><br>    bytes := []<span class="hljs-type">byte</span>(s)<br><br>    <span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bytes &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Byte %d: %c\n&quot;</span>, i, b)<br>    &#125;<br>    <span class="hljs-comment">// 输出:</span><br>    <span class="hljs-comment">// Byte 0: h</span><br>    <span class="hljs-comment">// Byte 1: e</span><br>    <span class="hljs-comment">// Byte 2: l</span><br>    <span class="hljs-comment">// Byte 3: l</span><br>    <span class="hljs-comment">// Byte 4: o</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们遍历字符串 <code>&quot;hello&quot;</code> 的字节表示，并使用 <code>%c</code> 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，&lt;code&gt;fmt.Printf&lt;/code&gt; 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。&lt;/p&gt;
&lt;p&gt;&lt;cod</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang slice无法添加指针</title>
    <link href="https://leiqichn.github.io/2024-05-02-247b79126fb5.html"/>
    <id>https://leiqichn.github.io/2024-05-02-247b79126fb5.html</id>
    <published>2024-05-02T13:37:36.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向<code>int</code>的指针，比如<code>timePtr *int</code>，你可以通过<code>*timePtr</code>来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。</p><p>在你提供的<code>add</code>函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(timePtr *<span class="hljs-type">int</span>)</span></span> &#123; *timePtr += <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// 增加一秒</span><br></code></pre></td></tr></table></figure><p><code>timePtr</code>是一个指向<code>int</code>的指针。虽然你可以通过<code>*timePtr</code>来间接修改它所指向的<code>int</code>值，但是你不能使用这个指针来创建一个关于<code>*int</code>的切片。原因如下：</p><ol><li><p><strong>指针的值是地址</strong>：<code>timePtr</code>变量存储的是<code>currentTime</code>变量的内存地址，而不是<code>currentTime</code>的值。切片是基于数组的，它们需要一个具体的数据集合来创建。</p></li><li><p><strong>切片的元素类型</strong>：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于<code>*int</code>的切片，<strong>因为切片的元素类型是</strong><code>int</code>，而不是<code>*int</code>（指向<code>int</code>的指针）。</p></li><li><p><strong>切片创建语法</strong>：创建切片通常需要一个数组或另一个切片作为基础，或者使用<code>make</code>函数指定长度和容量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>slice1 := arr[:] <span class="hljs-comment">// 基于数组的切片</span><br>slice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 使用make创建切片</span><br></code></pre></td></tr></table></figure></li></ol><p>如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在<code>main</code>函数中声明这样一个切片，并在CRUD操作中更新它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> currentTime <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> history []<span class="hljs-type">int</span> <span class="hljs-comment">// 用于记录历史时间</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(timePtr *<span class="hljs-type">int</span>, historyPtr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    *timePtr++<br>    historyPtr = <span class="hljs-built_in">append</span>(*historyPtr, *timePtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    currentTime = <span class="hljs-number">0</span><br>    history = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始化历史切片</span><br><br>    add(&amp;currentTime, &amp;history)<br>    <span class="hljs-comment">// 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点</span><br><br>    fmt.Println(<span class="hljs-string">&quot;History of times:&quot;</span>, history)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>history</code>是一个切片，用于存储时间点的历史记录。每次调用<code>add</code>函数时，我们不仅更新<code>currentTime</code>，还将新的时间点添加到<code>history</code>切片中。注意，由于切片是引用类型，我们传递<code>&amp;history</code>来允许函数修改原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向&lt;code&gt;int&lt;/code&gt;的指针，比如&lt;code&gt;timePtr *int&lt;/code&gt;，你可以通过&lt;code&gt;*timePtr&lt;/code&gt;来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络概览</title>
    <link href="https://leiqichn.github.io/2024-05-02-82705503428a.html"/>
    <id>https://leiqichn.github.io/2024-05-02-82705503428a.html</id>
    <published>2024-05-02T07:27:45.000Z</published>
    <updated>2024-07-06T13:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240502152821.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153252.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153337.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153543.png"></p><p>【计算机网络】常识</p><p>知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；<br>两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线<br>【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；<br>数据链路层；<br>【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；<br>【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；<br>【物理地址MAC】<br>交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）<br>【点对点连接】【全双工通讯】提高了带宽利用率；<br>【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；<br>【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；<br>【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长<br>【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；<br>【IP地址】用于标识不同的网络和网络设备；<br>【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）<br>【默认网关IP】不同网段连接到路由器的IP；<br>【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；<br>设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；<br>【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器<br>【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；<br>【海底光缆】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240502152821.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240502153252.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>ssh 隧道 端口转发</title>
    <link href="https://leiqichn.github.io/2024-04-21-29ab33001840.html"/>
    <id>https://leiqichn.github.io/2024-04-21-29ab33001840.html</id>
    <published>2024-04-21T14:30:08.000Z</published>
    <updated>2024-07-06T13:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<p>使用SSH端口转发<br>   如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用<code>-L</code>参数实现，如下所示：<br>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh -L 本地端口:localhost:13579 用户名@物理机IP<br></code></pre></td></tr></table></figure><br>   其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。</p><p>例如：<br>我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh -L <span class="hljs-number">13579</span>:localhost:<span class="hljs-number">13579</span> <span class="hljs-symbol">root@</span><span class="hljs-number">110.43</span><span class="hljs-number">.203</span><span class="hljs-number">.19</span> -p <span class="hljs-number">30005</span> <br><span class="hljs-comment">// </span><br>ssh -p <span class="hljs-number">13579</span> <span class="hljs-symbol">root@</span>localhost<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用SSH端口转发&lt;br&gt;   如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用&lt;code&gt;-L&lt;/code&gt;参数实现，如下所示：&lt;br&gt;   &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 208. 实现 Trie (前缀树)</title>
    <link href="https://leiqichn.github.io/2024-04-16-1150f59f3df6.html"/>
    <id>https://leiqichn.github.io/2024-04-16-1150f59f3df6.html</id>
    <published>2024-04-16T16:34:47.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。</p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240417003637.png"></p><p>Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。</p><p>为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    Value <span class="hljs-type">int</span><br><br>    Next  *TrieNode<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    children [<span class="hljs-number">26</span>]*TrieNode<br><br>    isEnd    <span class="hljs-type">bool</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br>  <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <br><br><span class="hljs-comment">// TrieNode 代表Trie中的每个节点</span><br><br><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    children [<span class="hljs-number">26</span>]*TrieNode<br><br>    isEnd    <span class="hljs-type">bool</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Trie 代表整个前缀树</span><br><br><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br><br>    root *TrieNode<br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Constructor 初始化一个Trie对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br><br>    <span class="hljs-keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;<br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Insert 将word插入到trie中</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>) &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            node.children[index] = &amp;TrieNode&#123;&#125;<br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    node.isEnd = <span class="hljs-literal">true</span> <span class="hljs-comment">// 标记单词结束的节点</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Search 在trie中搜索word</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明word不在trie中</span><br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node.isEnd <span class="hljs-comment">// 检查最后一个节点是否标记为单词结尾</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// StartsWith 返回trie中是否有任何单词以prefix为前缀</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明没有以prefix为前缀的word</span><br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 所有的char都在路径中，说明trie有以prefix为前缀的word</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-trie-prefix-tree/&quot;&gt;208. 实现 Trie (前</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang slice作为参数传递给函数需要使用指针</title>
    <link href="https://leiqichn.github.io/2024-04-11-22166b2f52d0.html"/>
    <id>https://leiqichn.github.io/2024-04-11-22166b2f52d0.html</id>
    <published>2024-04-11T16:35:04.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">1</span>,n,k,&amp;res,&amp;[]<span class="hljs-type">int</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s, n, k <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>, item *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*item) == k &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, *item...))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := s; i &lt;= n-(k-<span class="hljs-built_in">len</span>(*item))+<span class="hljs-number">1</span>; i++&#123;<br>        *item = <span class="hljs-built_in">append</span>(*item, i)<br>        dfs(i+<span class="hljs-number">1</span>, n, k, res, item)<br>        *item = (*item)[:<span class="hljs-built_in">len</span>(*item)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 append 函数或者直接索引赋值的方式，那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。</p><p>这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。</p><p>例如，在 <code>combine</code> 函数中，如果想要 <code>dfs</code> 函数能够修改 <code>res</code> slice 的长度（即添加新的组合到 <code>res</code> 中），那么需要传递 <code>res</code> 的指针的指针。这样，当 <code>dfs</code> 函数执行 <code>*res = append(*res, newCombination...)</code> 时，它会修改原始的 <code>res</code> slice 而不是它的副本。</p><p>传递指针的原因是为了：</p><ol><li><p><strong>避免不必要的副本创建</strong>：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。</p></li><li><p><strong>确保函数内部的修改能够反映到原始数据上</strong>：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。</p></li><li><p><strong>提高代码的效率和性能</strong>：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。</p></li></ol><p>还可以转化为全局变量；需要注意的是<br>go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span> <span class="hljs-comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 需要进行初始化</span><br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i&lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>)<br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; <strong>tempPath :&#x3D; []int{}</strong>,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。<br>copy(tempPath, path)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span> <span class="hljs-comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, startIndex <span class="hljs-type">int</span>)</span></span><br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, startIndex <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            tempPath := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k) <span class="hljs-comment">// tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。</span><br>            <span class="hljs-built_in">copy</span>(tempPath, path)<br>            res = <span class="hljs-built_in">append</span>(res, tempPath)<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> i:= startIndex; i &lt;= n; i++ &#123;<br>            <span class="hljs-keyword">if</span> (n -i +<span class="hljs-number">1</span> ) &lt; (k -<span class="hljs-built_in">len</span>(path)) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            path = <span class="hljs-built_in">append</span>(path, i)<br>            backtracking(n, k, i+<span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题 总结</title>
    <link href="https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html"/>
    <id>https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html</id>
    <published>2024-04-05T17:21:04.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>举个简单的例子：<br><strong>设计题 - 实现浏览器历史记录</strong><br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p><ul><li>和当前页相同，则直接返回</li><li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description: 浏览器实现</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.GetCurrentPage() == newPageURL &#123;<br><span class="hljs-keyword">return</span> newPageURL<br>&#125;<br><br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p><h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p><p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p><h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p><p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p><h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p><p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p><h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p><h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p><p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面，我们来按照难度多练习几道题目</p><h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ol><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></li></ol><p><img src="/../../imgs/Pasted%20image%2020240405184827.png"></p><p> <strong>思路：</strong>input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>inputStack  []<span class="hljs-type">int</span><br>outputStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br><span class="hljs-keyword">return</span> MyQueue&#123;<br>inputStack:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputStack: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputStack = <span class="hljs-built_in">append</span>(this.inputStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.inputStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(this.outputStack) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Peek();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a><img src="/../../imgs/Pasted%20image%2020240405184932.png"></li></ol><p><strong>思路：</strong>用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>inputQueue  []<span class="hljs-type">int</span><br>outputQueue []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br><span class="hljs-keyword">return</span> MyStack&#123;<br>inputQueue:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputQueue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.inputQueue, x)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = this.outputQueue<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue...)<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(this.inputQueue) == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">len</span>(this.outputQueue) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406201421.png"><br>思路：简单题，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    nums  []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    <span class="hljs-keyword">return</span> NumArray&#123;nums: nums&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i:= left; i&lt;= right; i++ &#123;<br>        sum += this.nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用前缀和<br><img src="/../../imgs/Pasted%20image%2020240406201959.png"><br>怎么求 preSum 数组<br>利用前面提到的递推式:<br><img src="/../../imgs/Pasted%20image%2020240406201929.png"></p><p>遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，<strong>即preSum[0]为nums[0]（前提是nums有元素）</strong>。</p><p>预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。</p><p>需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。</p><p>后面会给出简化的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(nums);i++ &#123;<br>        preSum[ i] = preSum[ i<span class="hljs-number">-1</span>] + nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.preSum) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 但如果nums根本没有长度，直接返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> this.preSum[right]<br>&#125;<br>    <span class="hljs-keyword">return</span> this.preSum[right] - this.preSum[left<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用多一位长度的前缀和<br>之所以上面处理东西多，是因为<code>preSum[i]</code>的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index</p><p>要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]<br>即：</p><p><img src="/../../imgs/Pasted%20image%2020240406202142.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> nums &#123;<br>        preSum[index + <span class="hljs-number">1</span>] = preSum[index] + value<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.preSum[right + <span class="hljs-number">1</span>] - this.preSum[left]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406204841.png"><br><strong>暴力解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 排序后的nums</span><br>index      <span class="hljs-type">int</span><br>sortedNums []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br><span class="hljs-keyword">return</span> KthLargest&#123;k, nums&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>this.sortedNums = <span class="hljs-built_in">append</span>(this.sortedNums, val)<br>sort.Ints(this.sortedNums)<br>revert(this.sortedNums)<br><span class="hljs-keyword">return</span> this.sortedNums[this.index<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">revert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(k, nums);</span><br><span class="hljs-comment"> * param_1 := obj.Add(val);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><strong>优先队列</strong><br>我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。</p><p>在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br>    sort.IntSlice<br>    k <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br>    kl := KthLargest&#123;k: k&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>        kl.Add(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    kl.IntSlice = <span class="hljs-built_in">append</span>(kl.IntSlice, v.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    a := kl.IntSlice<br>    v := a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    kl.IntSlice = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    heap.Push(kl, val)<br>    <span class="hljs-keyword">if</span> kl.Len() &gt; kl.k &#123;<br>        heap.Pop(kl)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl.IntSlice[<span class="hljs-number">0</span>]<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146 LRU缓存"></a>146 LRU缓存</h1><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p><p><img src="/../../imgs/Pasted%20image%2020240512220224.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>capacity <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>keysList []<span class="hljs-type">int</span> <span class="hljs-comment">// 实现最新时间 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间</span><br>keysMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 存放key value</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br><span class="hljs-comment">//return</span><br><span class="hljs-keyword">return</span> LRUCache&#123;capacity, <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果key存在于缓存中，则返回关键字的值，否则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> ele, ok := this.keysMap[key]; ok &#123;<br>this.updateListKey(key)<br><span class="hljs-keyword">return</span> ele<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 关键字存在 则更新值为value</span><br><span class="hljs-comment">// 不存在，则插入value</span><br><span class="hljs-comment">// 如果插入超过数量capacity 则删除最久没有使用的关键字【list]</span><br><span class="hljs-keyword">if</span> _, ok := this.keysMap[key]; ok &#123;<br>this.updateListKey(key)<br>this.keysMap[key] = value<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>this.updateListKey(key)<br>this.keysMap[key] = value<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.keysList) &gt; this.capacity &#123;<br><span class="hljs-built_in">delete</span>(this.keysMap, this.keysList[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 这里删除key 从list队列中获取</span><br>this.keysList = this.keysList[<span class="hljs-number">1</span>:]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> updateListKey(key <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(this.keysList); i++ &#123;<br><span class="hljs-keyword">if</span> key == this.keysList[i] &#123;<br>this.keysList = <span class="hljs-built_in">append</span>(this.keysList[:i], this.keysList[i+<span class="hljs-number">1</span>:]...) <span class="hljs-comment">// 删除该key, 然后放在末尾</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>this.keysList = <span class="hljs-built_in">append</span>(this.keysList, key)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355 设计推特"></a>355 设计推特</h1><p><a href="https://leetcode.cn/problems/design-twitter/">355. 设计推特</a><br><img src="/../../imgs/Pasted%20image%2020240512221227.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Twitter <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>userId    <span class="hljs-type">int</span><br>followees <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br>tweets    []*Tweet<br>&#125;<br><br><span class="hljs-keyword">type</span> Tweet <span class="hljs-keyword">struct</span> &#123;<br>tweetId <span class="hljs-type">int</span><br>time    <span class="hljs-type">int</span><br>userId  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 推特数目，用于时间排序</span><br><span class="hljs-keyword">var</span> tweetCount <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Twitter &#123;<br><span class="hljs-keyword">return</span> Twitter&#123;userMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> PostTweet(userId <span class="hljs-type">int</span>, tweetId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 新建tweet  将自己设置为关注</span><br><br><span class="hljs-comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span><br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;<br>t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="hljs-built_in">make</span>([]*Tweet, <span class="hljs-number">0</span>), followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)&#125;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br>t.userMap[userId].followees[userId] = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br><br>&#125;<br><br><span class="hljs-comment">// 将tweetId 和时间做一个新增</span><br>tweetCount++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Follow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 如果关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;<br>        t.userMap[followerId] = &amp;User&#123;<br>            userId:        followerId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followerId].followees[followerId] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果被关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;<br>        t.userMap[followeeId] = &amp;User&#123;<br>            userId:        followeeId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followeeId].followees[followeeId] = <span class="hljs-literal">true</span><br>    &#125;<br>    t.userMap[followerId].followees[followeeId] = <span class="hljs-literal">true</span><br><br>&#125;<br><br><span class="hljs-comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Unfollow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;<br><span class="hljs-built_in">delete</span>(t.userMap[followerId].followees, followeeId)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>resTop10 := []<span class="hljs-type">int</span>&#123;&#125;<br>tweeters := []*Tweet&#123;&#125;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; ok &#123;<br><br><span class="hljs-keyword">for</span> followeeId, _ := <span class="hljs-keyword">range</span> t.userMap[userId].followees &#123;<br>tweeters = <span class="hljs-built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)<br>&#125;<br><br>&#125;<br>sort.Slice(tweeters, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="hljs-number">10</span> ; i++ &#123;<br>resTop10 = <span class="hljs-built_in">append</span>(resTop10, tweeters[i].tweetId)<br>&#125;<br><span class="hljs-keyword">return</span> resTop10<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221416.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// TrieNode 代表Trie中的每个节点</span><br><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br>    children [<span class="hljs-number">26</span>]*TrieNode<br>    isEnd    <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// Trie 代表整个前缀树</span><br><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    root *TrieNode<br>&#125;<br><br><span class="hljs-comment">// Constructor 初始化一个Trie对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;<br>&#125;<br><br><span class="hljs-comment">// Insert 将word插入到trie中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>) &#123;<br>    node := this.root<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br>            node.children[index] = &amp;TrieNode&#123;&#125;<br>        &#125;<br>        node = node.children[index]<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span> <span class="hljs-comment">// 标记单词结束的节点</span><br>&#125;<br><br><span class="hljs-comment">// Search 在trie中搜索word</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.root<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明word不在trie中</span><br>        &#125;<br>        node = node.children[index]<br>    &#125;<br>    <span class="hljs-keyword">return</span> node.isEnd <span class="hljs-comment">// 检查最后一个节点是否标记为单词结尾</span><br>&#125;<br><br><span class="hljs-comment">// StartsWith 返回trie中是否有任何单词以prefix为前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.root<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明没有以prefix为前缀的word</span><br>        &#125;<br>        node = node.children[index]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 所有的char都在路径中，说明trie有以prefix为前缀的word</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221549.png"></p><p>一次AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strings&quot;</span><br><br><span class="hljs-keyword">type</span> WordDictionary <span class="hljs-keyword">struct</span> &#123;<br>wordMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> WordDictionary &#123;<br><span class="hljs-keyword">return</span> WordDictionary&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *WordDictionary)</span></span> AddWord(word <span class="hljs-type">string</span>) &#123;<br>this.wordMap[word] = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *WordDictionary)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> _, ok := this.wordMap[word]; ok &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> strings.Contains(word, <span class="hljs-string">&quot;.&quot;</span>) &#123;<br><span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> this.wordMap &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(key) == <span class="hljs-built_in">len</span>(word) &#123;<br>flag := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(word); i++ &#123;<br><span class="hljs-keyword">if</span> key[i] == word[i] || word[i] == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>flag = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> flag == <span class="hljs-literal">true</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddWord(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="284-窥视迭代器"><a href="#284-窥视迭代器" class="headerlink" title="284. 窥视迭代器"></a><a href="https://leetcode.cn/problems/peeking-iterator/">284. 窥视迭代器</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512221905.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*   Below is the interface for Iterator, which is already defined for you.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   type Iterator struct &#123;</span><br><span class="hljs-comment"> *       </span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   func (this *Iterator) hasNext() bool &#123;</span><br><span class="hljs-comment"> *// Returns true if the iteration has more elements.</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   func (this *Iterator) next() int &#123;</span><br><span class="hljs-comment"> *// Returns the next element in the iteration.</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">type</span> PeekingIterator <span class="hljs-keyword">struct</span> &#123;<br>    iter     *Iterator<br>    _hasNext <span class="hljs-type">bool</span><br>    _next    <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(iter *Iterator)</span></span> *PeekingIterator &#123;<br>    <span class="hljs-keyword">return</span> &amp;PeekingIterator&#123;iter, iter.hasNext(), iter.next()&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(it *PeekingIterator)</span></span> hasNext() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> it._hasNext<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(it *PeekingIterator)</span></span> next() <span class="hljs-type">int</span> &#123;<br>    ret := it._next<br>    it._hasNext = it.iter.hasNext()<br>    <span class="hljs-keyword">if</span> it._hasNext &#123;<br>        it._next = it.iter.next()<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(it *PeekingIterator)</span></span> peek() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> it._next<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="535-TinyURL-的加密与解密"><a href="#535-TinyURL-的加密与解密" class="headerlink" title="535. TinyURL 的加密与解密"></a><a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222106.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过自增id 的方式来实现encode</span><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;<br>dataId <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br>nums   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Codec &#123;<br><span class="hljs-keyword">return</span> Codec&#123;<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;, <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Encodes a URL to a shortened URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> encode(longUrl <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>this.nums++<br>this.dataId[this.nums] = longUrl<br>res := <span class="hljs-string">&quot;http://tinyurl.com/&quot;</span> + strconv.Itoa(this.nums)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// Decodes a shortened URL to its original URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span></span> decode(shortUrl <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>index := strings.Split(shortUrl, <span class="hljs-string">&quot;/&quot;</span>)<br>tmp := index[<span class="hljs-built_in">len</span>(index)<span class="hljs-number">-1</span>]<br>idx, _ := strconv.Atoi(tmp)<br>long := this.dataId[idx]<br><span class="hljs-keyword">return</span> long<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * url := obj.encode(longUrl);</span><br><span class="hljs-comment"> * ans := obj.decode(url);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222241.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 如何确定结构体里应设置什么变量？</span><br><span class="hljs-comment">// 总的List 包含 有多少个节点，以及头节点是什么</span><br>Size      <span class="hljs-type">int</span><br>dummyHead *ListNode <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br><span class="hljs-comment">// Constructor 该如何写？如何才能符合题目要求？</span><br><span class="hljs-keyword">return</span> MyLinkedList&#123;<span class="hljs-number">0</span>, &amp;ListNode&#123;<span class="hljs-number">0</span>,<span class="hljs-literal">nil</span>&#125;&#125; <span class="hljs-comment">// 这个虚拟头节点不应该删掉吗？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= this.Size &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">//dummyHead := &amp;ListNode&#123;0, this.head&#125;</span><br>cur := this.dummyHead.Next<br><span class="hljs-keyword">for</span> index != <span class="hljs-number">0</span> &amp;&amp; cur != <span class="hljs-literal">nil</span> &#123;<br>cur = cur.Next<br>index--<br>&#125;<br><span class="hljs-keyword">return</span> cur.Val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br>this.AddAtIndex(<span class="hljs-number">0</span>, val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br>this.AddAtIndex(this.Size, val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= this.Size &#123;<br>cur := this.dummyHead <span class="hljs-comment">//cur 等于虚拟头节点，插入节点的前驱</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;<br>cur = cur.Next<br>&#125;<br>newNode := &amp;ListNode&#123;val, cur.Next&#125;<br>cur.Next = newNode<br>this.Size++<br>&#125;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123;<br>this.AddAtIndex(<span class="hljs-number">0</span>, val)<br>this.Size++<br>&#125;<br><span class="hljs-keyword">if</span> index &gt; this.Size &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 这个return 到哪里了？ 代表结束这个程序吗？</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br><br><span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; this.Size &#123;<br>cur := this.dummyHead <span class="hljs-comment">//cur 等于虚拟头节点，插入节点的前驱</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;<br>cur = cur.Next<br>&#125;<br>cur.Next = cur.Next.Next<br>this.Size--<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Get(index);</span><br><span class="hljs-comment"> * obj.AddAtHead(val);</span><br><span class="hljs-comment"> * obj.AddAtTail(val);</span><br><span class="hljs-comment"> * obj.AddAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.DeleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240512222402.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> StockSpanner <span class="hljs-keyword">struct</span> &#123;<br>    stack [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br>    idx   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> StockSpanner &#123;<br>    <span class="hljs-keyword">return</span> StockSpanner&#123;[][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, math.MaxInt32&#125;&#125;, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StockSpanner)</span></span> Next(price <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    s.idx++<br>    <span class="hljs-keyword">for</span> price &gt;= s.stack[<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &#123;<br>        s.stack = s.stack[:<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-1</span>]<br>    &#125;<br>    s.stack = <span class="hljs-built_in">append</span>(s.stack, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;s.idx, price&#125;)<br>    <span class="hljs-keyword">return</span> s.idx - s.stack[<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-2</span>][<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Next(price);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222459.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> StockSpanner <span class="hljs-keyword">struct</span> &#123;<br>    stack [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br>    idx   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> StockSpanner &#123;<br>    <span class="hljs-keyword">return</span> StockSpanner&#123;[][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, math.MaxInt32&#125;&#125;, <span class="hljs-number">-1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StockSpanner)</span></span> Next(price <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    s.idx++<br>    <span class="hljs-keyword">for</span> price &gt;= s.stack[<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &#123;<br>        s.stack = s.stack[:<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-1</span>]<br>    &#125;<br>    s.stack = <span class="hljs-built_in">append</span>(s.stack, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;s.idx, price&#125;)<br>    <span class="hljs-keyword">return</span> s.idx - s.stack[<span class="hljs-built_in">len</span>(s.stack)<span class="hljs-number">-2</span>][<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Next(price);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/design-underground-system/">1396. 设计地铁系统</a><br><img src="/../../imgs/Pasted%20image%2020240512222605.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;<br>id <span class="hljs-type">int</span><br>startTime <span class="hljs-type">int</span><br>endTime <span class="hljs-type">int</span><br>startStationName <span class="hljs-type">string</span><br>endStatationName <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UndergroundSystem <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user<br>pathMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span> <span class="hljs-comment">// 存放对应路程的用时，用于计算平均时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> UndergroundSystem &#123;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">return</span> UndergroundSystem&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckIn(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//userMap 添加</span><br>this.userMap[id] = &amp;user&#123;id:id&#125; <span class="hljs-comment">// 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址</span><br>this.userMap[id].startTime = t<br>this.userMap[id].startStationName = stationName<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckOut(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//出站时，更新user.end* ;append pathmap</span><br>useTime := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> _,ok := this.userMap[id] ;ok &#123;<br>this.userMap[id].endTime = t<br>this.userMap[id].endStatationName = stationName<br>&#125;<br><br>mapKey := this.userMap[id].startStationName +<span class="hljs-string">&quot;-&gt;&quot;</span> + this.userMap[id].endStatationName<br>useTime = this.userMap[id].endTime - this.userMap[id].startTime<br>this.pathMap[mapKey] = <span class="hljs-built_in">append</span>(this.pathMap[mapKey],useTime)<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> GetAverageTime(startStation <span class="hljs-type">string</span>, endStation <span class="hljs-type">string</span>) <span class="hljs-type">float64</span> &#123;<br>mapKey := startStation +<span class="hljs-string">&quot;-&gt;&quot;</span> + endStation<br><span class="hljs-keyword">return</span> average(this.pathMap[mapKey])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">average</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s &#123;<br>sum +=v<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(sum)/<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(s))<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your UndergroundSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.CheckIn(id,stationName,t);</span><br><span class="hljs-comment"> * obj.CheckOut(id,stationName,t);</span><br><span class="hljs-comment"> * param_3 := obj.GetAverageTime(startStation,endStation);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="1476-子矩形查询"><a href="#1476-子矩形查询" class="headerlink" title="1476. 子矩形查询"></a><a href="https://leetcode.cn/problems/subrectangle-queries/">1476. 子矩形查询</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222653.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SubrectangleQueries <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 需要什么数据结构呢？ 1. 一个二维数组</span><br>rectangle [][]<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(rectangle [][]<span class="hljs-type">int</span>)</span></span> SubrectangleQueries &#123;<br><span class="hljs-keyword">return</span> SubrectangleQueries&#123;rectangle: rectangle&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SubrectangleQueries)</span></span> UpdateSubrectangle(row1 <span class="hljs-type">int</span>, col1 <span class="hljs-type">int</span>, row2 <span class="hljs-type">int</span>, col2 <span class="hljs-type">int</span>, newValue <span class="hljs-type">int</span>)  &#123;<br><span class="hljs-keyword">for</span> i:=row1;i &lt;= row2;i++ &#123;<br><span class="hljs-keyword">for</span> j:= col1; j &lt;= col2; j++ &#123;<br>this.rectangle[i][j] = newValue<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SubrectangleQueries)</span></span> GetValue(row <span class="hljs-type">int</span>, col <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> this.rectangle[row][col]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your SubrectangleQueries object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(rectangle);</span><br><span class="hljs-comment"> * obj.UpdateSubrectangle(row1,col1,row2,col2,newValue);</span><br><span class="hljs-comment"> * param_2 := obj.GetValue(row,col);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/seat-reservation-manager/">1845. 座位预约管理系统</a><br><img src="/../../imgs/Pasted%20image%2020240512222738.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats []<span class="hljs-type">int</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>set:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> SeatManager&#123;seats:set,min:<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>value := this.min<br>this.seats[value]=<span class="hljs-number">1</span><br>length := <span class="hljs-built_in">len</span> (this.seats)<br>fmt.Println(length)<br>i:=value<br><span class="hljs-keyword">for</span> ;i&lt;length+<span class="hljs-number">1</span>;i++&#123;<br><span class="hljs-keyword">if</span> this.seats[i]==<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>this.min=i <span class="hljs-comment">// 中间变量，更新下次的最小座位号</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> value <span class="hljs-comment">// 最小的座位号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>)  &#123;<br>this.seats[seatNumber] = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> seatNumber &lt; this.min&#123;<br>this.min=seatNumber<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="1993-树上的操作"><a href="#1993-树上的操作" class="headerlink" title="1993. 树上的操作"></a><a href="https://leetcode.cn/problems/operations-on-tree/">1993. 树上的操作</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512222930.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LockingTree <span class="hljs-keyword">struct</span> &#123;<br>    parent []<span class="hljs-type">int</span><br>    lockNodeUser []<span class="hljs-type">int</span><br>    children [][]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(parent []<span class="hljs-type">int</span>)</span></span> LockingTree &#123;<br>    n := <span class="hljs-built_in">len</span>(parent)<br>    lockNodeUser := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    children := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        lockNodeUser[i] = <span class="hljs-number">-1</span><br>        p := parent[i]<br>        <span class="hljs-keyword">if</span> p != <span class="hljs-number">-1</span> &#123;<br>            children[p] = <span class="hljs-built_in">append</span>(children[p], i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> LockingTree&#123;parent, lockNodeUser, children&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LockingTree)</span></span> Lock(num <span class="hljs-type">int</span>, user <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> this.lockNodeUser[num] == <span class="hljs-number">-1</span> &#123;<br>        this.lockNodeUser[num] = user<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LockingTree)</span></span> Unlock(num <span class="hljs-type">int</span>, user <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> this.lockNodeUser[num] == user &#123;<br>        this.lockNodeUser[num] = <span class="hljs-number">-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LockingTree)</span></span> Upgrade(num <span class="hljs-type">int</span>, user <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    res := this.lockNodeUser[num] == <span class="hljs-number">-1</span> &amp;&amp; !this.hasLockedAncestor(num) &amp;&amp; this.checkAndUnlockDescendant(num)<br>    <span class="hljs-keyword">if</span> res &#123;<br>        this.lockNodeUser[num] = user<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LockingTree)</span></span> hasLockedAncestor(num <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    num = this.parent[num]<br>    <span class="hljs-keyword">for</span> num != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> this.lockNodeUser[num] != <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        num = this.parent[num]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LockingTree)</span></span> checkAndUnlockDescendant(num <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    res := <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> this.lockNodeUser[num] != <span class="hljs-number">-1</span> &#123;<br>        res = <span class="hljs-literal">true</span><br>    &#125;<br>    this.lockNodeUser[num] = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> this.children[num] &#123;<br>        <span class="hljs-keyword">if</span> this.checkAndUnlockDescendant(child) &#123;<br>            res = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;            <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2241-设计一个-ATM-机器"><a href="#2241-设计一个-ATM-机器" class="headerlink" title="2241. 设计一个 ATM 机器"></a><a href="https://leetcode.cn/problems/design-an-atm-machine/">2241. 设计一个 ATM 机器</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223036.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ATM <span class="hljs-keyword">struct</span> &#123;<br>orderList []<span class="hljs-type">int</span><br>amountMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// map 是多余的</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> ATM &#123;<br><span class="hljs-keyword">return</span> ATM&#123;<br><span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>),<br><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<span class="hljs-comment">// 初始化 使用make 多练习多学习，保持手感。</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> price [<span class="hljs-number">5</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">500</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *ATM)</span></span> Deposit(banknotesCount []<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> i , count := <span class="hljs-keyword">range</span> banknotesCount&#123;<br>this.orderList[i] += count<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *ATM)</span></span> Withdraw(amount <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">//使用整除法</span><br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">4</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>ans[i] = min(amount/price[i],this.orderList[i])<br>amount -= ans[i]*price[i]<br>&#125;<br><span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> idx,v := <span class="hljs-keyword">range</span> ans &#123;<br>this.orderList[idx] -= v<br>&#125;<br><span class="hljs-keyword">return</span> ans <span class="hljs-comment">// 注意试着返回是需要钞票的数量，不是钞票的剩余数量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2353-设计食物评分系统"><a href="#2353-设计食物评分系统" class="headerlink" title="2353. 设计食物评分系统"></a><a href="https://leetcode.cn/problems/design-a-food-rating-system/">2353. 设计食物评分系统</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223102.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FoodRatings <span class="hljs-keyword">struct</span> &#123;<br>    Map <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*FoodHeap<br>    NameMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Food<br>&#125;<br><br><br><span class="hljs-keyword">type</span> Food <span class="hljs-keyword">struct</span> &#123;<br>    Name, C <span class="hljs-type">string</span><br>    Rating, Idx <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 实现堆</span><br><span class="hljs-keyword">type</span> FoodHeap []*Food<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h FoodHeap)</span></span> String() <span class="hljs-type">string</span>  &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> h &#123;<br>        res = fmt.Sprintf(<span class="hljs-string">&quot;%s -&gt; (%v, %v)&quot;</span>, res, f.Name, f.Rating)    <br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h FoodHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h FoodHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; <br>    h[i], h[i].Idx, h[j], h[j].Idx = h[j], h[j].Idx, h[i], h[i].Idx<br>&#125;<br><br><br><span class="hljs-comment">// 大顶堆 如果分数相同，Name 字典序小的更大</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h FoodHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <br>    <span class="hljs-keyword">if</span> h[j].Rating == h[i].Rating &#123;<br>        <span class="hljs-keyword">return</span> h[i].Name &lt; h[j].Name<br>    &#125;<br>    <span class="hljs-keyword">return</span> h[j].Rating &lt; h[i].Rating<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *FoodHeap)</span></span> Push(f <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span><br><span class="hljs-comment">// not just its contents.</span><br>    food := f.(*Food)<br>    food.Idx = h.Len()<br>*h = <span class="hljs-built_in">append</span>(*h, food)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *FoodHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125;   &#123; a := *h; v := a[<span class="hljs-built_in">len</span>(a) - <span class="hljs-number">1</span>]; *h = a[:<span class="hljs-built_in">len</span>(a) - <span class="hljs-number">1</span>]; <span class="hljs-keyword">return</span> v &#125;<br><br><br><span class="hljs-comment">// 以烹饪方式对评分归类</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(foods []<span class="hljs-type">string</span>, cuisines []<span class="hljs-type">string</span>, ratings []<span class="hljs-type">int</span>)</span></span> FoodRatings &#123;<br>    f := FoodRatings&#123;<br>        Map: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*FoodHeap),<br>        NameMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Food, <span class="hljs-built_in">len</span>(foods)),<br>    &#125;<br>    <span class="hljs-keyword">var</span> (<br>        food *Food<br>        h *FoodHeap<br>        has <span class="hljs-type">bool</span><br>    )<br>    <span class="hljs-keyword">for</span> idx := <span class="hljs-keyword">range</span> foods &#123;<br>        food = &amp;Food &#123;<br>            foods[idx],<br>            cuisines[idx],<br>            ratings[idx],<br>            <span class="hljs-number">0</span>,<br>        &#125;<br>        f.NameMap[foods[idx]] = food<br>        <br>        <span class="hljs-keyword">if</span> h, has = f.Map[cuisines[idx]]; !has &#123;<br>            h = &amp;FoodHeap&#123;&#125;<br>            f.Map[cuisines[idx]] = h<br>        &#125;<br>    <br>        heap.Push(h, food)<br>    &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FoodRatings)</span></span> ChangeRating(food <span class="hljs-type">string</span>, newRating <span class="hljs-type">int</span>)  &#123;<br>    f := this.NameMap[food]<br>    h := this.Map[f.C]<br>    f.Rating = newRating<br>    <br>    heap.Fix(h, f.Idx)        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FoodRatings)</span></span> HighestRated(cuisine <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>    h := this.Map[cuisine]<br>    <span class="hljs-keyword">if</span> h.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> cuisine + <span class="hljs-string">&quot;No exist&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (*h)[<span class="hljs-number">0</span>].Name<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="LCR-184-设计自助结算系统"><a href="#LCR-184-设计自助结算系统" class="headerlink" title="LCR 184. 设计自助结算系统"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">LCR 184. 设计自助结算系统</a></h1><p><img src="/../../imgs/Pasted%20image%2020240512223239.png"></p><blockquote></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MaxQueue <span class="hljs-keyword">struct</span> &#123;<br>    q1 []<span class="hljs-type">int</span><br>    max []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MaxQueue &#123;<br>    <span class="hljs-keyword">return</span> MaxQueue&#123;<br>        <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span></span> Max_value() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.max) == <span class="hljs-number">0</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.max[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span></span> Push_back(value <span class="hljs-type">int</span>)  &#123;<br>    this.q1 = <span class="hljs-built_in">append</span>(this.q1,value)<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.max) != <span class="hljs-number">0</span> &amp;&amp; value &gt; this.max[<span class="hljs-built_in">len</span>(this.max)<span class="hljs-number">-1</span>]&#123;<br>        this.max = this.max[:<span class="hljs-built_in">len</span>(this.max)<span class="hljs-number">-1</span>]<br>    &#125;<br>    this.max = <span class="hljs-built_in">append</span>(this.max,value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span></span> Pop_front() <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.q1) != <span class="hljs-number">0</span>&#123;<br>        n = this.q1[<span class="hljs-number">0</span>]<br>        this.q1 = this.q1[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> this.max[<span class="hljs-number">0</span>] == n&#123;<br>            this.max = this.max[<span class="hljs-number">1</span>:]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * param_1 := obj.Max_value();</span><br><span class="hljs-comment"> * obj.Push_back(value);</span><br><span class="hljs-comment"> * param_3 := obj.Pop_front();</span><br><span class="hljs-comment"> */</span><br><br>作者：Sakura<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solutions/135149/golang-shuang-dui-lie-by-sakura-151/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;举个简单的例子：&lt;br&gt;&lt;strong&gt;设计题 - 实现浏览器历史记录&lt;/strong&gt;&lt;br&gt;1.初始化 homepage 和历史记录容量&lt;br&gt;2.浏览网页 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和当前页相同，则直接返回&lt;/li&gt;
&lt;li&gt;和当前页不同，如果容量满了，则删除最早的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows IE代理问题解决</title>
    <link href="https://leiqichn.github.io/2024-04-05-e1116cf34b00.html"/>
    <id>https://leiqichn.github.io/2024-04-05-e1116cf34b00.html</id>
    <published>2024-04-05T05:11:29.000Z</published>
    <updated>2024-07-06T13:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<p>CMD <strong>检查系统代理配置</strong>：</p><pre><code class="hljs">- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。- 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CMD &lt;strong&gt;检查系统代理配置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。
- 如果需要更改系统代理，可以使用`netsh win</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 双指针</title>
    <link href="https://leiqichn.github.io/2024-03-23-84678021105b.html"/>
    <id>https://leiqichn.github.io/2024-03-23-84678021105b.html</id>
    <published>2024-03-23T14:51:46.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除有序数组中的重复元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast:=<span class="hljs-number">1</span>;fast &lt;<span class="hljs-built_in">len</span>(nums);fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<span class="hljs-comment">// 跳到下个位置，保存slow</span><br><br>            nums[slow] = nums[fast]<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow +<span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p><p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>注意到以下性质：</strong></p><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>slow, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123; <span class="hljs-comment">// 注意第一个是0的时候需要比较</span><br><span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span><br>nums[slow], nums[fast] = nums[fast], nums[slow]<br>slow++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(height); j++ &#123;<br>area := (j - i) * min(height[i], height[j])<br>ans = max(area,ans)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化两边指针</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        area := (right - left) * min(height[left], height[right]) <span class="hljs-comment">// 计算面积</span><br>        ans = max(ans, area) <span class="hljs-comment">// 计算最大值</span><br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123; <br>            left++ <span class="hljs-comment">// 移动短的那个</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240326011627.png"></p><p>前缀和，后缀和<br>木桶效应，当前能装的水，取决于两边最大值 的最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    preMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// preMax[i] 表示从 height[0] 到 height[i] 的最大值</span><br>    preMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        preMax[i] = max(preMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    sufMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值</span><br>    sufMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        sufMax[i] = max(sufMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        ans += min(preMax[i], sufMax[i]) - h <span class="hljs-comment">// 累加每个水桶能接多少水</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right, preMax, sufMax := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        preMax = max(preMax, height[left])<br>        sufMax = max(sufMax, height[right])<br>        <span class="hljs-keyword">if</span> preMax &lt; sufMax &#123;<br>            ans += preMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += sufMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240323225412.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 单调栈</title>
    <link href="https://leiqichn.github.io/2024-02-24-dd95d981cb94.html"/>
    <id>https://leiqichn.github.io/2024-02-24-dd95d981cb94.html</id>
    <published>2024-02-24T15:57:54.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p><p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123; <span class="hljs-comment">// 倒着入栈是为了后边正着出栈</span><br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &lt;= nums[i] &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有更大的元素</span><br>            res[i] = <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 正着出栈</span><br>        &#125;<br>        s = <span class="hljs-built_in">append</span>(s, nums[i]) <span class="hljs-comment">// 当前元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」&lt;/p&gt;
&lt;p&gt;输入一个数组 &lt;code&gt;nums&lt;/code&gt;，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <link href="https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html"/>
    <id>https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html</id>
    <published>2024-02-24T14:50:06.000Z</published>
    <updated>2024-07-06T13:15:37.724Z</updated>
    
    <content type="html"><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p><pre><code class="hljs">*res = append(*res, root.Val)dfs(root.Left, res)dfs(root.Right, res)</code></pre><p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p><p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p><p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p><p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;func dfs(root *TreeNode, res *[]int) {&lt;br&gt;    if root &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;*res = ap</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器设置桥接</title>
    <link href="https://leiqichn.github.io/2024-02-15-1f66da892e14.html"/>
    <id>https://leiqichn.github.io/2024-02-15-1f66da892e14.html</id>
    <published>2024-02-15T13:34:12.000Z</published>
    <updated>2024-07-06T13:15:37.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240215213434.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215213536.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215213849.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215214100.png"><br><img src="/../../imgs/Pasted%20image%2020240215221821.png"><br>设置密码类型和主路由一样<br><img src="/../../imgs/Pasted%20image%2020240215221453.png"></p><p>记得关闭DHCP服务器<br><img src="/../../imgs/Pasted%20image%2020240215221417.png"><br><img src="/../../imgs/Pasted%20image%2020240215221130.png"><img src="/../../imgs/Pasted%20image%2020240215221401.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240215213434.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240215213536.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
