<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2023-09-03T06:05:03.229Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="https://leiqichn.github.io/2023-09-03-c58ee0dac51b.html"/>
    <id>https://leiqichn.github.io/2023-09-03-c58ee0dac51b.html</id>
    <published>2023-09-03T05:09:25.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p>网站链接：<br><a href="https://refactoringguru.cn/design-patterns/factory-method">工厂方法设计模式 (refactoringguru.cn)</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。<br><img src="/../../imgs/Pasted%20image%2020230903131943.png"></p><blockquote><p>其实就是使用简单工厂类<br>‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂</p></blockquote><p><img src="/../../imgs/Pasted%20image%2020230903134040.png"><br><img src="/../../imgs/Pasted%20image%2020230903133944.png"></p><h2 id="UML类图如何看"><a href="#UML类图如何看" class="headerlink" title="UML类图如何看"></a>UML类图如何看</h2><p><img src="/../../imgs/Pasted%20image%2020230903132154.png"></p><p>首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”</p><p><img src="/../../imgs/Pasted%20image%2020230903134233.png"></p><p><strong>接口:</strong> </p><p><img src="https://res.weread.qq.com/wrepub/CB_85fDPzDPICld6ht6gW5IeD0Q_Image00017.jpg"></p><p>‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口.</p><p><strong>类和类之间的关系:</strong> 继承的关系，继承关系用空心三角形+实线来表示<br><img src="/../../imgs/Pasted%20image%2020230903134840.png"></p><p><strong>聚合:</strong> 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。</p><p><img src="/../../imgs/Pasted%20image%2020230903140037.png"><br><strong>合成</strong>（Composition，也有翻译成‘<strong>组合</strong>’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。<br><img src="/../../imgs/Pasted%20image%2020230903140113.png"></p><p><strong>依赖</strong><br><img src="/../../imgs/Pasted%20image%2020230903140305.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网站链接：&lt;br&gt;&lt;a href=&quot;https://refactoringguru.cn/design-patterns/factory-method&quot;&gt;工厂方法设计模式 (refactoringguru.cn)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="设计模式" scheme="https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 2511 最多可以摧毁的敌人城堡数目</title>
    <link href="https://leiqichn.github.io/2023-09-02-72954cc13c19.html"/>
    <id>https://leiqichn.github.io/2023-09-02-72954cc13c19.html</id>
    <published>2023-09-02T12:51:41.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/description/?envType=daily-question&envId=2023-09-02">2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230902205220.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>抽象出来就是求1和-1间最大连续0 的数量。</p><p>有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？</p><p>1.当然可以分类讨论，代码会很复杂，判断很多，容易出错</p><ol start="2"><li>使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">captureForts</span><span class="hljs-params">(forts []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    ans, pre := <span class="hljs-number">0</span>, <span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">//pre 记录的是 1 或 -1 的位置 </span><br><br>    <span class="hljs-keyword">for</span> i, fort := <span class="hljs-keyword">range</span> forts &#123;<br><br>        <span class="hljs-keyword">if</span> fort == <span class="hljs-number">-1</span> || fort == <span class="hljs-number">1</span> &#123;<br><br>            <span class="hljs-keyword">if</span> pre &gt;= <span class="hljs-number">0</span> &amp;&amp; forts[pre] != fort &#123;<br><br>                ans = max(ans, i - pre - <span class="hljs-number">1</span>)<br><br>            &#125;<br><br>            pre = i<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br><br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br><br>        <span class="hljs-keyword">return</span> a<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/description/?envType=daily-question&amp;envId=2023-09-02&quot;&gt;2511</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://leiqichn.github.io/2023-08-07-e74632bdccbf.html"/>
    <id>https://leiqichn.github.io/2023-08-07-e74632bdccbf.html</id>
    <published>2023-08-07T15:29:00.000Z</published>
    <updated>2023-09-03T06:05:03.225Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230807233035.png"></p><p>list Elemet 双向列表；<br><img src="/../../imgs/Pasted%20image%2020230807233013.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span><br><span class="hljs-comment">// 本代码还未经过力扣测试，仅供参考，如有疑惑，可以参照我写的 java 代码对比查看。</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">cap</span>  <span class="hljs-type">int</span>                    <span class="hljs-comment">// 缓存容量</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<span class="hljs-comment">//!!! 双向链表 使用Element // 双向链表节点 指向的map</span><br>    list *list.List             <span class="hljs-comment">// 双向链表</span><br>&#125;<br><br><span class="hljs-keyword">type</span> keyVal <span class="hljs-keyword">struct</span> &#123;<br>    key, val <span class="hljs-type">int</span> <span class="hljs-comment">// 节点的Key和Value</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    <span class="hljs-keyword">return</span> LRUCache&#123;<br>        <span class="hljs-built_in">cap</span>:   capacity,                            <span class="hljs-comment">// 初始化缓存容量</span><br>        cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),          <span class="hljs-comment">// 初始化map映射</span><br>        list:  list.New(),                           <span class="hljs-comment">// 初始化双向链表</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="hljs-comment">// 如果map里有key对应的双向链表节点</span><br>        this.list.MoveToFront(elem)                  <span class="hljs-comment">// 把节点移动到链表头</span><br>        <span class="hljs-keyword">return</span> elem.Value.(*keyVal).val              <span class="hljs-comment">// 返回节点的value值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>                                        <span class="hljs-comment">// 没有找到的情况下，返回-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="hljs-comment">// 如果map里有key对应的双向链表节点</span><br>        this.list.MoveToFront(elem)                  <span class="hljs-comment">// 把节点移动到链表头</span><br>        <span class="hljs-comment">//!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值；</span><br>        elem.Value.(*keyVal).val = value             <span class="hljs-comment">// 更新节点的value值 </span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.list.Len() &gt;= this.<span class="hljs-built_in">cap</span> &#123;                 <span class="hljs-comment">// 如果超过了缓存容量</span><br>        tail := this.list.Back()                     <span class="hljs-comment">// 获取链表的尾节点</span><br>        k := tail.Value.(*keyVal).key                <span class="hljs-comment">// 获取节点的key</span><br>        this.list.Remove(tail)                       <span class="hljs-comment">// 从链表中删除尾节点</span><br>        <span class="hljs-built_in">delete</span>(this.cache, k)                        <span class="hljs-comment">// 从map中删除尾节点</span><br>    &#125;<br>    elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) <span class="hljs-comment">// 将节点添加到链表头</span><br>    this.cache[key] = elem                           <span class="hljs-comment">// 将节点映射到map中</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lru-cache/description/&quot;&gt;146. LRU 缓存 - 力扣（LeetCode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 最大深度和最小深度</title>
    <link href="https://leiqichn.github.io/2023-07-29-4df215f63090.html"/>
    <id>https://leiqichn.github.io/2023-07-29-4df215f63090.html</id>
    <published>2023-07-29T15:46:22.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230729235323.png"><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230729235305.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>深度 是指从根节点到该节点的距离（节点数量）<br>高度 是指从该节点到叶子节点的角力（节点数量）</p><p><strong>最大深度</strong> 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)<br><strong>最小子树</strong> 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现：</p><h1 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h1><h2 id="递归分治"><a href="#递归分治" class="headerlink" title="递归分治"></a>递归分治</h2><p>后序遍历 需要调用自生函数，需要严格按照定义调用递归。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rightMaxDepth := maxDepth(root.Right)<br>    leftMaxDepth := maxDepth(root.Left)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(rightMaxDepth,leftMaxDepth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>queue := []*TreeNode&#123;&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue,root)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// queue 不为空的时候</span><br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt;size ;i++ &#123;<span class="hljs-comment">// 遍历一层</span><br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 取最上层元素，并切掉该元素</span><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Left)<br>&#125;<br>&#125;<br>        depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>后序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最小深度</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rightMaxDepth := minDepth(root.Right)<br><br>    leftMaxDepth := minDepth(root.Left)<br><br>    <span class="hljs-comment">// 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论</span><br><br>    <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Left !=<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftMaxDepth <span class="hljs-comment">// 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right !=<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightMaxDepth<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(rightMaxDepth,leftMaxDepth)<br><br>&#125;<br><br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="迭代-层序遍历-1"><a href="#迭代-层序遍历-1" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>queue := []*TreeNode&#123;&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue,root)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// queue 不为空的时候</span><br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt;size ;i++ &#123;<span class="hljs-comment">// 遍历一层</span><br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 取最上层元素，并切掉该元素</span><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Left)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right == <span class="hljs-literal">nil</span> &amp;&amp; top.Left == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span> <span class="hljs-comment">// 当前节点也算哦</span><br>&#125;<br>&#125;<br>        depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/maximum-depth-of-binary-tree/des</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言中的byte类型与Unicode码点与整数的转换</title>
    <link href="https://leiqichn.github.io/2023-07-09-dda1c4b9508f.html"/>
    <id>https://leiqichn.github.io/2023-07-09-dda1c4b9508f.html</id>
    <published>2023-07-09T14:22:16.000Z</published>
    <updated>2023-09-03T06:05:03.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="byte类型与Unicode码点的转换"><a href="#byte类型与Unicode码点的转换" class="headerlink" title="byte类型与Unicode码点的转换"></a>byte类型与Unicode码点的转换</h1><p>在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。</p><p>当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b := <span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>i := <span class="hljs-type">int</span>(b)<br><br>fmt.Printf(<span class="hljs-string">&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\n&quot;</span>, b, b, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Byte: A, Unicode码点: <span class="hljs-number">65</span>, 转换后的整数: <span class="hljs-number">65</span><br></code></pre></td></tr></table></figure><p>可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。</p><h1 id="byte类型与整数的转换"><a href="#byte类型与整数的转换" class="headerlink" title="byte类型与整数的转换"></a>byte类型与整数的转换</h1><p>之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；<br>在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br>   <span class="hljs-string">&quot;fmt&quot;</span>  <br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   ch := <span class="hljs-string">&#x27;0&#x27;</span>  <br>   num := <span class="hljs-type">int</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)  <br>  <br>   fmt.Printf(<span class="hljs-string">&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\n&quot;</span>, ch, ch, num)  <br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">字符: <span class="hljs-number">0</span>, unicode码点或者<span class="hljs-type">byte</span>对应的数值: <span class="hljs-number">48</span>, 转换后的整数: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，字符 ‘0’ 成功转换为整数 0。<br>其中需要注意的是：在Go语言中，格式化输出时 <code>%c</code> 是一个占位符，用于表示要输出的值是一个Unicode字符。<br>具体来说，<code>%c</code> 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48</p><p>这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；<br>如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;byte类型与Unicode码点的转换&quot;&gt;&lt;a href=&quot;#byte类型与Unicode码点的转换&quot; class=&quot;headerlink&quot; title=&quot;byte类型与Unicode码点的转换&quot;&gt;&lt;/a&gt;byte类型与Unicode码点的转换&lt;/h1&gt;&lt;p&gt;在G</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Mesh组网：家庭路由和无线连接新方式</title>
    <link href="https://leiqichn.github.io/2023-06-25-a45e5f4edabc.html"/>
    <id>https://leiqichn.github.io/2023-06-25-a45e5f4edabc.html</id>
    <published>2023-06-25T14:24:32.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p>在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><ol><li>Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。</li></ol><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><ol start="2"><li><p>Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释：</p><ul><li>设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。</li><li>路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。</li><li>中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。</li><li>自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。</li></ul><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1></li><li><p>为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择：</p><ul><li>扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。</li><li>提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。</li><li>可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。</li><li>鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。</li><li>应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。</li></ul></li></ol><h1 id="与桥接路由对比"><a href="#与桥接路由对比" class="headerlink" title="与桥接路由对比"></a>与桥接路由对比</h1><ol><li><p>Mesh组网：</p><ul><li>概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。</li><li>特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。</li><li>优点：<ul><li>扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。</li><li>鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。</li><li>简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。</li></ul></li><li>缺点：<ul><li>延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。</li><li>多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。</li><li>网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。</li></ul></li></ul></li><li><p>桥接路由：</p><ul><li>概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。</li><li>特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。</li><li>优点：<ul><li>低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。</li><li>单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。</li><li>集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。</li></ul></li><li>缺点：<ul><li>单点故障：中央路由器的故障可能导致整个网络失去连接。</li><li>限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。</li><li>扩展性：增加节点时，可能需要重新配置和调整网络结构。</li></ul></li></ul></li></ol><p>结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>链表总结</title>
    <link href="https://leiqichn.github.io/2023-06-24-42b41b131ba0.html"/>
    <id>https://leiqichn.github.io/2023-06-24-42b41b131ba0.html</id>
    <published>2023-06-24T16:15:32.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h1><ul><li>虚拟头节点</li><li>拉拉链 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    p := dummy<br>    p1 := l1<br>    p2 := l2<br>    <br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 比较 p1 和 p2 两个指针</span><br>        <span class="hljs-comment">// 将值较小的的节点接到 p 指针</span><br>        <span class="hljs-keyword">if</span> p1.Val &gt; p2.Val &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.Next<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="链表的拆分"><a href="#链表的拆分" class="headerlink" title="链表的拆分"></a>链表的拆分</h1><ul><li>初始化两个链表，分别添加</li><li>合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next</li><li>合并</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(head *ListNode, x <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 存放小于 x 的链表的虚拟头结点</span><br>    dummy1 := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-comment">// 存放大于等于 x 的链表的虚拟头结点</span><br>    dummy2 := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-comment">// p1, p2 指针负责生成结果链表</span><br>    p1, p2 := dummy1, dummy2<br>    <span class="hljs-comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span><br>    <span class="hljs-comment">// 这里是将一个链表分解成两个链表</span><br>    p := head<br>    <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p.Val &gt;= x &#123;<br>            p2.Next = p<br>            p2 = p2.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p1.Next = p<br>            p1 = p1.Next<br>        &#125;<br>        <span class="hljs-comment">// 断开原链表中的每个节点的 next 指针</span><br>        temp := p.Next<br>        p.Next = <span class="hljs-literal">nil</span><br>        p = temp<br>    &#125;<br>    <span class="hljs-comment">// 连接两个链表</span><br>    p1.Next = dummy2.Next<br><br>    <span class="hljs-keyword">return</span> dummy1.Next<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="k-链表合并"><a href="#k-链表合并" class="headerlink" title="k 链表合并"></a>k 链表合并</h1><ul><li>最小堆 go语言的实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;<br>    Val <span class="hljs-type">int</span><br>    Next *ListNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    p := dummy<br>    <span class="hljs-comment">// 优先级队列，最小堆</span><br>    pq := <span class="hljs-built_in">make</span>(PriorityQueue, <span class="hljs-number">0</span>)<br>    heap.Init(&amp;pq)<br>    <span class="hljs-comment">// 将 k 个链表的头结点加入最小堆</span><br>    <span class="hljs-keyword">for</span> _, head := <span class="hljs-keyword">range</span> lists &#123;<br>        <span class="hljs-keyword">if</span> head != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(&amp;pq, head)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> pq.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 获取最小节点，接到结果链表中</span><br>        node := heap.Pop(&amp;pq).(*ListNode)<br>        p.Next = node<br>        <span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(&amp;pq, node.Next)<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-keyword">type</span> PriorityQueue []*ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> pq[i].Val &lt; pq[j].Val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    node := x.(*ListNode)<br>    *pq = <span class="hljs-built_in">append</span>(*pq, node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *pq<br>    n := <span class="hljs-built_in">len</span>(old)<br>    node := old[n<span class="hljs-number">-1</span>]<br>    *pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="倒数K链表"><a href="#倒数K链表" class="headerlink" title="倒数K链表"></a>倒数K链表</h1><ul><li>n 是包含nil 的</li><li>一个fast 去探路，先走k步</li><li>slow 和fast 一起走</li><li>当fast为nil 时，到达k ,赋值为next.next 即可<br><img src="/../../imgs/Pasted%20image%2020230625002218.png"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, head&#125;<br>    <span class="hljs-comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span><br>    x := findFromEnd(dummy, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 删掉倒数第 n 个节点</span><br>    x.Next = x.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br>    <br><span class="hljs-comment">// 返回链表的倒数第 k 个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    p1 := head<br>    <span class="hljs-comment">// p1 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        p1 = p1.Next<br>    &#125;<br>    p2 := head<br>    <span class="hljs-comment">// p1 和 p2 同时走 n - k 步</span><br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br>    <span class="hljs-keyword">return</span> p2<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="倒数K链表移除"><a href="#倒数K链表移除" class="headerlink" title="倒数K链表移除"></a>倒数K链表移除</h1><p>复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, head&#125;<br>    <span class="hljs-comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span><br>    x := findFromEnd(dummy, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 删掉倒数第 n 个节点</span><br>    x.next = x.next.next<br>    <span class="hljs-keyword">return</span> dummy.next<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 代码见上文</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除中间链表"><a href="#移除中间链表" class="headerlink" title="移除中间链表"></a>移除中间链表</h1><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode）</a></p><ul><li>slow 走一步，fast走两步</li><li>fast nil，slow 为中间<br><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    slow, fast := head, head<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-comment">// for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步</span><br>    <span class="hljs-keyword">for</span> fast!= <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span>&#123; <span class="hljs-comment">// 应该修改为这个，slow 会停在中点右边第二个部分</span><br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="判断链表是否成环"><a href="#判断链表是否成环" class="headerlink" title="判断链表是否成环"></a>判断链表是否成环</h1><ul><li>slow 走一步，fast走两步</li><li>fast 和slow 相遇则成环，fast 遇到nil 则不成环。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    slow, fast := head, head<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>        <span class="hljs-comment">// 快慢指针相遇，说明含有环</span><br>        <span class="hljs-keyword">if</span> slow == fast &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不包含环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>labuladong</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表的合并&quot;&gt;&lt;a href=&quot;#链表的合并&quot; class=&quot;headerlink&quot; title=&quot;链表的合并&quot;&gt;&lt;/a&gt;链表的合并&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;虚拟头节点&lt;/li&gt;
&lt;li&gt;拉拉链 &lt;figure class=&quot;highlight go&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>数组双指针刷题总结</title>
    <link href="https://leiqichn.github.io/2023-06-22-079d0af75447.html"/>
    <id>https://leiqichn.github.io/2023-06-22-079d0af75447.html</id>
    <published>2023-06-22T14:01:13.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p>双指针技巧分为<strong>快慢指针</strong>和<strong>左右指针</strong></p><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><ul><li>原地修改数组<ul><li>遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++</li></ul></li><li>去除有序数组&#x2F;链表中去重<ul><li>和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast]</li></ul></li></ul><h1 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h1><p>1.二分查找<br>    * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界<br>2.<strong>N sum 之和</strong><br>    * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大<br>3.反转字符串<br>    * 终止条件是i&gt;j<br>4.回文串判断<br>     * 判断条件s[i] &#x3D;&#x3D; s[j]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;双指针技巧分为&lt;strong&gt;快慢指针&lt;/strong&gt;和&lt;strong&gt;左右指针&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;快慢指针&quot;&gt;&lt;a href=&quot;#快慢指针&quot; class=&quot;headerlink&quot; title=&quot;快慢指针&quot;&gt;&lt;/a&gt;快慢指针&lt;/h1&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1170. 比较字符串最小字母出现频次</title>
    <link href="https://leiqichn.github.io/2023-06-14-88f65f0a1bb7.html"/>
    <id>https://leiqichn.github.io/2023-06-14-88f65f0a1bb7.html</id>
    <published>2023-06-14T15:28:09.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/">1170. 比较字符串最小字母出现频次 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230614235423.png"></p><p><strong>后缀和（</strong>Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。</p><p>具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。</p><p>在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。</p><h2 id="不使用后缀和"><a href="#不使用后缀和" class="headerlink" title="不使用后缀和"></a>不使用后缀和</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-number">0</span><br>    ch := <span class="hljs-string">&#x27;z&#x27;</span><br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> c &lt; ch &#123;<br>        ch = c<br>        cnt = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == ch &#123;<br>        cnt++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSmallerByFrequency</span><span class="hljs-params">(queries []<span class="hljs-type">string</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">12</span>)<br>    <span class="hljs-comment">// 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> words &#123;<br>        count[f(s)] += <span class="hljs-number">1</span><br>    &#125;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br>    <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> queries &#123;<br>        <span class="hljs-keyword">for</span> idx, c := <span class="hljs-keyword">range</span> count &#123; <span class="hljs-comment">// 遍历count</span><br>            <span class="hljs-keyword">if</span> c&gt;<span class="hljs-number">0</span> &amp;&amp; f(s) &lt; idx &#123;<span class="hljs-comment">// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c</span><br>                res[i]+=c<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="使用后缀和"><a href="#使用后缀和" class="headerlink" title="使用后缀和"></a>使用后缀和</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-number">0</span><br>    ch := <span class="hljs-string">&#x27;z&#x27;</span><br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> c &lt; ch &#123;<br>        ch = c<br>        cnt = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == ch &#123;<br>        cnt++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSmallerByFrequency</span><span class="hljs-params">(queries []<span class="hljs-type">string</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">12</span>)<br>    <span class="hljs-comment">// 先计算word 里的每个数</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> words &#123;<br>        count[f(s)] += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// 计算后缀和,i+1 就是大于i位置的所有个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">1</span>; i-- &#123;<br>        count[i] += count[i + <span class="hljs-number">1</span>]<br>    &#125;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br>    <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> queries &#123;<br>        res[i] = count[f(s) + <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？</strong></p><p>在<code>numSmallerByFrequency</code>函数中， <code>count</code>数组记录的是各个不同频次出现的次数，因此 <code>count[i]</code>代表所有最小字母出现频次不于 i 的字符串的数量。</p><p>如果对于 <code>queries</code> 中的某个字符串 <code>s</code> ，它的最小字母出现频次为 <code>f(s)</code>，那么可以依据 <code>count</code> 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 <code>f(s)+1</code> 开始的所有频次出现次数即可：</p><p><code>res[i] = count[f(s) + 1]</code></p><p>这里使用的是 <code>f(s)+1</code> 而不是 <code>f(s)</code> 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/&quot;&gt;1170. 比较字符串最小字母出现频次 - 力扣（Leetc</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是二进制的按位或和按位异或</title>
    <link href="https://leiqichn.github.io/2023-06-08-3d1c210a715f.html"/>
    <id>https://leiqichn.github.io/2023-06-08-3d1c210a715f.html</id>
    <published>2023-06-08T15:59:19.000Z</published>
    <updated>2023-09-03T06:05:03.225Z</updated>
    
    <content type="html"><![CDATA[<p>按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！</p><p>按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">input bit a | <span class="hljs-type">input</span> bit b | <span class="hljs-type">output</span> <br>------------------------------- <br><span class="hljs-number">0</span>        |     <span class="hljs-type">0</span>      | <span class="hljs-type">0</span> <br><span class="hljs-number">0</span>        |     <span class="hljs-type">1</span>      | <span class="hljs-type">1</span> <br><span class="hljs-number">1</span>        |     <span class="hljs-type">0</span>      | <span class="hljs-type">1</span> <br><span class="hljs-number">1</span>        |     <span class="hljs-type">1</span>      | <span class="hljs-type">1</span><br></code></pre></td></tr></table></figure><p>例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111):</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  110</span><br><span class="hljs-section">| 011</span><br><span class="hljs-section">-----</span><br><span class="hljs-code">  111</span><br><br></code></pre></td></tr></table></figure><p>按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">input bit a | input bit b | output</span><br><span class="hljs-section">-------------------------------</span><br><span class="hljs-code">        0    |    0      |   0</span><br><span class="hljs-code">        0    |    1      |   1</span><br><span class="hljs-code">        1    |    0      |   1</span><br><span class="hljs-code">        1    |    1      |   0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  110</span><br><span class="hljs-section">^ 011</span><br><span class="hljs-section">-----</span><br><span class="hljs-code">  101</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按位或，就是只要有1 就为1 (包含了1  1 ；0 1；1  0；三种)<br>按位异或，必须一个0一个1，才为1 （包含0 1；1  0；两种）<br>大家记住了吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！&lt;/p&gt;
&lt;p&gt;按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 2460.对数组执行操作 2023.05.06每日一题</title>
    <link href="https://leiqichn.github.io/2023-06-05-869070f8049d.html"/>
    <id>https://leiqichn.github.io/2023-06-05-869070f8049d.html</id>
    <published>2023-06-05T14:46:05.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/apply-operations-to-an-array/description/">2460. 对数组执行操作 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230605224628.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接模拟</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>第一版<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyOperations</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>index := <span class="hljs-number">0</span><br><span class="hljs-comment">// 第一次遍历 进行赋值操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>nums[i] *= <span class="hljs-number">2</span><br>nums[i+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 第二次遍历 将非0移动到前边</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>res[index] = nums[i]<br>index++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二版<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyOperations</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    j := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>            nums[i] *= <span class="hljs-number">2</span><br>            nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>            nums[i], nums[j] = nums[j], nums[i]<br>            j++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/apply-operations-to-an-array/description/&quot;&gt;2460. 对数组执行操作 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../img</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 28.找出字符串中第一个匹配项的下标</title>
    <link href="https://leiqichn.github.io/2023-05-31-396a1cd3c61e.html"/>
    <id>https://leiqichn.github.io/2023-05-31-396a1cd3c61e.html</id>
    <published>2023-05-31T14:27:00.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531222721.png"></p><p>简单解法<br>利用split 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片</span><br>splitList := strings.Split(haystack, needle)<br><span class="hljs-comment">// 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(splitList)== <span class="hljs-number">1</span> &amp;&amp; needle!=haystack &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(splitList) &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(splitList[<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-comment">// needle 在haystack的最开头，返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/&quot;&gt;28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 104.二叉树的深度</title>
    <link href="https://leiqichn.github.io/2023-05-30-b1879d2b65d1.html"/>
    <id>https://leiqichn.github.io/2023-05-30-b1879d2b65d1.html</id>
    <published>2023-05-30T15:33:48.000Z</published>
    <updated>2023-09-03T06:05:03.225Z</updated>
    
    <content type="html"><![CDATA[<p>个人网站：<a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531000419.png"></p><p>二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。</p><p>所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(root *treenode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxdepth(root.left), maxdepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>可以使用模板层序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>queue := list.New()<br>queue.PushBack(root)<br><br><span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>size := queue.Len()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br><span class="hljs-comment">// 切掉第一个元素</span><br>first := queue.Remove(queue.Front()).(*TreeNode) <span class="hljs-comment">//注意层序遍历是切掉前边一个</span><br><span class="hljs-keyword">if</span> first.Left != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Left)<br>&#125;<br><span class="hljs-keyword">if</span> first.Right != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Right)<br>&#125;<br>&#125;<br>depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人网站：&lt;a href=&quot;https://leiqicn.gitee.io/categories/leetcode/&quot;&gt;https://leiqicn.gitee.io/categories/leetcode/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetco</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="DFS" scheme="https://leiqichn.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://leiqichn.github.io/tags/BFS/"/>
    
    <category term="层序遍历" scheme="https://leiqichn.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 122买动态股票的最佳时机II</title>
    <link href="https://leiqichn.github.io/2023-05-27-5cebfed1675b.html"/>
    <id>https://leiqichn.github.io/2023-05-27-5cebfed1675b.html</id>
    <published>2023-05-27T15:51:57.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230527235217.png"></p><p>每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。</p><p>相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。</p><p>下面是代码解释：</p><p>首先定义变量 sum 记录当前总利润。<br>然后从第二个价格开始遍历，计算当日价格与前一天价格之差。<br>如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。<br>最后返回累计的总利润。<br>这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-comment">// 累加每次大于0的交易</span><br>        <span class="hljs-keyword">if</span> prices[i] - prices[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            sum += prices[i] - prices[i<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/&quot;&gt;122. 买卖股票的最佳时机 II - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1091.二进制矩阵中的最短路径</title>
    <link href="https://leiqichn.github.io/2023-05-26-5abcbf266873.html"/>
    <id>https://leiqichn.github.io/2023-05-26-5abcbf266873.html</id>
    <published>2023-05-26T15:35:54.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230526235236.png"><br>DFS 超时版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">int</span><br>y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(grid)<br><span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>res := <span class="hljs-number">0</span><br>dirs := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-keyword">var</span> help <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span><br><br>help = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 判断是否越界或已经访问过当前节点</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= n || grid[i][j] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> i == n<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span> &#123;<br><span class="hljs-comment">// 当到达终点时，更新res</span><br><span class="hljs-keyword">if</span> tmp+<span class="hljs-number">1</span> &lt; res || res == <span class="hljs-number">0</span> &#123;<br>res = tmp + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 将当前点标记为已访问</span><br>grid[i][j] = <span class="hljs-number">1</span><br>tmp++<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dirs &#123;<br>x := i + item[<span class="hljs-number">0</span>]<br>y := j + item[<span class="hljs-number">1</span>]<br>help(x, y, tmp)<br>&#125;<br><span class="hljs-comment">// 回溯操作，将当前点复原为未访问状态</span><br>grid[i][j] = <span class="hljs-number">0</span><br>&#125;<br><br>help(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BFS，最短路径使用BFS </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x,y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// queue 维护</span><br>m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[point]<span class="hljs-type">int</span>)<br>queue := <span class="hljs-built_in">make</span>([]point,<span class="hljs-number">0</span>)<br>step := <span class="hljs-number">1</span><br>start := point&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;<br>end := point&#123;m<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>&#125;<br>dirs := []point&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;<br><span class="hljs-comment">// 起点为1 则直接返回</span><br>    <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>queue = <span class="hljs-built_in">append</span>(queue,start)<br>visited[start] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 将当前队列中的所有节点向四周扩散</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; size; i++&#123;<br>cur := queue[<span class="hljs-number">0</span>] <span class="hljs-comment">// 当前cur</span><br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 切掉当前点</span><br><span class="hljs-comment">// 判断是否是终点</span><br><span class="hljs-keyword">if</span> cur == end &#123;<br><span class="hljs-keyword">return</span> step<br>&#125;<br><span class="hljs-comment">// 遍历八个方向 判断是否符合边界条件</span><br><span class="hljs-keyword">for</span> _, dir :=<span class="hljs-keyword">range</span> dirs&#123;<br>newX := cur.x + dir.x<br>newY := cur.y + dir.y<br>newPoint := point&#123;newX,newY&#125;<br><span class="hljs-keyword">if</span> newX &gt;=<span class="hljs-number">0</span> &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=<span class="hljs-number">0</span> &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==<span class="hljs-number">0</span> &amp;&amp; grid[newX][newY]==<span class="hljs-number">0</span> &#123;<br>visited[point&#123;newX,newY&#125;] = <span class="hljs-number">1</span><br>queue =<span class="hljs-built_in">append</span>(queue,newPoint)<br>&#125;<br>&#125;<br><br>&#125;<br>step++<br>&#125;<br><span class="hljs-comment">// 只能为0 的路径才可以更新到queue  边界控制</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>&gt; <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solutions/1076268/bfszui-duan-lu-jing-wen-ti-bfsdfsde-si-k-ngc5/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a>### 解题思路</strong></p><blockquote><p>典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。</p></blockquote><p><strong>&gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？</strong></p><blockquote><p>1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</p></blockquote><p><strong>&gt; ### BFS解法中的visited为什么可以全局使用？</strong></p><blockquote><p>BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/&quot;&gt;1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="二维数组最短路径" scheme="https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 53.最大子数和</title>
    <link href="https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html"/>
    <id>https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html</id>
    <published>2023-05-25T15:08:24.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p><strong>个人网站：</strong> <a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><img src="https://pic.leetcode.cn/1685028457-IOzjjG-image.png" alt="image.png"><br>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>方法1  算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。</p></blockquote><blockquote><p>方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums<a href="dp%5B0%5D">0</a>; 遍历顺序，从idx &#x3D; 1 开始遍历。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 方法1 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br>res := math.MinInt32<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>count += nums[i]<br><span class="hljs-keyword">if</span> count &gt; res &#123;<br>res = count<br>&#125;<br><br><span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span> &#123;<br>count = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-comment">// 方法2 使用了类似动态规划的思想</span><br><span class="hljs-comment">// 定义 nums[i] 当前元素，nums[i-1] 前序列之和</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>max := nums[<span class="hljs-number">0</span>] <span class="hljs-comment">//初始化最大值为前边一个元素</span><br><span class="hljs-comment">// 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。</span><br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span> ;i &lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] + nums[i] &gt; nums[i+<span class="hljs-number">1</span>] &#123;<br>nums[i+<span class="hljs-number">1</span>] = nums[i+<span class="hljs-number">1</span>] + nums[i]<br>&#125;<br><span class="hljs-comment">// 超过最大值，则更新</span><br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] &gt;  max &#123;<br>max = nums[i+<span class="hljs-number">1</span>]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/maximum-subarray/description/&quot;&gt;53. 最大子数组和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;个人</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="贪心" scheme="https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>go语言-回调函数（钩子）</title>
    <link href="https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html"/>
    <id>https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html</id>
    <published>2023-05-25T13:56:41.000Z</published>
    <updated>2023-09-03T06:05:03.225Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。</p><p>以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printWithCallback</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span>) &#123;<br>    text := <span class="hljs-string">&quot;Hello, world!&quot;</span><br>    fmt.Println(text)<br>    callback(text)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    callback := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Printed: %s\n&quot;</span>, text)<br>    &#125;<br>    printWithCallback(callback)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。</p><p>当程序运行起来后，会输出如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Hello, world!<br>Printed: Hello, world!<br></code></pre></td></tr></table></figure><p>这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。</p><p>对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeElapsedCallback</span><span class="hljs-params">(start time.Time)</span></span> &#123;<br>    elapsed := time.Now().Sub(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(time.Time)</span></span>) &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    callback(start)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation(TimeElapsedCallback)<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。</p><p>在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容：</p><p>Time elapsed: 1.001201ms<br>以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。</p><h2 id="回调函数的不同"><a href="#回调函数的不同" class="headerlink" title="回调函数的不同"></a>回调函数的不同</h2><p>以下是不使用回调函数的方式实现计算程序执行时间的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    elapsed := time.Since(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation()<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。</p><p>在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。</p><p>当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。</p><p>使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。</p><p>而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。</p><p>钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。</p><h2 id="以下是使用回调函数的优点："><a href="#以下是使用回调函数的优点：" class="headerlink" title="以下是使用回调函数的优点："></a>以下是使用回调函数的优点：</h2><p>灵活性：可以轻松地将自定义代码插入到已有的代码流程中。<br>可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。<br>易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。<br>总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。&lt;/p&gt;
&lt;p&gt;以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 376.摆动序列</title>
    <link href="https://leiqichn.github.io/2023-05-23-7b5e53100757.html"/>
    <id>https://leiqichn.github.io/2023-05-23-7b5e53100757.html</id>
    <published>2023-05-23T17:05:07.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230524010708.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> count, preDiff, curDiff <span class="hljs-type">int</span><br>    count = <span class="hljs-number">1</span> <span class="hljs-comment">// 初始化计数为1，至少有一个数字是有效的</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 如果数组长度小于2，直接返回计数值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br>        curDiff = nums[i+<span class="hljs-number">1</span>] - nums[i] <span class="hljs-comment">// 计算当前数字之间的差值</span><br><br>        <span class="hljs-comment">// 根据差值的正负和前一个差值的正负进行判断</span><br>        <span class="hljs-comment">// 如果满足摆动序列的条件，更新前一个差值和计数值</span><br>        <span class="hljs-keyword">if</span> (curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>) &#123;<br>            preDiff = curDiff<br>            count++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 返回最终的计数值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/wiggle-subsequence/description/&quot;&gt;376. 摆动序列 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20ima</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 226. 翻转二叉树</title>
    <link href="https://leiqichn.github.io/2023-05-23-d59f64e0619b.html"/>
    <id>https://leiqichn.github.io/2023-05-23-d59f64e0619b.html</id>
    <published>2023-05-23T15:06:25.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523230644.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 定义将二叉树翻转</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点</span><br>    root.Right,root.Left = root.Left,root.Right <br>    <span class="hljs-comment">// 将右子树翻转</span><br>    invertTree(root.Right)<br>    <span class="hljs-comment">// 将左子树翻转</span><br>    invertTree(root.Left)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/invert-binary-tree/description/&quot;&gt;226. 翻转二叉树 - 力扣（Leetcode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20im</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 144. 二叉树的前序遍历</title>
    <link href="https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html"/>
    <id>https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html</id>
    <published>2023-05-23T14:49:08.000Z</published>
    <updated>2023-09-03T06:05:03.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230523224940.png"></p><p>记得提前判断是否为空，否则会报找不到内存指针的错误<br><img src="/../../imgs/Pasted%20image%2020230523225147.png"></p><p>注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。<a href="leetcode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">leetcode 102. 二叉树的层序遍历</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := list.New()<br>res :=  []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<span class="hljs-comment">//防止为空</span><br><span class="hljs-keyword">return</span> res<br>&#125;<br>stack.PushBack(root)<br><span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &#123;<br>top := stack.Remove(stack.Back()).(*TreeNode)<br>res = <span class="hljs-built_in">append</span>(res,top.Val)<br><span class="hljs-keyword">if</span> top.Right !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Left)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  res <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-preorder-traversal/description/&quot;&gt;144. 二叉树的前序遍历 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
