<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2024-04-06T13:15:18.320Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计题 总结</title>
    <link href="https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html"/>
    <id>https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html</id>
    <published>2024-04-05T17:21:04.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计题 - 实现浏览器历史记录</strong><br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p><ul><li>和当前页相同，则直接返回</li><li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description: 浏览器实现</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.GetCurrentPage() == newPageURL &#123;<br><span class="hljs-keyword">return</span> newPageURL<br>&#125;<br><br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p><h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p><p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p><h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p><p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p><h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p><p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p><h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p><h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p><p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面，我们来按照难度多练习几道题目</p><h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ol><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></li></ol><p><img src="/../../imgs/Pasted%20image%2020240405184827.png"></p><p> <strong>思路：</strong>input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>inputStack  []<span class="hljs-type">int</span><br>outputStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br><span class="hljs-keyword">return</span> MyQueue&#123;<br>inputStack:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputStack: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputStack = <span class="hljs-built_in">append</span>(this.inputStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.inputStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(this.outputStack) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Peek();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a><img src="/../../imgs/Pasted%20image%2020240405184932.png"></li></ol><p><strong>思路：</strong>用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>inputQueue  []<span class="hljs-type">int</span><br>outputQueue []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br><span class="hljs-keyword">return</span> MyStack&#123;<br>inputQueue:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputQueue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.inputQueue, x)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = this.outputQueue<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue...)<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(this.inputQueue) == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">len</span>(this.outputQueue) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406201421.png"><br>思路：简单题，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    nums  []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    <span class="hljs-keyword">return</span> NumArray&#123;nums: nums&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i:= left; i&lt;= right; i++ &#123;<br>        sum += this.nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用前缀和<br><img src="/../../imgs/Pasted%20image%2020240406201959.png"><br>怎么求 preSum 数组<br>利用前面提到的递推式:<br><img src="/../../imgs/Pasted%20image%2020240406201929.png"></p><p>遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，<strong>即preSum[0]为nums[0]（前提是nums有元素）</strong>。</p><p>预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。</p><p>需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。</p><p>后面会给出简化的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(nums);i++ &#123;<br>        preSum[ i] = preSum[ i<span class="hljs-number">-1</span>] + nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.preSum) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 但如果nums根本没有长度，直接返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> this.preSum[right]<br>&#125;<br>    <span class="hljs-keyword">return</span> this.preSum[right] - this.preSum[left<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用多一位长度的前缀和<br>之所以上面处理东西多，是因为<code>preSum[i]</code>的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index</p><p>要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]<br>即：</p><p><img src="/../../imgs/Pasted%20image%2020240406202142.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> nums &#123;<br>        preSum[index + <span class="hljs-number">1</span>] = preSum[index] + value<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.preSum[right + <span class="hljs-number">1</span>] - this.preSum[left]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406204841.png"><br><strong>暴力解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 排序后的nums</span><br>index      <span class="hljs-type">int</span><br>sortedNums []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br><span class="hljs-keyword">return</span> KthLargest&#123;k, nums&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>this.sortedNums = <span class="hljs-built_in">append</span>(this.sortedNums, val)<br>sort.Ints(this.sortedNums)<br>revert(this.sortedNums)<br><span class="hljs-keyword">return</span> this.sortedNums[this.index<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">revert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(k, nums);</span><br><span class="hljs-comment"> * param_1 := obj.Add(val);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><strong>优先队列</strong><br>我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。</p><p>在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br>    sort.IntSlice<br>    k <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br>    kl := KthLargest&#123;k: k&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>        kl.Add(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    kl.IntSlice = <span class="hljs-built_in">append</span>(kl.IntSlice, v.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    a := kl.IntSlice<br>    v := a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    kl.IntSlice = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    heap.Push(kl, val)<br>    <span class="hljs-keyword">if</span> kl.Len() &gt; kl.k &#123;<br>        heap.Pop(kl)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl.IntSlice[<span class="hljs-number">0</span>]<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;设计题 - 实现浏览器历史记录&lt;/strong&gt;&lt;br&gt;1.初始化 homepage 和历史记录容量&lt;br&gt;2.浏览网页 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和当前页相同，则直接返回&lt;/li&gt;
&lt;li&gt;和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows IE代理问题解决</title>
    <link href="https://leiqichn.github.io/2024-04-05-e1116cf34b00.html"/>
    <id>https://leiqichn.github.io/2024-04-05-e1116cf34b00.html</id>
    <published>2024-04-05T05:11:29.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p>CMD <strong>检查系统代理配置</strong>：</p><pre><code class="hljs">- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。- 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CMD &lt;strong&gt;检查系统代理配置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。
- 如果需要更改系统代理，可以使用`netsh win</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 双指针</title>
    <link href="https://leiqichn.github.io/2024-03-23-84678021105b.html"/>
    <id>https://leiqichn.github.io/2024-03-23-84678021105b.html</id>
    <published>2024-03-23T14:51:46.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除有序数组中的重复元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast:=<span class="hljs-number">1</span>;fast &lt;<span class="hljs-built_in">len</span>(nums);fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<span class="hljs-comment">// 跳到下个位置，保存slow</span><br><br>            nums[slow] = nums[fast]<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow +<span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p><p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>注意到以下性质：</strong></p><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>slow, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123; <span class="hljs-comment">// 注意第一个是0的时候需要比较</span><br><span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span><br>nums[slow], nums[fast] = nums[fast], nums[slow]<br>slow++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(height); j++ &#123;<br>area := (j - i) * min(height[i], height[j])<br>ans = max(area,ans)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化两边指针</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        area := (right - left) * min(height[left], height[right]) <span class="hljs-comment">// 计算面积</span><br>        ans = max(ans, area) <span class="hljs-comment">// 计算最大值</span><br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123; <br>            left++ <span class="hljs-comment">// 移动短的那个</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240326011627.png"></p><p>前缀和，后缀和<br>木桶效应，当前能装的水，取决于两边最大值 的最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    preMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// preMax[i] 表示从 height[0] 到 height[i] 的最大值</span><br>    preMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        preMax[i] = max(preMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    sufMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值</span><br>    sufMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        sufMax[i] = max(sufMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        ans += min(preMax[i], sufMax[i]) - h <span class="hljs-comment">// 累加每个水桶能接多少水</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right, preMax, sufMax := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        preMax = max(preMax, height[left])<br>        sufMax = max(sufMax, height[right])<br>        <span class="hljs-keyword">if</span> preMax &lt; sufMax &#123;<br>            ans += preMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += sufMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240323225412.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 单调栈</title>
    <link href="https://leiqichn.github.io/2024-02-24-dd95d981cb94.html"/>
    <id>https://leiqichn.github.io/2024-02-24-dd95d981cb94.html</id>
    <published>2024-02-24T15:57:54.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p><p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123; <span class="hljs-comment">// 倒着入栈是为了后边正着出栈</span><br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &lt;= nums[i] &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有更大的元素</span><br>            res[i] = <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 正着出栈</span><br>        &#125;<br>        s = <span class="hljs-built_in">append</span>(s, nums[i]) <span class="hljs-comment">// 当前元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」&lt;/p&gt;
&lt;p&gt;输入一个数组 &lt;code&gt;nums&lt;/code&gt;，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <link href="https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html"/>
    <id>https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html</id>
    <published>2024-02-24T14:50:06.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p><pre><code class="hljs">*res = append(*res, root.Val)dfs(root.Left, res)dfs(root.Right, res)</code></pre><p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p><p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p><p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p><p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;func dfs(root *TreeNode, res *[]int) {&lt;br&gt;    if root &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;*res = ap</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <link href="https://leiqichn.github.io/2024-01-23-1cb0809a7893.html"/>
    <id>https://leiqichn.github.io/2024-01-23-1cb0809a7893.html</id>
    <published>2024-01-23T16:13:30.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> people[i][<span class="hljs-number">0</span>] == people[j][<span class="hljs-number">0</span>]&#123;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">1</span>] &lt; people[j][<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">0</span>] &gt; people[j][<span class="hljs-number">0</span>] <span class="hljs-comment">// 身高由大到小排列</span><br><br>&#125;)i<br><span class="hljs-comment">// 再按照K进行插入排序，优先插入K小的</span><br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-built_in">copy</span>(people[p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span> :i+<span class="hljs-number">1</span>], people[p[<span class="hljs-number">1</span>] :i=<span class="hljs-number">1</span>])  <span class="hljs-comment">// 腾空出一个位置</span><br>        people[p[<span class="hljs-number">1</span>]] = pi<br>&#125;<br><span class="hljs-keyword">return</span> people<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p></li><li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p></li><li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p></li><li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p></li></ol><p>最终，返回重新排列后的队列 <code>people</code>。</p><p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p><p>让我们考虑一下为什么使用 <code>i+1</code>：</p><ol><li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li><li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li><li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/queue-reconstruction-by-height/description/&quot;&gt;406. 根据身高重建队列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <link href="https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html"/>
    <id>https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html</id>
    <published>2024-01-23T15:17:11.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p><p>使用回溯的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>path := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// return </span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>) <span class="hljs-comment">// i+1 进行下一轮</span><br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p></li><li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p></li><li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p></li><li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p></li><li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p></li><li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinations/description/&quot;&gt;77. 组合 - 力扣（LeetCode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202024</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【BFS DFS通用模板】</title>
    <link href="https://leiqichn.github.io/2024-01-22-759654485d5d.html"/>
    <id>https://leiqichn.github.io/2024-01-22-759654485d5d.html</id>
    <published>2024-01-22T16:05:29.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 通用的深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node <span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> visited[node] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理当前节点</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 标记当前节点为已访问</span><br>    visited[node] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 递归处理相邻节点</span><br>    <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>        dfs(neighbor, visited, graph)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化节点、访问数组等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 遍历所有节点</span><br>    <span class="hljs-keyword">for</span> node := <span class="hljs-number">0</span>; node &lt; <span class="hljs-built_in">len</span>(graph); node++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[node] &#123;<br>            dfs(node, visited, graph)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通用的广度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(graph))<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 出队列</span><br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment">// 处理当前节点</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 标记当前节点为已访问</span><br>        visited[node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 将相邻节点入队列</span><br>        <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[neighbor] &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, neighbor)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化起始节点、图等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用BFS函数</span><br>    bfs(start, graph)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;a href=&quot;#深度优先搜索（DFS）通用模板&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;/a&gt;深度优先搜索（DFS）通用模板&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <link href="https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html"/>
    <id>https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html</id>
    <published>2024-01-22T15:01:59.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">var</span> traversal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traversal = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br>traversal(node.Left)<br>res = <span class="hljs-built_in">append</span>(res,node.Val)<br>traversal(node.Right)<br>    &#125;<br>    traversal(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br><br>    st := list.New()<br>    cur := root<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> || st.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            st.PushBack(cur)<br>            cur = cur.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = st.Remove(st.Back()).(*TreeNode)<br>            ans = <span class="hljs-built_in">append</span>(ans, cur.Val)<br>            cur = cur.Right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对代码的解释：</p><ol><li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p></li><li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p></li><li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p></li><li><p><code>cur := root</code>: 初始化当前节点为根节点。</p></li><li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p></li><li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p><ul><li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p></li><li><p><code>cur = cur.Left</code>: 移动到左子树。</p></li></ul></li><li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p><ul><li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p></li><li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p></li><li><p><code>cur = cur.Right</code>: 移动到右子树。</p></li></ul></li><li><p>循环回到第5步，直到栈为空。</p></li></ol><p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p><p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p><ul><li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p></li><li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p></li></ul><p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p><p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归方法&quot;&gt;&lt;a href=&quot;#递归方法&quot; class=&quot;headerlink&quot; title=&quot;递归方法&quot;&gt;&lt;/a&gt;递归方法&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【go】初始化双向列表List</title>
    <link href="https://leiqichn.github.io/2024-01-22-93119ce81a1c.html"/>
    <id>https://leiqichn.github.io/2024-01-22-93119ce81a1c.html</id>
    <published>2024-01-22T14:39:01.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，两种方法都可以用于初始化一个<code>list.List</code>。</p><ol><li><p><code>queue := &amp;list.List&#123;&#125;</code>: 这是使用结构体字面量的方式，创建一个 <code>list.List</code> 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。</p></li><li><p><code>queue := list.New()</code>: 这是使用 <code>list</code> 包中的 <code>New</code> 函数来创建一个新的 <code>list.List</code>。<code>New</code> 函数返回一个指向新创建的 <code>list.List</code> 实例的指针。同样，这种方式也创建了一个空的链表。</p></li></ol><p>两种方式都是有效的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，两种方法都可以用于初始化一个&lt;code&gt;list.List&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;queue := &amp;amp;list.List&amp;#123;&amp;#125;&lt;/code&gt;: 这是使用结构体字面量的方式，创建一个 &lt;code&gt;l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240114】LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="https://leiqichn.github.io/2024-01-14-e61755fec3db.html"/>
    <id>https://leiqichn.github.io/2024-01-14-e61755fec3db.html</id>
    <published>2024-01-14T10:10:30.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">for</span> i := head; i != <span class="hljs-literal">nil</span> &amp;&amp; i.Next != <span class="hljs-literal">nil</span> ; &#123;<br>        <span class="hljs-keyword">if</span> i.Next.Val == i.Val &#123;<br>            i.Next = i.Next.Next <span class="hljs-comment">// 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123;  i = i.Next不需要</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    current := head<br><br>    <span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &amp;&amp; current.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> current.Next.Val == current.Val &#123;<br>            <span class="hljs-comment">// 保存下一个节点的引用</span><br>            nextNode := current.Next<br>            <span class="hljs-comment">// 删除当前节点</span><br>            current.Next = nextNode.Next<br>            <span class="hljs-comment">// 释放内存</span><br>            nextNode = <span class="hljs-literal">nil</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非重复元素，继续遍历</span><br>            current = current.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/&quot;&gt;83. 删除排序链表中的重复元素&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Win】键盘下键坏了，使用组合键模拟下方向键</title>
    <link href="https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html"/>
    <id>https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html</id>
    <published>2024-01-14T09:05:02.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：</p><p>下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。<br><img src="/../../imgs/Pasted%20image%2020240114170655.png"><br>创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">!s::<span class="hljs-built_in">Send</span> &#123;Down&#125;<br></code></pre></td></tr></table></figure><p>这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。<br><img src="/../../imgs/Pasted%20image%2020240114170729.png"><br>保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。</p><p>运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。</p><p>现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：&lt;/p&gt;
&lt;p&gt;下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。&lt;br&gt;&lt;img src</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240106】leetcode 2807. 在链表中插入最大公约数</title>
    <link href="https://leiqichn.github.io/2024-01-06-2b3ad028343c.html"/>
    <id>https://leiqichn.github.io/2024-01-06-2b3ad028343c.html</id>
    <published>2024-01-06T15:27:26.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&envId=2024-01-06">2807. 在链表中插入最大公约数 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240106233021.png"></p><p>最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。</p><p>计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下：</p><ol><li>用较大的数除以较小的数，得到余数。</li><li>将较小的数作为新的被除数，余数作为新的除数。</li><li>重复步骤 1 和 2，直到余数为零。</li><li>最后的非零余数即为最大公约数。</li></ol><p>这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。</p><p>以下是一个用 Go 语言实现的最大公约数的辗转相除法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 辗转相除法求最大公约数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        temp := b<br>        b = a % b<br>        a = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num1 := <span class="hljs-number">48</span><br>    num2 := <span class="hljs-number">18</span><br><br>    result := gcd(num1, num2)<br><br>    fmt.Println(<span class="hljs-string">&quot;最大公约数为:&quot;</span>, result)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>gcd</code> 函数使用了辗转相除法来计算两个整数的最大公约数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&amp;envId=2024-01-06</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1071. 字符串的最大公因子</title>
    <link href="https://leiqichn.github.io/2024-01-03-58e186a9065e.html"/>
    <id>https://leiqichn.github.io/2024-01-03-58e186a9065e.html</id>
    <published>2024-01-03T15:12:16.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></p><p><img src="/../../imgs/Pasted%20image%2020240103231323.png"></p><p><strong>解题思路：</strong></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n1, n2 := <span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2)<br><br>    <span class="hljs-comment">// 从最长的可能的子串长度开始尝试</span><br>    <span class="hljs-keyword">for</span> i := min(n1, n2); i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> n1%i == <span class="hljs-number">0</span> &amp;&amp; n2%i == <span class="hljs-number">0</span> &#123;<br>            commonSubstring := str1[:i]<br><br>            <span class="hljs-comment">// 检查是否满足条件</span><br>            <span class="hljs-keyword">if</span> checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123;<br>                <span class="hljs-keyword">return</span> commonSubstring<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 检查字符串是否能够整除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDivisible</span><span class="hljs-params">(s <span class="hljs-type">string</span>, sub <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    repeats := <span class="hljs-built_in">len</span>(s) / <span class="hljs-built_in">len</span>(sub)<br>    concatenated := repeatString(sub, repeats)<br>    <span class="hljs-keyword">return</span> s == concatenated<br>&#125;<br><br><span class="hljs-comment">// 重复字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    result := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>        result += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>辗转相除法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> str1 + str2 != str2 + str1 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    gcd := gcd(<span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2))<br>    <span class="hljs-keyword">return</span> str1[<span class="hljs-number">0</span>:gcd]<br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        a, b = b, a % b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/greatest-common-divisor-of-strings/&quot;&gt;1071. 字符串的最大公因子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20imag</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows新增wsl bash here键快捷方式</title>
    <link href="https://leiqichn.github.io/2024-01-01-38178c63ba17.html"/>
    <id>https://leiqichn.github.io/2024-01-01-38178c63ba17.html</id>
    <published>2024-01-01T10:23:10.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p>win + R 输入regedit<br><img src="/../../imgs/Pasted%20image%2020240101182355.png"><br>输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p><h1 id="新建wsl-bash-here目录-设置如下默认值"><a href="#新建wsl-bash-here目录-设置如下默认值" class="headerlink" title="新建wsl_bash_here目录, 设置如下默认值"></a>新建wsl_bash_here目录, 设置如下默认值</h1><p><img src="/../../imgs/Pasted%20image%2020240101183252.png"></p><h1 id="新建command新建项，输入wsl-exe-的地址"><a href="#新建command新建项，输入wsl-exe-的地址" class="headerlink" title="新建command新建项，输入wsl.exe 的地址"></a>新建command新建项，输入wsl.exe 的地址</h1><p><img src="/../../imgs/Pasted%20image%2020240101183246.png"></p><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>可以看到右侧是有wsl bash here的选项的<br><img src="/../../imgs/Pasted%20image%2020240101183634.png"><br><strong>在当面目录打开wsl 成功</strong><br><img src="/../../imgs/Pasted%20image%2020240101183645.png"><br>原理和添加git bash here 类似, 参考:<br><a href="https://blog.csdn.net/Passerby_Wang/article/details/120881670">手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;win + R 输入regedit&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240101182355.png&quot;&gt;&lt;br&gt;输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git 设置免密配置-全局免密-单仓库免密-SSH免密</title>
    <link href="https://leiqichn.github.io/2024-01-01-91517aa963bc.html"/>
    <id>https://leiqichn.github.io/2024-01-01-91517aa963bc.html</id>
    <published>2024-01-01T06:56:28.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h1><p>我们要首先知道一个简单的概念:<br>https通过<strong>记住账号密码免登</strong>，ssh通过<strong>校验生成的密钥免登</strong>。 通常都用ssh校验。</p><p>查看通信方式</p><p>在项目目录中运行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote -v<br></code></pre></td></tr></table></figure><p>如果出现提示是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">origin  https://gitee.com/xxx/xxx.git (fetch)<br>origin  https://gitee.com/xxx/xxx.git (push)<br></code></pre></td></tr></table></figure><p>则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密<br>如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址<br><img src="/../../imgs/Pasted%20image%2020240101151457.png"></p><h1 id="一、https-方式及免密码配置"><a href="#一、https-方式及免密码配置" class="headerlink" title="一、https 方式及免密码配置"></a>一、https 方式及免密码配置</h1><h3 id="0-项目中-git-基本配置"><a href="#0-项目中-git-基本配置" class="headerlink" title="0. 项目中 git 基本配置"></a>0. 项目中 git 基本配置</h3><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text"># 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令<br>git init<br># 关联远程仓库<br>git remote add origin https://gitee.com/xxx/xxx.git<br>git add -A<br>git commit -m &quot;初始化&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。</p><p>这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。</p><h3 id="1-全局免密码配置"><a href="#1-全局免密码配置" class="headerlink" title="1.全局免密码配置"></a>1.全局免密码配置</h3><p>配置存储模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store</p><p>Linux 下查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.gitconfig<br></code></pre></td></tr></table></figure><p>windows10 下当前用户路径：<code>%USERPROFILE%</code><br>内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[user]<br>        name = lenovo<br>        email = xxxx@outlook.com<br>[credential]<br>        helper = store<br></code></pre></td></tr></table></figure><p>然后在项目目录，执行git pull&#x2F;git push命令，会提示输入<strong>账号密码</strong>。这次输入账号密码之后，就会<strong>记住</strong>账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。<br><img src="/../../imgs/Pasted%20image%2020240101145902.png"></p><h3 id="2、单项目免密码配置"><a href="#2、单项目免密码配置" class="headerlink" title="2、单项目免密码配置"></a>2、单项目免密码配置</h3><p>编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]<br>url = https://gitee.com/xxx/xxx.git<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]   <br>url = https://yourusername:password@gitee.com/xxx/xxxx.git<br></code></pre></td></tr></table></figure><p>也就是在 <code>https://</code> 之后，增加 <code>用户名:密码@</code></p><h1 id="二-SSH免密登录"><a href="#二-SSH免密登录" class="headerlink" title="二. SSH免密登录"></a>二. SSH免密登录</h1><p>如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式,</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote rm origin<br></code></pre></td></tr></table></figure><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>github 网页增加本机SSH key</p><p>git ssh 方式免密提交方式需要将 <code>ssh-keygen</code> 生成的公钥放到服务器上</p><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot; <br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置 ssh 远程项目地址。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 如果是新仓库需要git init ;否则不需要git init; git init<br># git 关联远程仓库<br>git remote add origin git@gitee.com:xxx/xxx.git<br></code></pre></td></tr></table></figure><h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><p>1、首先需要检查你电脑是否已经有 SSH key</p><p>运行 git Bash 客户端，检查本机的ssh密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">$ cd ~/.ssh <br>$ ls<br></code></pre></td></tr></table></figure><p>如果提示：No such file or directory ，说明是第一次使用 git。</p><p>如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ mkdir key_backup   <br>$ cp id_rsa* key_backup   <br>$ rm id_rsa*<br></code></pre></td></tr></table></figure><p>2、执行生成公钥和私钥的命令，生成新的密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;xxx&quot;<br></code></pre></td></tr></table></figure><p>代码参数：</p><p>-t 指定密钥类型，默认是 rsa ，可以省略。</p><p>-C 设置注释文字，比如邮箱。</p><p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p><p>按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p><p>执行查看公钥信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>Windows 系统，位置在用户目录下 .ssh文件夹中。<code>%USERPROFILE%</code></p><h2 id="复制公钥信息到远端仓库"><a href="#复制公钥信息到远端仓库" class="headerlink" title="复制公钥信息到远端仓库"></a>复制公钥信息到远端仓库</h2><p><strong>gitee</strong><br>打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p><p><img src="https://pic3.zhimg.com/80/v2-8c26fae5769cb56da5e20c884a33c702_720w.webp"></p><p><strong>github</strong><br>Settings -SSH and GPG keys - New SSH key<br><img src="app://db738d3bb1089e4d04f6eb022a68209f31bf/D:/obsidian_note/LeiQi_Blog/source/imgs/Pasted%20image%2020240101151324.png?1704093204312"><br>然后，提交时就不再需要用户名和密码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">git add -A<br>git commit -m &quot;ssh免密提交&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/358721423">https://zhuanlan.zhihu.com/p/358721423</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍之前&quot;&gt;&lt;a href=&quot;#介绍之前&quot; class=&quot;headerlink&quot; title=&quot;介绍之前&quot;&gt;&lt;/a&gt;介绍之前&lt;/h1&gt;&lt;p&gt;我们要首先知道一个简单的概念:&lt;br&gt;https通过&lt;strong&gt;记住账号密码免登&lt;/strong&gt;，ssh通过&lt;stro</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows设置Clion 下方Terminal为WSL linux 子系统</title>
    <link href="https://leiqichn.github.io/2023-12-30-397a0b919639.html"/>
    <id>https://leiqichn.github.io/2023-12-30-397a0b919639.html</id>
    <published>2023-12-30T15:49:39.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端上的小箭头下的设置"><a href="#终端上的小箭头下的设置" class="headerlink" title="终端上的小箭头下的设置"></a>终端上的小箭头下的设置</h1><p><img src="/../../imgs/Pasted%20image%2020231230235906.png"><br><img src="/../../imgs/Pasted%20image%2020231230234942.png"></p><h1 id="找到WSL的地址"><a href="#找到WSL的地址" class="headerlink" title="找到WSL的地址"></a>找到WSL的地址</h1><p><img src="/../../imgs/Pasted%20image%2020231231000039.png"></p><p>粘贴到对应地址中<br><img src="/../../imgs/Pasted%20image%2020231231000121.png"></p><h1 id="设置成功"><a href="#设置成功" class="headerlink" title="设置成功"></a>设置成功</h1><p>这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端上的小箭头下的设置&quot;&gt;&lt;a href=&quot;#终端上的小箭头下的设置&quot; class=&quot;headerlink&quot; title=&quot;终端上的小箭头下的设置&quot;&gt;&lt;/a&gt;终端上的小箭头下的设置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20ima</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>免费使用Jetbrain 全家桶-服务器激活码激活软件</title>
    <link href="https://leiqichn.github.io/2023-12-30-6a1e804ab992.html"/>
    <id>https://leiqichn.github.io/2023-12-30-6a1e804ab992.html</id>
    <published>2023-12-30T15:08:29.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.</p><p>Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。</p><ul><li><a href="https://search.censys.io/">https://search.censys.io/</a>     搜索：<code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></li><li><a href="https://www.shodan.io/">https://www.shodan.io</a>  搜索：<br><code>Location: https://account.jetbrains.com/fls-auth</code></li><li><a href="https://fofa.info/">https://fofa.info/</a>     搜索：<code>fls-auth</code></li></ul><p>随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是<a href="https://search.censys.io/">https://search.censys.io/</a> 网站, 搜索 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">services<span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.location</span>: account<span class="hljs-selector-class">.jetbrains</span>.com/fls-auth<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020231230231034.png"><br>例如上边就是 <a href="http://111.231.22.61:1024/">http://111.231.22.61:1024</a></p><p><img src="/../../imgs/Pasted%20image%2020231230231326.png"></p><h1 id="激活成功"><a href="#激活成功" class="headerlink" title="激活成功"></a>激活成功</h1><p>激活成功，请开始愉快的编码吧！<br><img src="/../../imgs/Pasted%20image%2020231230231349.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.&lt;/p&gt;
&lt;p&gt;Jetbrain 是针对公</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>WPS设置打开文件自动同步云文档</title>
    <link href="https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html"/>
    <id>https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html</id>
    <published>2023-12-30T14:08:47.000Z</published>
    <updated>2024-04-06T13:15:18.320Z</updated>
    
    <content type="html"><![CDATA[<p>不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。<br>WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：</p><h1 id="打开首页，设置中心"><a href="#打开首页，设置中心" class="headerlink" title="打开首页，设置中心"></a>打开首页，设置中心</h1><p><img src="/../../imgs/Pasted%20image%2020231230221037.png"></p><p><img src="/../../imgs/Pasted%20image%2020231230220856.png"></p><h1 id="打开新文件会自动上传更新"><a href="#打开新文件会自动上传更新" class="headerlink" title="打开新文件会自动上传更新"></a>打开新文件会自动上传更新</h1><p><img src="/../../imgs/Pasted%20image%2020231230221311.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。&lt;br&gt;WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：&lt;/p&gt;
&lt;h1 id=&quot;打开首页，设置中心&quot;&gt;&lt;a href=&quot;#打开首页，设置中心&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git强制拉取远端</title>
    <link href="https://leiqichn.github.io/2023-10-22-9bf76366f18c.html"/>
    <id>https://leiqichn.github.io/2023-10-22-9bf76366f18c.html</id>
    <published>2023-10-22T09:53:57.000Z</published>
    <updated>2024-04-06T13:15:18.316Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/&lt;branch_name&gt;<br></code></pre></td></tr></table></figure><p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p><p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p><p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p><p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
</feed>
