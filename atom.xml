<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-11-13T15:50:11.685Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Git】Git代理配置</title>
    <link href="https://leiqi.top/2025-11-13-3d86348f7e48.html"/>
    <id>https://leiqi.top/2025-11-13-3d86348f7e48.html</id>
    <published>2025-11-13T15:24:53.000Z</published>
    <updated>2025-11-13T15:50:11.685Z</updated>
    
    <content type="html"><![CDATA[<p>配置 Git 插件使用代理，有几种方法可以实现：</p><h2 id="方法一：通过-Git-全局配置代理（推荐）"><a href="#方法一：通过-Git-全局配置代理（推荐）" class="headerlink" title="方法一：通过 Git 全局配置代理（推荐）"></a>方法一：通过 Git 全局配置代理（推荐）</h2><p>在终端中执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 Git 全局代理</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7897</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7897</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要设置不使用代理的地址（如内网地址）</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7897</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7897</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置是否生效</span></span><br><span class="line">git config --global --list | grep proxy</span><br></pre></td></tr></table></figure><h2 id="方法二：为特定仓库配置代理"><a href="#方法二：为特定仓库配置代理" class="headerlink" title="方法二：为特定仓库配置代理"></a>方法二：为特定仓库配置代理</h2><p>如果只想为 Obsidian 仓库设置代理，进入仓库目录后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/obsidian/vault</span><br><span class="line">git config http.proxy http://127.0.0.1:7897</span><br><span class="line">git config https.proxy http://127.0.0.1:7897</span><br></pre></td></tr></table></figure><h2 id="方法三：通过环境变量（临时方案）"><a href="#方法三：通过环境变量（临时方案）" class="headerlink" title="方法三：通过环境变量（临时方案）"></a>方法三：通过环境变量（临时方案）</h2><p>创建启动脚本，在启动 Obsidian 前设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建启动脚本 obsidian-with-proxy.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="comment"># 启动 Obsidian（路径根据实际情况调整）</span></span><br><span class="line">open /Applications/Obsidian.app</span><br></pre></td></tr></table></figure><h2 id="方法四：优化-alias"><a href="#方法四：优化-alias" class="headerlink" title="方法四：优化 alias"></a>方法四：优化 alias</h2><p>将您的 alias 扩展为更完整的功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加到 ~/.bashrc 或 ~/.zshrc</span></span><br><span class="line"><span class="built_in">alias</span> proxyon=<span class="string">&#x27;export http_proxy=http://127.0.0.1:7897 https_proxy=http://127.0.0.1:7897; git config --global http.proxy http://127.0.0.1:7897; git config --global https.proxy http://127.0.0.1:7897&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> proxyoff=<span class="string">&#x27;unset http_proxy https_proxy; git config --global --unset http.proxy; git config --global --unset https.proxy&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> proxyinfo=<span class="string">&#x27;echo &quot;HTTP Proxy: $http_proxy&quot;; echo &quot;HTTPS Proxy: $https_proxy&quot;; git config --global --get http.proxy; git config --global --get https.proxy&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="方法五：验证代理是否生效"><a href="#方法五：验证代理是否生效" class="headerlink" title="方法五：验证代理是否生效"></a>方法五：验证代理是否生效</h2><p>配置完成后，可以通过以下命令测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试 Git 连接</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/username/test-repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 curl 测试</span></span><br><span class="line">curl -I --proxy http://127.0.0.1:7897 https://github.com</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>端口号确认</strong>：确保 <code>7897</code> 代理软件的实际端口</li><li><strong>代理协议</strong>：根据您的代理类型，可能需要使用 <code>socks5://</code> 而不是 <code>http://</code></li><li><strong>排除内网地址</strong>：如果需要访问内网 Git 仓库，可以设置排除规则：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7897</span><br><span class="line">git config --global http.<span class="string">&quot;https://github.com&quot;</span>.proxy <span class="string">&quot;&quot;</span>  <span class="comment"># GitHub 不使用代理</span></span><br></pre></td></tr></table></figure><p>推荐使用<strong>方法一和二</strong>，因为 Git 插件会直接读取 Git 的配置，这样设置后  Git 插件就会自动使用代理进行网络操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置 Git 插件使用代理，有几种方法可以实现：&lt;/p&gt;
&lt;h2 id=&quot;方法一：通过-Git-全局配置代理（推荐）&quot;&gt;&lt;a href=&quot;#方法一：通过-Git-全局配置代理（推荐）&quot; class=&quot;headerlink&quot; title=&quot;方法一：通过 Git 全局配置代理（</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="https://leiqi.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【Golang】滑动窗口总结</title>
    <link href="https://leiqi.top/2025-11-13-ea801c9c4aea.html"/>
    <id>https://leiqi.top/2025-11-13-ea801c9c4aea.html</id>
    <published>2025-11-13T15:04:26.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针与滑动窗口算法总结"><a href="#双指针与滑动窗口算法总结" class="headerlink" title="双指针与滑动窗口算法总结"></a>双指针与滑动窗口算法总结</h1><h2 id="一、核心思想"><a href="#一、核心思想" class="headerlink" title="一、核心思想"></a>一、核心思想</h2><h3 id="双指针-Two-Pointers"><a href="#双指针-Two-Pointers" class="headerlink" title="双指针 (Two Pointers)"></a>双指针 (Two Pointers)</h3><ul><li><strong>思想</strong>：使用两个指针在序列中按特定规则移动，避免暴力枚举</li><li><strong>特点</strong>：通常时间复杂度从 O(n²) 优化到 O(n)</li></ul><h3 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口 (Sliding Window)"></a>滑动窗口 (Sliding Window)</h3><ul><li><strong>思想</strong>：维护一个动态的窗口，通过移动左右边界来寻找最优解</li><li><strong>特点</strong>：窗口大小可能固定或可变</li></ul><h2 id="二、通用模板"><a href="#二、通用模板" class="headerlink" title="二、通用模板"></a>二、通用模板</h2><h3 id="1-滑动窗口通用模板"><a href="#1-滑动窗口通用模板" class="headerlink" title="1. 滑动窗口通用模板"></a>1. 滑动窗口通用模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    count := <span class="number">0</span> <span class="comment">// 或使用map记录窗口内元素</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        <span class="comment">// 右指针扩张，更新窗口状态</span></span><br><span class="line">        count = updateCount(count, nums[right], +<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩窗口条件</span></span><br><span class="line">        <span class="keyword">for</span> windowNeedShrink(left, right, count, k) &#123;</span><br><span class="line">            <span class="comment">// 左指针收缩，更新窗口状态</span></span><br><span class="line">            count = updateCount(count, nums[left], <span class="number">-1</span>)</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新结果（注意边界处理）</span></span><br><span class="line">        <span class="keyword">if</span> windowValid(left, right, count, k) &#123;</span><br><span class="line">            result = updateResult(result, left, right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-双指针通用模板"><a href="#2-双指针通用模板" class="headerlink" title="2. 双指针通用模板"></a>2. 双指针通用模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoPointers</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        sum := nums[left] + nums[right]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="comment">// 找到解</span></span><br><span class="line">            result = updateResult(result, left, right)</span><br><span class="line">            left++ <span class="comment">// 或 right-- 根据具体情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、常见题型分类"><a href="#三、常见题型分类" class="headerlink" title="三、常见题型分类"></a>三、常见题型分类</h2><h3 id="1-固定长度窗口"><a href="#1-固定长度窗口" class="headerlink" title="1. 固定长度窗口"></a>1. 固定长度窗口</h3><p><strong>特点</strong>：窗口大小固定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：大小为k的子数组最大和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    maxSum := sum</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        sum = sum - nums[i-k] + nums[i]</span><br><span class="line">        maxSum = max(maxSum, sum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-可变长度窗口（最常用）"><a href="#2-可变长度窗口（最常用）" class="headerlink" title="2. 可变长度窗口（最常用）"></a>2. 可变长度窗口（最常用）</h3><p><strong>特点</strong>：窗口大小根据条件动态变化</p><h4 id="A-最多包含K个某类元素"><a href="#A-最多包含K个某类元素" class="headerlink" title="A. 最多包含K个某类元素"></a>A. 最多包含K个某类元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长包含最多K个0的子数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atMostK</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, zeroCount, maxLen := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span> &#123;</span><br><span class="line">            zeroCount++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> zeroCount &gt; k &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span> &#123;</span><br><span class="line">                zeroCount--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxLen = max(maxLen, right-left+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-恰好包含K个某类元素"><a href="#B-恰好包含K个某类元素" class="headerlink" title="B. 恰好包含K个某类元素"></a>B. 恰好包含K个某类元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exactlyK</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atMostK(nums, k) - atMostK(nums, k<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-快慢指针"><a href="#3-快慢指针" class="headerlink" title="3. 快慢指针"></a>3. 快慢指针</h3><p><strong>特点</strong>：处理环形数组、链表环检测等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowFastPointer</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    slow, fast := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[fast] != <span class="number">0</span> &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 有环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键细节与技巧"><a href="#四、关键细节与技巧" class="headerlink" title="四、关键细节与技巧"></a>四、关键细节与技巧</h2><h3 id="1-结果计算时机"><a href="#1-结果计算时机" class="headerlink" title="1. 结果计算时机"></a>1. 结果计算时机</h3><ul><li><strong>窗口扩张后</strong>：立即计算（如求最大值）</li><li><strong>窗口收缩后</strong>：满足条件时计算（如求最小值）</li></ul><h3 id="2-边界处理"><a href="#2-边界处理" class="headerlink" title="2. 边界处理"></a>2. 边界处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：是否需要 +1 取决于问题定义</span></span><br><span class="line">res = max(res, right-left)    <span class="comment">// 区间长度 = right - left</span></span><br><span class="line">res = max(res, right-left+<span class="number">1</span>)  <span class="comment">// 区间长度 = right - left + 1</span></span><br></pre></td></tr></table></figure><h3 id="3-收缩条件"><a href="#3-收缩条件" class="headerlink" title="3. 收缩条件"></a>3. 收缩条件</h3><ul><li><code>while</code> vs <code>if</code>：通常用 <code>while</code> 确保窗口始终有效</li><li>收缩时机：根据问题要求决定何时收缩</li></ul><h2 id="五、经典问题映射"><a href="#五、经典问题映射" class="headerlink" title="五、经典问题映射"></a>五、经典问题映射</h2><table><thead><tr><th>问题类型</th><th>窗口条件</th><th>结果计算</th></tr></thead><tbody><tr><td>无重复字符的最长子串</td><td>字符计数 ≤ 1</td><td>right-left+1</td></tr><tr><td>最小覆盖子串</td><td>包含所有目标字符</td><td>right-left+1</td></tr><tr><td>最大连续1的个数III</td><td>0的个数 ≤ K</td><td>right-left+1</td></tr><tr><td>长度最小的子数组</td><td>和 ≥ target</td><td>right-left+1</td></tr><tr><td>删除一个元素后全1数组</td><td>0的个数 ≤ 1</td><td>right-left</td></tr></tbody></table><h2 id="六、复杂度分析"><a href="#六、复杂度分析" class="headerlink" title="六、复杂度分析"></a>六、复杂度分析</h2><ul><li><strong>时间复杂度</strong>：O(n)，每个元素最多被左右指针各访问一次</li><li><strong>空间复杂度</strong>：O(1) 或 O(k)，取决于使用的数据结构</li></ul><h2 id="七、实战技巧"><a href="#七、实战技巧" class="headerlink" title="七、实战技巧"></a>七、实战技巧</h2><ol><li><strong>先确定窗口维护什么</strong>：计数、和、唯一性等</li><li><strong>明确收缩条件</strong>：什么情况下需要移动左指针</li><li><strong>注意结果更新时机</strong>：在收缩前、收缩后还是循环外</li><li><strong>处理边界情况</strong>：空数组、全符合条件、全不符合条件</li></ol><p>掌握这些模板和思路，就能应对大多数双指针和滑动窗口问题, 欢迎交流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针与滑动窗口算法总结&quot;&gt;&lt;a href=&quot;#双指针与滑动窗口算法总结&quot; class=&quot;headerlink&quot; title=&quot;双指针与滑动窗口算法总结&quot;&gt;&lt;/a&gt;双指针与滑动窗口算法总结&lt;/h1&gt;&lt;h2 id=&quot;一、核心思想&quot;&gt;&lt;a href=&quot;#一、核心思想&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Dijkstra算法实现带权重最短路径</title>
    <link href="https://leiqi.top/2025-08-07-e9a26e827379.html"/>
    <id>https://leiqi.top/2025-08-07-e9a26e827379.html</id>
    <published>2025-08-07T15:47:53.000Z</published>
    <updated>2025-11-13T15:50:11.680Z</updated>
    
    <content type="html"><![CDATA[<p>以下是使用 Dijkstra 算法解决带权重最短路径问题的 Golang 实现（以 LeetCode 743 “网络延迟时间” 为例）。该算法通过优先队列（最小堆）高效地寻找单源最短路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列元素结构</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">node     <span class="type">int</span> <span class="comment">// 节点编号</span></span><br><span class="line">distance <span class="type">int</span> <span class="comment">// 从起点到该节点的距离</span></span><br><span class="line">index    <span class="type">int</span> <span class="comment">// 在堆中的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列（最小堆）</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pq[i].distance &lt; pq[j].distance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = i</span><br><span class="line">pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*Item)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">old[n<span class="number">-1</span>] = <span class="literal">nil</span>  <span class="comment">// 避免内存泄漏</span></span><br><span class="line">item.index = <span class="number">-1</span> <span class="comment">// 标记已移除</span></span><br><span class="line">*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra 算法主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">networkDelayTime</span><span class="params">(times [][]<span class="type">int</span>, n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 构建图的邻接表</span></span><br><span class="line">graph := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][][<span class="number">2</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, time := <span class="keyword">range</span> times &#123;</span><br><span class="line">u, v, w := time[<span class="number">0</span>], time[<span class="number">1</span>], time[<span class="number">2</span>]</span><br><span class="line">graph[u] = <span class="built_in">append</span>(graph[u], [<span class="number">2</span>]<span class="type">int</span>&#123;v, w&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化距离数组</span></span><br><span class="line">dist := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dist &#123;</span><br><span class="line">dist[i] = math.MaxInt32</span><br><span class="line">&#125;</span><br><span class="line">dist[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化优先队列</span></span><br><span class="line">pq := <span class="built_in">make</span>(PriorityQueue, <span class="number">0</span>)</span><br><span class="line">heap.Push(&amp;pq, &amp;Item&#123;node: k, distance: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra 算法核心</span></span><br><span class="line"><span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">u := item.node</span><br><span class="line">d := item.distance</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过已处理的节点</span></span><br><span class="line"><span class="keyword">if</span> d &gt; dist[u] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历邻居节点</span></span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> graph[u] &#123;</span><br><span class="line">v, w := edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">newDist := d + w</span><br><span class="line"><span class="comment">// 发现更短路径</span></span><br><span class="line"><span class="keyword">if</span> newDist &lt; dist[v] &#123;</span><br><span class="line">dist[v] = newDist</span><br><span class="line">heap.Push(&amp;pq, &amp;Item&#123;node: v, distance: newDist&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找最大距离</span></span><br><span class="line">maxTime := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> dist[i] == math.MaxInt32 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 存在不可达节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dist[i] &gt; maxTime &#123;</span><br><span class="line">maxTime = dist[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法说明："><a href="#算法说明：" class="headerlink" title="算法说明："></a>算法说明：</h3><ol><li><strong>图表示</strong>：使用邻接表 <code>map[int][][2]int</code> 存储图结构，键为源节点，值为目标节点和权重的二元组</li><li><strong>距离数组</strong>：<code>dist</code> 数组记录起点到各节点的最短距离，初始化为最大值（除起点为0）</li><li><strong>优先队列</strong>：<ul><li>实现最小堆，按距离排序</li><li>初始将起点 (距离&#x3D;0) 入队</li></ul></li><li><strong>核心流程</strong>：<ul><li>弹出当前距离最小的节点</li><li>若该节点距离已过期则跳过（由于堆不支持修改，可能有多个版本）</li><li>遍历邻居节点，若发现更短路径则更新距离并入队</li></ul></li><li><strong>结果处理</strong>：<ul><li>遍历 <code>dist</code> 数组，若有节点不可达（距离仍为最大值）则返回 -1</li><li>否则返回最大距离值</li></ul></li></ol><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul><li><strong>时间复杂度</strong>：O(E log V)，其中 E 是边数，V 是节点数（每个边最多入队一次，堆操作 O(log V)）</li><li><strong>空间复杂度</strong>：O(V + E)（存储图和距离数组）</li></ul><p>此实现严格遵循 Dijkstra 算法，适用于解决带非负权重的有向图单源最短路径问题。在 LeetCode 743 中，函数返回使所有节点收到信号所需的时间（即最短路径的最大值），若有节点不可达则返回 -1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是使用 Dijkstra 算法解决带权重最短路径问题的 Golang 实现（以 LeetCode 743 “网络延迟时间” 为例）。该算法通过优先队列（最小堆）高效地寻找单源最短路径：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【新开发】GoToDo 四象限法待办谷歌插件</title>
    <link href="https://leiqi.top/2025-07-31-c1ada6c33858.html"/>
    <id>https://leiqi.top/2025-07-31-c1ada6c33858.html</id>
    <published>2025-07-31T15:25:28.000Z</published>
    <updated>2025-11-13T15:50:11.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GOTODO"><a href="#GOTODO" class="headerlink" title="GOTODO"></a>GOTODO</h1><blockquote><p>四象限法 TODO 管理 Chrome 插件<br>Eisenhower Matrix TODO Chrome Extension</p></blockquote><hr><h2 id="项目简介-Introduction"><a href="#项目简介-Introduction" class="headerlink" title="项目简介 | Introduction"></a>项目简介 | Introduction</h2><p>GOTODO 是一个基于四象限法（重要紧急矩阵&#x2F;Eisenhower Matrix）的 TODO 管理 Chrome 插件，帮助你高效管理任务，聚焦真正重要的事情。支持任务添加、优先级分类、象限视图、日视图、任务排序等功能。</p><p>GOTODO is a Chrome extension for managing your tasks using the Eisenhower Matrix (Important&#x2F;Urgent Quadrant). It helps you focus on what really matters. Features include task add&#x2F;edit, priority classification, quadrant view, day view, and task sorting.</p><p><img src="/../../imgs/Pasted%20image%2020250731233159.png"><br><img src="/../../imgs/Pasted%20image%2020250731233210.png"></p><hr><h2 id="主要功能-Features"><a href="#主要功能-Features" class="headerlink" title="主要功能 | Features"></a>主要功能 | Features</h2><ul><li>添加 TODO（名称、描述、优先级、截止时间）</li><li>四象限法分类（重要紧急、重要不紧急、紧急不重要、不重要不紧急）</li><li>总览模式（列表）与日模式（象限图）切换</li><li>TODO 项上下移动排序</li><li>本地持久化存储（无需账号）</li><li>简洁美观的界面</li></ul><hr><h2 id="安装与使用-Installation-Usage"><a href="#安装与使用-Installation-Usage" class="headerlink" title="安装与使用 | Installation &amp; Usage"></a>安装与使用 | Installation &amp; Usage</h2><ol><li><strong>下载插件安装包</strong><ul><li>前往 <a href="https://github.com/leiqichn/GOTODO/releases">Releases 页面</a> 下载最新的 <code>GOTODO-V1.0.0.zip</code> 文件。</li></ul></li><li><strong>解压安装包</strong><ul><li>右键压缩包，选择“解压到当前文件夹”或“解压到 GOTODO”</li></ul></li><li><strong>加载插件到 Chrome</strong><ul><li>打开 Chrome，访问 <code>chrome://extensions/</code></li><li>开启右上角“开发者模式”</li><li>点击“加载已解压的扩展程序”</li><li>选择刚刚解压出来的文件夹（里面应包含 manifest.json、index.html、assets 等文件）</li><li>安装完成后，浏览器右上角会出现 GOTODO 图标，点击即可使用</li></ul></li></ol><hr><h2 id="开发与构建-Development-Build"><a href="#开发与构建-Development-Build" class="headerlink" title="开发与构建 | Development &amp; Build"></a>开发与构建 | Development &amp; Build</h2><ul><li>开发预览：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line"><span class="comment"># 访问 http://localhost:5173 预览页面</span></span><br></pre></td></tr></table></figure></li><li>构建打包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment"># 生成 dist 目录，供 Chrome 加载</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="技术栈-Tech-Stack"><a href="#技术栈-Tech-Stack" class="headerlink" title="技术栈 | Tech Stack"></a>技术栈 | Tech Stack</h2><ul><li>React 18</li><li>TypeScript</li><li>Vite 4</li><li>Chrome Extension Manifest V3</li></ul><hr><h2 id="目录结构-Directory-Structure"><a href="#目录结构-Directory-Structure" class="headerlink" title="目录结构 | Directory Structure"></a>目录结构 | Directory Structure</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GOTODO/</span><br><span class="line">├─ public/           # 静态资源（如 icon.png）</span><br><span class="line">├─ src/              # 源码</span><br><span class="line">│  ├─ components/    # 组件</span><br><span class="line">│  ├─ App.tsx</span><br><span class="line">│  ├─ main.tsx</span><br><span class="line">│  ├─ storage.ts</span><br><span class="line">│  └─ types.ts</span><br><span class="line">├─ manifest.json     # 插件清单</span><br><span class="line">├─ index.html        # 入口页面</span><br><span class="line">├─ package.json</span><br><span class="line">├─ vite.config.ts</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><hr><h2 id="贡献-Contributing"><a href="#贡献-Contributing" class="headerlink" title="贡献 | Contributing"></a>贡献 | Contributing</h2><p><a href="https://github.com/leiqichn">https://github.com/leiqichn</a><br>欢迎 PR 和 Issue！如有建议或 bug，欢迎提交。</p><p>Pull requests and issues are welcome!</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GOTODO&quot;&gt;&lt;a href=&quot;#GOTODO&quot; class=&quot;headerlink&quot; title=&quot;GOTODO&quot;&gt;&lt;/a&gt;GOTODO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;四象限法 TODO 管理 Chrome 插件&lt;br&gt;Eisenhower Matr</summary>
      
    
    
    
    <category term="作品集" scheme="https://leiqi.top/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>【工具】7小时代码编写机器claude code 安装</title>
    <link href="https://leiqi.top/2025-07-29-f4ab9b8e573f.html"/>
    <id>https://leiqi.top/2025-07-29-f4ab9b8e573f.html</id>
    <published>2025-07-29T16:24:23.000Z</published>
    <updated>2025-11-13T15:50:11.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Node-macOS-用户"><a href="#安装Node-macOS-用户" class="headerlink" title="安装Node macOS 用户"></a>安装Node macOS 用户</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select --install # 安装 Xcode 命令行工具</span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; # 安装 Homebrew</span><br><span class="line">brew install node</span><br><span class="line">node --version</span><br></pre></td></tr></table></figure><p>18版本以上即可</p><h2 id="安装-Claude-Code"><a href="#安装-Claude-Code" class="headerlink" title="安装 Claude Code"></a>安装 Claude Code</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @anthropic-ai/claude-code</span><br></pre></td></tr></table></figure><p>验证是否成功</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">claude --version</span><br></pre></td></tr></table></figure><h1 id="大功告成-启动！"><a href="#大功告成-启动！" class="headerlink" title="大功告成 启动！"></a>大功告成 启动！</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">claude</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../../imgs/%E6%88%AA%E5%B1%8F2025-07-30%20%E4%B8%8A%E5%8D%8812.27.40.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Node-macOS-用户&quot;&gt;&lt;a href=&quot;#安装Node-macOS-用户&quot; class=&quot;headerlink&quot; title=&quot;安装Node macOS 用户&quot;&gt;&lt;/a&gt;安装Node macOS 用户&lt;/h2&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>英文输入时再也不打出中文标点啦</title>
    <link href="https://leiqi.top/2025-07-23-c43371daa575.html"/>
    <id>https://leiqi.top/2025-07-23-c43371daa575.html</id>
    <published>2025-07-23T15:17:33.000Z</published>
    <updated>2025-11-13T15:50:11.686Z</updated>
    
    <content type="html"><![CDATA[<p>以微软拼音为例, 需要打开 <code>中文输入时使用英文标点</code><br><img src="/../../imgs/Pasted%20image%2020250723231812.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以微软拼音为例, 需要打开 &lt;code&gt;中文输入时使用英文标点&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250723231812.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【算法】链表</title>
    <link href="https://leiqi.top/2025-07-18-238daccb5ae9.html"/>
    <id>https://leiqi.top/2025-07-18-238daccb5ae9.html</id>
    <published>2025-07-18T15:22:31.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<p>   <code>206.</code>  反转链表 <a href="https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5zy/">https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5zy/</a><br>   <code>92.</code> 反转链表 II <a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-teqq/">https://leetcode.cn/problems/reverse-linked-list-ii/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-teqq/</a><br>   <code>25.</code> K 个一组翻转链表 <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/">https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;   &lt;code&gt;206.&lt;/code&gt;  反转链表 &lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【算法】二分法</title>
    <link href="https://leiqi.top/2025-07-10-ee05a539b560.html"/>
    <id>https://leiqi.top/2025-07-10-ee05a539b560.html</id>
    <published>2025-07-10T15:52:10.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<p>转化方式：<br><img src="/../../imgs/Pasted%20image%2020250710235247.png"><br>  <code>&gt;=x</code>  使用sort.SearchInts(nums, x)<br> <code>&gt;x</code> 使用 sort.SearchInts(nums, x+1)<br> <code>&lt;x</code> 使用sort.SearchInts(nums, x) -1<br> <code>&lt;=</code> 使用sort.SearchInts(nums, x +1) -1</p><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020250710235340.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right - left)/ <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2529-正整数和负整数的最大计数"><a href="#2529-正整数和负整数的最大计数" class="headerlink" title="2529. 正整数和负整数的最大计数"></a><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">2529. 正整数和负整数的最大计数</a></h1><p><img src="/../../imgs/Pasted%20image%2020250710235425.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumCount</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 返回反照非低价顺序排列的数组 nums ， 返回正整数数目和负整数数目中的最大值</span></span><br><span class="line"><span class="comment">// pos neg pos neg max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 &gt;0 =》 &gt;= target + 1 ;  &lt;0   &gt;=(target) -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 负整数个数：第一个大于等于0的索引位置（即所有小于0的元素数量）</span></span><br><span class="line">    negCount := sort.SearchInts(nums, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正整数个数：总长度减去第一个大于等于1的索引位置</span></span><br><span class="line">    posCount := n - sort.SearchInts(nums, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> negCount &gt; posCount &#123;</span><br><span class="line">        <span class="keyword">return</span> negCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1385-两个数组间的距离值"><a href="#1385-两个数组间的距离值" class="headerlink" title="1385. 两个数组间的距离值"></a><a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/">1385. 两个数组间的距离值</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func findTheDistanceValue(arr1, arr2 []<span class="built_in">int</span>, d <span class="built_in">int</span>) (ans <span class="built_in">int</span>) &#123;</span><br><span class="line">    sort.Ints(arr2)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="built_in">range</span> arr1 &#123;</span><br><span class="line">        i := sort.SearchInts(arr2, x - d) // </span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(arr2) || arr2[i] &gt; x + d &#123; // 不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d， 即都不在[x - d, x + d] 之间， 所以不能使用arr2[i] &gt;= x + d</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>  <span class="comment">// 左闭右闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;             <span class="comment">// 终止条件：left == right</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &#123;</span><br><span class="line">            right = mid           <span class="comment">// 最小值在 [left, mid]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>       <span class="comment">// 最小值在 [mid + 1, right]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]             <span class="comment">// 此时 left == right，指向最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(nums) <span class="number">-1</span> <span class="comment">// 左开右闭区间 (left, right]</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123;</span><br><span class="line">        mid := left + (right - left) /<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250717232854.png"></p><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p><img src="/../../imgs/Pasted%20image%2020250718000347.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    end := nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x := nums[i]</span><br><span class="line">        <span class="keyword">if</span> x &gt; end &#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; end &amp;&amp; x &gt;= target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target &gt; end || x &gt;= target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 开区间 (-1, n-1)</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123; <span class="comment">// 开区间不为空</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[right] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> <ol start="34"><li>在排序数组中查找元素的第一个和最后一个位置 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/</a><br>课后作业：</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2529"><li>正整数和负整数的最大计数 <a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2300"><li>咒语和药水的成功对数 <a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2563"><li>统计公平数对的数目 <a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">https://leetcode.cn/problems/count-the-number-of-fair-pairs/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="275"><li>H 指数 II <a href="https://leetcode.cn/problems/h-index-ii/">https://leetcode.cn/problems/h-index-ii/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="875"><li>爱吃香蕉的珂珂 <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2187"><li>完成旅途的最少时间 <a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/">https://leetcode.cn/problems/minimum-time-to-complete-trips/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2861"><li>最大合金数 <a href="https://leetcode.cn/problems/maximum-number-of-alloys/">https://leetcode.cn/problems/maximum-number-of-alloys/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2439"><li>最小化数组中的最大值 <a href="https://leetcode.cn/problems/minimize-maximum-of-array/">https://leetcode.cn/problems/minimize-maximum-of-array/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2517"><li>礼盒的最大甜蜜度 <a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/">https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转化方式：&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250710235247.png&quot;&gt;&lt;br&gt;  &lt;code&gt;&amp;gt;=x&lt;/code&gt;  使用sort.SearchInts(nums, x)&lt;br&gt; &lt;code&gt;&amp;gt;x</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go24种设计模式--创建型模式</title>
    <link href="https://leiqi.top/2025-07-09-7705ca14d931.html"/>
    <id>https://leiqi.top/2025-07-09-7705ca14d931.html</id>
    <published>2025-07-09T16:10:38.000Z</published>
    <updated>2025-11-13T15:50:11.687Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design Pattern）是软件工程中针对常见问题的通用解决方案。</p><p>它们不是具体的代码，而是经过验证的最佳实践，帮助开发者设计出灵活、可维护和可扩展的软件系统</p><h2 id="使用设计模式的好处"><a href="#使用设计模式的好处" class="headerlink" title="使用设计模式的好处"></a>使用设计模式的好处</h2><ol><li>面试</li><li>提高代码复用性，写出高质量代码</li><li>前人总结的最佳实践，在合适的地方用合适的设计模式，可以事半功倍</li></ol><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>在 Go 语言中，创建型模式（Creational Patterns）是一类用于处理对象创建的设计模式。它们的主要目标是提供一种灵活的方式来创建对象，同时隐藏对象创建的具体细节，从而降低代码的耦合度，并提高代码的可复用性和可维护性。</p><p>比如<code>http.NewRequest()</code>，<code>bytes.NewReader()</code>，<code>md5.New()</code></p><p>创建型模式的核心思想是将对象的创建与使用分离，使得系统不依赖于具体的对象创建方式，而是依赖于抽象。</p><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><p>确保一个类只有一个实例，并提供一个全局访问点。</p><p>适用场景：</p><ul><li>配置管理、日志记录、数据库连接池等需要全局唯一实例的场景。</li></ul><p>之前在项目里面，我们之前一直在用的global.DB，global.Config其实和这个差不多，但是它不是单例模式，因为是直接使用的对应的对象，而不是通过函数返回的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">  db = &amp;DB&#123;</span><br><span class="line">    Database: <span class="string">&quot;fengfeng&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := db</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前是直接使用全局变量，但是这个变量是存在为nil的情况的，这种情况下再使用它就是为出现空指针的情况</p><p><img src="https://image.fengfengzhidao.com/rj_102520250107110801.png"></p><p>那么可以使用一个函数，在里面判断一下，如果这个对象是nil，就去初始化对象，后续如果有的话，就直接返回之前的那个创建好的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *DB</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">  once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db = &amp;DB&#123;</span><br><span class="line">      Database: <span class="string">&quot;fengfeng&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := GetDB()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">  d = GetDB()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式 Simple Factory Pattern"></a>简单工厂模式 <strong>Simple Factory Pattern</strong></h3><p>它们的目标都是将对象的创建与使用分离，从而降低代码的耦合度</p><p>但是具体的工厂还是有区别</p><table><thead><tr><th>模式</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>简单工厂</strong></td><td>一个工厂类负责创建所有产品，通过条件判断决定创建哪种产品。</td><td>产品种类较少，创建逻辑简单。</td></tr><tr><td><strong>工厂方法模式</strong></td><td>每个产品对应一个工厂类，符合开闭原则。</td><td>产品种类较多，创建逻辑复杂。</td></tr><tr><td><strong>抽象工厂模式</strong></td><td>每个工厂类可以创建一组相关产品，强调产品族的概念。</td><td>需要创建一组相关对象的场景。</td></tr></tbody></table><p>简单工厂并不是一个正式的设计模式，而是一种编程习惯。它通过一个工厂类来封装对象的创建逻辑，客户端只需要传递参数给工厂类，由工厂类决定创建哪种对象。</p><p><strong>特点</strong>：</p><ul><li>只有一个工厂类，负责创建所有产品。</li><li>通过条件判断（如 <code>switch</code> 或 <code>if-else</code>）来决定创建哪种产品。</li></ul><p><strong>适用场景</strong>：</p><ul><li>产品种类较少，且创建逻辑简单的场景。</li></ul><blockquote><p>开闭原则：当需求发生变化时，可以通过增加新的代码来扩展系统的功能，而不是修改现有的代码。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">  Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span></span> Use() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Using Product A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span></span> Use() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Using Product B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateProduct</span><span class="params">(productType <span class="type">string</span>)</span></span> Product &#123;</span><br><span class="line">  <span class="keyword">switch</span> productType &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  productA := CreateProduct(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">  productA.Use()</span><br><span class="line"></span><br><span class="line">  productB := CreateProduct(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">  productB.Use()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>简单易用，适合小型项目。</li></ul><p><strong>缺点</strong>：</p><ul><li>不符合开闭原则（OCP），新增产品时需要修改工厂类。</li></ul><h3 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h3><p>之前的简单工厂模式，一个工厂就负责了好几个产品的生产</p><p>工厂方法模式则是定义了一个创建对象的接口，但将具体的创建逻辑延迟到子类中。每个子类负责创建一种具体的产品。</p><p><strong>特点</strong>：</p><ul><li>每个产品对应一个工厂类。</li><li>符合开闭原则，新增产品时只需增加新的工厂类，无需修改现有代码。</li></ul><p><strong>适用场景</strong>：</p><ul><li>产品种类较多，且创建逻辑复杂的场景。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">  Connect() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 操作</span></span><br><span class="line"><span class="keyword">type</span> MySQL <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQL)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to MySQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQL 操作</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQL <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQL)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to PostgreSQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DatabaseFactory 工厂接口</span></span><br><span class="line"><span class="keyword">type</span> DatabaseFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  CreateDatabase() Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLFactory MySQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> MySQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateDatabase() Database &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQL&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateDatabase() Database &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQL&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseDatabase 使用数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseDatabase</span><span class="params">(factory DatabaseFactory)</span></span> &#123;</span><br><span class="line">  db := factory.CreateDatabase()</span><br><span class="line">  fmt.Println(db.Connect())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 使用 MySQL</span></span><br><span class="line">  mysqlFactory := &amp;MySQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(mysqlFactory)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 PostgreSQL</span></span><br><span class="line">  postgresFactory := &amp;PostgreSQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(postgresFactory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>符合开闭原则，扩展性强。</li><li>每个工厂只负责一种产品的创建，职责单一。</li></ul><p><strong>缺点</strong>：</p><ul><li>类的数量会增加，系统复杂度提高。</li></ul><h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h3><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。它适用于需要创建一组相关产品的场景。</p><p><strong>特点</strong>：</p><ul><li>每个工厂类可以创建多个相关产品。</li><li>强调产品族的概念，例如 GUI 库中的不同风格组件（Windows 风格、Mac 风格）。</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要创建一组相关对象的场景。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DBConnection 抽象产品：数据库连接接口</span></span><br><span class="line"><span class="keyword">type</span> DBConnection <span class="keyword">interface</span> &#123;</span><br><span class="line">  Connect() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBCommand 抽象产品：数据库命令接口</span></span><br><span class="line"><span class="keyword">type</span> DBCommand <span class="keyword">interface</span> &#123;</span><br><span class="line">  Execute(query <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLConnection 具体产品：MySQL 连接</span></span><br><span class="line"><span class="keyword">type</span> MySQLConnection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLConnection)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to MySQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLCommand 具体产品：MySQL 命令</span></span><br><span class="line"><span class="keyword">type</span> MySQLCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLCommand)</span></span> Execute(query <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MySQL executing query: %s&quot;</span>, query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLConnection 具体产品：PostgreSQL 连接</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLConnection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLConnection)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to PostgreSQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLCommand 具体产品：PostgreSQL 命令</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLCommand)</span></span> Execute(query <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;PostgreSQL executing query: %s&quot;</span>, query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBFactory 抽象工厂接口</span></span><br><span class="line"><span class="keyword">type</span> DBFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  CreateConnection() DBConnection</span><br><span class="line">  CreateCommand() DBCommand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLFactory 具体工厂：MySQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> MySQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateConnection() DBConnection &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQLConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateCommand() DBCommand &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQLCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLFactory 具体工厂：PostgreSQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateConnection() DBConnection &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQLConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateCommand() DBCommand &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQLCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseDatabase</span><span class="params">(factory DBFactory)</span></span> &#123;</span><br><span class="line">  connection := factory.CreateConnection()</span><br><span class="line">  command := factory.CreateCommand()</span><br><span class="line"></span><br><span class="line">  fmt.Println(connection.Connect())</span><br><span class="line">  fmt.Println(command.Execute(<span class="string">&quot;SELECT * FROM users&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 使用 MySQL</span></span><br><span class="line">  mysqlFactory := &amp;MySQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(mysqlFactory)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 PostgreSQL</span></span><br><span class="line">  postgresFactory := &amp;PostgreSQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(postgresFactory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>可以创建一组相关对象，保证对象之间的兼容性。</li><li>符合开闭原则，扩展性强。</li></ul><p><strong>缺点</strong>：</p><ul><li>类的数量会增加，系统复杂度提高。</li><li>新增产品族或产品等级结构时，需要修改抽象工厂接口及其所有实现类。</li></ul><h4 id="抽象工厂模式和工厂方法模式的区别"><a href="#抽象工厂模式和工厂方法模式的区别" class="headerlink" title="抽象工厂模式和工厂方法模式的区别"></a>抽象工厂模式和工厂方法模式的区别</h4><table><thead><tr><th>特性</th><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td><strong>产品数量</strong></td><td>一个工厂方法只创建一个产品。</td><td>一个抽象工厂创建多个相关产品（产品族）。</td></tr><tr><td><strong>产品关系</strong></td><td>产品之间没有直接关系。</td><td>产品之间是相关的（属于同一个产品族）。</td></tr><tr><td><strong>扩展性</strong></td><td>扩展时需要新增具体工厂类。</td><td>扩展时需要新增具体工厂类和产品族。</td></tr><tr><td><strong>实现方式</strong></td><td>通过继承实现。</td><td>通过组合实现。</td></tr><tr><td><strong>适用场景</strong></td><td>单一产品的创建。</td><td>多个相关产品的创建。</td></tr></tbody></table><ul><li><strong>工厂方法模式</strong> 更简单，适用于单一产品的创建。</li><li><strong>抽象工厂模式</strong> 更强大，适用于创建多个相关产品，但实现也更复杂。</li></ul><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3><p>它用于分步构建复杂对象。建造者模式的核心思想是将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式特别适用于以下场景：</p><ul><li>对象的构建过程非常复杂，包含多个步骤。</li><li>对象的构建过程需要支持不同的配置或表示。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品：House</span></span><br><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">  Walls   <span class="type">string</span></span><br><span class="line">  Roof    <span class="type">string</span></span><br><span class="line">  Windows <span class="type">string</span></span><br><span class="line">  Doors   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *House)</span></span> Show() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;House with %s walls, %s roof, %s windows, and %s doors\n&quot;</span>,</span><br><span class="line">    h.Walls, h.Roof, h.Windows, h.Doors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者接口</span></span><br><span class="line"><span class="keyword">type</span> HouseBuilder <span class="keyword">interface</span> &#123;</span><br><span class="line">  BuildWalls()</span><br><span class="line">  BuildRoof()</span><br><span class="line">  BuildWindows()</span><br><span class="line">  BuildDoors()</span><br><span class="line">  GetHouse() *House</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：ConcreteHouseBuilder</span></span><br><span class="line"><span class="keyword">type</span> ConcreteHouseBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">  house *House</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteHouseBuilder</span><span class="params">()</span></span> *ConcreteHouseBuilder &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;ConcreteHouseBuilder&#123;house: &amp;House&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildWalls() &#123;</span><br><span class="line">  b.house.Walls = <span class="string">&quot;concrete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildRoof() &#123;</span><br><span class="line">  b.house.Roof = <span class="string">&quot;tile&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildWindows() &#123;</span><br><span class="line">  b.house.Windows = <span class="string">&quot;glass&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildDoors() &#123;</span><br><span class="line">  b.house.Doors = <span class="string">&quot;wooden&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> GetHouse() *House &#123;</span><br><span class="line">  <span class="keyword">return</span> b.house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">  builder HouseBuilder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirector</span><span class="params">(builder HouseBuilder)</span></span> *Director &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Director&#123;builder: builder&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span></span> Construct() &#123;</span><br><span class="line">  d.builder.BuildWalls()</span><br><span class="line">  d.builder.BuildRoof()</span><br><span class="line">  d.builder.BuildWindows()</span><br><span class="line">  d.builder.BuildDoors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建具体建造者</span></span><br><span class="line">  builder := NewConcreteHouseBuilder()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建指挥者</span></span><br><span class="line">  director := NewDirector(builder)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指挥者构建产品</span></span><br><span class="line">  director.Construct()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最终产品</span></span><br><span class="line">  house := builder.GetHouse()</span><br><span class="line">  house.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>它通过复制现有对象来创建新对象，而不是通过新建类的方式。原型模式的核心思想是利用对象的克隆能力，避免重复初始化，特别适用于创建成本较高的对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototype 原型接口</span></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">  Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcretePrototype 具体原型</span></span><br><span class="line"><span class="keyword">type</span> ConcretePrototype <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span></span> Clone() Prototype &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象，并复制当前对象的属性</span></span><br><span class="line">  <span class="keyword">return</span> &amp;ConcretePrototype&#123;</span><br><span class="line">    Name: p.Name,</span><br><span class="line">    Age:  p.Age,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建原型对象</span></span><br><span class="line">  prototype := &amp;ConcretePrototype&#123;</span><br><span class="line">    Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    Age:  <span class="number">25</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆原型对象</span></span><br><span class="line">  clone := prototype.Clone().(*ConcretePrototype)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改克隆对象的属性</span></span><br><span class="line">  clone.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">  clone.Age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出原型对象和克隆对象</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Prototype:&quot;</span>, prototype)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Clone:&quot;</span>, clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原型模式，如果有引用类型，则需要考虑深拷贝和浅拷贝的问题</p><p>浅拷贝只复制对象本身而不复制其引用的对象，深拷贝则会递归地复制整个对象图。</p><p>这需要根据需求选择适当的拷贝方式</p><p>参考：<br><a href="https://www.fengfengzhidao.com/article/JI33Q5QB8lppN5cbFPQR">Go24种设计模式——创建型模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式（Design Pattern）是软件工程中针对常见问题的通用解决方案。&lt;/p&gt;
&lt;p&gt;它们不是具体的代码，而是经过验证的最佳实践，帮助开发者设计出灵活、可维护和可扩展的软件系统&lt;/p&gt;
&lt;h2 id=&quot;使用设计模式的好处&quot;&gt;&lt;a href=&quot;#使用设计模式的好处&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="go" scheme="https://leiqi.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux任务忘挂后台？bg来救</title>
    <link href="https://leiqi.top/2025-06-27-10e3559d5a60.html"/>
    <id>https://leiqi.top/2025-06-27-10e3559d5a60.html</id>
    <published>2025-06-27T16:34:18.000Z</published>
    <updated>2025-11-13T15:50:11.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法-1：直接挂起当前任务到后台（推荐）"><a href="#方法-1：直接挂起当前任务到后台（推荐）" class="headerlink" title="方法 1：直接挂起当前任务到后台（推荐）"></a>方法 1：直接挂起当前任务到后台（推荐）</h3><ol><li><strong>暂停任务</strong>：<br> 按组合键 <code>Ctrl + Z</code>，将当前前台任务<strong>暂停</strong>（挂起），此时终端会显示类似：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  Stopped                 python code/bert_baseline.py</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>将任务切换到后台运行</strong>：<br> 输入命令 <code>bg</code>（将最近暂停的任务放到后台运行），终端显示：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) root@gpu-1092425eb65d87e4b97a1-1-b6nqycupjgmy:~/IDRsPredictor# bg</span><br><span class="line">[1]+ python code/bert_baseline.py &amp;</span><br></pre></td></tr></table></figure><p>此时任务会在后台继续运行<br><img src="/../../imgs/Pasted%20image%2020250628003523.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法-1：直接挂起当前任务到后台（推荐）&quot;&gt;&lt;a href=&quot;#方法-1：直接挂起当前任务到后台（推荐）&quot; class=&quot;headerlink&quot; title=&quot;方法 1：直接挂起当前任务到后台（推荐）&quot;&gt;&lt;/a&gt;方法 1：直接挂起当前任务到后台（推荐）&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>pycharm快速跳出括号</title>
    <link href="https://leiqi.top/2025-06-26-7823cd405765.html"/>
    <id>https://leiqi.top/2025-06-26-7823cd405765.html</id>
    <published>2025-06-26T16:16:46.000Z</published>
    <updated>2025-11-13T15:50:11.685Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8&spm=1001.2101.3001.7020">自动补全</a>括号，但是写到代码语句末尾，要跳出括号，还得向右下角方向移动一下，按右键<code>→</code>，再移手回来按分号<code>;</code>，再移到右下角，按<code>↓</code>向下键。这样手就脱离了键盘，降低了效率。<br>我们可以把上下左右改成<code>Alt+i/k/j/l</code>，爽到飞起！</p><p><img src="/../../imgs/Pasted%20image%2020250627001735.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8&amp;spm=1001.2101.3001.7020&quot;&gt;自动补全&lt;/a&gt;括号，但是写到代码语句末尾，要跳出括号，还得向右下角</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>下载huggingface模型</title>
    <link href="https://leiqi.top/2025-06-23-bf53e7543f79.html"/>
    <id>https://leiqi.top/2025-06-23-bf53e7543f79.html</id>
    <published>2025-06-23T14:53:29.000Z</published>
    <updated>2025-11-13T15:50:11.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-huggingface-hub-工具"><a href="#使用-huggingface-hub-工具" class="headerlink" title="使用 huggingface_hub 工具"></a>使用 <code>huggingface_hub</code> 工具</h3><ol><li><p><strong>安装工具库</strong>：</p><p> bash</p><p> 复制</p><p> 下载</p><p> pip install huggingface_hub</p></li><li><p><strong>通过命令行下载</strong>：</p><p> bash</p><p> 复制</p><p> 下载</p><p> huggingface-cli download Rostlab&#x2F;prot_bert –local-dir .&#x2F;prot_bert_model</p><ul><li><code>--local-dir</code>：指定本地保存路径（如 <code>./prot_bert_model</code>）。</li></ul></li></ol><p><img src="/../../imgs/Pasted%20image%2020250623225401.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用-huggingface-hub-工具&quot;&gt;&lt;a href=&quot;#使用-huggingface-hub-工具&quot; class=&quot;headerlink&quot; title=&quot;使用 huggingface_hub 工具&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;huggingface_hu</summary>
      
    
    
    
    <category term="AI学习" scheme="https://leiqi.top/categories/AI%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>sudo命令缺失解决</title>
    <link href="https://leiqi.top/2025-06-22-fbc6289be980.html"/>
    <id>https://leiqi.top/2025-06-22-fbc6289be980.html</id>
    <published>2025-06-22T10:50:58.000Z</published>
    <updated>2025-11-13T15:50:11.678Z</updated>
    
    <content type="html"><![CDATA[<p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@799b7657ed3c:/app# sudo apt update</span><br><span class="line">sudo apt install iputils-ping</span><br><span class="line">bash: sudo: command not found</span><br><span class="line">bash: sudo: command not found</span><br></pre></td></tr></table></figure><p>通过以下步骤在 Ubuntu（或 Debian 系统）中安装 <code>sudo</code> 命令：</p><ol><li><p><strong>切换到 root 用户</strong>（如果你还不是 root，提示符应该是 <code>#</code>，如果是 <code>$</code> 需要切换）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>然后输入 root 密码。</p></li><li><p><strong>更新软件包列表</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 sudo</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install sudo</span><br></pre></td></tr></table></figure></li><li><p><strong>（可选）将你的用户添加到 sudo 用户组</strong>（假设你的用户名是 <code>yourusername</code>，请替换为实际用户名）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo yourusername</span><br></pre></td></tr></table></figure><p>这样你下次用 <code>yourusername</code> 登录时就可以使用 <code>sudo</code> 了。</p></li><li><p><strong>重新登录</strong> 或者执行 <code>su - yourusername</code> 让组权限生效。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>主机密钥变更客户端无法ssh连接</title>
    <link href="https://leiqi.top/2025-06-22-ef8361a6bfbe.html"/>
    <id>https://leiqi.top/2025-06-22-ef8361a6bfbe.html</id>
    <published>2025-06-22T10:20:15.000Z</published>
    <updated>2025-11-13T15:50:11.678Z</updated>
    
    <content type="html"><![CDATA[<p> SSH 报告了“**REMOTE HOST IDENTIFICATION HAS CHANGED!**”这个错误。具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">...</span><br><span class="line">Offending ECDSA key in C:\\Users\\QiLei/.ssh/known_hosts:9</span><br><span class="line">Host key for [xxxxxx]:20032 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>这是 SSH 的安全机制。它检测到你之前连接的远程主机（10.152.255.101:20032）的主机密钥和现在的不一样。可能的原因有：</p><ul><li>远程主机重装过系统或 SSH 服务，主机密钥发生了变化。</li><li>你连接的其实不是同一台机器（IP 被复用）。</li><li>有人试图进行中间人攻击（一般内网环境下很少见）。</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>如果你确认远程主机的变更是正常的（比如重装过系统或 SSH 服务），可以按照如下步骤操作：</strong></p><ol><li><p>打开命令行，输入以下命令，删除有问题的 known_hosts 记录（第9行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -R [10.152.255.101]:20032</span><br></pre></td></tr></table></figure><p>或者手动编辑 <code>C:\Users\QiLei\.ssh\known_hosts</code> 文件，删除第9行。</p></li><li><p>重新用 VS Code Remote-SSH 连接远程主机，系统会提示你接受新的主机密钥，输入 <code>yes</code> 即可。</p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; SSH 报告了“**REMOTE HOST IDENTIFICATION HAS CHANGED!**”这个错误。具体内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】动态规划</title>
    <link href="https://leiqi.top/2025-06-17-97ef30d737ce.html"/>
    <id>https://leiqi.top/2025-06-17-97ef30d737ce.html</id>
    <published>2025-06-17T16:35:57.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（Dynamic Programming, DP）是算法中的经典题型，LeetCode 上有许多高频题目。以下是常见的 DP 分类、经典题目及 Golang 实现模板总结：</p><hr><h3 id="一、经典题目分类与-Golang-实现"><a href="#一、经典题目分类与-Golang-实现" class="headerlink" title="一、经典题目分类与 Golang 实现"></a><strong>一、经典题目分类与 Golang 实现</strong></h3><h4 id="1-线性-DP"><a href="#1-线性-DP" class="headerlink" title="1. 线性 DP"></a>1. <strong>线性 DP</strong></h4><ul><li><p><strong>题目</strong>：<a href="https://leetcode.com/problems/climbing-stairs/">70. 爬楼梯</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化空间</strong>（滚动数组）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>模板总结</strong>：</p><ul><li>状态定义：<code>dp[i]</code> 表示第 <code>i</code> 阶的方案数。</li><li>转移方程：<code>dp[i] = dp[i-1] + dp[i-2]</code>。</li><li>初始化：<code>dp[1] = 1</code>, <code>dp[2] = 2</code>。</li></ul></li></ul><h4 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. <strong>背包问题</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[j]</code> 表示能否凑出和为 <code>j</code>。</li><li>转移方程：<code>dp[j] = dp[j] || dp[j-num]</code>。</li><li>初始化：<code>dp[0] = true</code>（和为 0 不需要选任何数）。</li></ul></li></ul><h4 id="3-字符串-DP"><a href="#3-字符串-DP" class="headerlink" title="3. 字符串 DP"></a>3. <strong>字符串 DP</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][j]</code> 表示 <code>text1[0..i-1]</code> 和 <code>text2[0..j-1]</code> 的 LCS 长度。</li><li>转移方程：<ul><li>字符匹配：<code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li><li>不匹配：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li></ul></li></ul></li></ul><h4 id="4-股票买卖问题"><a href="#4-股票买卖问题" class="headerlink" title="4. 股票买卖问题"></a>4. <strong>股票买卖问题</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minPrice, maxProfit := math.MaxInt32, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, price := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="keyword">if</span> price &lt; minPrice &#123;</span><br><span class="line">            minPrice = price</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> profit := price - minPrice; profit &gt; maxProfit &#123;</span><br><span class="line">            maxProfit = profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][0]</code> 表示第 <code>i</code> 天不持股的最大利润，<code>dp[i][1]</code> 表示持股的最大利润。</li><li>转移方程：<ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></li><li><code>dp[i][1] = max(dp[i-1][1], -prices[i])</code></li></ul></li></ul></li></ul><h4 id="5-区间-DP"><a href="#5-区间-DP" class="headerlink" title="5. 区间 DP"></a>5. <strong>区间 DP</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/longest-palindromic-substring/">5. 最长回文子串</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    start, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">2</span>; l &lt;= n; l++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n-l; i++ &#123;</span><br><span class="line">            j := i + l - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                <span class="keyword">if</span> l == <span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> l &gt; maxLen &#123;</span><br><span class="line">                        start, maxLen = i, l</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : start+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][j]</code> 表示 <code>s[i..j]</code> 是否为回文。</li><li>转移方程：<code>dp[i][j] = (s[i] == s[j]) &amp;&amp; (j-i &lt;= 2 || dp[i+1][j-1])</code>。</li></ul></li></ul><hr><h3 id="二、动态规划通用解题模板（Golang）"><a href="#二、动态规划通用解题模板（Golang）" class="headerlink" title="二、动态规划通用解题模板（Golang）"></a><strong>二、动态规划通用解题模板（Golang）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dpProblem</span><span class="params">(input)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 DP 数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 边界条件</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = baseCase</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、高频题目推荐"><a href="#三、高频题目推荐" class="headerlink" title="三、高频题目推荐"></a><strong>三、高频题目推荐</strong></h3><ol><li>简单：70（爬楼梯）、198（打家劫舍）、53（最大子数组和）</li><li>中等：322（零钱兑换）、300（最长递增子序列）、139（单词拆分）</li><li>困难：72（编辑距离）、312（戳气球）、10（正则表达式匹配）</li></ol><hr><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a><strong>四、注意事项</strong></h3><ol><li><strong>状态定义</strong>：明确 <code>dp[i]</code> 或 <code>dp[i][j]</code> 的含义。</li><li><strong>转移方程</strong>：分析问题如何分解为子问题。</li><li><strong>空间优化</strong>：滚动数组或逆序更新（如背包问题）。</li><li><strong>边界条件</strong>：如 <code>dp[0]</code> 或 <code>dp[0][0]</code> 的初始化。</li></ol><p>通过练习这些题目并总结模板，可以快速掌握动态规划的核心思想！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划（Dynamic Programming, DP）是算法中的经典题型，LeetCode 上有许多高频题目。以下是常见的 DP 分类、经典题目及 Golang 实现模板总结：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、经典题目分类与-Golang-实现&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】贪心</title>
    <link href="https://leiqi.top/2025-06-17-12ec7942da63.html"/>
    <id>https://leiqi.top/2025-06-17-12ec7942da63.html</id>
    <published>2025-06-17T16:33:41.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法经典题目及Golang实现"><a href="#贪心算法经典题目及Golang实现" class="headerlink" title="贪心算法经典题目及Golang实现"></a>贪心算法经典题目及Golang实现</h1><p>贪心算法是一种在每一步选择中都采取当前状态下最优的选择，从而希望导致全局最优解的算法策略。以下是一些LeetCode上经典的贪心算法题目及其Golang实现，并总结一个通用的解题模板。</p><h2 id="经典贪心题目及Golang实现"><a href="#经典贪心题目及Golang实现" class="headerlink" title="经典贪心题目及Golang实现"></a>经典贪心题目及Golang实现</h2><h3 id="1-分发饼干-455-Assign-Cookies"><a href="#1-分发饼干-455-Assign-Cookies" class="headerlink" title="1. 分发饼干 (455. Assign Cookies)"></a>1. 分发饼干 (455. Assign Cookies)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    </span><br><span class="line">    child, cookie := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> child &lt; <span class="built_in">len</span>(g) &amp;&amp; cookie &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[cookie] &gt;= g[child] &#123;</span><br><span class="line">            child++</span><br><span class="line">        &#125;</span><br><span class="line">        cookie++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-无重叠区间-435-Non-overlapping-Intervals"><a href="#2-无重叠区间-435-Non-overlapping-Intervals" class="headerlink" title="2. 无重叠区间 (435. Non-overlapping Intervals)"></a>2. 无重叠区间 (435. Non-overlapping Intervals)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)"></a>3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    arrows := <span class="number">1</span></span><br><span class="line">    pos := points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; pos &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            pos = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)"></a>4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-跳跃游戏-55-Jump-Game"><a href="#5-跳跃游戏-55-Jump-Game" class="headerlink" title="5. 跳跃游戏 (55. Jump Game)"></a>5. 跳跃游戏 (55. Jump Game)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    farthest := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; farthest &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-跳跃游戏-II-45-Jump-Game-II"><a href="#6-跳跃游戏-II-45-Jump-Game-II" class="headerlink" title="6. 跳跃游戏 II (45. Jump Game II)"></a>6. 跳跃游戏 II (45. Jump Game II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    jumps, curEnd, farthest := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == curEnd &#123;</span><br><span class="line">            jumps++</span><br><span class="line">            curEnd = farthest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-加油站-134-Gas-Station"><a href="#7-加油站-134-Gas-Station" class="headerlink" title="7. 加油站 (134. Gas Station)"></a>7. 加油站 (134. Gas Station)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total, curr, start := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gas); i++ &#123;</span><br><span class="line">        total += gas[i] - cost[i]</span><br><span class="line">        curr += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> curr &lt; <span class="number">0</span> &#123;</span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> total &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-任务调度器-621-Task-Scheduler"><a href="#8-任务调度器-621-Task-Scheduler" class="headerlink" title="8. 任务调度器 (621. Task Scheduler)"></a>8. 任务调度器 (621. Task Scheduler)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leastInterval</span><span class="params">(tasks []<span class="type">byte</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        freq[t-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(freq)</span><br><span class="line">    </span><br><span class="line">    maxFreq := freq[<span class="number">25</span>]</span><br><span class="line">    idleSlots := (maxFreq - <span class="number">1</span>) * n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; freq[i] &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        idleSlots -= min(freq[i], maxFreq<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> idleSlots &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idleSlots + <span class="built_in">len</span>(tasks)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tasks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法通用模板"><a href="#贪心算法通用模板" class="headerlink" title="贪心算法通用模板"></a>贪心算法通用模板</h2><p>虽然贪心算法没有固定的模板，但通常可以遵循以下步骤：</p><ol><li><strong>排序</strong>：很多贪心问题需要对输入数据进行排序</li><li><strong>初始化</strong>：设置必要的变量（如计数器、指针等）</li><li><strong>遍历处理</strong>：遍历排序后的数据，做出贪心选择</li><li><strong>验证结果</strong>：检查是否满足题目要求</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greedyAlgorithm</span><span class="params">(input []Type)</span></span> ResultType &#123;</span><br><span class="line">    <span class="comment">// 1. 排序（如果需要）</span></span><br><span class="line">    sort.Slice(input, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(input[i], input[j])</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化变量</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    current := initialValue</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 遍历处理</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> input &#123;</span><br><span class="line">        <span class="keyword">if</span> canMakeGreedyChoice(current, item) &#123;</span><br><span class="line">            <span class="comment">// 做出贪心选择</span></span><br><span class="line">            update(current, item)</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法适用场景"><a href="#贪心算法适用场景" class="headerlink" title="贪心算法适用场景"></a>贪心算法适用场景</h2><p>贪心算法通常适用于以下类型的问题：</p><ul><li>可以分解为子问题的问题</li><li>子问题的最优解能递推到最终问题的最优解</li><li>无后效性，即某个状态以后的过程不会影响以前的状态</li></ul><p>常见应用场景包括：</p><ul><li>分配问题（如分发饼干）</li><li>区间问题（如无重叠区间）</li><li>调度问题（如任务调度器）</li><li>股票买卖问题</li><li>跳跃游戏类问题</li></ul><p>贪心算法的关键在于证明贪心策略的正确性，这通常需要数学证明或直观理解。在实际应用中，如果无法确定贪心策略是否正确，可以先尝试，然后验证是否能够得到全局最优解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#贪心算法经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;/a&gt;贪心算法经典题目及Golang实现&lt;/h1&gt;&lt;p&gt;贪心算法是一种在每一</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】优先队列</title>
    <link href="https://leiqi.top/2025-06-17-96c1b8914ef4.html"/>
    <id>https://leiqi.top/2025-06-17-96c1b8914ef4.html</id>
    <published>2025-06-17T16:29:57.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列在LeetCode上的经典题目及Golang实现"><a href="#优先队列在LeetCode上的经典题目及Golang实现" class="headerlink" title="优先队列在LeetCode上的经典题目及Golang实现"></a>优先队列在LeetCode上的经典题目及Golang实现</h1><p>优先队列（Priority Queue）是一种重要的数据结构，它在很多算法问题中都有广泛应用。以下是LeetCode上一些经典的优先队列题目，以及用Golang实现的解决方案和模板总结。</p><h2 id="优先队列的Golang实现"><a href="#优先队列的Golang实现" class="headerlink" title="优先队列的Golang实现"></a>优先队列的Golang实现</h2><p>在Golang中，我们可以使用<code>container/heap</code>包来实现优先队列。首先，我们需要定义一个实现heap.Interface的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个最小堆</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆只需修改Less方法</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 改为大于号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典题目及实现"><a href="#经典题目及实现" class="headerlink" title="经典题目及实现"></a>经典题目及实现</h2><h3 id="1-合并K个升序链表-LeetCode-23"><a href="#1-合并K个升序链表-LeetCode-23" class="headerlink" title="1. 合并K个升序链表 (LeetCode 23)"></a>1. 合并K个升序链表 (LeetCode 23)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    h := &amp;NodeHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有链表的头节点加入堆</span></span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    current := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := heap.Pop(h).(*ListNode)</span><br><span class="line">        current.Next = node</span><br><span class="line">        current = current.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, node.Next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组中的第K个最大元素-LeetCode-215"><a href="#2-数组中的第K个最大元素-LeetCode-215" class="headerlink" title="2. 数组中的第K个最大元素 (LeetCode 215)"></a>2. 数组中的第K个最大元素 (LeetCode 215)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := &amp;MinHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.Push(h, num)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-前K个高频元素-LeetCode-347"><a href="#3-前K个高频元素-LeetCode-347" class="headerlink" title="3. 前K个高频元素 (LeetCode 347)"></a>3. 前K个高频元素 (LeetCode 347)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> pq[i].count &lt; pq[j].count &#125; <span class="comment">// 最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; pq[i], pq[j] = pq[j], pq[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 统计频率</span></span><br><span class="line">    frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        frequency[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建优先队列</span></span><br><span class="line">    pq := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素加入队列</span></span><br><span class="line">    <span class="keyword">for</span> value, count := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">        heap.Push(pq, &amp;Item&#123;value: value, count: count&#125;)</span><br><span class="line">        <span class="keyword">if</span> pq.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(pq)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集结果</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        result[i] = heap.Pop(pq).(*Item).value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数据流的中位数-LeetCode-295"><a href="#4-数据流的中位数-LeetCode-295" class="headerlink" title="4. 数据流的中位数 (LeetCode 295)"></a>4. 数据流的中位数 (LeetCode 295)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxHeap *MaxHeap <span class="comment">// 存储较小的一半</span></span><br><span class="line">    minHeap *MinHeap <span class="comment">// 存储较大的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        maxHeap: &amp;MaxHeap&#123;&#125;,</span><br><span class="line">        minHeap: &amp;MinHeap&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入maxHeap</span></span><br><span class="line">    heap.Push(this.maxHeap, num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平衡两个堆</span></span><br><span class="line">    heap.Push(this.minHeap, heap.Pop(this.maxHeap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;</span><br><span class="line">        heap.Push(this.maxHeap, heap.Pop(this.minHeap))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>]+(*this.minHeap)[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列解题模板"><a href="#优先队列解题模板" class="headerlink" title="优先队列解题模板"></a>优先队列解题模板</h2><p>基于以上题目，可以总结出优先队列的通用解题模板：</p><ol><li><p><strong>定义堆类型</strong>：</p><ul><li>实现heap.Interface接口（Len, Less, Swap, Push, Pop方法）</li><li>根据需求决定是最小堆还是最大堆（通过Less方法控制）</li></ul></li><li><p><strong>初始化堆</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;CustomHeap&#123;&#125;</span><br><span class="line">heap.Init(h)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用堆</strong>：</p><ul><li>添加元素：<code>heap.Push(h, element)</code></li><li>弹出元素：<code>heap.Pop(h)</code></li><li>访问堆顶元素（不弹出）：对于最小堆是<code>h[0]</code>，注意要先检查长度</li></ul></li><li><p><strong>常见模式</strong>：</p><ul><li>维护一个大小为K的堆（求前K大&#x2F;小元素）</li><li>使用两个堆维护动态数据流的中位数</li><li>在贪心算法中使用优先队列选择最优解</li></ul></li></ol><h2 id="其他经典优先队列题目"><a href="#其他经典优先队列题目" class="headerlink" title="其他经典优先队列题目"></a>其他经典优先队列题目</h2><ol><li>滑动窗口最大值 (LeetCode 239)</li><li>任务调度器 (LeetCode 621)</li><li>最接近原点的K个点 (LeetCode 973)</li><li>重构字符串 (LeetCode 767)</li><li>网络延迟时间 (LeetCode 743)</li></ol><p>优先队列是解决许多复杂问题的有力工具，特别是在需要动态获取最大&#x2F;最小元素或前K个元素的场景中。掌握其实现和应用模式对算法面试非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#优先队列在LeetCode上的经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;/a&gt;优先</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】sort.Search二分包</title>
    <link href="https://leiqi.top/2025-06-17-5b0e8e4ea44f.html"/>
    <id>https://leiqi.top/2025-06-17-5b0e8e4ea44f.html</id>
    <published>2025-06-17T16:26:45.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-中二分查找包的使用方法"><a href="#Golang-中二分查找包的使用方法" class="headerlink" title="Golang 中二分查找包的使用方法"></a>Golang 中二分查找包的使用方法</h1><p>Go 标准库中的 <code>sort</code> 包提供了二分查找的功能，主要通过 <code>sort.Search</code> 函数实现。下面详细介绍如何使用这个功能。</p><h3 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 初始化边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 防止溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">// 找到目标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 调整左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment">// 调整右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeftBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找右边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRightBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-sort-Search-基本用法"><a href="#1-sort-Search-基本用法" class="headerlink" title="1. sort.Search 基本用法"></a>1. <code>sort.Search</code> 基本用法</h2><p><code>sort.Search</code> 函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure><p>它会在 <code>[0, n)</code> 范围内查找满足 <code>f(i)</code> 为 <code>true</code> 的最小索引 <code>i</code>。如果不存在这样的索引，则返回 <code>n</code>。</p><h3 id="基本示例：在有序切片中查找元素"><a href="#基本示例：在有序切片中查找元素" class="headerlink" title="基本示例：在有序切片中查找元素"></a>基本示例：在有序切片中查找元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找目标值的索引</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查找特定条件的元素"><a href="#2-查找特定条件的元素" class="headerlink" title="2. 查找特定条件的元素"></a>2. 查找特定条件的元素</h2><p><code>sort.Search</code> 的强大之处在于可以查找满足任意条件的第一个元素。</p><h3 id="示例：查找第一个大于等于目标值的元素"><a href="#示例：查找第一个大于等于目标值的元素" class="headerlink" title="示例：查找第一个大于等于目标值的元素"></a>示例：查找第一个大于等于目标值的元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;第一个大于等于 %d 的元素是 %d，索引为 %d\n&quot;</span>, target, nums[index], index)</span><br></pre></td></tr></table></figure><h3 id="示例：查找第一个满足条件的偶数"><a href="#示例：查找第一个满足条件的偶数" class="headerlink" title="示例：查找第一个满足条件的偶数"></a>示例：查找第一个满足条件的偶数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i]%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第一个偶数是 %d，索引为 %d\n&quot;</span>, nums[index], index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;没有找到偶数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-自定义类型的二分查找"><a href="#3-自定义类型的二分查找" class="headerlink" title="3. 自定义类型的二分查找"></a>3. 自定义类型的二分查找</h2><p>对于自定义类型，需要先实现 <code>sort.Interface</code> 接口，然后才能使用 <code>sort.Search</code>。</p><h3 id="示例：自定义结构体切片查找"><a href="#示例：自定义结构体切片查找" class="headerlink" title="示例：自定义结构体切片查找"></a>示例：自定义结构体切片查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := ByAge&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先排序</span></span><br><span class="line">    sort.Sort(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找年龄大于等于 33 的第一个人</span></span><br><span class="line">    targetAge := <span class="number">33</span></span><br><span class="line">    index := sort.Search(<span class="built_in">len</span>(people), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &gt;= targetAge</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(people) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;找到 %+v，索引为 %d\n&quot;</span>, people[index], index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有找到满足条件的人&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-查找浮点数近似值"><a href="#4-查找浮点数近似值" class="headerlink" title="4. 查找浮点数近似值"></a>4. 查找浮点数近似值</h2><p><code>sort.Search</code> 也可以用于浮点数近似查找。</p><h3 id="示例：查找平方根近似值"><a href="#示例：查找平方根近似值" class="headerlink" title="示例：查找平方根近似值"></a>示例：查找平方根近似值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 设置精度</span></span><br><span class="line">    precision := <span class="number">1e-6</span></span><br><span class="line">    low, high := <span class="number">0.0</span>, x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用二分查找逼近平方根</span></span><br><span class="line">    <span class="keyword">for</span> high-low &gt; precision &#123;</span><br><span class="line">        mid := (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid*mid &lt; x &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (low + high) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;√2 ≈&quot;</span>, sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-查找切片中的插入位置"><a href="#5-查找切片中的插入位置" class="headerlink" title="5. 查找切片中的插入位置"></a>5. 查找切片中的插入位置</h2><p><code>sort.Search</code> 非常适合用来查找元素应该插入的位置。</p><h3 id="示例：查找插入位置"><a href="#示例：查找插入位置" class="headerlink" title="示例：查找插入位置"></a>示例：查找插入位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d 应该插入到索引 %d 的位置\n&quot;</span>, target, index)</span><br><span class="line"><span class="comment">// 输出: 6 应该插入到索引 3 的位置</span></span><br></pre></td></tr></table></figure><h2 id="6-标准库中的其他相关函数"><a href="#6-标准库中的其他相关函数" class="headerlink" title="6. 标准库中的其他相关函数"></a>6. 标准库中的其他相关函数</h2><p>除了 <code>sort.Search</code>，标准库还提供了：</p><ul><li><code>sort.SearchInts(a []int, x int) int</code> - 在已排序的 int 切片中查找 x</li><li><code>sort.SearchFloat64s(a []float64, x float64) int</code> - 在已排序的 float64 切片中查找 x</li><li><code>sort.SearchStrings(a []string, x string) int</code> - 在已排序的 string 切片中查找 x</li></ul><h3 id="示例：使用-sort-SearchInts"><a href="#示例：使用-sort-SearchInts" class="headerlink" title="示例：使用 sort.SearchInts"></a>示例：使用 <code>sort.SearchInts</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.SearchInts(nums, target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-性能考虑"><a href="#7-性能考虑" class="headerlink" title="7. 性能考虑"></a>7. 性能考虑</h2><p><code>sort.Search</code> 的时间复杂度是 O(log n)，因为它使用的是二分查找算法。但需要注意：</p><ol><li>切片必须是已排序的，否则结果不可靠</li><li>比较函数 <code>f</code> 应该尽可能简单高效</li><li>对于非常大的数据集，考虑内存局部性和缓存效应</li></ol><h2 id="8-实际应用示例"><a href="#8-实际应用示例" class="headerlink" title="8. 实际应用示例"></a>8. 实际应用示例</h2><h3 id="示例：实现类似-C-的-lower-bound-和-upper-bound"><a href="#示例：实现类似-C-的-lower-bound-和-upper-bound" class="headerlink" title="示例：实现类似 C++ 的 lower_bound 和 upper_bound"></a>示例：实现类似 C++ 的 lower_bound 和 upper_bound</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowerBound 返回第一个 &gt;= target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upperBound 返回第一个 &gt; target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upperBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    target := <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    lb := lowerBound(nums, target)</span><br><span class="line">    ub := upperBound(nums, target)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;lowerBound: %d, upperBound: %d\n&quot;</span>, lb, ub)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;元素 %d 的出现次数: %d\n&quot;</span>, target, ub-lb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-中二分查找包的使用方法&quot;&gt;&lt;a href=&quot;#Golang-中二分查找包的使用方法&quot; class=&quot;headerlink&quot; title=&quot;Golang 中二分查找包的使用方法&quot;&gt;&lt;/a&gt;Golang 中二分查找包的使用方法&lt;/h1&gt;&lt;p&gt;Go 标准库</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】DFS</title>
    <link href="https://leiqi.top/2025-06-17-8ecaae2ca2b5.html"/>
    <id>https://leiqi.top/2025-06-17-8ecaae2ca2b5.html</id>
    <published>2025-06-17T16:21:34.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结"><a href="#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结" class="headerlink" title="LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结"></a>LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结</h1><p>DFS（深度优先搜索）是算法面试中的常见题型，下面我将总结 LeetCode 上一些经典的 DFS 题目，并用 Golang 实现，最后提炼出通用的 DFS 解题模板。</p><h2 id="经典-DFS-题目分类及-Golang-实现"><a href="#经典-DFS-题目分类及-Golang-实现" class="headerlink" title="经典 DFS 题目分类及 Golang 实现"></a>经典 DFS 题目分类及 Golang 实现</h2><h3 id="1-二叉树遍历类"><a href="#1-二叉树遍历类" class="headerlink" title="1. 二叉树遍历类"></a>1. 二叉树遍历类</h3><h4 id="题目-94-二叉树的中序遍历"><a href="#题目-94-二叉树的中序遍历" class="headerlink" title="题目 94. 二叉树的中序遍历"></a>题目 94. 二叉树的中序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-排列组合类"><a href="#2-排列组合类" class="headerlink" title="2. 排列组合类"></a>2. 排列组合类</h3><h4 id="题目-46-全排列"><a href="#题目-46-全排列" class="headerlink" title="题目 46. 全排列"></a>题目 46. 全排列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(path)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-岛屿问题类"><a href="#3-岛屿问题类" class="headerlink" title="3. 岛屿问题类"></a>3. 岛屿问题类</h3><h4 id="题目-200-岛屿数量"><a href="#题目-200-岛屿数量" class="headerlink" title="题目 200. 岛屿数量"></a>题目 200. 岛屿数量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-回溯类问题"><a href="#4-回溯类问题" class="headerlink" title="4. 回溯类问题"></a>4. 回溯类问题</h3><h4 id="题目-39-组合总和"><a href="#题目-39-组合总和" class="headerlink" title="题目 39. 组合总和"></a>题目 39. 组合总和</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            dfs(i, path, sum+candidates[i])</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, []<span class="type">int</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang-DFS-通用模板"><a href="#Golang-DFS-通用模板" class="headerlink" title="Golang DFS 通用模板"></a>Golang DFS 通用模板</h2><p>根据以上题目，可以总结出 DFS 的通用模板：</p><h3 id="递归回溯模板"><a href="#递归回溯模板" class="headerlink" title="递归回溯模板"></a>递归回溯模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">problemFunction</span><span class="params">(params)</span></span> [][]resultType &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]resultType</span><br><span class="line">    <span class="comment">// 可能需要 visited 数组或其他辅助数据结构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> meetCondition &#123;</span><br><span class="line">            <span class="comment">// 可能需要深拷贝 path</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]resultType, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> _, choice := <span class="keyword">range</span> choices &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不满足条件的选项</span></span><br><span class="line">            <span class="keyword">if</span> !isValid(choice) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, choice)</span><br><span class="line">            markAsVisited(choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(path, updatedParams...)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            markAsUnvisited(choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(initialPath, initialParams...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格-矩阵DFS模板"><a href="#网格-矩阵DFS模板" class="headerlink" title="网格&#x2F;矩阵DFS模板"></a>网格&#x2F;矩阵DFS模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gridProblem</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != targetValue &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记已访问</span></span><br><span class="line">        grid[i][j] = markedValue</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四个方向扩散</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要8个方向，可以加上对角线方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历整个网格</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == targetValue &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他经典DFS题目推荐"><a href="#其他经典DFS题目推荐" class="headerlink" title="其他经典DFS题目推荐"></a>其他经典DFS题目推荐</h2><ol><li><ol start="78"><li>子集</li></ol></li><li><ol start="17"><li>电话号码的字母组合</li></ol></li><li><ol start="79"><li>单词搜索</li></ol></li><li><ol start="207"><li>课程表 (拓扑排序)</li></ol></li><li><ol start="437"><li>路径总和 III</li></ol></li><li><ol start="494"><li>目标和</li></ol></li><li><ol start="695"><li>岛屿的最大面积</li></ol></li><li><ol start="733"><li>图像渲染</li></ol></li><li><ol start="113"><li>路径总和 II</li></ol></li><li><ol start="129"><li>求根到叶子节点数字和</li></ol></li></ol><p>DFS的关键在于理解递归的思想，明确递归的终止条件，以及在递归前后做好状态的保存和恢复（回溯）。掌握这些模板后，可以解决大部分DFS相关问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot;&gt;&lt;a href=&quot;#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 上经典的 DFS 题目</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】BFS</title>
    <link href="https://leiqi.top/2025-06-17-e53745bb0899.html"/>
    <id>https://leiqi.top/2025-06-17-e53745bb0899.html</id>
    <published>2025-06-17T16:12:10.000Z</published>
    <updated>2025-11-13T15:50:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-BFS-练习题单与模板总结-Golang-实现"><a href="#LeetCode-BFS-练习题单与模板总结-Golang-实现" class="headerlink" title="LeetCode BFS 练习题单与模板总结 (Golang 实现)"></a>LeetCode BFS 练习题单与模板总结 (Golang 实现)</h1><p>BFS（广度优先搜索）是一种重要的图遍历算法，特别适合解决最短路径、层次遍历等问题。以下是 Golang 实现的 BFS 模板和分类练习题单。</p><h2 id="BFS-通用模板-Golang"><a href="#BFS-通用模板-Golang" class="headerlink" title="BFS 通用模板 (Golang)"></a>BFS 通用模板 (Golang)</h2><h3 id="1-树的-BFS-模板"><a href="#1-树的-BFS-模板" class="headerlink" title="1. 树的 BFS 模板"></a>1. 树的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, levelSize)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-图的-BFS-模板"><a href="#2-图的-BFS-模板" class="headerlink" title="2. 图的 BFS 模板"></a>2. 图的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsGraph</span><span class="params">(start Node)</span></span> []Node &#123;</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[Node]<span class="type">bool</span>)</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    queue := []Node&#123;start&#125;</span><br><span class="line">    result := []Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, node)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> getNeighbors(node) &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-BFS-练习题单-Golang"><a href="#LeetCode-BFS-练习题单-Golang" class="headerlink" title="LeetCode BFS 练习题单 (Golang)"></a>LeetCode BFS 练习题单 (Golang)</h2><h3 id="基础练习"><a href="#基础练习" class="headerlink" title="基础练习"></a>基础练习</h3><ol><li><p><strong>二叉树的层次遍历</strong></p><ul><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></li><li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li><li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></li></ul></li><li><p><strong>简单图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/number-of-islands/">200. 岛屿数量</a></li><li><a href="https://leetcode.com/problems/flood-fill/">733. 图像渲染</a></li><li><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></li></ul></li></ol><h3 id="进阶练习"><a href="#进阶练习" class="headerlink" title="进阶练习"></a>进阶练习</h3><ol><li><p><strong>最短路径问题</strong></p><ul><li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li><li><a href="https://leetcode.com/problems/open-the-lock/">752. 打开转盘锁</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></li><li><a href="https://leetcode.com/problems/01-matrix/">542. 01 矩阵</a></li></ul></li><li><p><strong>复杂图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/word-ladder/">127. 单词接龙</a></li><li><a href="https://leetcode.com/problems/clone-graph/">133. 克隆图</a></li><li><a href="https://leetcode.com/problems/minimum-height-trees/">310. 最小高度树</a></li></ul></li><li><p><strong>多源BFS</strong></p><ul><li><a href="https://leetcode.com/problems/rotting-oranges/">994. 腐烂的橘子</a></li><li><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a> (付费题)</li></ul></li></ol><h3 id="困难级别挑战"><a href="#困难级别挑战" class="headerlink" title="困难级别挑战"></a>困难级别挑战</h3><ol><li><a href="https://leetcode.com/problems/bus-routes/">815. 公交路线</a></li><li><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></li></ol><h2 id="Golang-BFS-实现技巧"><a href="#Golang-BFS-实现技巧" class="headerlink" title="Golang BFS 实现技巧"></a>Golang BFS 实现技巧</h2><ol><li><p><strong>队列实现</strong>：Golang 中可以用 slice 实现队列，但要注意 dequeue 操作是 O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:] <span class="comment">// 这会创建新的 slice，可能影响性能</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong>：对于大型队列，可以使用链表或固定大小的循环队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes []*TreeNode</span><br><span class="line">    head  <span class="type">int</span></span><br><span class="line">    tail  <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>visited 记录</strong>：对于图问题，使用 map 记录已访问节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>方向数组</strong>：处理网格问题时很有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例题解：200-岛屿数量-Golang"><a href="#示例题解：200-岛屿数量-Golang" class="headerlink" title="示例题解：200. 岛屿数量 (Golang)"></a>示例题解：200. 岛屿数量 (Golang)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                queue := [][]<span class="type">int</span>&#123;&#123;i, j&#125;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    cell := queue[<span class="number">0</span>]</span><br><span class="line">                    queue = queue[<span class="number">1</span>:]</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                        x, y := cell[<span class="number">0</span>]+dir[<span class="number">0</span>], cell[<span class="number">1</span>]+dir[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                            grid[x][y] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, []<span class="type">int</span>&#123;x, y&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-BFS-练习题单与模板总结-Golang-实现&quot;&gt;&lt;a href=&quot;#LeetCode-BFS-练习题单与模板总结-Golang-实现&quot; class=&quot;headerlink&quot; title=&quot;LeetCode BFS 练习题单与模板总结 (Gola</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
