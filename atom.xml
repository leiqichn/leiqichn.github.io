<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2024-05-12T06:27:50.751Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 355设计推特</title>
    <link href="https://leiqichn.github.io/2024-05-10-b1491b9671d6.html"/>
    <id>https://leiqichn.github.io/2024-05-10-b1491b9671d6.html</id>
    <published>2024-05-10T15:26:56.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/design-twitter/description/">355. 设计推特</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Twitter <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>userId    <span class="hljs-type">int</span><br>followees <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br>tweets    []*Tweet<br>&#125;<br><br><span class="hljs-keyword">type</span> Tweet <span class="hljs-keyword">struct</span> &#123;<br>tweetId <span class="hljs-type">int</span><br>time    <span class="hljs-type">int</span><br>userId  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 推特时间排序</span><br><span class="hljs-keyword">var</span> tweetCount <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Twitter &#123;<br><span class="hljs-keyword">return</span> Twitter&#123;userMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> PostTweet(userId <span class="hljs-type">int</span>, tweetId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 新建tweet  将自己设置为关注</span><br><br><span class="hljs-comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span><br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;<br>t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="hljs-built_in">make</span>([]*Tweet, <span class="hljs-number">0</span>), followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)&#125;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br>t.userMap[userId].followees[userId] = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br><br>&#125;<br><br><span class="hljs-comment">// 将tweetId 时间做一个新增</span><br>tweetCount++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Follow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 如果关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;<br>        t.userMap[followerId] = &amp;User&#123;<br>            userId:        followerId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followerId].followees[followerId] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果被关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;<br>        t.userMap[followeeId] = &amp;User&#123;<br>            userId:        followeeId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followeeId].followees[followeeId] = <span class="hljs-literal">true</span><br>    &#125;<br>    t.userMap[followerId].followees[followeeId] = <span class="hljs-literal">true</span><br><br>&#125;<br><br><span class="hljs-comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Unfollow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;<br><span class="hljs-built_in">delete</span>(t.userMap[followerId].followees, followeeId)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>resTop10 := []<span class="hljs-type">int</span>&#123;&#125;<br>tweeters := []*Tweet&#123;&#125;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; ok &#123;<br><br><span class="hljs-keyword">for</span> followeeId, _ := <span class="hljs-keyword">range</span> t.userMap[userId].followees &#123;<br>tweeters = <span class="hljs-built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)<br>&#125;<br><br>&#125;<br>sort.Slice(tweeters, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="hljs-number">10</span> ; i++ &#123;<br>resTop10 = <span class="hljs-built_in">append</span>(resTop10, tweeters[i].tweetId)<br>&#125;<br><br><span class="hljs-keyword">return</span> resTop10<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/design-twitter/description/&quot;&gt;355. 设计推特&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题思考</title>
    <link href="https://leiqichn.github.io/2024-05-08-9a58f8b87168.html"/>
    <id>https://leiqichn.github.io/2024-05-08-9a58f8b87168.html</id>
    <published>2024-05-08T17:20:58.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>设计数据结构和算法时，通常需要遵循以下步骤来解决问题：</p><ol><li><p><strong>理解问题</strong>：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。</p></li><li><p><strong>确定需求</strong>：明确需要哪些<strong>数据结构</strong>来存储信息，以及如何使用这些数据结构来满足题目的需求。</p></li><li><p><strong>设计数据结构</strong>：</p><ul><li>确定实体类型：例如，用户（User）、推文（Tweet）等。</li><li>确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。</li></ul></li><li><p><strong>定义方法</strong>：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。</p></li><li><p><strong>实现逻辑</strong>：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。</p></li><li><p><strong>考虑边界条件和错误处理</strong>：确保你的代码可以处理各种边界情况和潜在的错误。</p></li><li><p><strong>优化</strong>：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。</p></li></ol><p>对于LeetCode题目 <strong>设计推特</strong>，思考过程如下：</p><ol><li><p><strong>理解题目</strong>：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。</p></li><li><p><strong>确定需求</strong>：</p><ul><li>需要存储用户信息，包括用户ID、关注列表和推文列表。</li><li>需要存储推文信息，包括推文ID和时间戳。</li></ul></li><li><p><strong>设计数据结构</strong>：</p><ul><li><code>Twitter</code>：包含用户映射，用于快速访问用户信息。</li><li><code>User</code>：包含用户ID、关注列表和推文列表。</li><li><code>Tweet</code>：包含推文ID和时间戳。</li></ul></li><li><p><strong>定义方法</strong>：</p><ul><li><code>Constructor</code>：初始化<code>Twitter</code>实例。</li><li><code>PostTweet</code>：实现用户发布推文的逻辑。</li><li><code>Follow</code>：实现用户关注其他用户的逻辑。</li><li><code>Unfollow</code>：实现用户取消关注的逻辑。</li><li><code>GetNewsFeed</code>：实现获取用户信息流的逻辑。</li></ul></li><li><p><strong>实现逻辑</strong>：</p><ul><li>对于<code>PostTweet</code>，检查用户是否存在，如果不存在则创建用户，然后添加推文。</li><li>对于<code>Follow</code>和<code>Unfollow</code>，更新用户的<code>followees</code>映射。</li><li>对于<code>GetNewsFeed</code>，收集并排序推文，然后返回结果。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>确保在添加推文或关注用户时，处理用户不存在的情况。</li><li>在获取信息流时，处理用户没有推文或关注任何人的情况。</li></ul></li><li><p><strong>优化</strong>：</p><ul><li>考虑是否可以使用更高效的数据结构或算法来提高性能。</li></ul></li></ol><p>在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计数据结构和算法时，通常需要遵循以下步骤来解决问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;理解问题&lt;/strong&gt;：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;确定需求&lt;/strong&gt;：明确</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用递归</title>
    <link href="https://leiqichn.github.io/2024-05-08-23291165e2d9.html"/>
    <id>https://leiqichn.github.io/2024-05-08-23291165e2d9.html</id>
    <published>2024-05-08T15:15:21.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traversal(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义：返回nums root 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traversal</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,left <span class="hljs-type">int</span> , right <span class="hljs-type">int</span>)</span></span> *TreeNode&#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right)/<span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;nums[mid],<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.Left =  traversal(nums,left,mid<span class="hljs-number">-1</span>) <span class="hljs-comment">// 把后边 root 节点添加到当前root left 左节点上</span><br>    root.Right = traversal(nums,mid+<span class="hljs-number">1</span>,right) <span class="hljs-comment">// 把后边 root 节点添加到当前root right 左节点上</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤：</p><ol><li><p><strong>识别重复模式</strong>：</p><ul><li>确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。</li></ul></li><li><p><strong>定义递归函数</strong>：</p><ul><li>根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。</li></ul></li><li><p><strong>确定基本情况</strong>：</p><ul><li>找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。</li></ul></li><li><p><strong>分解问题</strong>：</p><ul><li>将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。</li></ul></li><li><p><strong>递归工作</strong>：</p><ul><li>描述递归如何工作，包括如何从子问题的解中构建出原问题的解。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>确定如何将子问题的解合并为原问题的解。</li></ul></li><li><p><strong>编写伪代码</strong>：</p><ul><li>在编写实际代码之前，先用伪代码描述递归逻辑。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。</li></ul></li><li><p><strong>优化性能</strong>：</p><ul><li>如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。</li></ul></li><li><p><strong>测试和调试</strong>：</p><ul><li>编写测试用例来验证递归逻辑，并调试任何出现的问题。</li></ul></li></ol><p>以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成：</p><ul><li><p><strong>重复模式</strong>：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。</p></li><li><p><strong>定义递归函数</strong>：<code>traversal</code> 函数接收一个数组和两个索引，表示当前考虑的子数组。</p></li><li><p><strong>确定基本情况</strong>：如果左索引大于右索引，说明子数组为空，返回 <code>nil</code>。</p></li><li><p><strong>分解问题</strong>：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 <code>traversal</code> 函数。</p></li><li><p><strong>递归工作</strong>：递归地构建左子树和右子树，然后将它们连接到当前根节点。</p></li><li><p><strong>合并结果</strong>：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。</p></li><li><p><strong>编写伪代码</strong>：在脑中或纸上概述递归调用的流程。</p></li><li><p><strong>考虑边界条件</strong>：确保数组索引不会超出数组边界。</p></li><li><p><strong>优化性能</strong>：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。</p></li><li><p><strong>测试和调试</strong>：通过在不同的数组输入上测试函数来确保其正确性。</p></li></ul><p>通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中debug 无法显示全局变量解决</title>
    <link href="https://leiqichn.github.io/2024-05-07-c105be0dd846.html"/>
    <id>https://leiqichn.github.io/2024-05-07-c105be0dd846.html</id>
    <published>2024-05-07T16:22:44.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240508002347.png">实际只会有局部变量，没有全局变量test</p><p><img src="/../../imgs/Pasted%20image%2020240508002425.png"></p><p>解决方法：</p><p>右键  选择+ New Watch ； 或者 按按键 Insert </p><p>添加变量 test 即可</p><p><img src="/../../imgs/Pasted%20image%2020240508002502.png"><img src="/../../imgs/Pasted%20image%2020240508002708.png"></p><h1 id="添加成功"><a href="#添加成功" class="headerlink" title="添加成功"></a>添加成功</h1><p><img src="/../../imgs/Pasted%20image%2020240508002737.png"><br>之后每次单步执行都会显示变量结果：<br><img src="/../../imgs/Pasted%20image%2020240508002814.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240508002347.png&quot;&gt;实际只会有局部变量，没有全局变量test&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240508002</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 中格式化打印单个字符</title>
    <link href="https://leiqichn.github.io/2024-05-03-ec16a5fd018e.html"/>
    <id>https://leiqichn.github.io/2024-05-03-ec16a5fd018e.html</id>
    <published>2024-05-03T08:58:56.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，<code>fmt.Printf</code> 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。</p><p><code>%c</code> 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 <code>fmt.Printf</code> 中使用 <code>%c</code>，并且传入一个整数（<code>int</code> 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> codePoint <span class="hljs-type">int</span> = <span class="hljs-number">65</span> <span class="hljs-comment">// ASCII码中A的码点</span><br>    fmt.Printf(<span class="hljs-string">&quot;%c\n&quot;</span>, codePoint) <span class="hljs-comment">// 输出: A</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>codePoint</code> 的值为 <code>65</code>，它是大写字母 “A” 在ASCII编码中的码点。<code>fmt.Printf(&quot;%c\n&quot;, codePoint)</code> 将这个整数值格式化为字符 “A” 并输出。</p><p>在处理字节数组 <code>[]byte</code> 并想要将每个字节转换为对应的字符时，<code>%c</code> 非常有用，因为Go的 <code>string</code> 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;hello&quot;</span><br>    bytes := []<span class="hljs-type">byte</span>(s)<br><br>    <span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bytes &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Byte %d: %c\n&quot;</span>, i, b)<br>    &#125;<br>    <span class="hljs-comment">// 输出:</span><br>    <span class="hljs-comment">// Byte 0: h</span><br>    <span class="hljs-comment">// Byte 1: e</span><br>    <span class="hljs-comment">// Byte 2: l</span><br>    <span class="hljs-comment">// Byte 3: l</span><br>    <span class="hljs-comment">// Byte 4: o</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们遍历字符串 <code>&quot;hello&quot;</code> 的字节表示，并使用 <code>%c</code> 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，&lt;code&gt;fmt.Printf&lt;/code&gt; 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。&lt;/p&gt;
&lt;p&gt;&lt;cod</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang slice无法添加指针</title>
    <link href="https://leiqichn.github.io/2024-05-02-247b79126fb5.html"/>
    <id>https://leiqichn.github.io/2024-05-02-247b79126fb5.html</id>
    <published>2024-05-02T13:37:36.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向<code>int</code>的指针，比如<code>timePtr *int</code>，你可以通过<code>*timePtr</code>来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。</p><p>在你提供的<code>add</code>函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(timePtr *<span class="hljs-type">int</span>)</span></span> &#123; *timePtr += <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// 增加一秒</span><br></code></pre></td></tr></table></figure><p><code>timePtr</code>是一个指向<code>int</code>的指针。虽然你可以通过<code>*timePtr</code>来间接修改它所指向的<code>int</code>值，但是你不能使用这个指针来创建一个关于<code>*int</code>的切片。原因如下：</p><ol><li><p><strong>指针的值是地址</strong>：<code>timePtr</code>变量存储的是<code>currentTime</code>变量的内存地址，而不是<code>currentTime</code>的值。切片是基于数组的，它们需要一个具体的数据集合来创建。</p></li><li><p><strong>切片的元素类型</strong>：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于<code>*int</code>的切片，<strong>因为切片的元素类型是</strong><code>int</code>，而不是<code>*int</code>（指向<code>int</code>的指针）。</p></li><li><p><strong>切片创建语法</strong>：创建切片通常需要一个数组或另一个切片作为基础，或者使用<code>make</code>函数指定长度和容量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>slice1 := arr[:] <span class="hljs-comment">// 基于数组的切片</span><br>slice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 使用make创建切片</span><br></code></pre></td></tr></table></figure></li></ol><p>如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在<code>main</code>函数中声明这样一个切片，并在CRUD操作中更新它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> currentTime <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> history []<span class="hljs-type">int</span> <span class="hljs-comment">// 用于记录历史时间</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(timePtr *<span class="hljs-type">int</span>, historyPtr *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    *timePtr++<br>    historyPtr = <span class="hljs-built_in">append</span>(*historyPtr, *timePtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    currentTime = <span class="hljs-number">0</span><br>    history = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始化历史切片</span><br><br>    add(&amp;currentTime, &amp;history)<br>    <span class="hljs-comment">// 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点</span><br><br>    fmt.Println(<span class="hljs-string">&quot;History of times:&quot;</span>, history)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>history</code>是一个切片，用于存储时间点的历史记录。每次调用<code>add</code>函数时，我们不仅更新<code>currentTime</code>，还将新的时间点添加到<code>history</code>切片中。注意，由于切片是引用类型，我们传递<code>&amp;history</code>来允许函数修改原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向&lt;code&gt;int&lt;/code&gt;的指针，比如&lt;code&gt;timePtr *int&lt;/code&gt;，你可以通过&lt;code&gt;*timePtr&lt;/code&gt;来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络概览</title>
    <link href="https://leiqichn.github.io/2024-05-02-82705503428a.html"/>
    <id>https://leiqichn.github.io/2024-05-02-82705503428a.html</id>
    <published>2024-05-02T07:27:45.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240502152821.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153252.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153337.png"></p><p><img src="/../../imgs/Pasted%20image%2020240502153543.png"></p><p>【计算机网络】常识</p><p>知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；<br>两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线<br>【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；<br>数据链路层；<br>【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；<br>【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；<br>【物理地址MAC】<br>交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）<br>【点对点连接】【全双工通讯】提高了带宽利用率；<br>【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；<br>【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；<br>【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长<br>【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；<br>【IP地址】用于标识不同的网络和网络设备；<br>【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）<br>【默认网关IP】不同网段连接到路由器的IP；<br>【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；<br>设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；<br>【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器<br>【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；<br>【海底光缆】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240502152821.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240502153252.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>ssh 隧道 端口转发</title>
    <link href="https://leiqichn.github.io/2024-04-21-29ab33001840.html"/>
    <id>https://leiqichn.github.io/2024-04-21-29ab33001840.html</id>
    <published>2024-04-21T14:30:08.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>使用SSH端口转发<br>   如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用<code>-L</code>参数实现，如下所示：<br>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh -L 本地端口:localhost:13579 用户名@物理机IP<br></code></pre></td></tr></table></figure><br>   其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。</p><p>例如：<br>我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh -L <span class="hljs-number">13579</span>:localhost:<span class="hljs-number">13579</span> <span class="hljs-symbol">root@</span><span class="hljs-number">110.43</span><span class="hljs-number">.203</span><span class="hljs-number">.19</span> -p <span class="hljs-number">30005</span> <br><span class="hljs-comment">// </span><br>ssh -p <span class="hljs-number">13579</span> <span class="hljs-symbol">root@</span>localhost<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用SSH端口转发&lt;br&gt;   如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用&lt;code&gt;-L&lt;/code&gt;参数实现，如下所示：&lt;br&gt;   &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 208. 实现 Trie (前缀树)</title>
    <link href="https://leiqichn.github.io/2024-04-16-1150f59f3df6.html"/>
    <id>https://leiqichn.github.io/2024-04-16-1150f59f3df6.html</id>
    <published>2024-04-16T16:34:47.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。</p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240417003637.png"></p><p>Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。</p><p>为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    Value <span class="hljs-type">int</span><br><br>    Next  *TrieNode<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    children [<span class="hljs-number">26</span>]*TrieNode<br><br>    isEnd    <span class="hljs-type">bool</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br>  <br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <br><br><span class="hljs-comment">// TrieNode 代表Trie中的每个节点</span><br><br><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br><br>    children [<span class="hljs-number">26</span>]*TrieNode<br><br>    isEnd    <span class="hljs-type">bool</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Trie 代表整个前缀树</span><br><br><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br><br>    root *TrieNode<br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Constructor 初始化一个Trie对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br><br>    <span class="hljs-keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;<br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Insert 将word插入到trie中</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>) &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            node.children[index] = &amp;TrieNode&#123;&#125;<br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    node.isEnd = <span class="hljs-literal">true</span> <span class="hljs-comment">// 标记单词结束的节点</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// Search 在trie中搜索word</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明word不在trie中</span><br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node.isEnd <span class="hljs-comment">// 检查最后一个节点是否标记为单词结尾</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">// StartsWith 返回trie中是否有任何单词以prefix为前缀</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><br>    node := this.root<br><br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br><br>        index := ch - <span class="hljs-string">&#x27;a&#x27;</span><br><br>        <span class="hljs-keyword">if</span> node.children[index] == <span class="hljs-literal">nil</span> &#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 如果路径中的节点不存在，说明没有以prefix为前缀的word</span><br><br>        &#125;<br><br>        node = node.children[index]<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 所有的char都在路径中，说明trie有以prefix为前缀的word</span><br><br>&#125;<br><br>  <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/implement-trie-prefix-tree/&quot;&gt;208. 实现 Trie (前</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang slice作为参数传递给函数需要使用指针</title>
    <link href="https://leiqichn.github.io/2024-04-11-22166b2f52d0.html"/>
    <id>https://leiqichn.github.io/2024-04-11-22166b2f52d0.html</id>
    <published>2024-04-11T16:35:04.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    dfs(<span class="hljs-number">1</span>,n,k,&amp;res,&amp;[]<span class="hljs-type">int</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s, n, k <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>, item *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*item) == k &#123;<br>        *res = <span class="hljs-built_in">append</span>(*res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, *item...))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := s; i &lt;= n-(k-<span class="hljs-built_in">len</span>(*item))+<span class="hljs-number">1</span>; i++&#123;<br>        *item = <span class="hljs-built_in">append</span>(*item, i)<br>        dfs(i+<span class="hljs-number">1</span>, n, k, res, item)<br>        *item = (*item)[:<span class="hljs-built_in">len</span>(*item)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 append 函数或者直接索引赋值的方式，那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。</p><p>这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。</p><p>例如，在 <code>combine</code> 函数中，如果想要 <code>dfs</code> 函数能够修改 <code>res</code> slice 的长度（即添加新的组合到 <code>res</code> 中），那么需要传递 <code>res</code> 的指针的指针。这样，当 <code>dfs</code> 函数执行 <code>*res = append(*res, newCombination...)</code> 时，它会修改原始的 <code>res</code> slice 而不是它的副本。</p><p>传递指针的原因是为了：</p><ol><li><p><strong>避免不必要的副本创建</strong>：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。</p></li><li><p><strong>确保函数内部的修改能够反映到原始数据上</strong>：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。</p></li><li><p><strong>提高代码的效率和性能</strong>：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。</p></li></ol><p>还可以转化为全局变量；需要注意的是<br>go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span> <span class="hljs-comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 需要进行初始化</span><br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i&lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>)<br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; <strong>tempPath :&#x3D; []int{}</strong>,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。<br>copy(tempPath, path)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span> <span class="hljs-comment">// go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br><br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, startIndex <span class="hljs-type">int</span>)</span></span><br>    backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, startIndex <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            tempPath := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k) <span class="hljs-comment">// tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。</span><br>            <span class="hljs-built_in">copy</span>(tempPath, path)<br>            res = <span class="hljs-built_in">append</span>(res, tempPath)<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> i:= startIndex; i &lt;= n; i++ &#123;<br>            <span class="hljs-keyword">if</span> (n -i +<span class="hljs-number">1</span> ) &lt; (k -<span class="hljs-built_in">len</span>(path)) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            path = <span class="hljs-built_in">append</span>(path, i)<br>            backtracking(n, k, i+<span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题 总结</title>
    <link href="https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html"/>
    <id>https://leiqichn.github.io/2024-04-05-d9f9294c39ef.html</id>
    <published>2024-04-05T17:21:04.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>举个简单的例子：<br><strong>设计题 - 实现浏览器历史记录</strong><br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p><ul><li>和当前页相同，则直接返回</li><li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description: 浏览器实现</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.GetCurrentPage() == newPageURL &#123;<br><span class="hljs-keyword">return</span> newPageURL<br>&#125;<br><br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p><h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p><p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p><h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p><p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p><h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p><p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p><h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p><h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p><p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面，我们来按照难度多练习几道题目</p><h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ol><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></li></ol><p><img src="/../../imgs/Pasted%20image%2020240405184827.png"></p><p> <strong>思路：</strong>input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>inputStack  []<span class="hljs-type">int</span><br>outputStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br><span class="hljs-keyword">return</span> MyQueue&#123;<br>inputStack:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputStack: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputStack = <span class="hljs-built_in">append</span>(this.inputStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.inputStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(this.outputStack) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Peek();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a><img src="/../../imgs/Pasted%20image%2020240405184932.png"></li></ol><p><strong>思路：</strong>用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>inputQueue  []<span class="hljs-type">int</span><br>outputQueue []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br><span class="hljs-keyword">return</span> MyStack&#123;<br>inputQueue:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputQueue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.inputQueue, x)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = this.outputQueue<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue...)<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(this.inputQueue) == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">len</span>(this.outputQueue) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406201421.png"><br>思路：简单题，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    nums  []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    <span class="hljs-keyword">return</span> NumArray&#123;nums: nums&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i:= left; i&lt;= right; i++ &#123;<br>        sum += this.nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用前缀和<br><img src="/../../imgs/Pasted%20image%2020240406201959.png"><br>怎么求 preSum 数组<br>利用前面提到的递推式:<br><img src="/../../imgs/Pasted%20image%2020240406201929.png"></p><p>遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，<strong>即preSum[0]为nums[0]（前提是nums有元素）</strong>。</p><p>预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。</p><p>需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。</p><p>后面会给出简化的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(nums);i++ &#123;<br>        preSum[ i] = preSum[ i<span class="hljs-number">-1</span>] + nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.preSum) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 但如果nums根本没有长度，直接返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> this.preSum[right]<br>&#125;<br>    <span class="hljs-keyword">return</span> this.preSum[right] - this.preSum[left<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用多一位长度的前缀和<br>之所以上面处理东西多，是因为<code>preSum[i]</code>的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index</p><p>要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]<br>即：</p><p><img src="/../../imgs/Pasted%20image%2020240406202142.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> nums &#123;<br>        preSum[index + <span class="hljs-number">1</span>] = preSum[index] + value<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.preSum[right + <span class="hljs-number">1</span>] - this.preSum[left]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406204841.png"><br><strong>暴力解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 排序后的nums</span><br>index      <span class="hljs-type">int</span><br>sortedNums []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br><span class="hljs-keyword">return</span> KthLargest&#123;k, nums&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>this.sortedNums = <span class="hljs-built_in">append</span>(this.sortedNums, val)<br>sort.Ints(this.sortedNums)<br>revert(this.sortedNums)<br><span class="hljs-keyword">return</span> this.sortedNums[this.index<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">revert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(k, nums);</span><br><span class="hljs-comment"> * param_1 := obj.Add(val);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><strong>优先队列</strong><br>我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。</p><p>在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br>    sort.IntSlice<br>    k <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br>    kl := KthLargest&#123;k: k&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>        kl.Add(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    kl.IntSlice = <span class="hljs-built_in">append</span>(kl.IntSlice, v.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    a := kl.IntSlice<br>    v := a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    kl.IntSlice = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    heap.Push(kl, val)<br>    <span class="hljs-keyword">if</span> kl.Len() &gt; kl.k &#123;<br>        heap.Pop(kl)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl.IntSlice[<span class="hljs-number">0</span>]<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;举个简单的例子：&lt;br&gt;&lt;strong&gt;设计题 - 实现浏览器历史记录&lt;/strong&gt;&lt;br&gt;1.初始化 homepage 和历史记录容量&lt;br&gt;2.浏览网页 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和当前页相同，则直接返回&lt;/li&gt;
&lt;li&gt;和当前页不同，如果容量满了，则删除最早的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows IE代理问题解决</title>
    <link href="https://leiqichn.github.io/2024-04-05-e1116cf34b00.html"/>
    <id>https://leiqichn.github.io/2024-04-05-e1116cf34b00.html</id>
    <published>2024-04-05T05:11:29.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>CMD <strong>检查系统代理配置</strong>：</p><pre><code class="hljs">- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。- 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CMD &lt;strong&gt;检查系统代理配置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。
- 如果需要更改系统代理，可以使用`netsh win</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 双指针</title>
    <link href="https://leiqichn.github.io/2024-03-23-84678021105b.html"/>
    <id>https://leiqichn.github.io/2024-03-23-84678021105b.html</id>
    <published>2024-03-23T14:51:46.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除有序数组中的重复元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast:=<span class="hljs-number">1</span>;fast &lt;<span class="hljs-built_in">len</span>(nums);fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<span class="hljs-comment">// 跳到下个位置，保存slow</span><br><br>            nums[slow] = nums[fast]<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow +<span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p><p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>注意到以下性质：</strong></p><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>slow, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123; <span class="hljs-comment">// 注意第一个是0的时候需要比较</span><br><span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span><br>nums[slow], nums[fast] = nums[fast], nums[slow]<br>slow++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(height); j++ &#123;<br>area := (j - i) * min(height[i], height[j])<br>ans = max(area,ans)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化两边指针</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        area := (right - left) * min(height[left], height[right]) <span class="hljs-comment">// 计算面积</span><br>        ans = max(ans, area) <span class="hljs-comment">// 计算最大值</span><br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123; <br>            left++ <span class="hljs-comment">// 移动短的那个</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240326011627.png"></p><p>前缀和，后缀和<br>木桶效应，当前能装的水，取决于两边最大值 的最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    preMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// preMax[i] 表示从 height[0] 到 height[i] 的最大值</span><br>    preMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        preMax[i] = max(preMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    sufMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值</span><br>    sufMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        sufMax[i] = max(sufMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        ans += min(preMax[i], sufMax[i]) - h <span class="hljs-comment">// 累加每个水桶能接多少水</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right, preMax, sufMax := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        preMax = max(preMax, height[left])<br>        sufMax = max(sufMax, height[right])<br>        <span class="hljs-keyword">if</span> preMax &lt; sufMax &#123;<br>            ans += preMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += sufMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240323225412.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 单调栈</title>
    <link href="https://leiqichn.github.io/2024-02-24-dd95d981cb94.html"/>
    <id>https://leiqichn.github.io/2024-02-24-dd95d981cb94.html</id>
    <published>2024-02-24T15:57:54.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p><p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123; <span class="hljs-comment">// 倒着入栈是为了后边正着出栈</span><br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &lt;= nums[i] &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有更大的元素</span><br>            res[i] = <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 正着出栈</span><br>        &#125;<br>        s = <span class="hljs-built_in">append</span>(s, nums[i]) <span class="hljs-comment">// 当前元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」&lt;/p&gt;
&lt;p&gt;输入一个数组 &lt;code&gt;nums&lt;/code&gt;，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <link href="https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html"/>
    <id>https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html</id>
    <published>2024-02-24T14:50:06.000Z</published>
    <updated>2024-05-12T06:27:50.747Z</updated>
    
    <content type="html"><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p><pre><code class="hljs">*res = append(*res, root.Val)dfs(root.Left, res)dfs(root.Right, res)</code></pre><p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p><p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p><p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p><p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;func dfs(root *TreeNode, res *[]int) {&lt;br&gt;    if root &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;*res = ap</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>路由器设置桥接</title>
    <link href="https://leiqichn.github.io/2024-02-15-1f66da892e14.html"/>
    <id>https://leiqichn.github.io/2024-02-15-1f66da892e14.html</id>
    <published>2024-02-15T13:34:12.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240215213434.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215213536.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215213849.png"></p><p><img src="/../../imgs/Pasted%20image%2020240215214100.png"><br><img src="/../../imgs/Pasted%20image%2020240215221821.png"><br>设置密码类型和主路由一样<br><img src="/../../imgs/Pasted%20image%2020240215221453.png"></p><p>记得关闭DHCP服务器<br><img src="/../../imgs/Pasted%20image%2020240215221417.png"><br><img src="/../../imgs/Pasted%20image%2020240215221130.png"><img src="/../../imgs/Pasted%20image%2020240215221401.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240215213434.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240215213536.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <link href="https://leiqichn.github.io/2024-01-23-1cb0809a7893.html"/>
    <id>https://leiqichn.github.io/2024-01-23-1cb0809a7893.html</id>
    <published>2024-01-23T16:13:30.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> people[i][<span class="hljs-number">0</span>] == people[j][<span class="hljs-number">0</span>]&#123;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">1</span>] &lt; people[j][<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">0</span>] &gt; people[j][<span class="hljs-number">0</span>] <span class="hljs-comment">// 身高由大到小排列</span><br><br>&#125;)i<br><span class="hljs-comment">// 再按照K进行插入排序，优先插入K小的</span><br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-built_in">copy</span>(people[p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span> :i+<span class="hljs-number">1</span>], people[p[<span class="hljs-number">1</span>] :i=<span class="hljs-number">1</span>])  <span class="hljs-comment">// 腾空出一个位置</span><br>        people[p[<span class="hljs-number">1</span>]] = pi<br>&#125;<br><span class="hljs-keyword">return</span> people<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p></li><li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p></li><li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p></li><li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p></li></ol><p>最终，返回重新排列后的队列 <code>people</code>。</p><p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p><p>让我们考虑一下为什么使用 <code>i+1</code>：</p><ol><li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li><li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li><li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/queue-reconstruction-by-height/description/&quot;&gt;406. 根据身高重建队列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <link href="https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html"/>
    <id>https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html</id>
    <published>2024-01-23T15:17:11.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p><p>使用回溯的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>path := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// return </span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>) <span class="hljs-comment">// i+1 进行下一轮</span><br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p></li><li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p></li><li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p></li><li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p></li><li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p></li><li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinations/description/&quot;&gt;77. 组合 - 力扣（LeetCode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202024</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【BFS DFS通用模板】</title>
    <link href="https://leiqichn.github.io/2024-01-22-759654485d5d.html"/>
    <id>https://leiqichn.github.io/2024-01-22-759654485d5d.html</id>
    <published>2024-01-22T16:05:29.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 通用的深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node <span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> visited[node] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理当前节点</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 标记当前节点为已访问</span><br>    visited[node] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 递归处理相邻节点</span><br>    <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>        dfs(neighbor, visited, graph)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化节点、访问数组等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 遍历所有节点</span><br>    <span class="hljs-keyword">for</span> node := <span class="hljs-number">0</span>; node &lt; <span class="hljs-built_in">len</span>(graph); node++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[node] &#123;<br>            dfs(node, visited, graph)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通用的广度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(graph))<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 出队列</span><br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment">// 处理当前节点</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 标记当前节点为已访问</span><br>        visited[node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 将相邻节点入队列</span><br>        <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[neighbor] &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, neighbor)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化起始节点、图等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用BFS函数</span><br>    bfs(start, graph)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;a href=&quot;#深度优先搜索（DFS）通用模板&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;/a&gt;深度优先搜索（DFS）通用模板&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <link href="https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html"/>
    <id>https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html</id>
    <published>2024-01-22T15:01:59.000Z</published>
    <updated>2024-05-12T06:27:50.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">var</span> traversal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traversal = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br>traversal(node.Left)<br>res = <span class="hljs-built_in">append</span>(res,node.Val)<br>traversal(node.Right)<br>    &#125;<br>    traversal(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br><br>    st := list.New()<br>    cur := root<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> || st.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            st.PushBack(cur)<br>            cur = cur.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = st.Remove(st.Back()).(*TreeNode)<br>            ans = <span class="hljs-built_in">append</span>(ans, cur.Val)<br>            cur = cur.Right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对代码的解释：</p><ol><li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p></li><li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p></li><li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p></li><li><p><code>cur := root</code>: 初始化当前节点为根节点。</p></li><li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p></li><li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p><ul><li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p></li><li><p><code>cur = cur.Left</code>: 移动到左子树。</p></li></ul></li><li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p><ul><li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p></li><li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p></li><li><p><code>cur = cur.Right</code>: 移动到右子树。</p></li></ul></li><li><p>循环回到第5步，直到栈为空。</p></li></ol><p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p><p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p><ul><li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p></li><li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p></li></ul><p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p><p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归方法&quot;&gt;&lt;a href=&quot;#递归方法&quot; class=&quot;headerlink&quot; title=&quot;递归方法&quot;&gt;&lt;/a&gt;递归方法&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
