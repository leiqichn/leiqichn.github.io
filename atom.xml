<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-06-17T16:34:43.215Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leiqi.top/2025-06-17-f2a8de41a3fe.html"/>
    <id>https://leiqi.top/2025-06-17-f2a8de41a3fe.html</id>
    <published>2025-06-17T16:34:43.215Z</published>
    <updated>2025-06-17T16:34:43.215Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，<code>switch</code> 语句提供了灵活的条件分支控制，相比其他语言有更多特性。以下是详细用法和示例：</p><hr><h3 id="1-基础值匹配"><a href="#1-基础值匹配" class="headerlink" title="1. 基础值匹配"></a>1. <strong>基础值匹配</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">day := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> day &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Wednesday&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Thursday&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Weekend&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-多值匹配（逗号分隔）"><a href="#2-多值匹配（逗号分隔）" class="headerlink" title="2. 多值匹配（逗号分隔）"></a>2. <strong>多值匹配（逗号分隔）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char := <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Vowel&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sometimes vowel&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Consonant&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-无表达式（替代-if-else）"><a href="#3-无表达式（替代-if-else）" class="headerlink" title="3. 无表达式（替代 if-else）"></a>3. <strong>无表达式（替代 if-else）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score := <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">80</span>: <span class="comment">// 满足条件</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-类型判断（Type-Switch）"><a href="#4-类型判断（Type-Switch）" class="headerlink" title="4. 类型判断（Type Switch）"></a>4. <strong>类型判断（Type Switch）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">switch</span> v := data.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Integer:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;String:&quot;</span>, v) <span class="comment">// 输出: String: hello</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-穿透执行（fallthrough）"><a href="#5-穿透执行（fallthrough）" class="headerlink" title="5. 穿透执行（fallthrough）"></a>5. <strong>穿透执行（fallthrough）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;One&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Two&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">fallthrough</span>        <span class="comment">// 强制执行下一个 case</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Three&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Two\nThree</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-初始化语句"><a href="#6-初始化语句" class="headerlink" title="6. 初始化语句"></a>6. <strong>初始化语句</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> lang := <span class="string">&quot;Go&quot;</span>; lang &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Java&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Enterprise&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Go&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Efficient&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关键特性总结："><a href="#关键特性总结：" class="headerlink" title="关键特性总结："></a>关键特性总结：</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>自动终止</strong></td><td>无需 <code>break</code>，执行完 case 后自动退出 switch</td></tr><tr><td><strong>多值匹配</strong></td><td>用逗号分隔多个值（如 <code>case 1, 2, 3</code>）</td></tr><tr><td><strong>无表达式模式</strong></td><td>类似 <code>if-else</code> 链，更简洁的条件分支</td></tr><tr><td><strong>类型判断</strong></td><td>通过 <code>data.(type)</code> 检测接口值的实际类型</td></tr><tr><td><strong>fallthrough</strong></td><td>显式声明继续执行下一个 case（<strong>不判断条件</strong>）</td></tr><tr><td><strong>作用域隔离</strong></td><td>支持在 <code>switch</code> 后初始化局部变量（如 <code>switch x := 10; &#123; ... &#125;</code>）</td></tr></tbody></table><hr><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> hour := time.Now().Hour(); &#123;</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Morning&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">18</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Afternoon&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Night&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 的 <code>switch</code> 设计强调简洁和安全，避免 C&#x2F;C++ 中因忘记 <code>break</code> 导致的错误。根据场景选择合适用法可大幅提升代码可读性。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，&lt;code&gt;switch&lt;/code&gt; 语句提供了灵活的条件分支控制，相比其他语言有更多特性。以下是详细用法和示例：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-基础值匹配&quot;&gt;&lt;a href=&quot;#1-基础值匹配&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="G" scheme="https://leiqi.top/categories/G/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】贪心</title>
    <link href="https://leiqi.top/2025-06-17-12ec7942da63.html"/>
    <id>https://leiqi.top/2025-06-17-12ec7942da63.html</id>
    <published>2025-06-17T16:33:41.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法经典题目及Golang实现"><a href="#贪心算法经典题目及Golang实现" class="headerlink" title="贪心算法经典题目及Golang实现"></a>贪心算法经典题目及Golang实现</h1><p>贪心算法是一种在每一步选择中都采取当前状态下最优的选择，从而希望导致全局最优解的算法策略。以下是一些LeetCode上经典的贪心算法题目及其Golang实现，并总结一个通用的解题模板。</p><h2 id="经典贪心题目及Golang实现"><a href="#经典贪心题目及Golang实现" class="headerlink" title="经典贪心题目及Golang实现"></a>经典贪心题目及Golang实现</h2><h3 id="1-分发饼干-455-Assign-Cookies"><a href="#1-分发饼干-455-Assign-Cookies" class="headerlink" title="1. 分发饼干 (455. Assign Cookies)"></a>1. 分发饼干 (455. Assign Cookies)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    </span><br><span class="line">    child, cookie := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> child &lt; <span class="built_in">len</span>(g) &amp;&amp; cookie &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[cookie] &gt;= g[child] &#123;</span><br><span class="line">            child++</span><br><span class="line">        &#125;</span><br><span class="line">        cookie++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-无重叠区间-435-Non-overlapping-Intervals"><a href="#2-无重叠区间-435-Non-overlapping-Intervals" class="headerlink" title="2. 无重叠区间 (435. Non-overlapping Intervals)"></a>2. 无重叠区间 (435. Non-overlapping Intervals)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)"></a>3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    arrows := <span class="number">1</span></span><br><span class="line">    pos := points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; pos &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            pos = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)"></a>4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-跳跃游戏-55-Jump-Game"><a href="#5-跳跃游戏-55-Jump-Game" class="headerlink" title="5. 跳跃游戏 (55. Jump Game)"></a>5. 跳跃游戏 (55. Jump Game)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    farthest := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; farthest &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-跳跃游戏-II-45-Jump-Game-II"><a href="#6-跳跃游戏-II-45-Jump-Game-II" class="headerlink" title="6. 跳跃游戏 II (45. Jump Game II)"></a>6. 跳跃游戏 II (45. Jump Game II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    jumps, curEnd, farthest := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == curEnd &#123;</span><br><span class="line">            jumps++</span><br><span class="line">            curEnd = farthest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-加油站-134-Gas-Station"><a href="#7-加油站-134-Gas-Station" class="headerlink" title="7. 加油站 (134. Gas Station)"></a>7. 加油站 (134. Gas Station)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total, curr, start := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gas); i++ &#123;</span><br><span class="line">        total += gas[i] - cost[i]</span><br><span class="line">        curr += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> curr &lt; <span class="number">0</span> &#123;</span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> total &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-任务调度器-621-Task-Scheduler"><a href="#8-任务调度器-621-Task-Scheduler" class="headerlink" title="8. 任务调度器 (621. Task Scheduler)"></a>8. 任务调度器 (621. Task Scheduler)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leastInterval</span><span class="params">(tasks []<span class="type">byte</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        freq[t-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(freq)</span><br><span class="line">    </span><br><span class="line">    maxFreq := freq[<span class="number">25</span>]</span><br><span class="line">    idleSlots := (maxFreq - <span class="number">1</span>) * n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; freq[i] &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        idleSlots -= min(freq[i], maxFreq<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> idleSlots &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idleSlots + <span class="built_in">len</span>(tasks)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tasks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法通用模板"><a href="#贪心算法通用模板" class="headerlink" title="贪心算法通用模板"></a>贪心算法通用模板</h2><p>虽然贪心算法没有固定的模板，但通常可以遵循以下步骤：</p><ol><li><strong>排序</strong>：很多贪心问题需要对输入数据进行排序</li><li><strong>初始化</strong>：设置必要的变量（如计数器、指针等）</li><li><strong>遍历处理</strong>：遍历排序后的数据，做出贪心选择</li><li><strong>验证结果</strong>：检查是否满足题目要求</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greedyAlgorithm</span><span class="params">(input []Type)</span></span> ResultType &#123;</span><br><span class="line">    <span class="comment">// 1. 排序（如果需要）</span></span><br><span class="line">    sort.Slice(input, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(input[i], input[j])</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化变量</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    current := initialValue</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 遍历处理</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> input &#123;</span><br><span class="line">        <span class="keyword">if</span> canMakeGreedyChoice(current, item) &#123;</span><br><span class="line">            <span class="comment">// 做出贪心选择</span></span><br><span class="line">            update(current, item)</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法适用场景"><a href="#贪心算法适用场景" class="headerlink" title="贪心算法适用场景"></a>贪心算法适用场景</h2><p>贪心算法通常适用于以下类型的问题：</p><ul><li>可以分解为子问题的问题</li><li>子问题的最优解能递推到最终问题的最优解</li><li>无后效性，即某个状态以后的过程不会影响以前的状态</li></ul><p>常见应用场景包括：</p><ul><li>分配问题（如分发饼干）</li><li>区间问题（如无重叠区间）</li><li>调度问题（如任务调度器）</li><li>股票买卖问题</li><li>跳跃游戏类问题</li></ul><p>贪心算法的关键在于证明贪心策略的正确性，这通常需要数学证明或直观理解。在实际应用中，如果无法确定贪心策略是否正确，可以先尝试，然后验证是否能够得到全局最优解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#贪心算法经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;/a&gt;贪心算法经典题目及Golang实现&lt;/h1&gt;&lt;p&gt;贪心算法是一种在每一</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】优先队列</title>
    <link href="https://leiqi.top/2025-06-17-96c1b8914ef4.html"/>
    <id>https://leiqi.top/2025-06-17-96c1b8914ef4.html</id>
    <published>2025-06-17T16:29:57.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列在LeetCode上的经典题目及Golang实现"><a href="#优先队列在LeetCode上的经典题目及Golang实现" class="headerlink" title="优先队列在LeetCode上的经典题目及Golang实现"></a>优先队列在LeetCode上的经典题目及Golang实现</h1><p>优先队列（Priority Queue）是一种重要的数据结构，它在很多算法问题中都有广泛应用。以下是LeetCode上一些经典的优先队列题目，以及用Golang实现的解决方案和模板总结。</p><h2 id="优先队列的Golang实现"><a href="#优先队列的Golang实现" class="headerlink" title="优先队列的Golang实现"></a>优先队列的Golang实现</h2><p>在Golang中，我们可以使用<code>container/heap</code>包来实现优先队列。首先，我们需要定义一个实现heap.Interface的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个最小堆</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆只需修改Less方法</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 改为大于号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典题目及实现"><a href="#经典题目及实现" class="headerlink" title="经典题目及实现"></a>经典题目及实现</h2><h3 id="1-合并K个升序链表-LeetCode-23"><a href="#1-合并K个升序链表-LeetCode-23" class="headerlink" title="1. 合并K个升序链表 (LeetCode 23)"></a>1. 合并K个升序链表 (LeetCode 23)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    h := &amp;NodeHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有链表的头节点加入堆</span></span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    current := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := heap.Pop(h).(*ListNode)</span><br><span class="line">        current.Next = node</span><br><span class="line">        current = current.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, node.Next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组中的第K个最大元素-LeetCode-215"><a href="#2-数组中的第K个最大元素-LeetCode-215" class="headerlink" title="2. 数组中的第K个最大元素 (LeetCode 215)"></a>2. 数组中的第K个最大元素 (LeetCode 215)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := &amp;MinHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.Push(h, num)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-前K个高频元素-LeetCode-347"><a href="#3-前K个高频元素-LeetCode-347" class="headerlink" title="3. 前K个高频元素 (LeetCode 347)"></a>3. 前K个高频元素 (LeetCode 347)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> pq[i].count &lt; pq[j].count &#125; <span class="comment">// 最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; pq[i], pq[j] = pq[j], pq[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 统计频率</span></span><br><span class="line">    frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        frequency[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建优先队列</span></span><br><span class="line">    pq := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素加入队列</span></span><br><span class="line">    <span class="keyword">for</span> value, count := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">        heap.Push(pq, &amp;Item&#123;value: value, count: count&#125;)</span><br><span class="line">        <span class="keyword">if</span> pq.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(pq)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集结果</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        result[i] = heap.Pop(pq).(*Item).value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数据流的中位数-LeetCode-295"><a href="#4-数据流的中位数-LeetCode-295" class="headerlink" title="4. 数据流的中位数 (LeetCode 295)"></a>4. 数据流的中位数 (LeetCode 295)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxHeap *MaxHeap <span class="comment">// 存储较小的一半</span></span><br><span class="line">    minHeap *MinHeap <span class="comment">// 存储较大的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        maxHeap: &amp;MaxHeap&#123;&#125;,</span><br><span class="line">        minHeap: &amp;MinHeap&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入maxHeap</span></span><br><span class="line">    heap.Push(this.maxHeap, num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平衡两个堆</span></span><br><span class="line">    heap.Push(this.minHeap, heap.Pop(this.maxHeap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;</span><br><span class="line">        heap.Push(this.maxHeap, heap.Pop(this.minHeap))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>]+(*this.minHeap)[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列解题模板"><a href="#优先队列解题模板" class="headerlink" title="优先队列解题模板"></a>优先队列解题模板</h2><p>基于以上题目，可以总结出优先队列的通用解题模板：</p><ol><li><p><strong>定义堆类型</strong>：</p><ul><li>实现heap.Interface接口（Len, Less, Swap, Push, Pop方法）</li><li>根据需求决定是最小堆还是最大堆（通过Less方法控制）</li></ul></li><li><p><strong>初始化堆</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;CustomHeap&#123;&#125;</span><br><span class="line">heap.Init(h)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用堆</strong>：</p><ul><li>添加元素：<code>heap.Push(h, element)</code></li><li>弹出元素：<code>heap.Pop(h)</code></li><li>访问堆顶元素（不弹出）：对于最小堆是<code>h[0]</code>，注意要先检查长度</li></ul></li><li><p><strong>常见模式</strong>：</p><ul><li>维护一个大小为K的堆（求前K大&#x2F;小元素）</li><li>使用两个堆维护动态数据流的中位数</li><li>在贪心算法中使用优先队列选择最优解</li></ul></li></ol><h2 id="其他经典优先队列题目"><a href="#其他经典优先队列题目" class="headerlink" title="其他经典优先队列题目"></a>其他经典优先队列题目</h2><ol><li>滑动窗口最大值 (LeetCode 239)</li><li>任务调度器 (LeetCode 621)</li><li>最接近原点的K个点 (LeetCode 973)</li><li>重构字符串 (LeetCode 767)</li><li>网络延迟时间 (LeetCode 743)</li></ol><p>优先队列是解决许多复杂问题的有力工具，特别是在需要动态获取最大&#x2F;最小元素或前K个元素的场景中。掌握其实现和应用模式对算法面试非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#优先队列在LeetCode上的经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;/a&gt;优先</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】sort.Search二分包</title>
    <link href="https://leiqi.top/2025-06-17-5b0e8e4ea44f.html"/>
    <id>https://leiqi.top/2025-06-17-5b0e8e4ea44f.html</id>
    <published>2025-06-17T16:26:45.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-中二分查找包的使用方法"><a href="#Golang-中二分查找包的使用方法" class="headerlink" title="Golang 中二分查找包的使用方法"></a>Golang 中二分查找包的使用方法</h1><p>Go 标准库中的 <code>sort</code> 包提供了二分查找的功能，主要通过 <code>sort.Search</code> 函数实现。下面详细介绍如何使用这个功能。</p><h3 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 初始化边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 防止溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">// 找到目标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 调整左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment">// 调整右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeftBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找右边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRightBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-sort-Search-基本用法"><a href="#1-sort-Search-基本用法" class="headerlink" title="1. sort.Search 基本用法"></a>1. <code>sort.Search</code> 基本用法</h2><p><code>sort.Search</code> 函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure><p>它会在 <code>[0, n)</code> 范围内查找满足 <code>f(i)</code> 为 <code>true</code> 的最小索引 <code>i</code>。如果不存在这样的索引，则返回 <code>n</code>。</p><h3 id="基本示例：在有序切片中查找元素"><a href="#基本示例：在有序切片中查找元素" class="headerlink" title="基本示例：在有序切片中查找元素"></a>基本示例：在有序切片中查找元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找目标值的索引</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查找特定条件的元素"><a href="#2-查找特定条件的元素" class="headerlink" title="2. 查找特定条件的元素"></a>2. 查找特定条件的元素</h2><p><code>sort.Search</code> 的强大之处在于可以查找满足任意条件的第一个元素。</p><h3 id="示例：查找第一个大于等于目标值的元素"><a href="#示例：查找第一个大于等于目标值的元素" class="headerlink" title="示例：查找第一个大于等于目标值的元素"></a>示例：查找第一个大于等于目标值的元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;第一个大于等于 %d 的元素是 %d，索引为 %d\n&quot;</span>, target, nums[index], index)</span><br></pre></td></tr></table></figure><h3 id="示例：查找第一个满足条件的偶数"><a href="#示例：查找第一个满足条件的偶数" class="headerlink" title="示例：查找第一个满足条件的偶数"></a>示例：查找第一个满足条件的偶数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i]%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第一个偶数是 %d，索引为 %d\n&quot;</span>, nums[index], index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;没有找到偶数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-自定义类型的二分查找"><a href="#3-自定义类型的二分查找" class="headerlink" title="3. 自定义类型的二分查找"></a>3. 自定义类型的二分查找</h2><p>对于自定义类型，需要先实现 <code>sort.Interface</code> 接口，然后才能使用 <code>sort.Search</code>。</p><h3 id="示例：自定义结构体切片查找"><a href="#示例：自定义结构体切片查找" class="headerlink" title="示例：自定义结构体切片查找"></a>示例：自定义结构体切片查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := ByAge&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先排序</span></span><br><span class="line">    sort.Sort(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找年龄大于等于 33 的第一个人</span></span><br><span class="line">    targetAge := <span class="number">33</span></span><br><span class="line">    index := sort.Search(<span class="built_in">len</span>(people), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &gt;= targetAge</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(people) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;找到 %+v，索引为 %d\n&quot;</span>, people[index], index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有找到满足条件的人&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-查找浮点数近似值"><a href="#4-查找浮点数近似值" class="headerlink" title="4. 查找浮点数近似值"></a>4. 查找浮点数近似值</h2><p><code>sort.Search</code> 也可以用于浮点数近似查找。</p><h3 id="示例：查找平方根近似值"><a href="#示例：查找平方根近似值" class="headerlink" title="示例：查找平方根近似值"></a>示例：查找平方根近似值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 设置精度</span></span><br><span class="line">    precision := <span class="number">1e-6</span></span><br><span class="line">    low, high := <span class="number">0.0</span>, x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用二分查找逼近平方根</span></span><br><span class="line">    <span class="keyword">for</span> high-low &gt; precision &#123;</span><br><span class="line">        mid := (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid*mid &lt; x &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (low + high) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;√2 ≈&quot;</span>, sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-查找切片中的插入位置"><a href="#5-查找切片中的插入位置" class="headerlink" title="5. 查找切片中的插入位置"></a>5. 查找切片中的插入位置</h2><p><code>sort.Search</code> 非常适合用来查找元素应该插入的位置。</p><h3 id="示例：查找插入位置"><a href="#示例：查找插入位置" class="headerlink" title="示例：查找插入位置"></a>示例：查找插入位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d 应该插入到索引 %d 的位置\n&quot;</span>, target, index)</span><br><span class="line"><span class="comment">// 输出: 6 应该插入到索引 3 的位置</span></span><br></pre></td></tr></table></figure><h2 id="6-标准库中的其他相关函数"><a href="#6-标准库中的其他相关函数" class="headerlink" title="6. 标准库中的其他相关函数"></a>6. 标准库中的其他相关函数</h2><p>除了 <code>sort.Search</code>，标准库还提供了：</p><ul><li><code>sort.SearchInts(a []int, x int) int</code> - 在已排序的 int 切片中查找 x</li><li><code>sort.SearchFloat64s(a []float64, x float64) int</code> - 在已排序的 float64 切片中查找 x</li><li><code>sort.SearchStrings(a []string, x string) int</code> - 在已排序的 string 切片中查找 x</li></ul><h3 id="示例：使用-sort-SearchInts"><a href="#示例：使用-sort-SearchInts" class="headerlink" title="示例：使用 sort.SearchInts"></a>示例：使用 <code>sort.SearchInts</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.SearchInts(nums, target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-性能考虑"><a href="#7-性能考虑" class="headerlink" title="7. 性能考虑"></a>7. 性能考虑</h2><p><code>sort.Search</code> 的时间复杂度是 O(log n)，因为它使用的是二分查找算法。但需要注意：</p><ol><li>切片必须是已排序的，否则结果不可靠</li><li>比较函数 <code>f</code> 应该尽可能简单高效</li><li>对于非常大的数据集，考虑内存局部性和缓存效应</li></ol><h2 id="8-实际应用示例"><a href="#8-实际应用示例" class="headerlink" title="8. 实际应用示例"></a>8. 实际应用示例</h2><h3 id="示例：实现类似-C-的-lower-bound-和-upper-bound"><a href="#示例：实现类似-C-的-lower-bound-和-upper-bound" class="headerlink" title="示例：实现类似 C++ 的 lower_bound 和 upper_bound"></a>示例：实现类似 C++ 的 lower_bound 和 upper_bound</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowerBound 返回第一个 &gt;= target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upperBound 返回第一个 &gt; target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upperBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    target := <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    lb := lowerBound(nums, target)</span><br><span class="line">    ub := upperBound(nums, target)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;lowerBound: %d, upperBound: %d\n&quot;</span>, lb, ub)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;元素 %d 的出现次数: %d\n&quot;</span>, target, ub-lb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-中二分查找包的使用方法&quot;&gt;&lt;a href=&quot;#Golang-中二分查找包的使用方法&quot; class=&quot;headerlink&quot; title=&quot;Golang 中二分查找包的使用方法&quot;&gt;&lt;/a&gt;Golang 中二分查找包的使用方法&lt;/h1&gt;&lt;p&gt;Go 标准库</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】DFS</title>
    <link href="https://leiqi.top/2025-06-17-8ecaae2ca2b5.html"/>
    <id>https://leiqi.top/2025-06-17-8ecaae2ca2b5.html</id>
    <published>2025-06-17T16:21:34.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结"><a href="#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结" class="headerlink" title="LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结"></a>LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结</h1><p>DFS（深度优先搜索）是算法面试中的常见题型，下面我将总结 LeetCode 上一些经典的 DFS 题目，并用 Golang 实现，最后提炼出通用的 DFS 解题模板。</p><h2 id="经典-DFS-题目分类及-Golang-实现"><a href="#经典-DFS-题目分类及-Golang-实现" class="headerlink" title="经典 DFS 题目分类及 Golang 实现"></a>经典 DFS 题目分类及 Golang 实现</h2><h3 id="1-二叉树遍历类"><a href="#1-二叉树遍历类" class="headerlink" title="1. 二叉树遍历类"></a>1. 二叉树遍历类</h3><h4 id="题目-94-二叉树的中序遍历"><a href="#题目-94-二叉树的中序遍历" class="headerlink" title="题目 94. 二叉树的中序遍历"></a>题目 94. 二叉树的中序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-排列组合类"><a href="#2-排列组合类" class="headerlink" title="2. 排列组合类"></a>2. 排列组合类</h3><h4 id="题目-46-全排列"><a href="#题目-46-全排列" class="headerlink" title="题目 46. 全排列"></a>题目 46. 全排列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(path)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-岛屿问题类"><a href="#3-岛屿问题类" class="headerlink" title="3. 岛屿问题类"></a>3. 岛屿问题类</h3><h4 id="题目-200-岛屿数量"><a href="#题目-200-岛屿数量" class="headerlink" title="题目 200. 岛屿数量"></a>题目 200. 岛屿数量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-回溯类问题"><a href="#4-回溯类问题" class="headerlink" title="4. 回溯类问题"></a>4. 回溯类问题</h3><h4 id="题目-39-组合总和"><a href="#题目-39-组合总和" class="headerlink" title="题目 39. 组合总和"></a>题目 39. 组合总和</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            dfs(i, path, sum+candidates[i])</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, []<span class="type">int</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang-DFS-通用模板"><a href="#Golang-DFS-通用模板" class="headerlink" title="Golang DFS 通用模板"></a>Golang DFS 通用模板</h2><p>根据以上题目，可以总结出 DFS 的通用模板：</p><h3 id="递归回溯模板"><a href="#递归回溯模板" class="headerlink" title="递归回溯模板"></a>递归回溯模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">problemFunction</span><span class="params">(params)</span></span> [][]resultType &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]resultType</span><br><span class="line">    <span class="comment">// 可能需要 visited 数组或其他辅助数据结构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> meetCondition &#123;</span><br><span class="line">            <span class="comment">// 可能需要深拷贝 path</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]resultType, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> _, choice := <span class="keyword">range</span> choices &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不满足条件的选项</span></span><br><span class="line">            <span class="keyword">if</span> !isValid(choice) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, choice)</span><br><span class="line">            markAsVisited(choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(path, updatedParams...)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            markAsUnvisited(choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(initialPath, initialParams...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格-矩阵DFS模板"><a href="#网格-矩阵DFS模板" class="headerlink" title="网格&#x2F;矩阵DFS模板"></a>网格&#x2F;矩阵DFS模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gridProblem</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != targetValue &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记已访问</span></span><br><span class="line">        grid[i][j] = markedValue</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四个方向扩散</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要8个方向，可以加上对角线方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历整个网格</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == targetValue &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他经典DFS题目推荐"><a href="#其他经典DFS题目推荐" class="headerlink" title="其他经典DFS题目推荐"></a>其他经典DFS题目推荐</h2><ol><li><ol start="78"><li>子集</li></ol></li><li><ol start="17"><li>电话号码的字母组合</li></ol></li><li><ol start="79"><li>单词搜索</li></ol></li><li><ol start="207"><li>课程表 (拓扑排序)</li></ol></li><li><ol start="437"><li>路径总和 III</li></ol></li><li><ol start="494"><li>目标和</li></ol></li><li><ol start="695"><li>岛屿的最大面积</li></ol></li><li><ol start="733"><li>图像渲染</li></ol></li><li><ol start="113"><li>路径总和 II</li></ol></li><li><ol start="129"><li>求根到叶子节点数字和</li></ol></li></ol><p>DFS的关键在于理解递归的思想，明确递归的终止条件，以及在递归前后做好状态的保存和恢复（回溯）。掌握这些模板后，可以解决大部分DFS相关问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot;&gt;&lt;a href=&quot;#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 上经典的 DFS 题目</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】BFS</title>
    <link href="https://leiqi.top/2025-06-17-e53745bb0899.html"/>
    <id>https://leiqi.top/2025-06-17-e53745bb0899.html</id>
    <published>2025-06-17T16:12:10.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-BFS-练习题单与模板总结-Golang-实现"><a href="#LeetCode-BFS-练习题单与模板总结-Golang-实现" class="headerlink" title="LeetCode BFS 练习题单与模板总结 (Golang 实现)"></a>LeetCode BFS 练习题单与模板总结 (Golang 实现)</h1><p>BFS（广度优先搜索）是一种重要的图遍历算法，特别适合解决最短路径、层次遍历等问题。以下是 Golang 实现的 BFS 模板和分类练习题单。</p><h2 id="BFS-通用模板-Golang"><a href="#BFS-通用模板-Golang" class="headerlink" title="BFS 通用模板 (Golang)"></a>BFS 通用模板 (Golang)</h2><h3 id="1-树的-BFS-模板"><a href="#1-树的-BFS-模板" class="headerlink" title="1. 树的 BFS 模板"></a>1. 树的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, levelSize)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-图的-BFS-模板"><a href="#2-图的-BFS-模板" class="headerlink" title="2. 图的 BFS 模板"></a>2. 图的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsGraph</span><span class="params">(start Node)</span></span> []Node &#123;</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[Node]<span class="type">bool</span>)</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    queue := []Node&#123;start&#125;</span><br><span class="line">    result := []Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, node)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> getNeighbors(node) &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-BFS-练习题单-Golang"><a href="#LeetCode-BFS-练习题单-Golang" class="headerlink" title="LeetCode BFS 练习题单 (Golang)"></a>LeetCode BFS 练习题单 (Golang)</h2><h3 id="基础练习"><a href="#基础练习" class="headerlink" title="基础练习"></a>基础练习</h3><ol><li><p><strong>二叉树的层次遍历</strong></p><ul><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></li><li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li><li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></li></ul></li><li><p><strong>简单图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/number-of-islands/">200. 岛屿数量</a></li><li><a href="https://leetcode.com/problems/flood-fill/">733. 图像渲染</a></li><li><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></li></ul></li></ol><h3 id="进阶练习"><a href="#进阶练习" class="headerlink" title="进阶练习"></a>进阶练习</h3><ol><li><p><strong>最短路径问题</strong></p><ul><li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li><li><a href="https://leetcode.com/problems/open-the-lock/">752. 打开转盘锁</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></li><li><a href="https://leetcode.com/problems/01-matrix/">542. 01 矩阵</a></li></ul></li><li><p><strong>复杂图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/word-ladder/">127. 单词接龙</a></li><li><a href="https://leetcode.com/problems/clone-graph/">133. 克隆图</a></li><li><a href="https://leetcode.com/problems/minimum-height-trees/">310. 最小高度树</a></li></ul></li><li><p><strong>多源BFS</strong></p><ul><li><a href="https://leetcode.com/problems/rotting-oranges/">994. 腐烂的橘子</a></li><li><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a> (付费题)</li></ul></li></ol><h3 id="困难级别挑战"><a href="#困难级别挑战" class="headerlink" title="困难级别挑战"></a>困难级别挑战</h3><ol><li><a href="https://leetcode.com/problems/bus-routes/">815. 公交路线</a></li><li><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></li></ol><h2 id="Golang-BFS-实现技巧"><a href="#Golang-BFS-实现技巧" class="headerlink" title="Golang BFS 实现技巧"></a>Golang BFS 实现技巧</h2><ol><li><p><strong>队列实现</strong>：Golang 中可以用 slice 实现队列，但要注意 dequeue 操作是 O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:] <span class="comment">// 这会创建新的 slice，可能影响性能</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong>：对于大型队列，可以使用链表或固定大小的循环队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes []*TreeNode</span><br><span class="line">    head  <span class="type">int</span></span><br><span class="line">    tail  <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>visited 记录</strong>：对于图问题，使用 map 记录已访问节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>方向数组</strong>：处理网格问题时很有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例题解：200-岛屿数量-Golang"><a href="#示例题解：200-岛屿数量-Golang" class="headerlink" title="示例题解：200. 岛屿数量 (Golang)"></a>示例题解：200. 岛屿数量 (Golang)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                queue := [][]<span class="type">int</span>&#123;&#123;i, j&#125;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    cell := queue[<span class="number">0</span>]</span><br><span class="line">                    queue = queue[<span class="number">1</span>:]</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                        x, y := cell[<span class="number">0</span>]+dir[<span class="number">0</span>], cell[<span class="number">1</span>]+dir[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                            grid[x][y] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, []<span class="type">int</span>&#123;x, y&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-BFS-练习题单与模板总结-Golang-实现&quot;&gt;&lt;a href=&quot;#LeetCode-BFS-练习题单与模板总结-Golang-实现&quot; class=&quot;headerlink&quot; title=&quot;LeetCode BFS 练习题单与模板总结 (Gola</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】滑动窗口</title>
    <link href="https://leiqi.top/2025-06-17-d8f0a4d6b8c7.html"/>
    <id>https://leiqi.top/2025-06-17-d8f0a4d6b8c7.html</id>
    <published>2025-06-17T15:52:02.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-滑动窗口模板与套路详解"><a href="#Golang-滑动窗口模板与套路详解" class="headerlink" title="Golang 滑动窗口模板与套路详解"></a>Golang 滑动窗口模板与套路详解</h1><p>针对 LeetCode 1004（最大连续1的个数 III）这类问题，以下是专门为 Golang 开发者准备的滑动窗口实现模板、适用场景和常见变种：</p><h2 id="Golang-滑动窗口模板（1004-类型）"><a href="#Golang-滑动窗口模板（1004-类型）" class="headerlink" title="Golang 滑动窗口模板（1004 类型）"></a>Golang 滑动窗口模板（1004 类型）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, maxLen, zeroCount := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        <span class="comment">// 1. 右指针移动：更新窗口状态</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span> &#123;</span><br><span class="line">            zeroCount++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 左指针移动：当窗口不合法时收缩</span></span><br><span class="line">        <span class="keyword">for</span> zeroCount &gt; k &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span> &#123;</span><br><span class="line">                zeroCount--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 更新结果（此时窗口合法）</span></span><br><span class="line">        <span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心套路与技巧（Golang-实现）"><a href="#核心套路与技巧（Golang-实现）" class="headerlink" title="核心套路与技巧（Golang 实现）"></a>核心套路与技巧（Golang 实现）</h2><ol><li><p><strong>双指针初始化</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">maxLen := <span class="number">0</span></span><br><span class="line">counter := <span class="number">0</span> <span class="comment">// 根据问题定义计数器</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右指针移动逻辑</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">    <span class="comment">// 更新计数器</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[right]) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>窗口收缩条件</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> counter &gt; k &#123; <span class="comment">// k 是允许的阈值</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[left]) &#123;</span><br><span class="line">        counter--</span><br><span class="line">    &#125;</span><br><span class="line">    left++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>结果更新</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">    maxLen = windowSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Golang-常见变种实现"><a href="#Golang-常见变种实现" class="headerlink" title="Golang 常见变种实现"></a>Golang 常见变种实现</h2><h3 id="1-替换后的最长重复字符（LeetCode-424）"><a href="#1-替换后的最长重复字符（LeetCode-424）" class="headerlink" title="1. 替换后的最长重复字符（LeetCode 424）"></a>1. 替换后的最长重复字符（LeetCode 424）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">characterReplacement</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    left, maxCount, maxLen := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        count[ch-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">        <span class="keyword">if</span> count[ch-<span class="string">&#x27;A&#x27;</span>] &gt; maxCount &#123;</span><br><span class="line">            maxCount = count[ch-<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：窗口大小 - 最大计数 &gt; k</span></span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>)-maxCount &gt; k &#123;</span><br><span class="line">            count[s[left]-<span class="string">&#x27;A&#x27;</span>]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-水果成篮（LeetCode-904）"><a href="#2-水果成篮（LeetCode-904）" class="headerlink" title="2. 水果成篮（LeetCode 904）"></a>2. 水果成篮（LeetCode 904）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    basket := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxFruits := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, fruit := <span class="keyword">range</span> fruits &#123;</span><br><span class="line">        basket[fruit]++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：水果种类超过2种</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(basket) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            basket[fruits[left]]--</span><br><span class="line">            <span class="keyword">if</span> basket[fruits[left]] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(basket, fruits[left])</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxFruits &#123;</span><br><span class="line">            maxFruits = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxFruits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最小覆盖子串（LeetCode-76）"><a href="#3-最小覆盖子串（LeetCode-76）" class="headerlink" title="3. 最小覆盖子串（LeetCode 76）"></a>3. 最小覆盖子串（LeetCode 76）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> t &#123;</span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left, valid := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    start, length := <span class="number">0</span>, math.MaxInt32</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="keyword">if</span> _, exists := need[c]; exists &#123;</span><br><span class="line">            window[c]++</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当窗口满足条件时尝试收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> right-left+<span class="number">1</span> &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 收缩窗口</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _, exists := need[d]; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> length == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : start+length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口适用场景总结"><a href="#滑动窗口适用场景总结" class="headerlink" title="滑动窗口适用场景总结"></a>滑动窗口适用场景总结</h2><table><thead><tr><th>问题特征</th><th>示例题目</th><th>Golang 实现要点</th></tr></thead><tbody><tr><td><strong>有限修改连续序列</strong></td><td>1004, 424, 2024</td><td>使用计数器跟踪修改需求</td></tr><tr><td><strong>不同元素数量限制</strong></td><td>904, 340</td><td>使用 map 跟踪元素种类</td></tr><tr><td><strong>最短满足条件子串</strong></td><td>209, 76</td><td>收缩时更新最小值</td></tr><tr><td><strong>固定窗口大小</strong></td><td>643, 1343</td><td>维护固定大小的窗口</td></tr><tr><td><strong>无重复字符</strong></td><td>3, 159</td><td>使用 map 或 set 检测重复</td></tr></tbody></table><h2 id="Golang-实现技巧"><a href="#Golang-实现技巧" class="headerlink" title="Golang 实现技巧"></a>Golang 实现技巧</h2><ol><li><p><strong>计数器选择</strong>：</p><ul><li>简单计数：<code>int</code> 变量</li><li>字符频率：<code>[26]int</code> 或 <code>[128]int</code></li><li>通用元素：<code>map[type]int</code></li></ul></li><li><p><strong>边界处理</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理空输入情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong>：</p><ul><li>避免不必要的内存分配（预分配 map 大小）</li><li>使用数组代替 map 当键范围有限时</li><li>减少循环内部的计算</li></ul></li><li><p><strong>复杂条件处理</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用辅助函数判断窗口合法性</span></span><br><span class="line"><span class="keyword">for</span> !isValid(window, condition) &#123;</span><br><span class="line">    <span class="comment">// 收缩窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>掌握这些 Golang 实现的滑动窗口模式和变种，能高效解决 LeetCode 上大部分滑动窗口问题。关键是根据问题特征选择合适的计数器类型和窗口收缩条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-滑动窗口模板与套路详解&quot;&gt;&lt;a href=&quot;#Golang-滑动窗口模板与套路详解&quot; class=&quot;headerlink&quot; title=&quot;Golang 滑动窗口模板与套路详解&quot;&gt;&lt;/a&gt;Golang 滑动窗口模板与套路详解&lt;/h1&gt;&lt;p&gt;针对 Lee</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】slice append 和copy对比</title>
    <link href="https://leiqi.top/2025-06-16-fa2f5d4a144d.html"/>
    <id>https://leiqi.top/2025-06-16-fa2f5d4a144d.html</id>
    <published>2025-06-16T15:53:12.000Z</published>
    <updated>2025-06-17T16:34:43.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, info)</span><br><span class="line"><span class="built_in">copy</span>(result[info[<span class="number">1</span>] +<span class="number">1</span>:], result[info[<span class="number">1</span>]:])<span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">result[info[<span class="number">1</span>]] = info<span class="comment">//将插入元素位置插入元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unc reconstructQueue(people [][]<span class="type">int</span>) [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, info)</span><br><span class="line">pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 在 pos 处分割并拼接</span></span><br><span class="line">        result[pos] = info      <span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250616235439.png"><br>两个 <code>reconstructQueue</code> 函数的主要区别在于 <strong>插入元素的方式</strong>，而第二个版本能通过是因为它正确处理了 <strong>切片的动态扩容和元素移动</strong></p><hr><h3 id="关键问题分析"><a href="#关键问题分析" class="headerlink" title="关键问题分析"></a><strong>关键问题分析</strong></h3><h4 id="1-第一个版本的问题（Slice-操作）"><a href="#1-第一个版本的问题（Slice-操作）" class="headerlink" title="1. 第一个版本的问题（Slice 操作）"></a>1. <strong>第一个版本的问题（Slice 操作）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line">pos := info[<span class="number">1</span>]</span><br><span class="line">result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 尝试在 pos 处腾出位置</span></span><br><span class="line">result[pos] = info                     <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：</p><ul><li><strong><code>append(result[:pos+1], result[pos:]...)</code> 会导致数据错乱</strong><br>当 <code>pos</code> 不是最后一个位置时，<code>result[pos:]</code> 会包含刚刚追加的 <code>info</code>（因为上一步 <code>append(result, info)</code> 已经增加了长度），导致切片拼接时重复复制元素，最终结果错误。</li></ul><h4 id="2-第二个版本的正确性（copy-操作）"><a href="#2-第二个版本的正确性（copy-操作）" class="headerlink" title="2. 第二个版本的正确性（copy 操作）"></a>2. <strong>第二个版本的正确性（copy 操作）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line"><span class="built_in">copy</span>(result[info[<span class="number">1</span>]+<span class="number">1</span>:], result[info[<span class="number">1</span>]:]) <span class="comment">// 正确后移元素</span></span><br><span class="line">result[info[<span class="number">1</span>]] = info                 <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure><p><strong>为什么正确</strong>：</p><ul><li><code>copy</code> <strong>直接覆盖内存</strong>，不会因 <code>append</code> 的嵌套调用引发数据错乱。</li><li>逻辑清晰：先扩展切片，再移动元素，最后插入新值。</li></ul><hr><h3 id="修复第一个版本的方法"><a href="#修复第一个版本的方法" class="headerlink" title="修复第一个版本的方法"></a><strong>修复第一个版本的方法</strong></h3><p>如果仍想用 <strong>Slice 操作</strong>，需避免提前追加元素，改为直接插入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">        pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos], <span class="built_in">append</span>([][]<span class="type">int</span>&#123;info&#125;, result[pos:]...)...) <span class="comment">// 直接插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键修改</strong>：</p><ul><li>使用 <code>append([][]int&#123;info&#125;, result[pos:]...)</code> 一次性完成插入，避免提前扩展切片。</li></ul><hr><h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a><strong>两种方式的对比</strong></h3><table><thead><tr><th>操作方式</th><th>代码示例</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>copy</strong></td><td><code>copy(result[pos+1:], result[pos:])</code></td><td>内存操作直接，不易出错</td><td>代码稍显冗长</td></tr><tr><td><strong>Slice 拼接</strong></td><td><code>append(result[:pos], append([][]int&#123;info&#125;, result[pos:]...)...)</code></td><td>代码简洁</td><td>嵌套 <code>append</code> 可读性略低</td></tr></tbody></table><hr><h3 id="为什么第二个版本更鲁棒？"><a href="#为什么第二个版本更鲁棒？" class="headerlink" title="为什么第二个版本更鲁棒？"></a><strong>为什么第二个版本更鲁棒？</strong></h3><ol><li><strong><code>copy</code> 是底层内存复制</strong><br>不会受切片共享或嵌套 <code>append</code> 的影响，适合需要精确控制内存的场景。</li><li><strong><code>append</code> 的嵌套可能导致临时切片</strong><br>在复杂逻辑中容易引入错误（如你的第一个版本）。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>推荐使用 <code>copy</code> 的版本</strong>：逻辑清晰，适合大多数场景。</li><li>如果追求代码简洁，可以用修复后的 <strong>Slice 拼接</strong>，但需注意 <code>append</code> 的副作用。</li></ul><blockquote><p><strong>关键教训</strong>：在操作切片时，**避免在同一个逻辑块中混合多次 <code>append</code>**，除非你能确保切片长度的变化不会影响后续操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正确&quot;&gt;&lt;a href=&quot;#正确&quot; class=&quot;headerlink&quot; title=&quot;正确&quot;&gt;&lt;/a&gt;正确&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】Golang 新手可能会踩的 50 个坑</title>
    <link href="https://leiqi.top/2025-06-15-bd60604455f8.html"/>
    <id>https://leiqi.top/2025-06-15-bd60604455f8.html</id>
    <published>2025-06-15T16:58:17.000Z</published>
    <updated>2025-06-17T16:34:43.215Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://github.com/wuYin">wuYin</a>&#x2F;<a href="https://github.com/wuYin/blog">blog</a> </p><p>原文：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">50 Shades of Go: Traps, Gotchas, and Common Mistakes</a>，翻译已获作者 <a href="https://twitter.com/kcqon">kcqon</a> 授权。</p><span id="more"></span><p>不久前发现在知乎这篇质量很高的文章，打算加上自己的理解翻译一遍。文章分为三部分：初级篇 1-34，中级篇 35-50，高级篇 51-57</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p><p>如果花时间学习官方 doc、wiki、<a href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p><h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-一般不能单独放一行"><a href="#1-左大括号-一般不能单独放一行" class="headerlink" title="1. 左大括号 { 一般不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 一般不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;<span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>.&#x2F;main.go: missing function body<br>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>注意代码块等特殊情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; 并不遵守分号注入规则，不会在其后边自动加分，此时可换行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="http://blog.csdn.net/icyday/article/details/8265864?hmsr=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">Golang中自动加分号的特殊分隔符</a></p><h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p><p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span> <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> one <span class="type">int</span> <span class="comment">// error: one declared and not used</span></span><br><span class="line">two := <span class="number">2</span><span class="comment">// error: two declared and not used</span></span><br><span class="line"><span class="keyword">var</span> three <span class="type">int</span><span class="comment">// error: three declared and not used</span></span><br><span class="line">three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">_ = one</span><br><span class="line"></span><br><span class="line">two := <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">one = three</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p><p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span><span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span><span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span><span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = log.Println</span><br><span class="line">_ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span><span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">one := <span class="number">0</span></span><br><span class="line">one, two := <span class="number">1</span>, <span class="number">2</span><span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">one, two = two, one<span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data info</span><br><span class="line">data.result, err := work()<span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data info</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span><span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">data.result, err = work()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p><p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">x := <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 2// 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Go 开发者常犯的错，而且不易被发现。</p><p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go tool vet -shadow main.go</span></span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure><p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$GOPATH</span>/bin/go-nyet main.go</span></span><br><span class="line">main.go:10:3:Shadowing variable `x`</span><br></pre></td></tr></table></figure><h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span><span class="comment">// error: use of untyped nil</span></span><br><span class="line">_ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">_ = x</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span><span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="built_in">cap</span>(m)) <span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11.  string 类型的变量值不能为 nil"></a>11.  string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span><span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;<span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">s = <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span><span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">s = <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p><p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;(x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [1 2 3]// 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想修改参数数组：</p><ul><li>直接传递指向这个数组的指针类型：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">(*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">&#125;(&amp;x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;(x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">fmt.Println(v)<span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;<span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p><p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p><p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p><ol><li><p>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</p></li><li><p>使用“独立”的切片分两步：</p></li></ol><ul><li><p>创建外部 slice</p><ul><li><p>对每个内部 slice 进行内存分配</p><p>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">2</span></span><br><span class="line">y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line"><span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用“共享底层数组”的切片</li></ol><ul><li><p>创建一个存放原始数据的容器 slice</p></li><li><p>创建其他的 slice</p></li><li><p>切割原始 slice 来初始化其他的 slice</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">raw[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化原始 slice</span></span><br><span class="line">fmt.Println(raw, &amp;raw[<span class="number">4</span>])<span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120 </span></span><br><span class="line">    </span><br><span class="line">table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">table[i] = raw[i*w : i*w + w]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])<span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于多维数组的参考</p><p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p><p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p><h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span></span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p><p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)<span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p><p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span><span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span><span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">x = <span class="type">string</span>(xBytes)</span><br><span class="line">fmt.Println(x)<span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p><p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">x = <span class="type">string</span>(xRunes)</span><br><span class="line">fmt.Println(x)<span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p><p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p><ul><li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li><li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li></ul><p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p><h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p><p>这种处理方式和其他语言一样，比如 PHP 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span><span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span></span><br><span class="line">string(6) &quot;中文&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span></span><br><span class="line">string(1) &quot;�&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span></span><br><span class="line">string(3) &quot;中&quot;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">fmt.Println(x[<span class="number">0</span>])<span class="comment">// 97</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p><h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str1))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str2))<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str3))<span class="comment">// true// 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>然而在 Go 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(char))<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的内建函数 <code>len()</code> 返回的是字符串的  byte 数量，而不是像 Python  中那样是计算 Unicode 字符数。</p><p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(char))<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;é&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(char))<span class="comment">// 3</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(char))<span class="comment">// 2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;cafe\u0301&quot;</span>)<span class="comment">// café// 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p><h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">int</span> &#123;</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span><span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p><h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)<span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p><p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p><h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p><p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p><p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)<span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4// 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)<span class="comment">// 0x41 0xfe 0x2 0xff 0x4// 正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p><p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p><p> <img src="https://contents.yinzige.com/map-range.png"></p><h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:<span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line"><span class="comment">// fallthrough// 返回 true</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))<span class="comment">// true</span></span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p><p>也可以改写 case 为多条件判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))<span class="comment">// true</span></span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code>  只作为运算符而非表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">++i<span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">fmt.Println(data[i++])<span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i++</span><br><span class="line">fmt.Println(data[i])<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(~<span class="number">2</span>)<span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)<span class="comment">// 00000010</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)<span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p><p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p><p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10000010 [A]</span><br><span class="line">00000010 [B]</span><br><span class="line">11111101 (NOT B)</span><br><span class="line">00000010 ^ 11111111 = 11111101 [B XOR 0xff]</span><br><span class="line">10000010 ^ 00000010 = 10000000 [A XOR B]</span><br><span class="line">10000010 &amp; 00000010 = 00000010 [A AND B]</span><br><span class="line">10000010 &amp;^00000010 = 10000000 [A &#x27;AND NOT&#x27; B]</span><br><span class="line">10000010&amp;(^00000010)= 10000000 [A AND (NOT B)]</span><br></pre></td></tr></table></figure><h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)<span class="comment">// &amp; 优先 +</span></span><br><span class="line"><span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line"><span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line"><span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)<span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line"><span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line"><span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line"><span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)<span class="comment">// | 优先 ^</span></span><br><span class="line"><span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line"><span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line"><span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure><h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以  <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)<span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">encoded, _ := json.Marshal(in)</span><br><span class="line">fmt.Println(<span class="type">string</span>(encoded))<span class="comment">// &#123;&quot;One&quot;:1&#125;// 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> out MyData</span><br><span class="line">json.Unmarshal(encoded, &amp;out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out) <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> doIt(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)<span class="comment">// 模拟 goroutine 正在执行 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p><p> <img src="https://contents.yinzige.com/goroutine-exits.png"></p><p>常用解决办法：使用 “WaitGroup”  变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p><p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-done</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p> <img src="https://contents.yinzige.com/dead-goroutine.png"></p><p>看起来好像 goroutine 都执行完了，然而报错：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p><p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)<span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;<span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/right-goroutine.png"></p><h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)<span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/unbuffed-chan.png"></p><h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p><p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p><p>向已关闭的 channel 中发送数据会造成 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- idx</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)<span class="comment">// 输出第一个发送的值</span></span><br><span class="line"><span class="built_in">close</span>(ch)<span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)<span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://contents.yinzige.com/channnel.png"></p><p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的  goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行效果：</p><p> <img src="https://contents.yinzige.com/normal-channel.png"></p><h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil  的 channel"></a>34. 使用了值为 <code>nil </code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtime 死锁错误：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p></blockquote><p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line"><span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- val:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">out = <span class="literal">nil</span></span><br><span class="line">in = inCh</span><br><span class="line"><span class="keyword">case</span> val = &lt;-in:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">out = outCh</span><br><span class="line">in = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">0</span>)</span><br><span class="line">inCh &lt;- <span class="number">1</span></span><br><span class="line">inCh &lt;- <span class="number">2</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br> <img src="https://contents.yinzige.com/runns.png"></p><h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num   <span class="type">int</span></span><br><span class="line">key   *<span class="type">string</span></span><br><span class="line">items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">this.num = <span class="number">8</span></span><br><span class="line">*this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">d.pointerFunc()<span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">d.valueFunc()<span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://contents.yinzige.com/change-origal.png"></p><h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p><blockquote><p>panic: runtime error: invalid memory address or nil pointer dereference</p></blockquote><p>应该先检查 HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=json</a>: x509: certificate signed by unknown authority</p></blockquote><p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p><ul><li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li><li>手动调用 <code>defer</code> 来关闭响应体：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p><p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)<span class="comment">// 手动丢弃读取完毕的数据</span></span><br></pre></td></tr></table></figure><p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)  </span><br></pre></td></tr></table></figure><h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p><ul><li>直接设置请求变量的 <code>Close </code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li><li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">req.Close = <span class="literal">true</span></span><br><span class="line"><span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)// 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(resp.StatusCode)<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据需求选择使用场景：</p><ul><li><p>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</p></li><li><p>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</p></li></ul><h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])<span class="comment">// float64</span></span><br><span class="line"><span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)<span class="comment">// 类型断言错误</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>panic: interface conversion: interface {} is float64, not int</p></blockquote><p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p><ul><li><p>将 int 值转为 float 统一使用</p></li><li><p>将 decode 后需要的 float 值转为 int 使用</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">decoder.UseNumber()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalln(err)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">checkError(err)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">  checkError(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型</p><p>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">StatusCode <span class="type">uint64</span></span><br><span class="line">StatusName <span class="type">string</span></span><br><span class="line">Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">result.StatusName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">result.StatusCode = code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num     <span class="type">int</span></span><br><span class="line">fp      <span class="type">float32</span></span><br><span class="line"><span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">str     <span class="type">string</span></span><br><span class="line">char    <span class="type">rune</span></span><br><span class="line">yes     <span class="type">bool</span></span><br><span class="line">events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ref     *<span class="type">byte</span></span><br><span class="line">raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num    <span class="type">int</span></span><br><span class="line">checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span><span class="comment">// 无法比较</span></span><br><span class="line">doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span><span class="comment">// 无法比较</span></span><br><span class="line">m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span><span class="comment">// 无法比较</span></span><br><span class="line">bytes  []<span class="type">byte</span><span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p></blockquote><p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>DeepEqual()</code> 并不总适合于比较 slice</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line"><span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">encoded, _ := json.Marshal(data)</span><br><span class="line"><span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code>  和 <code>strings.EqualFold()</code> </p><p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p><ul><li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()<span class="comment">// 什么都不会捕捉</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)<span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line"><span class="built_in">recover</span>()<span class="comment">// 不会被执行</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">doRecover()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>recobered:  <nil>   panic: not good</p></blockquote><h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v *= <span class="number">10</span><span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;data: &quot;</span>, data)<span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改原有元素的值，应该使用索引直接访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">data[i] = v * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;data: &quot;</span>, data)<span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v.num *= <span class="number">10</span><span class="comment">// 直接使用指针更新</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])<span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line"><span class="keyword">return</span> raw[:<span class="number">3</span>]<span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := get()</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])<span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := get()</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])<span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p><p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">dir1 := path[:sepIndex]</span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAA</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line">    </span><br><span class="line">path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAAsuffix</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffix/uffixBBBB// 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改 </p><p>解决方法：</p><ul><li>重新分配新的 slice 并拷贝你需要的数据</li><li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]<span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAAsuffix</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// BBBBBBBBB</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p><h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p><p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)<span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">s2 := s1[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)<span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">s2[i] += <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">fmt.Println(s1)<span class="comment">// [1 22 23]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)<span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">s2[i] += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1)<span class="comment">// [1 22 23]// 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">fmt.Println(s2)<span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mtx myMutex</span><br><span class="line">mtx.Lock()</span><br><span class="line">mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p></blockquote><p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> locker myLocker</span><br><span class="line">locker.Lock()</span><br><span class="line">locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 类型声明也保留它的方法集：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> locker myLocker</span><br><span class="line">locker.Lock()</span><br><span class="line">locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line"><span class="comment">//break// 死循环，一直打印 breaking out...</span></span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p><h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">vCopy := v</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(vCopy)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(in)</span><br><span class="line">&#125;(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意下边这个稍复杂的 3 个示例区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 three three three </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v := v</span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;<span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>result:  2</p></blockquote><h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p><p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dir := os.Args[<span class="number">1</span>]</span><br><span class="line">start, err := os.Stat(dir)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">f, err := os.Open(target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)<span class="comment">//error:too many open files</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()<span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 f 资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 10000 个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for n in &#123;1..10000&#125;; do</span><br><span class="line">echo content &gt; &quot;file$&#123;n&#125;.txt&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/file-open-errors.png"></p><p>解决办法：defer 延迟执行的函数写入匿名函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.Open(target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span><span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()<span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 f 资源</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p><h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line"><span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)<span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)<span class="comment">// [not an int], data:  great</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line"><span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p><p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p><p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p><p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p><ul><li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel  <code>default</code> 语句：</p><p><code>default</code> 的缓冲 channel  保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p><h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p><p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">d1.<span class="built_in">print</span>()<span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">in.<span class="built_in">print</span>()<span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()<span class="comment">// m[&quot;x&quot;] 是不可寻址的// 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cannot use data literal (type data) as type printer in assignment:</p><p>data does not implement printer (print method has pointer receiver)</p><p>cannot call pointer method on m[“x”]<br>cannot take the address of m[“x”]</p></blockquote><h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cannot assign to struct field m[“x”].name in map</p></blockquote><p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">fmt.Println(s)<span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p><p>更新 map 中 struct 元素的字段值，有 2 个方法：</p><ul><li>使用局部变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">fmt.Println(m)<span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用指向元素的 map 指针</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span><span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;x&quot;</span>])<span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意下边这种误用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span> </span><br><span class="line">fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>panic: runtime error: invalid memory address or nil pointer dereference</p></blockquote><h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p><p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(data, data == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">fmt.Println(in, in == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">in = data</span><br><span class="line">fmt.Println(in, in == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; false// data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的函数返回值类型是 interface，更要小心这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)<span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)<span class="comment">// *struct &#123;&#125;// res 不是 nil，它的值为 nil</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)<span class="comment">// &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span><span class="comment">// 明确指明返回 nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)<span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p><p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p><p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p><p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置： <img src="https://contents.yinzige.com/allocation.png"></p><h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p><p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p><p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p><p><code>GOMAXPROCS</code>  的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// 4</span></span><br><span class="line">fmt.Println(runtime.NumCPU())<span class="comment">// 4</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// 20</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line"><span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> u1()<span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line"><span class="keyword">go</span> u2()</span><br><span class="line"><span class="keyword">go</span> p()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/reorder.png"></p><p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p><h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p><p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)<span class="comment">// 并不内联执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p><p> <img src="https://contents.yinzige.com/not-inlined.png"></p><p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/gosched.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p><p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p><p>后续再更新类似高质量文章的翻译 😍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;https://github.com/wuYin&quot;&gt;wuYin&lt;/a&gt;&amp;#x2F;&lt;a href=&quot;https://github.com/wuYin/blog&quot;&gt;blog&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&quot;&gt;50 Shades of Go: Traps, Gotchas, and Common Mistakes&lt;/a&gt;，翻译已获作者 &lt;a href=&quot;https://twitter.com/kcqon&quot;&gt;kcqon&lt;/a&gt; 授权。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang 学习资料</title>
    <link href="https://leiqi.top/2025-06-15-4bfc586514c9.html"/>
    <id>https://leiqi.top/2025-06-15-4bfc586514c9.html</id>
    <published>2025-06-15T16:56:12.000Z</published>
    <updated>2025-06-17T16:34:43.214Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/anzhihe/learning/blob/8de2b0bd2ad36d296e1808080073cdb8521627af/golang/README.md?plain=1#L26">learning&#x2F;golang&#x2F;README.md at 8de2b0bd2ad36d296e1808080073cdb8521627af · anzhihe&#x2F;learning</a></p><h2 id="Golang-learning-book-and-source-code-Head-First-Go英文版-Go程序设计语言-Go语言实战-Go语言核心编程笔记-Go学习笔记-第四版-Go源码剖析（书签版）-Go-web-编程-Go-Web-编程-Go并发编程实战-第1版-Go并发编程实战-第2版-Lite-Go语言并发之道-Go网络编程-Go语言圣经-中文版-2020最新Gin框架中文文档-大厂Go工程师面试题集锦-Golang常见面试题目解析"><a href="#Golang-learning-book-and-source-code-Head-First-Go英文版-Go程序设计语言-Go语言实战-Go语言核心编程笔记-Go学习笔记-第四版-Go源码剖析（书签版）-Go-web-编程-Go-Web-编程-Go并发编程实战-第1版-Go并发编程实战-第2版-Lite-Go语言并发之道-Go网络编程-Go语言圣经-中文版-2020最新Gin框架中文文档-大厂Go工程师面试题集锦-Golang常见面试题目解析" class="headerlink" title="Golang learning book and source code- Head First Go英文版- Go程序设计语言- Go语言实战- Go语言核心编程笔记- Go学习笔记 第四版- Go源码剖析（书签版）- Go_web_编程- Go Web 编程- Go并发编程实战_第1版- Go并发编程实战_第2版_Lite- Go语言并发之道- Go网络编程- Go语言圣经(中文版)- 2020最新Gin框架中文文档- 大厂Go工程师面试题集锦- Golang常见面试题目解析"></a>Golang learning <a href="/golang/book"><strong>book</strong></a> and source code<br>- <a href="/golang/book/Head%20First%20Go.pdf">Head First Go英文版</a><br>- <a href="/golang/book/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%EF%BC%88%E8%AF%A6%E7%BB%86%E4%B9%A6%E7%AD%BE%E3%80%81%E6%B8%85%E6%99%B0%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89.pdf">Go程序设计语言</a><br>- <a href="/golang/book/Go%20%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98.pdf">Go语言实战</a><br>- <a href="/golang/book/Go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9F%A9%E9%A1%BA%E5%B9%B3.zip">Go语言核心编程笔记</a><br>- <a href="/golang/book/Go%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">Go学习笔记 第四版</a><br>- <a href="/golang/book/Go%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf">Go源码剖析（书签版）</a><br>- <a href="/golang/book/Go_web_%E7%BC%96%E7%A8%8B.pdf">Go_web_编程</a><br>- <a href="/golang/book/Go%20Web%20%E7%BC%96%E7%A8%8B.pdf">Go Web 编程</a><br>- <a href="/golang/book/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E7%AC%AC1%E7%89%88.pdf">Go并发编程实战_第1版</a><br>- <a href="/golang/book/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E7%AC%AC2%E7%89%88_Lite.pdf">Go并发编程实战_第2版_Lite</a><br>- <a href="https://drive.google.com/file/d/1_i-G4EQABtfhTsfgbPmXS5MOIjn6qd7M/view?usp=sharing">Go语言并发之道</a><br>- <a href="/golang/book/Go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.pdf">Go网络编程</a><br>- <a href="/golang/book/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F(%E4%B8%AD%E6%96%87%E7%89%88).pdf">Go语言圣经(中文版)</a><br>- <a href="/golang/book/2020%E6%9C%80%E6%96%B0Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-%E7%BF%BB%E8%AF%91-asong-%E6%97%A0%E6%B0%B4%E5%8D%B0%E7%89%88%E6%9C%ACV1.1.pdf">2020最新Gin框架中文文档</a><br>- <a href="/golang/book/%E5%A4%A7%E5%8E%82Go%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.docx">大厂Go工程师面试题集锦</a><br>- <a href="/golang/book/Golang%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90.pdf">Golang常见面试题目解析</a></h2><ul><li><a href="https://golang.org/">Golang官网</a></li><li><a href="https://golang.org/doc/">Golang doc</a></li><li><a href="https://blog.golang.org/">The Go Blog</a></li><li><a href="https://github.com/golang/go">Golang github</a></li><li><a href="https://gobyexample.com/">Go by Example</a></li><li><a href="https://play.golang.org/">The Go Playground</a></li><li><a href="https://segmentfault.com/a/1190000013739000">Golang 新手可能会踩的 50 个坑</a></li><li><a href="https://gfw.go101.org/article/101.html">Go语言101</a></li><li><a href="https://studygolang.com/">Go语言中文网</a></li><li><a href="https://github.com/unknwon/go-study-index">Go 语言学习资料与社区索引</a></li><li><a href="https://github.com/dariubs/GoBooks">Go Books</a></li><li><a href="https://github.com/unknwon/the-way-to-go_ZH_CN">《Go入门指南》</a></li><li><a href="http://c.biancheng.net/golang/">《Go语言入门教程》</a></li><li><a href="https://github.com/astaxie/build-https://github.com/unknwon/go-study-indexweb-application-with-golang">build-web-application-with-golang</a></li><li><a href="https://github.com/linehk/gopl">Go 程序设计语言代码示例和练习题参考答案</a></li><li><a href="https://golang.design/under-the-hood/">Go 语言原本</a></li><li><a href="https://golang2.eddycjy.com/">Go 语言编程之旅</a></li><li><a href="https://lailin.xyz/post/singleton.html">Go设计模式</a></li><li><a href="https://www.topgoer.cn/">地鼠文档</a></li><li><a href="https://chegva.com/5202.html">Go语言快速入门实战开发</a></li></ul><p>参考：<a href="https://github.com/anzhihe/learning.git">https://github.com/anzhihe/learning.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/anzhihe/learning/blob/8de2b0bd2ad36d296e1808080073cdb8521627af/golang/README.md?plain=1#L26&quot;&gt;learning&amp;#x2F;go</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang list.List 双向链表实现LRU</title>
    <link href="https://leiqi.top/2025-06-15-60ed4ee14474.html"/>
    <id>https://leiqi.top/2025-06-15-60ed4ee14474.html</id>
    <published>2025-06-15T16:36:57.000Z</published>
    <updated>2025-06-17T16:34:43.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言中使用双向链表-list-List-实现LRU缓存"><a href="#Go语言中使用双向链表-list-List-实现LRU缓存" class="headerlink" title="Go语言中使用双向链表(list.List)实现LRU缓存"></a>Go语言中使用双向链表(list.List)实现LRU缓存</h1><p>LeetCode第146题”LRU缓存”来演示如何在Go语言中使用<code>container/list</code>包中的双向链表。</p><h2 id="LRU缓存题目要求"><a href="#LRU缓存题目要求" class="headerlink" title="LRU缓存题目要求"></a>LRU缓存题目要求</h2><p>设计一个LRU (Least Recently Used) 缓存机制，它应该支持以下操作：</p><ul><li><code>Get(key)</code>: 如果密钥存在则获取值，否则返回-1</li><li><code>Put(key, value)</code>: 如果密钥不存在，则写入数据；当缓存容量达到上限时，删除最久未使用的数据</li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>我们将使用<code>container/list</code>包中的双向链表来跟踪访问顺序，同时使用map来实现快速查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUCache 结构体</span></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span>                      <span class="comment">// 缓存容量</span></span><br><span class="line">list     *list.List               <span class="comment">// 双向链表用于维护访问顺序</span></span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">int</span>]*list.Element    <span class="comment">// 哈希表用于快速查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 用于存储键值对</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor 初始化LRU缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">list:     list.New(),</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取键对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 将访问的元素移动到链表头部表示最近使用</span></span><br><span class="line">l.list.MoveToFront(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(*entry).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 插入或更新键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果键已存在，更新值并移动到头部</span></span><br><span class="line"><span class="keyword">if</span> elem, ok := l.cache[key]; ok &#123;</span><br><span class="line">l.list.MoveToFront(elem)</span><br><span class="line">elem.Value.(*entry).value = value</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果缓存已满，删除最近最少使用的元素（链表尾部）</span></span><br><span class="line"><span class="keyword">if</span> l.list.Len() == l.capacity &#123;</span><br><span class="line">tail := l.list.Back()</span><br><span class="line"><span class="keyword">if</span> tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(l.cache, tail.Value.(*entry).key)</span><br><span class="line">l.list.Remove(tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素到链表头部</span></span><br><span class="line">elem := l.list.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">l.cache[key] = elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>使用slice 实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">keysList []<span class="type">int</span> <span class="comment">// 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间</span></span><br><span class="line">keysMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> <span class="comment">// 存放key value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="comment">//return</span></span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;capacity, <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果key存在于缓存中，则返回关键字的值，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ele, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">this.updateListKey(key)</span><br><span class="line"><span class="keyword">return</span> ele</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 关键字存在 则更新值为value</span></span><br><span class="line"><span class="comment">// 不存在，则插入value</span></span><br><span class="line"><span class="comment">// 如果插入超过数量capacity 则删除最久没有使用的关键字【list]</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.keysMap[key]; ok &#123;</span><br><span class="line">this.updateListKey(key)</span><br><span class="line">this.keysMap[key] = value</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.updateListKey(key)</span><br><span class="line">this.keysMap[key] = value</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.keysList) &gt; this.capacity &#123;</span><br><span class="line"><span class="built_in">delete</span>(this.keysMap, this.keysList[<span class="number">0</span>]) <span class="comment">// 这里删除key 从list队列中获取</span></span><br><span class="line">this.keysList = this.keysList[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> updateListKey(key <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.keysList); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> key == this.keysList[i] &#123;</span><br><span class="line">this.keysList = <span class="built_in">append</span>(this.keysList[:i], this.keysList[i+<span class="number">1</span>:]...) <span class="comment">// 删除该key, 然后放在末尾</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.keysList = <span class="built_in">append</span>(this.keysList, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ol><li><p><strong>双向链表的使用</strong>:</p><ul><li><code>list.New()</code> 创建一个新的双向链表</li><li><code>PushFront()</code> 在链表头部插入元素</li><li><code>MoveToFront()</code> 将元素移动到链表头部</li><li><code>Back()</code> 获取链表尾部元素</li><li><code>Remove()</code> 从链表中删除元素</li></ul></li><li><p><strong>LRU策略实现</strong>:</p><ul><li>最近访问的元素总是放在链表头部</li><li>当需要淘汰元素时，删除链表尾部的元素</li><li>使用map实现O(1)时间的查找</li></ul></li><li><p><strong>性能分析</strong>:</p><ul><li>Get操作时间复杂度: O(1)</li><li>Put操作时间复杂度: O(1)</li><li>空间复杂度: O(capacity)</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言中使用双向链表-list-List-实现LRU缓存&quot;&gt;&lt;a href=&quot;#Go语言中使用双向链表-list-List-实现LRU缓存&quot; class=&quot;headerlink&quot; title=&quot;Go语言中使用双向链表(list.List)实现LRU缓存&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Obsidian配置代理</title>
    <link href="https://leiqi.top/2025-06-15-980a140fe20b.html"/>
    <id>https://leiqi.top/2025-06-15-980a140fe20b.html</id>
    <published>2025-06-15T16:07:58.000Z</published>
    <updated>2025-06-17T16:34:43.222Z</updated>
    
    <content type="html"><![CDATA[<p>在 Obsidian 中设置代理（Proxy）需要通过 <strong>系统环境变量</strong> 或 <strong>插件</strong> 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法：</p><hr><h2 id="方法-1：通过环境变量设置全局代理（推荐）"><a href="#方法-1：通过环境变量设置全局代理（推荐）" class="headerlink" title="方法 1：通过环境变量设置全局代理（推荐）"></a><strong>方法 1：通过环境变量设置全局代理（推荐）</strong></h2><p>Obsidian 是基于 Electron 的应用程序，它会遵循系统的 HTTP&#x2F;HTTPS 代理设置。你可以通过以下方式设置：</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h3><ol><li><p><strong>临时设置（仅当前终端窗口有效）</strong><br>在 CMD&#x2F;PowerShell 中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">set</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后启动 Obsidian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start <span class="string">&quot;&quot;</span> <span class="string">&quot;C:\path\to\Obsidian.exe&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置（系统环境变量）我使用的这个</strong>  </p><ul><li>按 <code>Win + R</code>，输入 <code>sysdm.cpl</code> 打开 <strong>系统属性</strong>。</li><li>进入 <strong>高级 → 环境变量</strong>。</li><li>在 <strong>用户变量</strong> 或 <strong>系统变量</strong> 中添加：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY=http://127.0.0.1:7897</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7897</span><br><span class="line">ALL_PROXY=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure></li><li>重启 Obsidian。</li></ul></li></ol><hr><h3 id="macOS-Linux"><a href="#macOS-Linux" class="headerlink" title="macOS&#x2F;Linux"></a><strong>macOS&#x2F;Linux</strong></h3><ol><li><p><strong>临时设置（终端启动）</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后启动 Obsidian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open -a Obsidian  <span class="comment"># macOS</span></span><br><span class="line">obsidian &amp;       <span class="comment"># Linux（如果安装正确）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置（<code>.bashrc</code>&#x2F;<code>.zshrc</code>）</strong><br>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7897</span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7897</span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 或 source ~/.zshrc</span></span><br></pre></td></tr></table></figure><p>重启 Obsidian。</p></li></ol><hr><h2 id="方法-2：使用-Proxy-插件（如果-Obsidian-支持）"><a href="#方法-2：使用-Proxy-插件（如果-Obsidian-支持）" class="headerlink" title="方法 2：使用 Proxy 插件（如果 Obsidian 支持）"></a><strong>方法 2：使用 Proxy 插件（如果 Obsidian 支持）</strong></h2><p>Obsidian 本身没有官方代理插件，但你可以尝试：</p><ol><li><p><strong>安装 <code>obsidian-proxy</code> 插件（如果存在）</strong>  </p><ul><li>进入 <code>设置 → 社区插件 → 浏览</code>，搜索 <code>proxy</code>。</li><li>安装并配置代理地址。</li></ul></li><li><p><strong>使用第三方工具（如 Proxifier&#x2F;Clash）</strong>  </p><ul><li>在 Proxifier 中设置 Obsidian 走代理：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">规则：Obsidian.exe → SOCKS5 127.0.0.1:7897</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="方法-3：修改-Electron-启动参数（高级）"><a href="#方法-3：修改-Electron-启动参数（高级）" class="headerlink" title="方法 3：修改 Electron 启动参数（高级）"></a><strong>方法 3：修改 Electron 启动参数（高级）</strong></h2><p>如果 Obsidian 是基于 Electron 的，可以尝试修改启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obsidian --proxy-server=<span class="string">&quot;http://127.0.0.1:7897&quot;</span></span><br></pre></td></tr></table></figure><p>（需找到 Obsidian 的实际启动方式）</p><hr><h2 id="验证代理是否生效"><a href="#验证代理是否生效" class="headerlink" title="验证代理是否生效"></a><strong>验证代理是否生效</strong></h2><ol><li>在 Obsidian 中安装插件或同步数据，看是否正常访问。</li><li>使用 <code>curl -v https://api.obsidian.md</code> 测试代理是否生效。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th>方法</th><th>适用场景</th><th>持久性</th></tr></thead><tbody><tr><td><strong>环境变量</strong></td><td>推荐，全局生效</td><td>✅ 永久</td></tr><tr><td><strong>终端临时设置</strong></td><td>测试用</td><td>❌ 临时</td></tr><tr><td><strong>Proxy 插件</strong></td><td>如果 Obsidian 支持</td><td>⚠️ 依赖插件</td></tr><tr><td><strong>Proxifier&#x2F;Clash</strong></td><td>强制代理所有流量</td><td>✅ 系统级</td></tr></tbody></table><p>如果你的代理是 <code>http://127.0.0.1:7897</code> 或 <code>socks5://127.0.0.1:7897</code>（如 Clash&#x2F;V2Ray），建议优先使用 <strong>环境变量</strong> 方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Obsidian 中设置代理（Proxy）需要通过 &lt;strong&gt;系统环境变量&lt;/strong&gt; 或 &lt;strong&gt;插件&lt;/strong&gt; 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;方法-1：通过</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 函数传入slice无法修改到原slice</title>
    <link href="https://leiqi.top/2025-06-15-f16e0f79fc66.html"/>
    <id>https://leiqi.top/2025-06-15-f16e0f79fc66.html</id>
    <published>2025-06-15T05:53:49.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, track, used, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>, track []<span class="type">int</span>, used []<span class="type">bool</span>, res *[][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used, res)</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上边的res 代码slice中需要使用指针 我去掉指针不行。</p><p>使用闭包函数可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    track := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列</span></span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(track))</span><br><span class="line">        <span class="built_in">copy</span>(temp, track)</span><br><span class="line">        res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">            <span class="comment">// 剪枝，避免重复使用同一个数字</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track = <span class="built_in">append</span>(track, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track = track[:<span class="built_in">len</span>(track)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    backtrack()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="切片与指针的区别"><a href="#切片与指针的区别" class="headerlink" title="切片与指针的区别"></a>切片与指针的区别</h1><p>Go 中的切片是引用类型，但它们与指针在行为上还是有一些关键区别，这正是为什么在这个回溯算法中需要使用指针的原因。</p><h2 id="切片作为引用类型的局限"><a href="#切片作为引用类型的局限" class="headerlink" title="切片作为引用类型的局限"></a>切片作为引用类型的局限</h2><p>虽然切片是引用类型（底层数组的指针+长度+容量），但切片头（slice header）本身是按值传递的。这意味着：</p><ol><li><strong>可以修改底层数组元素</strong>：函数内部可以修改切片指向的数组元素，这些修改会反映到外部</li><li><strong>不能修改切片头</strong>：<font color="#ff0000">对切片本身的修改（如追加元素导致重新分配）不会反映到外部</font></li></ol><h2 id="具体到代码"><a href="#具体到代码" class="headerlink" title="具体到代码"></a>具体到代码</h2><p>回溯算法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*res = <span class="built_in">append</span>(*res, temp)  <span class="comment">// 使用指针可以修改外部的res</span></span><br></pre></td></tr></table></figure><p>如果改为不使用指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">append</span>(res, temp)  <span class="comment">// 这只修改了函数内部的切片头副本</span></span><br></pre></td></tr></table></figure><h2 id="为什么需要指针的详细解释"><a href="#为什么需要指针的详细解释" class="headerlink" title="为什么需要指针的详细解释"></a>为什么需要指针的详细解释</h2><ol><li><p><strong>追加操作的特殊性</strong>：</p><ul><li><code>append</code> 可能会返回一个新的切片头（当容量不足时）</li><li>不使用指针时，新切片头只存在于函数内部</li></ul></li><li><p><strong>递归调用的累积效果</strong>：</p><ul><li>每次递归调用都需要累积结果</li><li>不使用指针时，每次递归的修改都会丢失</li></ul></li></ol><h2 id="验证示例"><a href="#验证示例" class="headerlink" title="验证示例"></a>验证示例</h2><p>简单例子验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>) <span class="comment">// 不会影响外部</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">99</span>          <span class="comment">// 会影响外部（修改底层数组）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySliceByPtr</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, <span class="number">100</span>) <span class="comment">// 会影响外部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3]</span></span><br><span class="line">    </span><br><span class="line">    modifySliceByPtr(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出: [99 2 3 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在需要修改切片本身<font color="#ff0000">（如追加元素）</font>并且希望这些修改在函数外部可见时，必须使用指针。这正是你的回溯算法中需要使用 <code>*[][]int</code> 的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/description/&quot;&gt;46. 全排列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang LeetCode 刷题必备基础和常用模板</title>
    <link href="https://leiqi.top/2025-06-13-e749796f24c2.html"/>
    <id>https://leiqi.top/2025-06-13-e749796f24c2.html</id>
    <published>2025-06-13T16:03:18.000Z</published>
    <updated>2025-06-17T16:34:43.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-LeetCode-刷题必备基础备忘录"><a href="#Golang-LeetCode-刷题必备基础备忘录" class="headerlink" title="Golang LeetCode 刷题必备基础备忘录"></a>Golang LeetCode 刷题必备基础备忘录</h1><h2 id="1-基础数据结构用法"><a href="#1-基础数据结构用法" class="headerlink" title="1. 基础数据结构用法"></a>1. 基础数据结构用法</h2><h3 id="数组-切片-Slice"><a href="#数组-切片-Slice" class="headerlink" title="数组&#x2F;切片 (Slice)"></a>数组&#x2F;切片 (Slice)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// 长度5</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>) <span class="comment">// 长度0，容量10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>) <span class="comment">// 追加</span></span><br><span class="line"><span class="built_in">len</span>(slice) <span class="comment">// 长度</span></span><br><span class="line"><span class="built_in">copy</span>(dest, src) <span class="comment">// 复制</span></span><br><span class="line">sort.Ints(slice) <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 字节长度(非字符数)</span></span><br><span class="line">utf8.RuneCountInString(s) <span class="comment">// 字符数</span></span><br><span class="line">strings.Contains(s, <span class="string">&quot;ell&quot;</span>) <span class="comment">// true</span></span><br><span class="line">strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>) <span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line">strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>) <span class="comment">// &quot;a-b&quot;</span></span><br><span class="line">strconv.Itoa(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line">strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// 123, error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> s &#123; <span class="comment">// r是rune类型(Unicode码点)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %c\n&quot;</span>, i, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 (Map)"></a>映射 (Map)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">val, exists := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// exists为bool表示是否存在</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>) <span class="comment">// 删除键</span></span><br></pre></td></tr></table></figure><h3 id="链表-List"><a href="#链表-List" class="headerlink" title="链表 (List)"></a>链表 (List)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line">l := list.New()</span><br><span class="line">l.PushBack(<span class="number">1</span>)</span><br><span class="line">l.PushFront(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">    fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常用算法模板"><a href="#2-常用算法模板" class="headerlink" title="2. 常用算法模板"></a>2. 常用算法模板</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pivot := nums[<span class="number">0</span>]</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= right; &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot &#123;</span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            left++</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &gt; pivot &#123;</span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(nums[:left])</span><br><span class="line">    quickSort(nums[right+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-标准库重要包"><a href="#3-标准库重要包" class="headerlink" title="3. 标准库重要包"></a>3. 标准库重要包</h2><h3 id="sort-排序包"><a href="#sort-排序包" class="headerlink" title="sort 排序包"></a><code>sort</code> 排序包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型排序</span></span><br><span class="line">sort.Ints(arr)</span><br><span class="line">sort.Strings(arr)</span><br><span class="line">sort.Float64s(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="container-heap-堆实现"><a href="#container-heap-堆实现" class="headerlink" title="container/heap 堆实现"></a><code>container/heap</code> 堆实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆示例</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x any)        &#123; *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">h := &amp;MinHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">smallest := heap.Pop(h)</span><br></pre></td></tr></table></figure><h3 id="math-数学包"><a href="#math-数学包" class="headerlink" title="math 数学包"></a><code>math</code> 数学包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line">math.Max(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Min(<span class="type">float64</span>, <span class="type">float64</span>)</span><br><span class="line">math.Abs(<span class="type">float64</span>)</span><br><span class="line">math.Pow(x, y <span class="type">float64</span>)</span><br><span class="line">math.Sqrt(<span class="type">float64</span>)</span><br><span class="line">math.Ceil(<span class="type">float64</span>)</span><br><span class="line">math.Floor(<span class="type">float64</span>)</span><br><span class="line">math.MaxInt32 <span class="comment">// 常量</span></span><br><span class="line">math.MinInt32</span><br></pre></td></tr></table></figure><h2 id="4-并发编程基础"><a href="#4-并发编程基础" class="headerlink" title="4. 并发编程基础"></a>4. 并发编程基础</h2><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 并发执行的代码</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 缓冲通道</span></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// 发送</span></span><br><span class="line">val := &lt;-ch <span class="comment">// 接收</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select多路复用</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">    fmt.Println(v)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-常用技巧"><a href="#5-常用技巧" class="headerlink" title="5. 常用技巧"></a>5. 常用技巧</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n &amp; <span class="number">1</span> <span class="comment">// 判断奇偶</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span> <span class="comment">// 除以2</span></span><br><span class="line">n &lt;&lt; <span class="number">1</span> <span class="comment">// 乘以2</span></span><br><span class="line">a ^ b <span class="comment">// 异或</span></span><br><span class="line">a &amp;^ b <span class="comment">// 位清除</span></span><br></pre></td></tr></table></figure><h3 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a>常用常量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INT_MAX = <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> INT_MIN = ^INT_MAX</span><br></pre></td></tr></table></figure><h3 id="快速输入输出-竞赛用"><a href="#快速输入输出-竞赛用" class="headerlink" title="快速输入输出 (竞赛用)"></a>快速输入输出 (竞赛用)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line">fmt.Fscan(reader, &amp;a, &amp;b)</span><br><span class="line">fmt.Fprintln(writer, a+b)</span><br></pre></td></tr></table></figure><h2 id="6-测试用例写法"><a href="#6-测试用例写法" class="headerlink" title="6. 测试用例写法"></a>6. 测试用例写法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">        input <span class="type">int</span></span><br><span class="line">        want <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;case1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;case2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> got := Func(tt.input); got != tt.want &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;Func() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-常见题型解题要点"><a href="#7-常见题型解题要点" class="headerlink" title="7. 常见题型解题要点"></a>7. 常见题型解题要点</h2><ol><li><strong>双指针</strong>：数组&#x2F;链表问题，滑动窗口</li><li><strong>DFS&#x2F;BFS</strong>：树&#x2F;图遍历，回溯问题</li><li><strong>动态规划</strong>：状态转移方程，备忘录</li><li><strong>贪心算法</strong>：局部最优解</li><li><strong>并查集</strong>：连通性问题</li><li><strong>前缀和&#x2F;差分数组</strong>：区间查询&#x2F;更新</li><li><strong>单调栈</strong>：下一个更大&#x2F;小元素问题</li></ol><h2 id="1-双指针技巧"><a href="#1-双指针技巧" class="headerlink" title="1. 双指针技巧"></a>1. 双指针技巧</h2><h3 id="数组-链表问题模板"><a href="#数组-链表问题模板" class="headerlink" title="数组&#x2F;链表问题模板"></a>数组&#x2F;链表问题模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针找链表中点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序数组两数之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        sum := nums[left] + nums[right]</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingWindow</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxLen := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        freq[s[right]]++</span><br><span class="line">        <span class="comment">// 窗口收缩条件</span></span><br><span class="line">        <span class="keyword">for</span> freq[s[right]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            freq[s[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = max(maxLen, right-left+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS-BFS-算法"><a href="#2-DFS-BFS-算法" class="headerlink" title="2. DFS&#x2F;BFS 算法"></a>2. DFS&#x2F;BFS 算法</h2><h3 id="树遍历模板"><a href="#树遍历模板" class="headerlink" title="树遍历模板"></a>树遍历模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    dfs(root.Left)</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    dfs(root.Right)</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">var</span> level []<span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            level = <span class="built_in">append</span>(level, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, level)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> used[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs()</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h2><h3 id="经典DP模板"><a href="#经典DP模板" class="headerlink" title="经典DP模板"></a>经典DP模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列 (备忘录)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-1背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(weights []<span class="type">int</span>, values []<span class="type">int</span>, W <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(weights)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, W+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= W; w++ &#123;</span><br><span class="line">            <span class="keyword">if</span> weights[i<span class="number">-1</span>] &gt; w &#123;</span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-weights[i<span class="number">-1</span>]]+values[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][W]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h2><h3 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intervalSchedule</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        start := interval[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = interval[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a>5. 并查集</h2><h3 id="标准实现"><a href="#标准实现" class="headerlink" title="标准实现"></a>标准实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionFind <span class="keyword">struct</span> &#123;</span><br><span class="line">    parent []<span class="type">int</span></span><br><span class="line">    count  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> *UnionFind &#123;</span><br><span class="line">    parent := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> parent &#123;</span><br><span class="line">        parent[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;UnionFind&#123;parent, n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Find(x <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> uf.parent[x] != x &#123;</span><br><span class="line">        uf.parent[x] = uf.parent[uf.parent[x]] <span class="comment">// 路径压缩</span></span><br><span class="line">        x = uf.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *UnionFind)</span></span> Union(x, y <span class="type">int</span>) &#123;</span><br><span class="line">    rootX := uf.Find(x)</span><br><span class="line">    rootY := uf.Find(y)</span><br><span class="line">    <span class="keyword">if</span> rootX == rootY &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    uf.parent[rootX] = rootY</span><br><span class="line">    uf.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-前缀和与差分数组"><a href="#6-前缀和与差分数组" class="headerlink" title="6. 前缀和与差分数组"></a>6. 前缀和与差分数组</h2><h3 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维前缀和</span></span><br><span class="line"><span class="keyword">type</span> PrefixSum <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrefixSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> *PrefixSum &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    prefix := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        prefix[i] = prefix[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PrefixSum&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PrefixSum)</span></span> Query(i, j <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ps.prefix[j+<span class="number">1</span>] - ps.prefix[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="keyword">type</span> NumMatrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    prefix [][]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> NumMatrix &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NumMatrix&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    prefix := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        prefix[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            prefix[i][j] = prefix[i<span class="number">-1</span>][j] + prefix[i][j<span class="number">-1</span>] - prefix[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NumMatrix&#123;prefix&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumMatrix)</span></span> SumRegion(row1 <span class="type">int</span>, col1 <span class="type">int</span>, row2 <span class="type">int</span>, col2 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.prefix[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - this.prefix[row1][col2+<span class="number">1</span>] - this.prefix[row2+<span class="number">1</span>][col1] + this.prefix[row1][col1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h2><h3 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElements</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> res &#123;</span><br><span class="line">        res[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125; <span class="comment">// 存储索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++ &#123;</span><br><span class="line">        num := nums[i%n]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; num &gt; nums[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            res[top] = num</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heights = <span class="built_in">append</span>(heights, <span class="number">0</span>) <span class="comment">// 哨兵</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;           <span class="comment">// 哨兵</span></span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(heights); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            h := heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            w := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">            maxArea = max(maxArea, h*w)</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各题型解题要点总结"><a href="#各题型解题要点总结" class="headerlink" title="各题型解题要点总结"></a>各题型解题要点总结</h2><ol><li><p><strong>双指针</strong>：</p><ul><li>数组问题：注意有序数组的特殊性质</li><li>滑动窗口：明确窗口收缩条件，维护窗口状态</li></ul></li><li><p><strong>DFS&#x2F;BFS</strong>：</p><ul><li>树遍历：前中后序选择取决于问题需求</li><li>回溯：注意状态恢复，剪枝优化</li></ul></li><li><p><strong>动态规划</strong>：</p><ul><li>明确状态定义和转移方程</li><li>考虑空间优化（滚动数组）</li></ul></li><li><p><strong>贪心算法</strong>：</p><ul><li>证明贪心选择的正确性</li><li>通常需要先排序</li></ul></li><li><p><strong>并查集</strong>：</p><ul><li>路径压缩和按秩合并优化</li><li>处理连通分量问题</li></ul></li><li><p><strong>前缀和&#x2F;差分</strong>：</p><ul><li>前缀和用于快速区间查询</li><li>差分数组用于快速区间更新</li></ul></li><li><p><strong>单调栈</strong>：</p><ul><li>维护栈内元素的单调性</li><li>用于解决”下一个更大&#x2F;小元素”类问题</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-LeetCode-刷题必备基础备忘录&quot;&gt;&lt;a href=&quot;#Golang-LeetCode-刷题必备基础备忘录&quot; class=&quot;headerlink&quot; title=&quot;Golang LeetCode 刷题必备基础备忘录&quot;&gt;&lt;/a&gt;Golang Leet</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 堆中返回的值为什么是最后一个，不是0位</title>
    <link href="https://leiqi.top/2025-06-12-6ce91bef2b21.html"/>
    <id>https://leiqi.top/2025-06-12-6ce91bef2b21.html</id>
    <published>2025-06-12T17:02:18.000Z</published>
    <updated>2025-06-17T16:34:43.214Z</updated>
    
    <content type="html"><![CDATA[<p>这涉及到 Go 中 <code>sort.Slice</code> 和堆(<code>container/heap</code>) 实现的<strong>关键区别</strong>。虽然它们都使用 <code>Less</code> 函数，但行为完全不同：</p><h3 id="1-sort-Slice-的-Less-函数（排序场景）"><a href="#1-sort-Slice-的-Less-函数（排序场景）" class="headerlink" title="1. sort.Slice 的 Less 函数（排序场景）"></a>1. <code>sort.Slice</code> 的 <code>Less</code> 函数（排序场景）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &lt; people[j].Age <span class="comment">// 升序排序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：直接定义最终排序顺序</li><li><strong>结果</strong>：当 <code>people[i].Age &lt; people[j].Age</code> 时，<code>i</code> 会排在 <code>j</code> 前面 → <strong>升序排列</strong></li><li><strong>内存布局</strong>：切片物理位置就是有序的，索引0是最小值，最后索引是最大值</li></ul><h3 id="2-堆的-Less-函数（堆场景）"><a href="#2-堆的-Less-函数（堆场景）" class="headerlink" title="2. 堆的 Less 函数（堆场景）"></a>2. 堆的 <code>Less</code> 函数（堆场景）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> h[i] &lt; h[j] <span class="comment">// 最小堆定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：定义堆的<strong>父子节点关系</strong>（不是最终排序顺序！）</li><li><strong>堆性质</strong>：在最小堆中，任意父节点 ≤ 子节点</li><li><strong>内存布局</strong>：堆是<strong>半排序</strong>的树状结构（数组实现）：<ul><li>索引0位置是<strong>根节点（最小值）</strong></li><li>最后一个元素位置<strong>不固定</strong>（可能大也可能小）</li></ul></li></ul><h3 id="关键区别：Pop-的实现"><a href="#关键区别：Pop-的实现" class="headerlink" title="关键区别：Pop() 的实现"></a>关键区别：<code>Pop()</code> 的实现</h3><p>堆的 <code>Pop()</code> 操作有特殊处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]  <span class="comment">// 取出最后一个元素</span></span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么取最后一个元素？</strong> 因为在标准库 <code>heap.Pop()</code> 中已经做了前置操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库 heap.Pop() 的伪代码：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    n := h.Len()</span><br><span class="line">    h.Swap(<span class="number">0</span>, n<span class="number">-1</span>)  <span class="comment">// 关键！交换根节点(最小值)和最后一个节点</span></span><br><span class="line">    down(h, <span class="number">0</span>, n<span class="number">-1</span>) <span class="comment">// 重新堆化</span></span><br><span class="line">    <span class="keyword">return</span> h.Pop()   <span class="comment">// 此时调用用户实现的Pop（取最后元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆操作流程（最小堆为例）"><a href="#堆操作流程（最小堆为例）" class="headerlink" title="堆操作流程（最小堆为例）"></a>堆操作流程（最小堆为例）</h3><ol><li><p><strong>初始化堆</strong>：<code>[3, 1, 5]</code> → 堆化后: <code>[1, 3, 5]</code></p><ul><li>索引0&#x3D;1（最小值）</li><li>最后索引&#x3D;5</li></ul></li><li><p><strong><code>heap.Pop()</code> 内部过程</strong>：</p><ul><li>交换根节点和最后节点: <code>[5, 3, 1]</code></li><li>重新堆化前n-1个元素: <code>[3, 5]</code> → 堆化后 <code>[3, 5]</code></li><li>调用用户 <code>Pop()</code> 返回最后元素 <code>1</code>（最小值）</li></ul></li><li><p><strong>结果</strong>：</p><ul><li>堆变为 <code>[3, 5]</code></li><li>弹出值 <code>1</code>（最小值）</li></ul></li></ol><h3 id="为什么最后位置不是最大值？"><a href="#为什么最后位置不是最大值？" class="headerlink" title="为什么最后位置不是最大值？"></a>为什么最后位置不是最大值？</h3><ul><li>堆的<strong>物理存储不是全排序的</strong>，只保证父≤子</li><li>最后一个元素是<strong>最后一片叶子节点</strong>，可能很小也可能很大</li><li>通过 <code>Swap(0, n-1)</code> 操作，实际弹出的是原根节点（最小值）</li></ul><h3 id="堆的视觉表示"><a href="#堆的视觉表示" class="headerlink" title="堆的视觉表示"></a>堆的视觉表示</h3><p>初始数组：<code>[3, 1, 5]</code><br>堆化后内存布局：<code>[1, 3, 5]</code><br>树状结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1    (根节点=最小值)</span><br><span class="line"> / \</span><br><span class="line">3   5  (5是最后一个叶子节点)</span><br></pre></td></tr></table></figure><p>Pop 时交换根和最后叶子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  5    (临时根)</span><br><span class="line"> / </span><br><span class="line">3    [1被交换到最后位置]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th><code>sort.Slice</code></th><th><code>container/heap</code></th></tr></thead><tbody><tr><td><code>Less</code> 作用</td><td>定义最终排序顺序</td><td>定义父子节点关系</td></tr><tr><td>内存布局</td><td>完全有序</td><td>半有序（树状结构）</td></tr><tr><td>索引0位置</td><td>最小值（升序时）</td><td>根节点（最小值）</td></tr><tr><td>最后索引位置</td><td>最大值（升序时）</td><td>不固定（最后一个叶子节点）</td></tr><tr><td><code>Pop()</code> 行为</td><td>无此操作</td><td>返回交换后的最后一个元素（原根节点）</td></tr></tbody></table><p>因此，在堆实现中：</p><ul><li><code>h[i] &lt; h[j]</code> 定义的是最小堆（根节点最小）</li><li><code>Pop()</code> 返回最小值，因为标准库在调用用户 <code>Pop()</code> 前已交换了根节点和最后节点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这涉及到 Go 中 &lt;code&gt;sort.Slice&lt;/code&gt; 和堆(&lt;code&gt;container/heap&lt;/code&gt;) 实现的&lt;strong&gt;关键区别&lt;/strong&gt;。虽然它们都使用 &lt;code&gt;Less&lt;/code&gt; 函数，但行为完全不同：&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>pycharm配置VPN代理</title>
    <link href="https://leiqi.top/2025-06-08-e7d1013a5402.html"/>
    <id>https://leiqi.top/2025-06-08-e7d1013a5402.html</id>
    <published>2025-06-08T16:18:16.000Z</published>
    <updated>2025-06-17T16:34:43.223Z</updated>
    
    <content type="html"><![CDATA[<p>确定本地VPN的代理端口：</p><p><img src="/../../imgs/Pasted%20image%2020250609001902.png"></p><p><img src="/../../imgs/Pasted%20image%2020250609001826.png"></p><p>点击check connetion 输入<a href="http://www.google.com/">http://www.google.com</a><br><img src="/../../imgs/Pasted%20image%2020250609001953.png"><br><img src="/../../imgs/Pasted%20image%2020250609001820.png"></p><p>也可以使用requests 包验证, 返回内容，不爆红即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.youtube.com&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250609002055.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确定本地VPN的代理端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250609001902.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202025060900</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯总结</title>
    <link href="https://leiqi.top/2025-06-03-fc6703ad881e.html"/>
    <id>https://leiqi.top/2025-06-03-fc6703ad881e.html</id>
    <published>2025-06-03T15:53:20.000Z</published>
    <updated>2025-06-17T16:34:43.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子集型回溯"><a href="#子集型回溯" class="headerlink" title="子集型回溯"></a>子集型回溯</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020250605230846.png"><br><img src="/../../imgs/Pasted%20image%2020250605230928.png"><br>方法一：输入的视角（选或不选）<br>对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2<br>n<br>  个不同的子集。</p><p>dfs 中的 i 表示当前考虑到 nums[i] 选或不选。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// 子集构造完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path)) <span class="comment">// 复制 path</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不选 nums[i]</span></span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选 nums[i]</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        dfs(i + <span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：<strong>答案的视角（枚举选哪个）</strong><br>枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。</p><p>dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。</p><p>如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。</p><p>注意：不需要在回溯中判断 i&#x3D;n 的边界情况，因为此时不会进入循环，if i &#x3D;&#x3D; n: return 这句话写不写都一样.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&lt;&lt;n) <span class="comment">// 预分配空间</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n) <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 关键位置：在递归开始时记录当前路径</span></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 从当前索引向后枚举</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[j])  <span class="comment">// 选择数字</span></span><br><span class="line">            dfs(j + <span class="number">1</span>)                   <span class="comment">// 递归下一层</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]     <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="131"><li>分割回文串 <a href="https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/">https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/</a></li></ol><p>从答案的角度，枚举选哪个，需要使用for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := left, right;i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> (ans [][]<span class="type">string</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑 s[i:] 怎么分割</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n &#123; <span class="comment">// s 分割完毕</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, slices.Clone(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">// 枚举子串的结束位置</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome(s, i, j) &#123;</span><br><span class="line">                path = <span class="built_in">append</span>(path, s[i:j+<span class="number">1</span>]) <span class="comment">// 分割！</span></span><br><span class="line">                <span class="comment">// 考虑剩余的 s[j+1:] 怎么分割</span></span><br><span class="line">                dfs(j + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="132"><li>电话号码的字母组合 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/</a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    m []<span class="type">string</span></span><br><span class="line">    path []<span class="type">byte</span></span><br><span class="line">    res []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 将index 和 字符串对应起来</span></span><br><span class="line">m = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">path, res = <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>),<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">backTracking(digits,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(digits <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 终止条件 ，遍历完digits</span></span><br><span class="line"><span class="keyword">if</span> start == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        tmp := <span class="type">string</span>(path)</span><br><span class="line">res = <span class="built_in">append</span>(res,tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到 digit</span></span><br><span class="line">digitNum := <span class="type">int</span>(digits[start] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">// 遍历 digit 对应的map 字符串</span></span><br><span class="line">str := m[digitNum]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; <span class="built_in">len</span>(str);i++ &#123; <span class="comment">// i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始</span></span><br><span class="line">path = <span class="built_in">append</span>(path,str[i])</span><br><span class="line">backTracking(digits,start+<span class="number">1</span>)</span><br><span class="line">path =path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合型回溯"><a href="#组合型回溯" class="headerlink" title="组合型回溯"></a>组合型回溯</h2><p><img src="/../../imgs/Pasted%20image%2020250611222518.png"></p><ol><li>左边选或者不选  K&#x3D;3  右边k &#x3D; 2, 因为是组合，等于是重复的就能再出现了，再选了2 之后，只能选1 了， 不能再选其他的了。<br><img src="/../../imgs/Pasted%20image%2020250611223356.png"><br>倒序的不等式简单点，正序的不等式为 n - i + 1 &lt; d 直接return</li></ol><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i - <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(n)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历减枝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="keyword">if</span> k &gt; n &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> <span class="comment">// 下一个位置的组合</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// base case</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path) <span class="comment">// copy 目标值在前边</span></span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= n; i++ &#123; <span class="comment">// 倒序方便</span></span><br><span class="line"><span class="comment">//path 还需要 k - len(path) 提前减枝</span></span><br><span class="line"><span class="keyword">if</span> n-i+<span class="number">1</span> &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 注意是k - len(path)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i + <span class="number">1</span>)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode216</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个合法组合</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == k &amp;&amp; sum == n &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(tmp, path)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝：剩余数字不足以填满 path 或无法达到 sum</span></span><br><span class="line"><span class="keyword">for</span> i := start; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; k-<span class="built_in">len</span>(path) &#123; <span class="comment">// 确保剩余数字足够填满 path</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum+i &gt; n &#123; <span class="comment">// 提前终止，避免无效递归  如果 sum + i &gt; n，说明当前 i 太大，不能选它。但 更小的 i 仍然可能满足 sum + i &lt;= n，所以不能直接 break（否则会漏掉可能的解）。</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, i)</span><br><span class="line">dfs(i<span class="number">-1</span>, sum+i)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">9</span>, <span class="number">0</span>) <span class="comment">// 数字范围是 1~9</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p><p>思路<a href="https://labuladong.online/algo/practice-in-action/generate-parentheses/">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态数据 回退操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//n 对括号 只要最后左右总和一样，</span></span><br><span class="line">m := n * <span class="number">2</span></span><br><span class="line">res := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span></span><br><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == m &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, strings.Join(path, <span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选左边</span></span><br><span class="line"><span class="keyword">if</span> open &lt; n &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选右边</span></span><br><span class="line"><span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 右边要小于左边才能加</span></span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;)&quot;</span>)</span><br><span class="line">dfs(i+<span class="number">1</span>, open)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 入口函数需要添加</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定长度+索引，不用回退</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    m := n * <span class="number">2</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, open <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == m &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, <span class="type">string</span>(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> open &lt; n &#123; <span class="comment">// 可以填左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i-open &lt; open &#123; <span class="comment">// 可以填右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, open)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你提供的这个实现中，不需要显式的回退操作（如 <code>path = path[:len(path)-1]</code>），是因为它采用了 <strong>固定长度的 <code>[]byte</code> 数组</strong> 和 <strong>索引覆盖</strong> 的方式，这与常见的回溯算法实现有所不同。下面详细解释为什么可以省略回退操作：</p><hr><h3 id="关键原因分析"><a href="#关键原因分析" class="headerlink" title="关键原因分析"></a><strong>关键原因分析</strong></h3><h4 id="1-使用固定长度的-byte-数组"><a href="#1-使用固定长度的-byte-数组" class="headerlink" title="1. 使用固定长度的 []byte 数组"></a>1. <strong>使用固定长度的 <code>[]byte</code> 数组</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)  <span class="comment">// 长度为 m 的固定数组</span></span><br></pre></td></tr></table></figure><ul><li>数组 <code>path</code> 的长度在初始化时就固定为 <code>m</code>（<code>=n*2</code>），不会动态增长。</li><li>每个递归层级直接通过索引 <code>i</code> 修改 <code>path[i]</code> 的位置，<strong>不会影响其他层级的存储</strong>。</li></ul><h4 id="2-索引覆盖写入"><a href="#2-索引覆盖写入" class="headerlink" title="2. 索引覆盖写入"></a>2. <strong>索引覆盖写入</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 或 path[i] = &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>每次写入都会<strong>精确覆盖 <code>path[i]</code> 的位置</strong>，而不会追加元素。</li><li>递归返回时，<strong>上层调用会覆盖当前层写入的值</strong>，因此不需要手动回退。</li></ul><h4 id="3-递归的自然回溯"><a href="#3-递归的自然回溯" class="headerlink" title="3. 递归的自然回溯"></a>3. <strong>递归的自然回溯</strong></h4><ul><li>当递归从深层返回时，<strong>上层调用会继续修改 <code>path</code> 的后续位置</strong>，覆盖之前的值。</li><li>例如：<ul><li>第一层递归写入 <code>path[0] = &#39;(&#39;</code>，然后进入第二层。</li><li>第二层写入 <code>path[1] = &#39;(&#39;</code> 或 <code>path[1] = &#39;)&#39;</code>。</li><li>当第二层递归返回后，第一层可能会写入 <code>path[1] = &#39;)&#39;</code>，覆盖之前的值。</li></ul></li></ul><hr><h3 id="对比需要回退操作的实现"><a href="#对比需要回退操作的实现" class="headerlink" title="对比需要回退操作的实现"></a><strong>对比需要回退操作的实现</strong></h3><h4 id="需要回退的版本（动态-append）"><a href="#需要回退的版本（动态-append）" class="headerlink" title="需要回退的版本（动态 append）"></a><strong>需要回退的版本（动态 <code>append</code>）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">path = <span class="built_in">append</span>(path, <span class="string">&quot;(&quot;</span>)  <span class="comment">// 修改切片长度</span></span><br><span class="line">dfs(...)</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>] <span class="comment">// 必须回退</span></span><br></pre></td></tr></table></figure><ul><li>动态 <code>append</code> 会改变切片长度，必须显式回退以恢复状态。</li></ul><h4 id="不需要回退的版本（固定数组-索引覆盖）"><a href="#不需要回退的版本（固定数组-索引覆盖）" class="headerlink" title="不需要回退的版本（固定数组 + 索引覆盖）"></a><strong>不需要回退的版本（固定数组 + 索引覆盖）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path := <span class="built_in">make</span>([]<span class="type">byte</span>, m)</span><br><span class="line">path[i] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 直接覆盖，不改变长度</span></span><br><span class="line">dfs(...)</span><br><span class="line"><span class="comment">// 无需回退，上层调用会覆盖 path[i]</span></span><br></pre></td></tr></table></figure><ul><li>固定数组的长度不变，通过索引直接修改值，递归返回后自然被覆盖。</li></ul><hr><h3 id="为什么这种写法是正确的？"><a href="#为什么这种写法是正确的？" class="headerlink" title="为什么这种写法是正确的？"></a><strong>为什么这种写法是正确的？</strong></h3><ol><li><p><strong>隐式回溯</strong>：</p><ul><li>每一层递归的 <code>path[i]</code> 写入是独立的，递归返回后会被上层调用覆盖。</li><li>例如：<ul><li>路径 <code>&quot;(())&quot;</code> 的生成过程：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path[<span class="number">0</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第一层</span></span><br><span class="line">path[<span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span>  <span class="comment">// 第二层</span></span><br><span class="line">path[<span class="number">2</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第三层</span></span><br><span class="line">path[<span class="number">3</span>] = <span class="string">&#x27;)&#x27;</span>  <span class="comment">// 第四层</span></span><br></pre></td></tr></table></figure></li><li>如果第二层尝试 <code>path[1] = &#39;)&#39;</code>，它会覆盖之前的 <code>&#39;(&#39;</code>，但通过条件 <code>i-open &lt; open</code> 保证了合法性。</li></ul></li></ul></li><li><p><strong>条件保证合法性</strong>：</p><ul><li><code>open &lt; n</code> 确保左括号不超过 <code>n</code> 个。</li><li><code>i-open &lt; open</code> 确保右括号数不超过左括号数。</li></ul></li></ol><hr><ul><li><strong>不需要回退</strong>：因为使用了固定长度的 <code>[]byte</code> 数组，通过索引直接覆盖写入，递归返回时上层调用会自然覆盖当前层的修改。</li><li><strong>更高效</strong>：避免了动态切片的扩容和回退操作，减少了内存分配。</li><li><strong>更简洁</strong>：代码更紧凑，但需要理解索引覆盖的隐式回溯逻辑。</li></ul><p>这种写法是回溯算法的一种优化技巧，适用于结果长度固定的场景（如括号生成、排列问题等）。</p><h2 id="排列型回溯"><a href="#排列型回溯" class="headerlink" title="排列型回溯"></a>排列型回溯</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子集型回溯&quot;&gt;&lt;a href=&quot;#子集型回溯&quot; class=&quot;headerlink&quot; title=&quot;子集型回溯&quot;&gt;&lt;/a&gt;子集型回溯&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/letter-combinations-</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>闭包介绍</title>
    <link href="https://leiqi.top/2025-05-28-3ec80348e81b.html"/>
    <id>https://leiqi.top/2025-05-28-3ec80348e81b.html</id>
    <published>2025-05-28T15:10:41.000Z</published>
    <updated>2025-06-17T16:34:43.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么闭包能共享变量-pre？"><a href="#为什么闭包能共享变量-pre？" class="headerlink" title="为什么闭包能共享变量 pre？"></a>为什么闭包能共享变量 <code>pre</code>？</h3><p>在提供的代码中，闭包能够共享变量 <code>pre</code> 的关键在于 <strong>词法作用域（Lexical Scoping）</strong> 和 <strong>闭包捕获变量</strong> 的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    pre := math.MinInt64 <span class="comment">// 外层函数变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以访问并修改外层的 pre 变量</span></span><br><span class="line">        <span class="keyword">if</span> node.Val &lt;= pre &#123; ... &#125;</span><br><span class="line">        pre = node.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><ol><li><p><strong>词法作用域</strong>：</p><ul><li>Go 中函数可以访问定义时所在作用域的所有变量</li><li><code>dfs</code> 匿名函数定义在 <code>isValidBST</code> 函数体内，自然能访问 <code>pre</code></li></ul></li><li><p><strong>闭包捕获变量</strong>：</p><ul><li>闭包不会复制变量值，而是<strong>捕获变量的引用</strong></li><li>所有递归调用的 <code>dfs</code> 都指向<strong>同一个 <code>pre</code> 变量</strong></li><li>修改 <code>pre</code> 会影响所有闭包实例</li></ul></li><li><p><strong>递归共享状态</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[pre=MinInt64] --&gt; B[dfs-根节点]</span><br><span class="line">B --&gt; C[dfs-左子节点]</span><br><span class="line">C --&gt; D[dfs-左孙节点]</span><br><span class="line">D --&gt;|更新pre| C</span><br><span class="line">C --&gt;|更新pre| B</span><br><span class="line">B --&gt;|更新pre| E[dfs-右子节点]</span><br></pre></td></tr></table></figure></li></ol><h3 id="闭包名称的含义与起源"><a href="#闭包名称的含义与起源" class="headerlink" title="闭包名称的含义与起源"></a>闭包名称的含义与起源</h3><h4 id="名称来源"><a href="#名称来源" class="headerlink" title="名称来源"></a>名称来源</h4><p>“闭包”（Closure）一词来源于 <strong>函数”闭合”（close over）其定义环境</strong> 的概念：</p><ul><li>最早由 Peter J. Landin 在 1964 年提出</li><li>源自数学中的 <strong>λ演算（Lambda Calculus）</strong> 和 <strong>闭包属性（Closure Property）</strong></li><li>在编译原理中称为 <strong>词法闭包（Lexical Closure）</strong></li></ul><h4 id="名称含义"><a href="#名称含义" class="headerlink" title="名称含义"></a>名称含义</h4><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>闭（Close）</strong></td><td>函数”封闭”地携带其定义时的环境</td></tr><tr><td><strong>包（-ure）</strong></td><td>将函数与其环境”打包”在一起</td></tr></tbody></table><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol><li><strong>环境捕获</strong>：函数记住并访问定义时的作用域</li><li><strong>状态持久化</strong>：捕获的变量生命周期与闭包相同</li><li><strong>私密状态</strong>：只有闭包能访问捕获的变量</li></ol><h3 id="闭包在-BST-验证中的优势"><a href="#闭包在-BST-验证中的优势" class="headerlink" title="闭包在 BST 验证中的优势"></a>闭包在 BST 验证中的优势</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre := math.MinInt64  <span class="comment">// 共享状态</span></span><br><span class="line">dfs := <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 递归过程共享同一个 pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>状态管理简化</strong>：无需指针传递</li><li><strong>代码更简洁</strong>：减少参数传递</li><li><strong>逻辑更直观</strong>：直接读写共享状态</li><li><strong>避免值复制</strong>：高效处理递归状态</li></ol><h3 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h3><p>闭包本质上是一个 <strong>（函数 + 绑定环境）</strong> 的组合体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">bool</span>  <span class="comment">// 函数逻辑</span></span><br><span class="line">    Env <span class="keyword">struct</span> &#123;            <span class="comment">// 捕获的环境</span></span><br><span class="line">        pre <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次递归调用时，都使用同一个 <code>Env</code> 环境，这正是 BST 验证需要的中序遍历状态一致性保证。</p><h3 id="闭包-vs-指针参数"><a href="#闭包-vs-指针参数" class="headerlink" title="闭包 vs 指针参数"></a>闭包 vs 指针参数</h3><table><thead><tr><th>特性</th><th>闭包</th><th>指针参数</th></tr></thead><tbody><tr><td>状态共享</td><td>自动捕获</td><td>需显式传递</td></tr><tr><td>可读性</td><td>★★★☆☆</td><td>★★☆☆☆</td></tr><tr><td>安全性</td><td>变量封装</td><td>暴露内存地址</td></tr><tr><td>递归适用性</td><td>非常适合</td><td>需要小心指针传递</td></tr></tbody></table><p>在 BST 验证场景中，闭包方案更简洁安全，避免了指针传递的复杂性，是 Go 语言处理递归状态的首选模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么闭包能共享变量-pre？&quot;&gt;&lt;a href=&quot;#为什么闭包能共享变量-pre？&quot; class=&quot;headerlink&quot; title=&quot;为什么闭包能共享变量 pre？&quot;&gt;&lt;/a&gt;为什么闭包能共享变量 &lt;code&gt;pre&lt;/code&gt;？&lt;/h3&gt;&lt;p&gt;在提供的代</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>comet 生成临时文件导致磁盘满</title>
    <link href="https://leiqi.top/2025-05-01-d5e22ea4be8d.html"/>
    <id>https://leiqi.top/2025-05-01-d5e22ea4be8d.html</id>
    <published>2025-05-01T13:50:34.000Z</published>
    <updated>2025-06-17T16:34:43.224Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>出现 <code>OSError: [Errno 28] No space left on device</code> 错误的原因是系统磁盘空间不足，尤其是在临时目录（如 <code>/tmp</code>）中。以下是分步解决方案：</p><hr><h4 id="1-检查磁盘空间"><a href="#1-检查磁盘空间" class="headerlink" title="1. 检查磁盘空间"></a><strong>1. 检查磁盘空间</strong></h4><p>在终端运行以下命令，查看磁盘使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><h4 id="2-清理临时文件"><a href="#2-清理临时文件" class="headerlink" title="2. 清理临时文件"></a><strong>2. 清理临时文件</strong></h4><p>删除临时目录中的旧文件（确保无重要进程依赖这些文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /tmp/*</span><br></pre></td></tr></table></figure><hr><h4 id="3-查找并删除大文件"><a href="#3-查找并删除大文件" class="headerlink" title="3. 查找并删除大文件"></a><strong>3. 查找并删除大文件</strong></h4><p>使用以下命令定位大文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看根目录下各文件夹的大小</span></span><br><span class="line">sudo <span class="built_in">du</span> -sh /* | <span class="built_in">sort</span> -hr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下大于 1GB 的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +1G -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>删除不再需要的大文件（如旧日志、缓存等）。</p><hr><h4 id="4-清理系统缓存和日志"><a href="#4-清理系统缓存和日志" class="headerlink" title="4. 清理系统缓存和日志"></a><strong>4. 清理系统缓存和日志</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理 APT 缓存（适用于 Ubuntu/Debian）</span></span><br><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理旧版 Linux 内核（谨慎操作）</span></span><br><span class="line">sudo apt-get autoremove --purge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理系统日志（保留最近7天）</span></span><br><span class="line">sudo journalctl --vacuum-time=7d</span><br></pre></td></tr></table></figure><hr><h4 id="5-更改临时目录路径"><a href="#5-更改临时目录路径" class="headerlink" title="5. 更改临时目录路径"></a><strong>5. 更改临时目录路径</strong></h4><p>如果 <code>/tmp</code> 所在分区空间不足，可以将临时目录指向其他分区：</p><p><strong>方法一：在代码中设置临时目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">tempfile.tempdir = <span class="string">&quot;/path/to/your/large/disk/tmp&quot;</span>  <span class="comment"># 替换为有足够空间的路径</span></span><br></pre></td></tr></table></figure><p><strong>方法二：通过环境变量设置</strong><br>在运行脚本前设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TMPDIR=/path/to/your/large/disk/tmp</span><br></pre></td></tr></table></figure><hr><h4 id="6-调整-Comet-ml-的存储路径"><a href="#6-调整-Comet-ml-的存储路径" class="headerlink" title="6. 调整 Comet.ml 的存储路径"></a><strong>6. 调整 Comet.ml 的存储路径</strong></h4><p>在初始化 <code>Experiment</code> 时指定日志和临时文件目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">experiment = Experiment(</span><br><span class="line">    <span class="string">&quot;H62QCY6dW6Vg9lLl27jZn4C2O&quot;</span>,</span><br><span class="line">    project_name=<span class="string">&quot;IDRsPredictor-transformer&quot;</span>,</span><br><span class="line">    log_code=<span class="literal">True</span>,</span><br><span class="line">    log_dir=<span class="string">&quot;/path/to/large/disk/comet_logs&quot;</span>  <span class="comment"># 指定存储路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参考：chatGPT</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;出现 &lt;code&gt;OSError: [Errno 28] No space le</summary>
      
    
    
    
    <category term="比赛" scheme="https://leiqi.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Git自动转换为Linux换行符</title>
    <link href="https://leiqi.top/2025-04-28-84ca2c3d5919.html"/>
    <id>https://leiqi.top/2025-04-28-84ca2c3d5919.html</id>
    <published>2025-04-28T13:15:32.000Z</published>
    <updated>2025-06-17T16:34:43.218Z</updated>
    
    <content type="html"><![CDATA[<p>在 Git 中处理不同操作系统（Windows&#x2F;Linux&#x2F;macOS）的换行符（<code>LF</code> 和 <code>CRLF</code>）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：</p><hr><h3 id="1-核心配置：core-autocrlf"><a href="#1-核心配置：core-autocrlf" class="headerlink" title="1. 核心配置：core.autocrlf"></a><strong>1. 核心配置：<code>core.autocrlf</code></strong></h3><p>通过设置 <code>core.autocrlf</code> 属性，让 Git 自动转换换行符：</p><h4 id="不同操作系统的推荐设置"><a href="#不同操作系统的推荐设置" class="headerlink" title="不同操作系统的推荐设置"></a><strong>不同操作系统的推荐设置</strong></h4><ul><li><p><strong>Windows（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时转换为 CRLF</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Linux&#x2F;macOS（推荐）</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br><span class="line"><span class="comment"># 提交时转换为 LF，检出时不转换</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-强制规范：-gitattributes-文件"><a href="#2-强制规范：-gitattributes-文件" class="headerlink" title="2. 强制规范：.gitattributes 文件"></a><strong>2. 强制规范：<code>.gitattributes</code> 文件</strong></h3><p>在项目根目录创建 <code>.gitattributes</code> 文件，<strong>优先级高于全局配置</strong>，适合团队协作。</p><h4 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 所有文本文件使用 LF 换行符</span><br><span class="line">* text=auto eol=lf</span><br><span class="line"></span><br><span class="line"># 排除二进制文件（避免误处理）</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br><span class="line">*.zip binary</span><br><span class="line"></span><br><span class="line"># 指定特定文件类型（可选）</span><br><span class="line">*.sh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure><ul><li><code>text=auto</code>：Git 自动识别文本文件。</li><li><code>eol=lf</code> 或 <code>eol=crlf</code>：强制统一换行符。</li></ul><hr><h3 id="3-修复已存在的换行符问题"><a href="#3-修复已存在的换行符问题" class="headerlink" title="3. 修复已存在的换行符问题"></a><strong>3. 修复已存在的换行符问题</strong></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h4><ol><li><p>删除缓存并重置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached -r .  <span class="comment"># 清除缓存</span></span><br><span class="line">git reset --hard      <span class="comment"># 重置文件</span></span><br></pre></td></tr></table></figure></li><li><p>重新添加文件并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;fix: normalize line endings&quot;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-检查换行符状态"><a href="#4-检查换行符状态" class="headerlink" title="4. 检查换行符状态"></a><strong>4. 检查换行符状态</strong></h3><h4 id="检查文件换行符："><a href="#检查文件换行符：" class="headerlink" title="检查文件换行符："></a><strong>检查文件换行符</strong>：</h4><ul><li><p><strong>Linux&#x2F;macOS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file yourfile.txt</span><br><span class="line"><span class="comment"># 输出中包含 &quot;LF&quot; 或 &quot;CRLF&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Windows（PowerShell）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> yourfile.txt <span class="literal">-Encoding</span> Byte | <span class="built_in">Select-String</span> <span class="string">&quot;0D 0A&quot;</span></span><br><span class="line"><span class="comment"># 存在 &quot;0D 0A&quot; 表示 CRLF</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="查看-Git-换行符转换日志："><a href="#查看-Git-换行符转换日志：" class="headerlink" title="查看 Git 换行符转换日志："></a><strong>查看 Git 换行符转换日志</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --eol</span><br></pre></td></tr></table></figure><hr><h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a><strong>常见问题解决</strong></h3><ul><li><p>**警告 <code>LF will be replaced by CRLF</code>**：<br>正常提示，表示 Git 正在按配置转换换行符。</p></li><li><p><strong>文件被标记为已修改（仅换行符变化）</strong>：<br>运行以下命令清除差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.whitespace cr-at-eol</span><br><span class="line">git add --renormalize .</span><br></pre></td></tr></table></figure></li><li><p><strong>混合换行符导致冲突</strong>：<br>使用 <code>.gitattributes</code> 强制统一换行符，并重新提交文件。</p></li></ul><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol><li><strong>团队协作</strong>：在项目中添加 <code>.gitattributes</code> 文件，统一换行符规则。</li><li><strong>编辑器配置</strong>：设置 IDE（如 VSCode）默认使用 <code>LF</code>（<a href="https://stackoverflow.com/a/44788470">配置示例</a>）。</li><li><strong>Windows 用户</strong>：安装 Git 时选择 <code>Checkout as-is, commit Unix-style line endings</code>。</li></ol><hr><p>通过上述配置，Git 会自动处理换行符，避免跨平台协作时的混乱！ 🛠️</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Git 中处理不同操作系统（Windows&amp;#x2F;Linux&amp;#x2F;macOS）的换行符（&lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt;）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
</feed>
