<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2024-03-24T14:47:15.366Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 双指针</title>
    <link href="https://leiqichn.github.io/2024-03-23-84678021105b.html"/>
    <id>https://leiqichn.github.io/2024-03-23-84678021105b.html</id>
    <published>2024-03-23T14:51:46.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除有序数组中的重复元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast:=<span class="hljs-number">1</span>;fast &lt;<span class="hljs-built_in">len</span>(nums);fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<span class="hljs-comment">// 跳到下个位置，保存slow</span><br><br>            nums[slow] = nums[fast]<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow +<span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p><p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>注意到以下性质：</strong></p><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>slow, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123; <span class="hljs-comment">// 注意第一个是0的时候需要比较</span><br><span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span><br>nums[slow], nums[fast] = nums[fast], nums[slow]<br>slow++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(height); j++ &#123;<br>area := (j - i) * min(height[i], height[j])<br>ans = max(area,ans)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化两边指针</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        area := (right - left) * min(height[left], height[right]) <span class="hljs-comment">// 计算面积</span><br>        ans = max(ans, area) <span class="hljs-comment">// 计算最大值</span><br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123; <br>            left++ <span class="hljs-comment">// 移动短的那个</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240323225412.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 单调栈</title>
    <link href="https://leiqichn.github.io/2024-02-24-dd95d981cb94.html"/>
    <id>https://leiqichn.github.io/2024-02-24-dd95d981cb94.html</id>
    <published>2024-02-24T15:57:54.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p><p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span><br><span class="hljs-comment">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 java 代码对比查看。</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123; <span class="hljs-comment">// 倒着入栈是为了后边正着出栈</span><br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &lt;= nums[i] &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有更大的元素</span><br>            res[i] = <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 正着出栈</span><br>        &#125;<br>        s = <span class="hljs-built_in">append</span>(s, nums[i]) <span class="hljs-comment">// 当前元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://labuladong.online/algo/data-structure/monotonic-stack">https://labuladong.online/algo/data-structure/monotonic-stack</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」&lt;/p&gt;
&lt;p&gt;输入一个数组 &lt;code&gt;nums&lt;/code&gt;，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <link href="https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html"/>
    <id>https://leiqichn.github.io/2024-02-24-4fbd7a88bf6f.html</id>
    <published>2024-02-24T14:50:06.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p><pre><code class="hljs">*res = append(*res, root.Val)dfs(root.Left, res)dfs(root.Right, res)</code></pre><p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p><p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p><p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p><p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;func dfs(root *TreeNode, res *[]int) {&lt;br&gt;    if root &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;*res = ap</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <link href="https://leiqichn.github.io/2024-01-23-1cb0809a7893.html"/>
    <id>https://leiqichn.github.io/2024-01-23-1cb0809a7893.html</id>
    <published>2024-01-23T16:13:30.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> people[i][<span class="hljs-number">0</span>] == people[j][<span class="hljs-number">0</span>]&#123;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">1</span>] &lt; people[j][<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">0</span>] &gt; people[j][<span class="hljs-number">0</span>] <span class="hljs-comment">// 身高由大到小排列</span><br><br>&#125;)i<br><span class="hljs-comment">// 再按照K进行插入排序，优先插入K小的</span><br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-built_in">copy</span>(people[p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span> :i+<span class="hljs-number">1</span>], people[p[<span class="hljs-number">1</span>] :i=<span class="hljs-number">1</span>])  <span class="hljs-comment">// 腾空出一个位置</span><br>        people[p[<span class="hljs-number">1</span>]] = pi<br>&#125;<br><span class="hljs-keyword">return</span> people<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p></li><li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p></li><li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p></li><li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p></li></ol><p>最终，返回重新排列后的队列 <code>people</code>。</p><p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p><p>让我们考虑一下为什么使用 <code>i+1</code>：</p><ol><li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li><li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li><li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/queue-reconstruction-by-height/description/&quot;&gt;406. 根据身高重建队列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <link href="https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html"/>
    <id>https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html</id>
    <published>2024-01-23T15:17:11.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p><p>使用回溯的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>path := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// return </span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>) <span class="hljs-comment">// i+1 进行下一轮</span><br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p></li><li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p></li><li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p></li><li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p></li><li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p></li><li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinations/description/&quot;&gt;77. 组合 - 力扣（LeetCode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202024</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【BFS DFS通用模板】</title>
    <link href="https://leiqichn.github.io/2024-01-22-759654485d5d.html"/>
    <id>https://leiqichn.github.io/2024-01-22-759654485d5d.html</id>
    <published>2024-01-22T16:05:29.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 通用的深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node <span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> visited[node] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理当前节点</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 标记当前节点为已访问</span><br>    visited[node] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 递归处理相邻节点</span><br>    <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>        dfs(neighbor, visited, graph)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化节点、访问数组等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 遍历所有节点</span><br>    <span class="hljs-keyword">for</span> node := <span class="hljs-number">0</span>; node &lt; <span class="hljs-built_in">len</span>(graph); node++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[node] &#123;<br>            dfs(node, visited, graph)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通用的广度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(graph))<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 出队列</span><br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment">// 处理当前节点</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 标记当前节点为已访问</span><br>        visited[node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 将相邻节点入队列</span><br>        <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[neighbor] &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, neighbor)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化起始节点、图等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用BFS函数</span><br>    bfs(start, graph)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;a href=&quot;#深度优先搜索（DFS）通用模板&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;/a&gt;深度优先搜索（DFS）通用模板&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <link href="https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html"/>
    <id>https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html</id>
    <published>2024-01-22T15:01:59.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">var</span> traversal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traversal = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br>traversal(node.Left)<br>res = <span class="hljs-built_in">append</span>(res,node.Val)<br>traversal(node.Right)<br>    &#125;<br>    traversal(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br><br>    st := list.New()<br>    cur := root<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> || st.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            st.PushBack(cur)<br>            cur = cur.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = st.Remove(st.Back()).(*TreeNode)<br>            ans = <span class="hljs-built_in">append</span>(ans, cur.Val)<br>            cur = cur.Right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对代码的解释：</p><ol><li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p></li><li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p></li><li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p></li><li><p><code>cur := root</code>: 初始化当前节点为根节点。</p></li><li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p></li><li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p><ul><li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p></li><li><p><code>cur = cur.Left</code>: 移动到左子树。</p></li></ul></li><li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p><ul><li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p></li><li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p></li><li><p><code>cur = cur.Right</code>: 移动到右子树。</p></li></ul></li><li><p>循环回到第5步，直到栈为空。</p></li></ol><p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p><p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p><ul><li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p></li><li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p></li></ul><p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p><p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归方法&quot;&gt;&lt;a href=&quot;#递归方法&quot; class=&quot;headerlink&quot; title=&quot;递归方法&quot;&gt;&lt;/a&gt;递归方法&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【go】初始化双向列表List</title>
    <link href="https://leiqichn.github.io/2024-01-22-93119ce81a1c.html"/>
    <id>https://leiqichn.github.io/2024-01-22-93119ce81a1c.html</id>
    <published>2024-01-22T14:39:01.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，两种方法都可以用于初始化一个<code>list.List</code>。</p><ol><li><p><code>queue := &amp;list.List&#123;&#125;</code>: 这是使用结构体字面量的方式，创建一个 <code>list.List</code> 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。</p></li><li><p><code>queue := list.New()</code>: 这是使用 <code>list</code> 包中的 <code>New</code> 函数来创建一个新的 <code>list.List</code>。<code>New</code> 函数返回一个指向新创建的 <code>list.List</code> 实例的指针。同样，这种方式也创建了一个空的链表。</p></li></ol><p>两种方式都是有效的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，两种方法都可以用于初始化一个&lt;code&gt;list.List&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;queue := &amp;amp;list.List&amp;#123;&amp;#125;&lt;/code&gt;: 这是使用结构体字面量的方式，创建一个 &lt;code&gt;l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240114】LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="https://leiqichn.github.io/2024-01-14-e61755fec3db.html"/>
    <id>https://leiqichn.github.io/2024-01-14-e61755fec3db.html</id>
    <published>2024-01-14T10:10:30.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">for</span> i := head; i != <span class="hljs-literal">nil</span> &amp;&amp; i.Next != <span class="hljs-literal">nil</span> ; &#123;<br>        <span class="hljs-keyword">if</span> i.Next.Val == i.Val &#123;<br>            i.Next = i.Next.Next <span class="hljs-comment">// 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123;  i = i.Next不需要</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    current := head<br><br>    <span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &amp;&amp; current.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> current.Next.Val == current.Val &#123;<br>            <span class="hljs-comment">// 保存下一个节点的引用</span><br>            nextNode := current.Next<br>            <span class="hljs-comment">// 删除当前节点</span><br>            current.Next = nextNode.Next<br>            <span class="hljs-comment">// 释放内存</span><br>            nextNode = <span class="hljs-literal">nil</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非重复元素，继续遍历</span><br>            current = current.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/&quot;&gt;83. 删除排序链表中的重复元素&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Win】键盘下键坏了，使用组合键模拟下方向键</title>
    <link href="https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html"/>
    <id>https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html</id>
    <published>2024-01-14T09:05:02.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：</p><p>下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。<br><img src="/../../imgs/Pasted%20image%2020240114170655.png"><br>创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">!s::<span class="hljs-built_in">Send</span> &#123;Down&#125;<br></code></pre></td></tr></table></figure><p>这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。<br><img src="/../../imgs/Pasted%20image%2020240114170729.png"><br>保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。</p><p>运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。</p><p>现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：&lt;/p&gt;
&lt;p&gt;下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。&lt;br&gt;&lt;img src</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240106】leetcode 2807. 在链表中插入最大公约数</title>
    <link href="https://leiqichn.github.io/2024-01-06-2b3ad028343c.html"/>
    <id>https://leiqichn.github.io/2024-01-06-2b3ad028343c.html</id>
    <published>2024-01-06T15:27:26.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&envId=2024-01-06">2807. 在链表中插入最大公约数 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240106233021.png"></p><p>最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。</p><p>计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下：</p><ol><li>用较大的数除以较小的数，得到余数。</li><li>将较小的数作为新的被除数，余数作为新的除数。</li><li>重复步骤 1 和 2，直到余数为零。</li><li>最后的非零余数即为最大公约数。</li></ol><p>这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。</p><p>以下是一个用 Go 语言实现的最大公约数的辗转相除法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 辗转相除法求最大公约数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        temp := b<br>        b = a % b<br>        a = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num1 := <span class="hljs-number">48</span><br>    num2 := <span class="hljs-number">18</span><br><br>    result := gcd(num1, num2)<br><br>    fmt.Println(<span class="hljs-string">&quot;最大公约数为:&quot;</span>, result)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>gcd</code> 函数使用了辗转相除法来计算两个整数的最大公约数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&amp;envId=2024-01-06</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1071. 字符串的最大公因子</title>
    <link href="https://leiqichn.github.io/2024-01-03-58e186a9065e.html"/>
    <id>https://leiqichn.github.io/2024-01-03-58e186a9065e.html</id>
    <published>2024-01-03T15:12:16.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></p><p><img src="/../../imgs/Pasted%20image%2020240103231323.png"></p><p><strong>解题思路：</strong></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n1, n2 := <span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2)<br><br>    <span class="hljs-comment">// 从最长的可能的子串长度开始尝试</span><br>    <span class="hljs-keyword">for</span> i := min(n1, n2); i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> n1%i == <span class="hljs-number">0</span> &amp;&amp; n2%i == <span class="hljs-number">0</span> &#123;<br>            commonSubstring := str1[:i]<br><br>            <span class="hljs-comment">// 检查是否满足条件</span><br>            <span class="hljs-keyword">if</span> checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123;<br>                <span class="hljs-keyword">return</span> commonSubstring<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 检查字符串是否能够整除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDivisible</span><span class="hljs-params">(s <span class="hljs-type">string</span>, sub <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    repeats := <span class="hljs-built_in">len</span>(s) / <span class="hljs-built_in">len</span>(sub)<br>    concatenated := repeatString(sub, repeats)<br>    <span class="hljs-keyword">return</span> s == concatenated<br>&#125;<br><br><span class="hljs-comment">// 重复字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    result := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>        result += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>辗转相除法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> str1 + str2 != str2 + str1 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    gcd := gcd(<span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2))<br>    <span class="hljs-keyword">return</span> str1[<span class="hljs-number">0</span>:gcd]<br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        a, b = b, a % b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/greatest-common-divisor-of-strings/&quot;&gt;1071. 字符串的最大公因子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20imag</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows新增wsl bash here键快捷方式</title>
    <link href="https://leiqichn.github.io/2024-01-01-38178c63ba17.html"/>
    <id>https://leiqichn.github.io/2024-01-01-38178c63ba17.html</id>
    <published>2024-01-01T10:23:10.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>win + R 输入regedit<br><img src="/../../imgs/Pasted%20image%2020240101182355.png"><br>输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p><h1 id="新建wsl-bash-here目录-设置如下默认值"><a href="#新建wsl-bash-here目录-设置如下默认值" class="headerlink" title="新建wsl_bash_here目录, 设置如下默认值"></a>新建wsl_bash_here目录, 设置如下默认值</h1><p><img src="/../../imgs/Pasted%20image%2020240101183252.png"></p><h1 id="新建command新建项，输入wsl-exe-的地址"><a href="#新建command新建项，输入wsl-exe-的地址" class="headerlink" title="新建command新建项，输入wsl.exe 的地址"></a>新建command新建项，输入wsl.exe 的地址</h1><p><img src="/../../imgs/Pasted%20image%2020240101183246.png"></p><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>可以看到右侧是有wsl bash here的选项的<br><img src="/../../imgs/Pasted%20image%2020240101183634.png"><br><strong>在当面目录打开wsl 成功</strong><br><img src="/../../imgs/Pasted%20image%2020240101183645.png"><br>原理和添加git bash here 类似, 参考:<br><a href="https://blog.csdn.net/Passerby_Wang/article/details/120881670">手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;win + R 输入regedit&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240101182355.png&quot;&gt;&lt;br&gt;输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git 设置免密配置-全局免密-单仓库免密-SSH免密</title>
    <link href="https://leiqichn.github.io/2024-01-01-91517aa963bc.html"/>
    <id>https://leiqichn.github.io/2024-01-01-91517aa963bc.html</id>
    <published>2024-01-01T06:56:28.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h1><p>我们要首先知道一个简单的概念:<br>https通过<strong>记住账号密码免登</strong>，ssh通过<strong>校验生成的密钥免登</strong>。 通常都用ssh校验。</p><p>查看通信方式</p><p>在项目目录中运行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote -v<br></code></pre></td></tr></table></figure><p>如果出现提示是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">origin  https://gitee.com/xxx/xxx.git (fetch)<br>origin  https://gitee.com/xxx/xxx.git (push)<br></code></pre></td></tr></table></figure><p>则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密<br>如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址<br><img src="/../../imgs/Pasted%20image%2020240101151457.png"></p><h1 id="一、https-方式及免密码配置"><a href="#一、https-方式及免密码配置" class="headerlink" title="一、https 方式及免密码配置"></a>一、https 方式及免密码配置</h1><h3 id="0-项目中-git-基本配置"><a href="#0-项目中-git-基本配置" class="headerlink" title="0. 项目中 git 基本配置"></a>0. 项目中 git 基本配置</h3><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text"># 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令<br>git init<br># 关联远程仓库<br>git remote add origin https://gitee.com/xxx/xxx.git<br>git add -A<br>git commit -m &quot;初始化&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。</p><p>这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。</p><h3 id="1-全局免密码配置"><a href="#1-全局免密码配置" class="headerlink" title="1.全局免密码配置"></a>1.全局免密码配置</h3><p>配置存储模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store</p><p>Linux 下查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.gitconfig<br></code></pre></td></tr></table></figure><p>windows10 下当前用户路径：<code>%USERPROFILE%</code><br>内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[user]<br>        name = lenovo<br>        email = xxxx@outlook.com<br>[credential]<br>        helper = store<br></code></pre></td></tr></table></figure><p>然后在项目目录，执行git pull&#x2F;git push命令，会提示输入<strong>账号密码</strong>。这次输入账号密码之后，就会<strong>记住</strong>账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。<br><img src="/../../imgs/Pasted%20image%2020240101145902.png"></p><h3 id="2、单项目免密码配置"><a href="#2、单项目免密码配置" class="headerlink" title="2、单项目免密码配置"></a>2、单项目免密码配置</h3><p>编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]<br>url = https://gitee.com/xxx/xxx.git<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]   <br>url = https://yourusername:password@gitee.com/xxx/xxxx.git<br></code></pre></td></tr></table></figure><p>也就是在 <code>https://</code> 之后，增加 <code>用户名:密码@</code></p><h1 id="二-SSH免密登录"><a href="#二-SSH免密登录" class="headerlink" title="二. SSH免密登录"></a>二. SSH免密登录</h1><p>如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式,</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote rm origin<br></code></pre></td></tr></table></figure><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>github 网页增加本机SSH key</p><p>git ssh 方式免密提交方式需要将 <code>ssh-keygen</code> 生成的公钥放到服务器上</p><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot; <br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置 ssh 远程项目地址。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 如果是新仓库需要git init ;否则不需要git init; git init<br># git 关联远程仓库<br>git remote add origin git@gitee.com:xxx/xxx.git<br></code></pre></td></tr></table></figure><h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><p>1、首先需要检查你电脑是否已经有 SSH key</p><p>运行 git Bash 客户端，检查本机的ssh密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">$ cd ~/.ssh <br>$ ls<br></code></pre></td></tr></table></figure><p>如果提示：No such file or directory ，说明是第一次使用 git。</p><p>如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ mkdir key_backup   <br>$ cp id_rsa* key_backup   <br>$ rm id_rsa*<br></code></pre></td></tr></table></figure><p>2、执行生成公钥和私钥的命令，生成新的密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;xxx&quot;<br></code></pre></td></tr></table></figure><p>代码参数：</p><p>-t 指定密钥类型，默认是 rsa ，可以省略。</p><p>-C 设置注释文字，比如邮箱。</p><p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p><p>按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p><p>执行查看公钥信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>Windows 系统，位置在用户目录下 .ssh文件夹中。<code>%USERPROFILE%</code></p><h2 id="复制公钥信息到远端仓库"><a href="#复制公钥信息到远端仓库" class="headerlink" title="复制公钥信息到远端仓库"></a>复制公钥信息到远端仓库</h2><p><strong>gitee</strong><br>打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p><p><img src="https://pic3.zhimg.com/80/v2-8c26fae5769cb56da5e20c884a33c702_720w.webp"></p><p><strong>github</strong><br>Settings -SSH and GPG keys - New SSH key<br><img src="app://db738d3bb1089e4d04f6eb022a68209f31bf/D:/obsidian_note/LeiQi_Blog/source/imgs/Pasted%20image%2020240101151324.png?1704093204312"><br>然后，提交时就不再需要用户名和密码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">git add -A<br>git commit -m &quot;ssh免密提交&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/358721423">https://zhuanlan.zhihu.com/p/358721423</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍之前&quot;&gt;&lt;a href=&quot;#介绍之前&quot; class=&quot;headerlink&quot; title=&quot;介绍之前&quot;&gt;&lt;/a&gt;介绍之前&lt;/h1&gt;&lt;p&gt;我们要首先知道一个简单的概念:&lt;br&gt;https通过&lt;strong&gt;记住账号密码免登&lt;/strong&gt;，ssh通过&lt;stro</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows设置Clion 下方Terminal为WSL linux 子系统</title>
    <link href="https://leiqichn.github.io/2023-12-30-397a0b919639.html"/>
    <id>https://leiqichn.github.io/2023-12-30-397a0b919639.html</id>
    <published>2023-12-30T15:49:39.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端上的小箭头下的设置"><a href="#终端上的小箭头下的设置" class="headerlink" title="终端上的小箭头下的设置"></a>终端上的小箭头下的设置</h1><p><img src="/../../imgs/Pasted%20image%2020231230235906.png"><br><img src="/../../imgs/Pasted%20image%2020231230234942.png"></p><h1 id="找到WSL的地址"><a href="#找到WSL的地址" class="headerlink" title="找到WSL的地址"></a>找到WSL的地址</h1><p><img src="/../../imgs/Pasted%20image%2020231231000039.png"></p><p>粘贴到对应地址中<br><img src="/../../imgs/Pasted%20image%2020231231000121.png"></p><h1 id="设置成功"><a href="#设置成功" class="headerlink" title="设置成功"></a>设置成功</h1><p>这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端上的小箭头下的设置&quot;&gt;&lt;a href=&quot;#终端上的小箭头下的设置&quot; class=&quot;headerlink&quot; title=&quot;终端上的小箭头下的设置&quot;&gt;&lt;/a&gt;终端上的小箭头下的设置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20ima</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>免费使用Jetbrain 全家桶-服务器激活码激活软件</title>
    <link href="https://leiqichn.github.io/2023-12-30-6a1e804ab992.html"/>
    <id>https://leiqichn.github.io/2023-12-30-6a1e804ab992.html</id>
    <published>2023-12-30T15:08:29.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.</p><p>Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。</p><ul><li><a href="https://search.censys.io/">https://search.censys.io/</a>     搜索：<code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></li><li><a href="https://www.shodan.io/">https://www.shodan.io</a>  搜索：<br><code>Location: https://account.jetbrains.com/fls-auth</code></li><li><a href="https://fofa.info/">https://fofa.info/</a>     搜索：<code>fls-auth</code></li></ul><p>随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是<a href="https://search.censys.io/">https://search.censys.io/</a> 网站, 搜索 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">services<span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.location</span>: account<span class="hljs-selector-class">.jetbrains</span>.com/fls-auth<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020231230231034.png"><br>例如上边就是 <a href="http://111.231.22.61:1024/">http://111.231.22.61:1024</a></p><p><img src="/../../imgs/Pasted%20image%2020231230231326.png"></p><h1 id="激活成功"><a href="#激活成功" class="headerlink" title="激活成功"></a>激活成功</h1><p>激活成功，请开始愉快的编码吧！<br><img src="/../../imgs/Pasted%20image%2020231230231349.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.&lt;/p&gt;
&lt;p&gt;Jetbrain 是针对公</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>WPS设置打开文件自动同步云文档</title>
    <link href="https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html"/>
    <id>https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html</id>
    <published>2023-12-30T14:08:47.000Z</published>
    <updated>2024-03-24T14:47:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。<br>WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：</p><h1 id="打开首页，设置中心"><a href="#打开首页，设置中心" class="headerlink" title="打开首页，设置中心"></a>打开首页，设置中心</h1><p><img src="/../../imgs/Pasted%20image%2020231230221037.png"></p><p><img src="/../../imgs/Pasted%20image%2020231230220856.png"></p><h1 id="打开新文件会自动上传更新"><a href="#打开新文件会自动上传更新" class="headerlink" title="打开新文件会自动上传更新"></a>打开新文件会自动上传更新</h1><p><img src="/../../imgs/Pasted%20image%2020231230221311.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。&lt;br&gt;WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：&lt;/p&gt;
&lt;h1 id=&quot;打开首页，设置中心&quot;&gt;&lt;a href=&quot;#打开首页，设置中心&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git强制拉取远端</title>
    <link href="https://leiqichn.github.io/2023-10-22-9bf76366f18c.html"/>
    <id>https://leiqichn.github.io/2023-10-22-9bf76366f18c.html</id>
    <published>2023-10-22T09:53:57.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/&lt;branch_name&gt;<br></code></pre></td></tr></table></figure><p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p><p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p><p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p><p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1726.同积元组</title>
    <link href="https://leiqichn.github.io/2023-10-20-9599b5db4d91.html"/>
    <id>https://leiqichn.github.io/2023-10-20-9599b5db4d91.html</id>
    <published>2023-10-20T15:21:57.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>使用排列组合的方法，开始使用三种语言同时写leetcode.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p><img src="/../../imgs/Pasted%20image%2020231020003943.png"></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<span class="hljs-comment">// j +1 不要重复</span><br>            cnt[nums[i] * nums[j]]++ <span class="hljs-comment">// 使用map 遍历每次乘积对应次数</span><br>        &#125;<br>    &#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cnt &#123;<br>        ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>    &#125;<br>   <br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                cnt[nums[i] * nums[j]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : cnt) &#123;<br>            ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python3">class Solution:<br>    def tupleSameProduct(self, nums: List[int]) -&gt; int:<br>        n = len(nums)<br>        maps = dict()<br>        <br>        for i in range(n):<br>            for j in range(i+1,n):<br>                if nums[i]*nums[j] in maps:<br>                    maps[nums[i] * nums[j]] += 1<br>                else:<br>                    maps[nums[i] * nums[j]] = 1<br><br>        ans = 0<br>        for _, v in maps.items():<br>            ans += v*(v-1) *4<br>        return ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/tuple-with-same-product/description/&quot;&gt;1726. 同积元组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="C++" scheme="https://leiqichn.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>本地运行LeetCode的Python代码 调试</title>
    <link href="https://leiqichn.github.io/2023-10-19-6057db0e071e.html"/>
    <id>https://leiqichn.github.io/2023-10-19-6057db0e071e.html</id>
    <published>2023-10-19T16:57:22.000Z</published>
    <updated>2024-03-24T14:47:15.366Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦</p><p>要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类：</p><p>创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。</p><p>导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br></code></pre></td></tr></table></figure><p>创建Solution类并在其中定义问题的解决方案。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 实现你的解决方案</span><br>        <span class="hljs-comment"># 例如，找到两个数的和等于目标，并返回它们的索引</span><br>        num_to_index = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> num_to_index:<br>                <span class="hljs-keyword">return</span> [num_to_index[complement], i]<br>            num_to_index[num] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>创建一个main函数来测试你的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    solution = Solution()<br>    <span class="hljs-comment"># 调用Solution类的方法进行测试</span><br>    result = solution.twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python leetcode_solution.py<br></code></pre></td></tr></table></figure><p>这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦&lt;/p&gt;
&lt;p&gt;要在本地运行LeetCode的Python代</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
</feed>
