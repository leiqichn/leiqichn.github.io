<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="http://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="http://leiqichn.github.io/"/>
  <updated>2023-04-08T05:46:04.414Z</updated>
  <id>http://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>波纹</title>
    <link href="http://leiqichn.github.io/2023-04-08-343cd8744ef0.html"/>
    <id>http://leiqichn.github.io/2023-04-08-343cd8744ef0.html</id>
    <published>2023-04-08T13:41:33.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/IMG_1502-01-01.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/IMG_1502-01-01.jpeg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="记录" scheme="http://leiqichn.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="摄影" scheme="http://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 513.找树左下角的值</title>
    <link href="http://leiqichn.github.io/2023-04-03-d2d9a7e62e40.html"/>
    <id>http://leiqichn.github.io/2023-04-03-d2d9a7e62e40.html</id>
    <published>2023-04-03T22:44:37.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（Leetcode）</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg"></p><p><strong>输入:</strong> root &#x3D; [2,1,3]<br><strong>输出:</strong> 1</p><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg"></p><p><strong>输入:</strong> [1,2,3,4,null,5,6,null,null,7]<br><strong>输出:</strong> 7</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本题可以转化为什么呢？</p><blockquote><p>1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值<br>2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> depth <span class="type">int</span>   <span class="comment">// 全局变量 最大深度</span></span><br><span class="line"><span class="keyword">var</span> res <span class="type">int</span>     <span class="comment">// 记录最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    depth, res = <span class="number">0</span>, <span class="number">0</span>   </span><br><span class="line">    dfs(root, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode, d <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里判断nil ,后边左右节点就不用判断了</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; depth &lt; d &#123; </span><br><span class="line">        depth = d</span><br><span class="line">        res = root.Val</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.Left, d+<span class="number">1</span>)   </span><br><span class="line">    dfs(root.Right, d+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">-1</span></span><br><span class="line">queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line"><span class="comment">//res 在哪里更新呢？</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">size := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="comment">// 遍历每一层</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">top := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 获取每一层的最左边的位置，更新res</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">res = top.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, top.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, top.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代2 每层用一个切片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">-1</span></span><br><span class="line">queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过另外一个切片来添加的解法也要尝试学习一下</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line"><span class="comment">//res 在哪里更新呢？</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">size := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="comment">// 使用nextqueue 保存每一层，然后追加到queue</span></span><br><span class="line">nextqueue := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">top := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">    res = nextqueue[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">nextqueue = <span class="built_in">append</span>(nextqueue, top.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">nextqueue = <span class="built_in">append</span>(nextqueue, top.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="built_in">append</span>(queue,nextqueue...)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>如果要求最右边的值呢？这里该怎么求呢？</p><p>只需要将 遍历左右的顺序颠倒一下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">-1</span></span><br><span class="line">queue := []*TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line"><span class="comment">//res 在哪里更新呢？</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">size := <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="comment">// 遍历每一层</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">top := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 获取每一层的最左边的位置，更新res</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">res = top.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, top.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, top.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-bottom-left-tree-value/&quot;&gt;513. 找树左下角的值 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的 &lt;strong&gt;根节点&lt;/strong&gt; </summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>递归debug 方法</title>
    <link href="http://leiqichn.github.io/2023-03-30-b84514acbbb2.html"/>
    <id>http://leiqichn.github.io/2023-03-30-b84514acbbb2.html</id>
    <published>2023-03-30T00:38:35.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<p>使用tab<br>参考<br><a href="https://zhuanlan.zhihu.com/p/369464796">递归函数的Debug技巧 - 知乎 (zhihu.com)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247490945&idx=1&sn=03da23d366ad4577d2a22328f3ba04f9">分享一个小技巧，提高刷题幸福感 (qq.com)</a><br><img src="/../../imgs/a96e8e7a2780c45a863303b03c2a068.jpg"></p><p><img src="/../../imgs/3f0c31123f22ff3aa51312dc4d9a726.jpg"></p><p><img src="/../../imgs/b4ef89bfab7f211d72486980e53d7b0.jpg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printIndent</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;n; i++ &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;|    &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 递归的输入和返回值是对的了</span></span><br><span class="line"></span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">    count++</span><br><span class="line">    printIndent(count)</span><br><span class="line">    fmt.Println(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        count--</span><br><span class="line">        printIndent(count)</span><br><span class="line">        fmt.Println(<span class="string">&quot;return:&quot;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">    leftNodeVal := <span class="number">0</span> </span><br><span class="line">    rightNodeVal := <span class="number">0</span></span><br><span class="line">leftNode := root.Left</span><br><span class="line">    rightNode := root.Right</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; leftNode.Left == <span class="literal">nil</span> &amp;&amp; leftNode.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">leftNodeVal = leftNode.Val</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> rightNode !=<span class="literal">nil</span> &amp;&amp; rightNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        rightNodeVal = sumOfLeftLeaves(rightNode.Left)</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">// 单次循环</span></span><br><span class="line">    res  = leftNodeVal +  rightNodeVal</span><br><span class="line">    count--</span><br><span class="line">    printIndent(count)</span><br><span class="line">    fmt.Println(<span class="string">&quot;return:&quot;</span>,res)</span><br><span class="line"><span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加以下部分是可以缩进 递归debug 的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printIndent</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;n; i++ &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;|    &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用tab&lt;br&gt;参考&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/369464796&quot;&gt;递归函数的Debug技巧 - 知乎 (zhihu.com)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 404.左叶子之和</title>
    <link href="http://leiqichn.github.io/2023-03-29-318ae3533bef.html"/>
    <id>http://leiqichn.github.io/2023-03-29-318ae3533bef.html</id>
    <published>2023-03-29T22:44:37.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">    leftNode := root.Left</span><br><span class="line">leftNodeVal := sumOfLeftLeaves(root.Left) <span class="comment">// 左</span></span><br><span class="line">    rightNodeVal := sumOfLeftLeaves(root.Right)<span class="comment">// 右</span></span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; leftNode.Left == <span class="literal">nil</span> &amp;&amp; leftNode.Right == <span class="literal">nil</span> &#123; <span class="comment">// 中</span></span><br><span class="line">leftNodeVal = leftNode.Val</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单次循环</span></span><br><span class="line">    res = leftNodeVal + rightNodeVal <span class="comment">// 中，左边+右边</span></span><br><span class="line"><span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>C盘文件太多？回收站太满？</title>
    <link href="http://leiqichn.github.io/2023-03-29-43e3d0171032.html"/>
    <id>http://leiqichn.github.io/2023-03-29-43e3d0171032.html</id>
    <published>2023-03-29T09:21:36.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>标签: #清理电脑内存 </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>windows 常常会有一个问题，用的时间久了，就是C 盘莫名奇妙的满了！下边是我的电脑截图。。。看看这可怕的红色 哈哈哈，只有350兆了。<br><img src="/../../imgs/Pasted%20image%2020230329212555.png"></p><h1 id="C盘都有哪些占内存的？"><a href="#C盘都有哪些占内存的？" class="headerlink" title="C盘都有哪些占内存的？"></a>C盘都有哪些占内存的？</h1><h3 id="右键C-盘-属性-磁盘清理"><a href="#右键C-盘-属性-磁盘清理" class="headerlink" title="右键C 盘- 属性-磁盘清理"></a>右键C 盘- 属性-磁盘清理</h3><p><img src="/../../imgs/Pasted%20image%2020230329212806.png"></p><p>可以看到最大可以清理的文件是回收站，占了整整5.62GB! 当然还有其它一些缩略图 和临时文件，我们可以暂时不勾选回收站，先把临时文件和缩略图给清理掉，勾选好点击确定即可清理。<br><img src="/../../imgs/Pasted%20image%2020230329212854.png"><br><img src="/../../imgs/Pasted%20image%2020230329213429.png"></p><h2 id="清理系统文件"><a href="#清理系统文件" class="headerlink" title="清理系统文件"></a>清理系统文件</h2><p>  Windows 会经常系统升级，为了安全起见，他们在升级的时候为了方式升级失败，会备份之前的系统文件。这回占用很大的空间。可以通过前面的磁盘清理来清理系统文件。<br>  <img src="/../../imgs/Pasted%20image%2020230329213806.png"></p><h2 id="转移回收站"><a href="#转移回收站" class="headerlink" title="转移回收站"></a>转移回收站</h2><p><strong>接下来开始我们的重头戏，回收站</strong>，我们看到了回收站很占内存，但是这是我们最后的救命稻草，也是最后反悔的良药，一般还是不要清除的好。所以我们可以换一个思路— 转移他。因为我们其他盘的资源还是很充足的，只要把回收站转移到其他盘即可。</p><ol><li>右键桌面的回收站图标，选择“属性”。<br><img src="/../../imgs/Pasted%20image%2020230329214012.png"></li></ol><p>修改为对应的磁盘，大小设置和之前一样<br><img src="/../../imgs/Pasted%20image%2020230329214848.png"></p><p>当然，你甚至和linux 一样，不设置回收站。移除文件后是真的删除了。不推荐这样做哈<img src="/../../imgs/Pasted%20image%2020230329215012.png"></p><p>确认好，点击应用，即可。后边删除的文件都会存在指定的磁盘啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>利用好磁盘清理工具，清理临时文件和系统大文件</li><li>将回收站设置保存到其他磁盘</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;标签: #清理电脑内存 &lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;windows 常常会有一个问题，用的时间久了，就是C 盘莫名奇妙的满了！下边是我的电脑截图。。。看</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="清理电脑内存" scheme="http://leiqichn.github.io/tags/%E6%B8%85%E7%90%86%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 257.二叉树的所有路径</title>
    <link href="http://leiqichn.github.io/2023-03-28-3849178edc04.html"/>
    <id>http://leiqichn.github.io/2023-03-28-3849178edc04.html</id>
    <published>2023-03-28T23:47:29.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    path = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">backTracking(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backTracking</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line"><span class="comment">// 终点 左右子节点都为nil</span></span><br><span class="line"><span class="keyword">if</span> isLeafNode(root) &#123;</span><br><span class="line">        NodeValStr := strconv.Itoa(root.Val)</span><br><span class="line">    path = <span class="built_in">append</span>(path, NodeValStr)</span><br><span class="line">pathStr := strings.Join(path, <span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">res = <span class="built_in">append</span>(res, pathStr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前序遍历 中左右</span></span><br><span class="line"><span class="comment">// 遍历 每次递归的操作</span></span><br><span class="line">NodeVal:= strconv.Itoa(root.Val)<span class="comment">// 中</span></span><br><span class="line">path = <span class="built_in">append</span>(path, NodeVal)</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123; <span class="comment">// 左</span></span><br><span class="line">backTracking(root.Left)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123; <span class="comment">// 右</span></span><br><span class="line">backTracking(root.Right)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLeafNode</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line"><span class="keyword">if</span> node.Right==<span class="literal">nil</span> &amp;&amp; node.Left== <span class="literal">nil</span> &amp;&amp; node!= <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 110.平衡二叉树</title>
    <link href="http://leiqichn.github.io/2023-03-28-40f110530226.html"/>
    <id>http://leiqichn.github.io/2023-03-28-40f110530226.html</id>
    <published>2023-03-28T11:18:47.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（Leetcode）</a></p><p><font color="#2DC26B">简单 </font><br>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p><p><strong>输入：</strong>root &#x3D; [3,9,20,null,null,15,7]<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p><p><strong>输入：</strong>root &#x3D; [1,2,2,3,3,null,null,4,4]<br><strong>输出：</strong>false</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root &#x3D; []<br><strong>输出：</strong>true</p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里是求<strong>高度</strong>： 节点到叶子节点的最长距离，使用<strong>后序遍历</strong><br><strong>深度</strong>是root 到该节点的最长距离（距离☞节点数），使用<strong>前序遍历</strong></p><p>因此只要分别计算左右子树的高度，并且做差不大于1就行</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用-1 记录 res 不是平衡二叉树<br>每次执行，都需要判断是不是等于-1，直接返回-1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/balanced-binary-tree/&quot;&gt;110. 平衡二叉树 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#2DC26B&quot;&gt;简单 &lt;/font&gt;&lt;br&gt;给定一</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 222.完全二叉树的节点个数</title>
    <link href="http://leiqichn.github.io/2023-03-28-b21cc0774662.html"/>
    <id>http://leiqichn.github.io/2023-03-28-b21cc0774662.html</id>
    <published>2023-03-28T10:10:45.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（Leetcode）</a></p><p>给出一个完全二叉树，求出该树的节点个数。<br><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p>示例 1：<br><img src="/../../imgs/Pasted%20image%2020230328221334.png"></p><ul><li>输入：root &#x3D; [1,2,3,4,5,6]</li><li>输出：6</li></ul><p>示例 2：</p><ul><li>输入：root &#x3D; []</li><li>输出：0</li></ul><p>示例 3：</p><ul><li>输入：root &#x3D; [1]</li><li>输出：1</li></ul><p>提示：</p><ul><li>树中节点的数目范围是[0, 5 * 10^4]</li><li>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4</li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>使用普通二叉树的思想来求，使用层序遍历 或者递归<br>  增加一个变量来存<strong>node</strong> 的个数</li><li>利用<strong>完全二叉树</strong>的性质，他只有最后一层没有填满，并且是从左到右依次填满的。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>思路1：普通二叉树</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">1</span> <span class="comment">//记录res, 递归算root=1</span></span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        count += countNodes(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        count += countNodes(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := list.New()</span><br><span class="line">    q.PushBack(root)</span><br><span class="line">    res := <span class="number">0</span> <span class="comment">// 记录res, 这里root 加入到了队列，所以res=0 而不是1</span></span><br><span class="line">    <span class="keyword">for</span> q.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := q.Len()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            node := q.Remove(q.Front()).(*TreeNode)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.PushBack(node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                q.PushBack(node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路2：完全二叉树</strong></p><ol><li>确定递归函数的参数和返回值 ： 输入根节点，返回int 节点数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br></pre></td></tr></table></figure></li><li>递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</li><li>单层递归逻辑：<br> 需要先求左子右树的节点数量（我们转化为满二叉树，使用公式计算）然后加上root<br> 结果等于 leftTreeNum + rightTreeNum + 1  （leftTreeNum为左子满二叉树，rightTreeNum为右子满二叉树，1是root）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    leftH, rightH := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    leftNode := root.Left</span><br><span class="line">    rightNode := root.Right</span><br><span class="line">    <span class="keyword">for</span> leftNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        leftNode = leftNode.Left</span><br><span class="line">        leftH++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        rightNode = rightNode.Right</span><br><span class="line">        rightH++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node</span></span><br><span class="line">    <span class="keyword">if</span> leftH == rightH &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftH) - <span class="number">1</span>  <span class="comment">// 2左移 即为平方</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftTreeNum := countNodes(root.Left) <span class="comment">// 左</span></span><br><span class="line">    rightTreeNum := countNodes(root.Right) <span class="comment">// 右</span></span><br><span class="line">    res := leftTreeNum + rightTreeNum + <span class="number">1</span> <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/count-complete-tree-nodes/&quot;&gt;222. 完全二叉树的节点个数 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出一个完全二叉树，求出该树的节点个数。&lt;br&gt;&lt;a hr</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
    <category term="二叉树" scheme="http://leiqichn.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>快来压缩你的博客图片</title>
    <link href="http://leiqichn.github.io/2023-03-24-92a37bba7a46.html"/>
    <id>http://leiqichn.github.io/2023-03-24-92a37bba7a46.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没多大变化 哈哈哈<br><img src="/../../imgs/Pasted%20image%2020230324011438.png"><br>再试试 更大更高清的图片<br><img src="/../../imgs/code-wallpaper-6.png"></p><p><img src="/../../imgs/Pasted%20image%2020230325200454.png"><br>实测,效果不太行….<br>但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下<br>待更新…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然没多大变化 哈哈哈&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230324011438.png&quot;&gt;&lt;br&gt;再试试 更大更高清的图片&lt;br&gt;&lt;img src=&quot;/../../imgs/code-wallpaper-6.png&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给你的博客 安装上PWA吧</title>
    <link href="http://leiqichn.github.io/2023-03-24-554b8cbb674b.html"/>
    <id>http://leiqichn.github.io/2023-03-24-554b8cbb674b.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<p>TODO:</p><ul><li>什么是PWA，可以提示添加到主屏幕<br>渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站</li><li>安装 hexo-pwa</li><li>由于hexo-pwa停止维护，需要解决报错</li><li>设置全局_config.yml 文件(非主题)</li></ul><p><img src="/../../imgs/Pasted%20image%2020230324004739.png"></p><p><img src="/../../imgs/ad6c5ebfc9a6401cde512120b6ed719.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是PWA，可以提示添加到主屏幕&lt;br&gt;渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站&lt;/li&gt;
&lt;li&gt;安装 hexo-pwa&lt;/li&gt;
&lt;li&gt;由于hexo-pwa停止维护，需要解决报错&lt;/li&gt;
&lt;li&gt;设置全局_con</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 命令 将前台任务挂到后台运行</title>
    <link href="http://leiqichn.github.io/2023-03-19-aaf910b916ec.html"/>
    <id>http://leiqichn.github.io/2023-03-19-aaf910b916ec.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用<code>bg</code>  挂后台的命令。</p><p><strong>第一步：ctrl + z</strong></p><p><strong>第二步：jobs  查看任务id</strong></p><p><strong>第三步： bg %任务id</strong></p><p><img src="/../../imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用&lt;code</summary>
      
    
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/categories/Linux/"/>
    
    
    <category term="linux命令" scheme="http://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>博客设置 obsidian 上传图片</title>
    <link href="http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html"/>
    <id>http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的<strong>相对路径</strong>就可以读取并显示图片。</p><p>而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="1-打开obsidian-文件与链接"><a href="#1-打开obsidian-文件与链接" class="headerlink" title="1. 打开obsidian - 文件与链接"></a>1. 打开obsidian - 文件与链接</h2><h2 id="2-按照下图配置"><a href="#2-按照下图配置" class="headerlink" title="2. 按照下图配置"></a>2. 按照下图配置</h2><p>   *　将内部链接类型 设置为 “基于当前笔记的<strong>相对路径</strong>”<br>     &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用<strong>相对路径</strong></p><ul><li>取消wiki 链接 </li><li>指定图片的默认路径为 <code>source/imgs</code><br>&gt; 如果没有该文件夹，则需要先新建一下。</li></ul><p><img src="/../../imgs/Pasted%20image%2020230319131458.png"></p><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>网页可以成功显示图片</p><p><img src="/../../imgs/Pasted%20image%2020230319134051.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>排版测试</title>
    <link href="http://leiqichn.github.io/2023-03-18-16129b89df14.html"/>
    <id>http://leiqichn.github.io/2023-03-18-16129b89df14.html</id>
    <published>2023-03-18T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<p>网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。</p><h1 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><h4 id="hello-world-1"><a href="#hello-world-1" class="headerlink" title="hello world"></a>hello world</h4><p><img src="/../../imgs/Pasted%20image%2020230408134405.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。&lt;/p&gt;
&lt;h1 id=&quot;HELLO-WORLD&quot;&gt;&lt;a href=&quot;#HELLO-WORLD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORLD&quot;&gt;&lt;/a&gt;HELLO </summary>
      
    
    
    
    <category term="Test" scheme="http://leiqichn.github.io/categories/Test/"/>
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>复旦大学 生命科学学院 生物医药复试 准备</title>
    <link href="http://leiqichn.github.io/2023-03-15-51aa6fac22ab.html"/>
    <id>http://leiqichn.github.io/2023-03-15-51aa6fac22ab.html</id>
    <published>2023-03-15T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到我的个人网站-欢迎收藏"><a href="#欢迎来到我的个人网站-欢迎收藏" class="headerlink" title="欢迎来到我的个人网站~ 欢迎收藏~"></a>欢迎来到我的个人网站~ 欢迎收藏~</h1><p><strong>复试，首先要确定时间</strong>，一般会邮件和短信同时通知，这个邮箱地址是你在研究生招生网上填的邮箱地址。如果是qq邮箱有可能会在垃圾邮箱里边，注意查收哈。<br>还有一种方法就是关注<a href="https://life.fudan.edu.cn/28139/list.htm">生科院的官网</a>。<br>​<br>复试流程</p><p><strong>1.首先是分组</strong></p><p>   按照往年的情况，一般会分为两组，两组同时开始面试。该分组是老师分的，非自主抽签。</p><p><strong>2.面试时间</strong><br>   一个人一般是在20分钟左右，前面几个人肯定会问的细一点，后边如果时间比较紧张，老师就会问的快一点。</p><p><strong>3.是大家比较关心的面试内容</strong><br>  分为两个部分：<br><strong>一、英语口语</strong>，可能是英文自我介绍，没有问答。也可能是进入到一个屋子里，一个老师问你一些简单的英语问题，比如去过哪里旅游，有什么爱好等等。可能会稍微问些专业方面的，比如之前做过哪些方向等。常见的专业词汇可以掌握一下，比如细菌（bacteria）等，都比较简单。而且英语是不算分的，只会给老师提供参考。（关注公众号”<strong>上岸FDU</strong>“**，回复“复试口语”会发口语资料哟）</p><p> 第二部分是<strong>专业面试</strong>，主要会先让你自我介绍，会问你之前的科研经历，可以说说毕设，但是务必把自己说的了解清楚，老师都很专业会问的很细。可以准备简历，但是简历上的东西都要十分清楚（准备10份是肯定够了，一般会有7-8个老师）<br>  还会问喜欢什么方向，如果录取了未来三年的规划等。总体比较轻松，要保证好心情，不要紧张就好。</p><p><strong>4.考完1-2天后，会电话&#x2F;邮件&#x2F;短信通知考试，通过复试，接下来就是等官方录取通知书就好啦！</strong></p><p>总体来说复试通过比例很大，我记得当时50多人只刷了一两个人，所以大家放平心态，多多准备就好啦！</p><p>祝大家复试成功～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;欢迎来到我的个人网站-欢迎收藏&quot;&gt;&lt;a href=&quot;#欢迎来到我的个人网站-欢迎收藏&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的个人网站~ 欢迎收藏~&quot;&gt;&lt;/a&gt;欢迎来到我的个人网站~ 欢迎收藏~&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;复试，首先要</summary>
      
    
    
    
    <category term="记录" scheme="http://leiqichn.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题常用数据结构（Go 篇）</title>
    <link href="http://leiqichn.github.io/2023-03-14-c45a3958f9a8.html"/>
    <id>http://leiqichn.github.io/2023-03-14-c45a3958f9a8.html</id>
    <published>2023-03-14T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作需要，最近使用Go 来刷算法题</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个大小为10，默认值为0的数组</span></span><br><span class="line">nums := <span class="built_in">make</span>([<span class="number">10</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个二位boolean数组</span></span><br><span class="line">visited := <span class="built_in">make</span>([<span class="number">5</span>][<span class="number">10</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="comment">// 访问num[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多行字符串</span></span><br><span class="line">s2 := <span class="string">`This is a</span></span><br><span class="line"><span class="string">multiline</span></span><br><span class="line"><span class="string">string.`</span></span><br></pre></td></tr></table></figure><h4 id="访问字符串"><a href="#访问字符串" class="headerlink" title="访问字符串"></a>访问字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可直接用索引访问字节（非字符）</span></span><br><span class="line">s1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">first := s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">s2 := []<span class="type">byte</span>(s1)</span><br><span class="line">first := s2[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串的值是不可变的，可以分配一个新字符串值</span></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">t := s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转为[]byte或[]rune可以进行修改</span></span><br><span class="line">s1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s2 := []<span class="type">byte</span>(s1)</span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">s3 := <span class="type">string</span>(s2)</span><br></pre></td></tr></table></figure><h4 id="查询字符是否属于特定字符集"><a href="#查询字符是否属于特定字符集" class="headerlink" title="查询字符是否属于特定字符集"></a>查询字符是否属于特定字符集</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串s的i索引位置字符是否是元音</span></span><br><span class="line"><span class="keyword">if</span> strings.Contains(<span class="string">&quot;aeiouAEIOU&quot;</span>, <span class="type">string</span>(s[i])) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断字符串大小"><a href="#判断字符串大小" class="headerlink" title="判断字符串大小"></a>判断字符串大小</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">    <span class="comment">// 相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Compare 函数可以用于比较，1大于，0相等，-1小于</span></span><br><span class="line"><span class="comment">// EqualFold 函数忽略大小写后比较</span></span><br></pre></td></tr></table></figure><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持直接用+进行连接，但是效率不高</span></span><br><span class="line">s1 := <span class="string">&quot;hello &quot;</span></span><br><span class="line">s2 := s1 + <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="高效拼接字符串"><a href="#高效拼接字符串" class="headerlink" title="高效拼接字符串"></a>高效拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bytes.Buffer可以一次性连接</span></span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">b.WriteString(<span class="string">&quot;Hello &quot;</span>)</span><br><span class="line">b.WriteString(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">b1 := b.String()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个字符串拼接</span></span><br><span class="line"><span class="keyword">var</span> strs []<span class="type">string</span></span><br><span class="line">strings.Join(strs, <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="整型-或任意数据类型-转为字符串"><a href="#整型-或任意数据类型-转为字符串" class="headerlink" title="整型 (或任意数据类型) 转为字符串"></a>整型 (或任意数据类型) 转为字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Itoa转换</span></span><br><span class="line">i := <span class="number">123</span></span><br><span class="line">t := strconv.Itoa(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sprintf转换</span></span><br><span class="line">i := <span class="number">123</span></span><br><span class="line">t := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br></pre></td></tr></table></figure><h3 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h3><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个存储String类型的切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">slice := []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个存储int类型的切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">slice := []<span class="type">int</span></span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(slice) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素个数</span></span><br><span class="line"><span class="built_in">len</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问索引元素</span></span><br><span class="line">slice[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在尾部添加元素</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="通过切片模拟栈和队列"><a href="#通过切片模拟栈和队列" class="headerlink" title="通过切片模拟栈和队列"></a>通过切片模拟栈和队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建栈</span></span><br><span class="line">stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// push压入</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// pop弹出</span></span><br><span class="line">v := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 检查栈空</span></span><br><span class="line"><span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">queue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// enqueue入队</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// dequeue出队</span></span><br><span class="line">v := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 长度0为空</span></span><br><span class="line"><span class="built_in">len</span>(queue) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 设置kv</span></span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 删除k</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m&#123;</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map键需要可比较，不能为slice、map、function</span></span><br><span class="line"><span class="comment">// map值都有默认值，可以直接操作默认值，如：m[age]++ 值由0变为1</span></span><br><span class="line"><span class="comment">// 比较两个map需要遍历，其中的kv是否相同，因为有默认值关系，所以需要检查val和ok两个值</span></span><br></pre></td></tr></table></figure><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int排序</span></span><br><span class="line">sort.Ints([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 字符串排序</span></span><br><span class="line">sort.Strings([]<span class="type">string</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="MATH"><a href="#MATH" class="headerlink" title="MATH"></a>MATH</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int32 最大最小值</span></span><br><span class="line">math.MaxInt32</span><br><span class="line">math.MinInt32</span><br><span class="line"><span class="comment">// int64 最大最小值（int默认是int64）</span></span><br><span class="line">math.MaxInt64</span><br><span class="line">math.MinInt64</span><br></pre></td></tr></table></figure><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除a[i]，可以用 copy 将i+1到末尾的值覆盖到i,然后末尾-1</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建长度，则通过索引赋值</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">a[n] = x</span><br><span class="line"></span><br><span class="line"><span class="comment">// make长度为0，则通过append()赋值</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">a = <span class="built_in">append</span>(a, x)</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte转数字 </span></span><br><span class="line"><span class="comment">// byte 和rune 都会转化为阿斯克吗，不同的是rune 遇到汉字是一个字符，byte 是三个</span></span><br><span class="line"><span class="comment">// byte 和int 转换需要 + &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">// int 转byte 需要  int(s[0] - &#x27;0&#x27;) </span></span><br><span class="line"><span class="comment">// 单个byte 或 rune 可以前面直接加string 进行转换。[]byte&#123;&#125; []rune&#123;&#125; 也可以使用string 转换。</span></span><br><span class="line">s = <span class="string">&quot;12345&quot;</span>  <span class="comment">// s[0] 类型是byte</span></span><br><span class="line">num := <span class="type">int</span>(s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line">str := <span class="type">string</span>(s[<span class="number">0</span>]) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">b := <span class="type">byte</span>(num + <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d%s%c\n&quot;</span>, num, str, b) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line">num, _ := strconv.Atoi()</span><br><span class="line">str := strconv.Itoa()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是“术”的内容，算法之“道” 需要经过大量练习和思考才能习得，加油</p><p>参考：<br><a href="https://www.pseudoyu.com/zh/2021/05/29/algorithm_data_structure_go/">LeetCode 刷题常用数据结构（Go 篇） · Pseudoyu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作需要，最近使用Go 来刷算法题&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://leiqichn.github.io/2023-03-14-2c94ed65547e.html"/>
    <id>http://leiqichn.github.io/2023-03-14-2c94ed65547e.html</id>
    <published>2023-03-14T00:00:00.000Z</published>
    <updated>2023-04-08T05:46:04.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h1><p><a href="https://leiqichn.github.io/">国外链接</a><br><a href="https://leiqicn.gitee.io/">国内链接</a><br>大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客链接&quot;&gt;&lt;a href=&quot;#博客链接&quot; class=&quot;headerlink&quot; title=&quot;博客链接&quot;&gt;&lt;/a&gt;博客链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leiqichn.github.io/&quot;&gt;国外链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="关于我" scheme="http://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
    
    <category term="about" scheme="http://leiqichn.github.io/tags/about/"/>
    
  </entry>
  
</feed>
