<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2023-10-22T09:56:49.109Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leiqichn.github.io/2023-10-22-ba57598dc4b8.html"/>
    <id>https://leiqichn.github.io/2023-10-22-ba57598dc4b8.html</id>
    <published>2023-10-22T09:56:49.109Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>使用排列组合的方法，开始使用三种语言同时写leetcode.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p><img src="/../../imgs/Pasted%20image%2020231020003943.png"></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<span class="hljs-comment">// j +1 不要重复</span><br>            cnt[nums[i] * nums[j]]++ <span class="hljs-comment">// 使用map 遍历每次乘积对应次数</span><br>        &#125;<br>    &#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cnt &#123;<br>        ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>    &#125;<br>   <br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                cnt[nums[i] * nums[j]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : cnt) &#123;<br>            ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python3">class Solution:<br>    def tupleSameProduct(self, nums: List[int]) -&gt; int:<br>        n = len(nums)<br>        maps = dict()<br>        <br>        for i in range(n):<br>            for j in range(i+1,n):<br>                if nums[i]*nums[j] in maps:<br>                    maps[nums[i] * nums[j]] += 1<br>                else:<br>                    maps[nums[i] * nums[j]] = 1<br><br>        ans = 0<br>        for _, v in maps.items():<br>            ans += v*(v-1) *4<br>        return ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/tuple-with-same-product/description/&quot;&gt;1726. 同积元组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="l" scheme="https://leiqichn.github.io/categories/l/"/>
    
    
  </entry>
  
  <entry>
    <title>git强制拉取远端</title>
    <link href="https://leiqichn.github.io/2023-10-22-9bf76366f18c.html"/>
    <id>https://leiqichn.github.io/2023-10-22-9bf76366f18c.html</id>
    <published>2023-10-22T09:53:57.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/&lt;branch_name&gt;<br></code></pre></td></tr></table></figure><p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p><p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p><p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p><p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td</summary>
      
    
    
    
    <category term="C++" scheme="https://leiqichn.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>本地运行LeetCode的Python代码 调试</title>
    <link href="https://leiqichn.github.io/2023-10-19-6057db0e071e.html"/>
    <id>https://leiqichn.github.io/2023-10-19-6057db0e071e.html</id>
    <published>2023-10-19T16:57:22.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦</p><p>要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类：</p><p>创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。</p><p>导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br></code></pre></td></tr></table></figure><p>创建Solution类并在其中定义问题的解决方案。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 实现你的解决方案</span><br>        <span class="hljs-comment"># 例如，找到两个数的和等于目标，并返回它们的索引</span><br>        num_to_index = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> num_to_index:<br>                <span class="hljs-keyword">return</span> [num_to_index[complement], i]<br>            num_to_index[num] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>创建一个main函数来测试你的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    solution = Solution()<br>    <span class="hljs-comment"># 调用Solution类的方法进行测试</span><br>    result = solution.twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python leetcode_solution.py<br></code></pre></td></tr></table></figure><p>这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦&lt;/p&gt;
&lt;p&gt;要在本地运行LeetCode的Python代</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>三种Python3 判断字典中是否存在对应key的方法</title>
    <link href="https://leiqichn.github.io/2023-10-19-8f51ae9ef5a1.html"/>
    <id>https://leiqichn.github.io/2023-10-19-8f51ae9ef5a1.html</id>
    <published>2023-10-19T16:41:07.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一种：使用get-方法"><a href="#第一种：使用get-方法" class="headerlink" title="第一种：使用get()方法"></a>第一种：使用get()方法</h1><p> <strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p> <strong>打印返回值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>))  # 结果返回对应val<br><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;id&#x27;</span>))  # 结果返回None<br></code></pre></td></tr></table></figure><p>第二种：使用keys()方法</p><p> <strong>生成一个字典</strong><br>dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’}<br> <strong>判断是否存在，其中dict.keys()是列出字典所有的key</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><p>除了使用in也可以使用not in，用于判定这个key不存在</p><p>第三种：使用 in 关键字</p><p><strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong># 判断key是否存在于dict中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><h1 id="补充：生成默认字典（collections-defaultdict）"><a href="#补充：生成默认字典（collections-defaultdict）" class="headerlink" title="补充：生成默认字典（collections.defaultdict）"></a>补充：生成默认字典（<code>collections.defaultdict</code>）</h1><p>使用<code>defaultdict(int)</code>来创建<code>maps</code>，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        maps = defaultdict(<span class="hljs-built_in">int</span>)<br>        <br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>                product = nums[i] * nums[j]<br>                ans += maps[product] * <span class="hljs-number">4</span><br>                maps[product] += <span class="hljs-number">1</span><br>                <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一种：使用get-方法&quot;&gt;&lt;a href=&quot;#第一种：使用get-方法&quot; class=&quot;headerlink&quot; title=&quot;第一种：使用get()方法&quot;&gt;&lt;/a&gt;第一种：使用get()方法&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;生成一个字典&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构和操作的对比：Python vs. Go vs. C++</title>
    <link href="https://leiqichn.github.io/2023-10-19-86483682723b.html"/>
    <id>https://leiqichn.github.io/2023-10-19-86483682723b.html</id>
    <published>2023-10-19T16:25:56.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python示例"><a href="#Python示例" class="headerlink" title="Python示例"></a>Python示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 切片</span><br>sub_list = my_list[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversed_list = my_list[::-1python]<br><br><span class="hljs-comment"># 字典</span><br>my_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;<br><br><span class="hljs-comment"># 双向链表（使用collections.deque）</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>my_linked_list = deque()<br>my_linked_list.append(<span class="hljs-number">1</span>)<br>my_linked_list.append(<span class="hljs-number">2</span>)<br>my_linked_list.append(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 最大堆和最小堆（需要使用第三方库heapq）</span><br><span class="hljs-keyword">import</span> heapq<br>max_heap = []<br>min_heap = []<br><br><span class="hljs-comment"># 二叉树（使用类或结构体）</span><br><br><span class="hljs-comment"># 字符串操作</span><br>my_string = <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring = my_string[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>my_int = <span class="hljs-number">42</span><br>my_str = <span class="hljs-built_in">str</span>(my_int)<br><br><span class="hljs-comment"># 深度拷贝和浅拷贝（使用copy模块）</span><br><span class="hljs-keyword">import</span> copy<br>original_list = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>]<br>shallow_copy = copy.copy(original_list)<br>deep_copy = copy.deepcopy(original_list)<br><br><span class="hljs-comment"># 删除元素</span><br>my_list.pop(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 删除第二个元素</span><br><br><span class="hljs-comment"># 查找小写字母</span><br><span class="hljs-keyword">if</span> my_string.islower():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;String contains only lowercase letters&quot;</span>)<br><br><span class="hljs-comment"># 遍历数组</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)<br><br><span class="hljs-comment"># 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br><br><span class="hljs-comment"># 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dictionary contains &#x27;name&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go示例</span><br><br><span class="hljs-comment">// 数组和切片</span><br>mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>subSlice := mySlice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversedSlice := reverseSlice(mySlice)<br><br><span class="hljs-comment">// 字典</span><br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>&#125;<br><br><span class="hljs-comment">// 双向链表（使用container/list）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br>myList := list.New()<br>myList.PushBack(<span class="hljs-number">1</span>)<br>myList.PushBack(<span class="hljs-number">2</span>)<br>myList.PushBack(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 最大堆和最小堆（需要使用heap包）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/heap&quot;</span><br>maxHeap := &amp;MaxHeap&#123;&#125;<br>minHeap := &amp;MinHeap&#123;&#125;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>myString := <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring := myString[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>myInt := <span class="hljs-number">42</span><br>myStr := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, myInt)<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝（使用复制切片或递归）</span><br>originalSlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>shallowCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(originalSlice))<br><span class="hljs-built_in">copy</span>(shallowCopy, originalSlice)<br>deepCopy := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), originalSlice...)<br><br><span class="hljs-comment">// 删除元素</span><br>index := <span class="hljs-number">1</span><br>mySlice = <span class="hljs-built_in">append</span>(mySlice[:index], mySlice[index+<span class="hljs-number">1</span>:]...)<br><br><span class="hljs-comment">// 查找小写字母</span><br>containsLowercase := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-keyword">if</span> unicode.IsLower(char) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历切片</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> mySlice &#123;<br>    fmt.Println(item)<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    fmt.Println(key, value)<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> _, exists := myMap[<span class="hljs-string">&quot;name&quot;</span>]; exists &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++示例</span><br><br><span class="hljs-comment">// 数组和向量</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subVector</span><span class="hljs-params">(myVector.begin() + <span class="hljs-number">1</span>, myVector.begin() + <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversedVector</span><span class="hljs-params">(myVector.rbegin(), myVector.rend())</span></span>;<br><br><span class="hljs-comment">// 字典（使用std::map）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br>myMap[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;Alice&quot;</span>;<br>myMap[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 双向链表（使用std::list）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br>std::list&lt;<span class="hljs-type">int</span>&gt; myList;<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 最大堆和最小堆（使用std::priority_queue）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>std::string myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string substring = myString.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> myInt = <span class="hljs-number">42</span>;<br>std::string myStr = std::<span class="hljs-built_in">to_string</span>(myInt);<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; originalVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; shallowCopy = originalVector;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deepCopy</span><span class="hljs-params">(originalVector)</span></span>;<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + index);<br><br><span class="hljs-comment">// 查找小写字母</span><br><span class="hljs-type">bool</span> containsLowercase = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : myString) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">islower</span>(c)) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历向量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : myVector) &#123;<br>    std::cout &lt;&lt; item &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;name&quot;</span>) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python示例&quot;&gt;&lt;a href=&quot;#Python示例&quot; class=&quot;headerlink&quot; title=&quot;Python示例&quot;&gt;&lt;/a&gt;Python示例&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 136.只出现一次的数字</title>
    <link href="https://leiqichn.github.io/2023-10-16-66afbe22520d.html"/>
    <id>https://leiqichn.github.io/2023-10-16-66afbe22520d.html</id>
    <published>2023-10-16T15:23:24.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/single-number/description/">136. 只出现一次的数字</a><br><img src="/../../imgs/Pasted%20image%2020231016232403.png"><br>[TOC]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p></blockquote><p>答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。</p><p>任何数和 0做异或运算，结果仍然是原来的数<br>任何数和其自身做异或运算，结果是 0<br><img src="https://pic.leetcode.cn/1697469725-QtsjoA-image.png" alt="image.png"></p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ol><li><p>hash</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>numsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>numsMap[val] += <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> numsMap &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> key<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>位运算</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    single := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        single ^= num<br>    &#125;<br>    <span class="hljs-keyword">return</span> single<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/single-number/description/&quot;&gt;136. 只出现一次的数字&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 155.最小栈</title>
    <link href="https://leiqichn.github.io/2023-10-12-cfa4d16bfad5.html"/>
    <id>https://leiqichn.github.io/2023-10-12-cfa4d16bfad5.html</id>
    <published>2023-10-12T16:07:58.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈</a></p></blockquote><p><img src="/../../imgs/Pasted%20image%2020231013000854.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>栈</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-comment">// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>stack    []<span class="hljs-type">int</span> <span class="hljs-comment">// 主栈</span><br>minStack []<span class="hljs-type">int</span> <span class="hljs-comment">// 辅助栈</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>minStacks := MinStack&#123;[]<span class="hljs-type">int</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;math.MaxInt&#125;&#125;<br><span class="hljs-keyword">return</span> minStacks<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 同时比较辅助站的的top元素，如果更小 则添加到辅助站</span><br>this.stack = <span class="hljs-built_in">append</span>(this.stack, x)<br>minTmp := min(x, this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>])<br>this.minStack = <span class="hljs-built_in">append</span>(this.minStack, minTmp)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;<br>this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> (this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> (this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> x &lt; y &#123;<br><span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">return</span> y<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/min-stack/description/&quot;&gt;155. 最小栈&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/../../im</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题 总结</title>
    <link href="https://leiqichn.github.io/2023-10-09-0f6b9d3bc0f2.html"/>
    <id>https://leiqichn.github.io/2023-10-09-0f6b9d3bc0f2.html</id>
    <published>2023-10-09T17:21:04.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<p>设计题 - 实现浏览器历史记录<br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p><ul><li>和当前页相同，则直接返回</li><li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description: 浏览器实现</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.GetCurrentPage() == newPageURL &#123;<br><span class="hljs-keyword">return</span> newPageURL<br>&#125;<br><br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p><h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p><p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p><h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p><p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p><h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p><p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p><h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p><h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p><p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计题 - 实现浏览器历史记录&lt;br&gt;1.初始化 homepage 和历史记录容量&lt;br&gt;2.浏览网页 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和当前页相同，则直接返回&lt;/li&gt;
&lt;li&gt;和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Go 的 container list 包：双向链表的便捷工具</title>
    <link href="https://leiqichn.github.io/2023-10-09-5ecfb18fa495.html"/>
    <id>https://leiqichn.github.io/2023-10-09-5ecfb18fa495.html</id>
    <published>2023-10-09T16:44:33.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。</p><h2 id="导入-container-x2F-list-包"><a href="#导入-container-x2F-list-包" class="headerlink" title="导入 container&#x2F;list 包"></a>导入 container&#x2F;list 包</h2><p>要使用 container&#x2F;list 包，首先需要导入它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br></code></pre></td></tr></table></figure><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><p>创建一个新的链表非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myList := list.New()<br></code></pre></td></tr></table></figure><p>这将创建一个名为 myList 的新链表。</p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">myList.PushBack(<span class="hljs-number">42</span>)<br>myList.PushFront(<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>要访问链表中的元素，你可以使用 Front 和 Back 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">firstElement := myList.Front().Value<br>lastElement := myList.Back().Value<br></code></pre></td></tr></table></figure><h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><p>遍历链表可以使用 for 循环来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> element := myList.Front(); element != <span class="hljs-literal">nil</span>; element = element.Next() &#123;<br>    <span class="hljs-comment">// 处理 element.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>要删除链表中的元素，可以使用 Remove 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">elementToRemove := myList.Front()<br>myList.Remove(elementToRemove)<br></code></pre></td></tr></table></figure><h1 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h1><h2 id="1-类型断言"><a href="#1-类型断言" class="headerlink" title="1. 类型断言"></a>1. 类型断言</h2><p>链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value := element.Value.(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>如果断言失败，会导致运行时错误。</p><h2 id="2-InsertAfter-和-InsertBefore"><a href="#2-InsertAfter-和-InsertBefore" class="headerlink" title="2. InsertAfter 和 InsertBefore"></a>2. InsertAfter 和 InsertBefore</h2><p>这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。</p><h1 id="示例：浏览器历史记录"><a href="#示例：浏览器历史记录" class="headerlink" title="示例：浏览器历史记录"></a>示例：浏览器历史记录</h1><p>下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言中的 container&amp;#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&amp;#x2F;lis</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1845. 座位预约管理系统</title>
    <link href="https://leiqichn.github.io/2023-10-06-c2afb6383992.html"/>
    <id>https://leiqichn.github.io/2023-10-06-c2afb6383992.html</id>
    <published>2023-10-06T04:09:42.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统</a></p></blockquote><p>个人博客,记录学习: <a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a><br>  [TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>使用slice 的index来表示座位号,<br>1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.<br>2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><strong>使用slice</strong><br>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br>  <br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats []<span class="hljs-type">int</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>set:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> SeatManager&#123;seats:set,min:<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>value := this.min<br>this.seats[value]=<span class="hljs-number">1</span><br>length := <span class="hljs-built_in">len</span> (this.seats)<br>fmt.Println(length)<br>i:=value<br><span class="hljs-keyword">for</span> ;i&lt;length+<span class="hljs-number">1</span>;i++&#123;<br><span class="hljs-keyword">if</span> this.seats[i]==<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>this.min=i <span class="hljs-comment">// 中间变量，更新下次的最小座位号</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> value <span class="hljs-comment">// 最小的座位号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>)  &#123;<br>this.seats[seatNumber] = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> seatNumber &lt; this.min&#123;<br>this.min=seatNumber<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>使用map</strong><br>map 有个用例会超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seatMap   <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>minSeat   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>seatMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 注意从0 开始初始化</span><br>seatMap[i] = <span class="hljs-number">0</span><br>&#125;<br>seatMan := SeatManager&#123;<br>seatMap,<br><span class="hljs-number">1</span>,<br>&#125;<br><span class="hljs-keyword">return</span> seatMan<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>  value := this.minSeat<br>this.seatMap[value] = <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">for</span> i:= value; i &lt;= <span class="hljs-built_in">len</span>(this.seatMap);i++ &#123;<br>    <span class="hljs-keyword">if</span> this.seatMap[i] == <span class="hljs-number">1</span> &#123;<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    this.minSeat = i<br>    <span class="hljs-keyword">break</span><br>  &#125;<br><span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>) &#123;<br>  this.seatMap[seatNumber] = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">if</span> seatNumber &lt; this.minSeat &#123;<br>    this.minSeat = seatNumber<br>  &#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> a &lt; b &#123;<br>    <span class="hljs-keyword">return</span> a<br>  &#125;<br>  <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/seat-reservation-manager/description/&quot;&gt;1845. 座位预约管理系统&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 中是否使用make创建slice的区别</title>
    <link href="https://leiqichn.github.io/2023-10-05-9d3185fd2258.html"/>
    <id>https://leiqichn.github.io/2023-10-05-9d3185fd2258.html</id>
    <published>2023-10-05T09:01:37.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<p>go slice 的make 会创建默认长度 且值为0 的slice </p><p>在 Go 语言中，可以使用 <code>make</code> 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 <code>make</code> 和不使用 <code>make</code> 创建切片的主要区别：</p><p><strong>使用 <code>make</code> 创建切片：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用 make 创建切片，指定长度和容量 </span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ol><li><p><strong>指定长度和容量：</strong> 使用 <code>make</code> 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。</p></li><li><p><strong>底层数组初始化：</strong> 使用 <code>make</code> 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，<code>slice</code> 是一个包含5个零值整数的切片。</p></li></ol><p><strong>不使用 <code>make</code> 创建切片：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 不使用 make 创建切片，长度为 5 </span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>&#96;</p><ol><li><p><strong>自动确定长度：</strong> 不使用 <code>make</code> 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，<code>slice</code> 的长度是5，因为提供了5个整数。</p></li><li><p><strong>容量与长度相同：</strong> 如果不使用 <code>make</code> 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。</p></li></ol><p>总结：</p><ul><li>使用 <code>make</code> 创建切片时，您可以明确控制切片的容量，并<strong>按长度初始化为0值</strong>，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。</li><li>不使用 <code>make</code> 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。</li></ul><p>无论使用哪种方式创建切片，都可以使用 <code>append</code> 函数来动态增长切片的长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go slice 的make 会创建默认长度 且值为0 的slice &lt;/p&gt;
&lt;p&gt;在 Go 语言中，可以使用 &lt;code&gt;make&lt;/code&gt; 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 &lt;code&gt;make&lt;/code</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>JetBrians 全家桶设置文件header</title>
    <link href="https://leiqichn.github.io/2023-10-05-7527c8e47a8b.html"/>
    <id>https://leiqichn.github.io/2023-10-05-7527c8e47a8b.html</id>
    <published>2023-10-05T08:41:46.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。</p><p>先看下效果图<br><img src="/../../imgs/Pasted%20image%2020231005164404.png"></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-file-settings"><a href="#1-file-settings" class="headerlink" title="1. file- settings"></a>1. file- settings</h2><p><img src="/../../imgs/Pasted%20image%2020231005164508.png"></p><h1 id="找到Copyright-CopyrightProfiles"><a href="#找到Copyright-CopyrightProfiles" class="headerlink" title="找到Copyright - CopyrightProfiles"></a>找到Copyright - CopyrightProfiles</h1><p>点击+ 号，新建一个name 为“copyRight” 的profile</p><p><img src="/../../imgs/Pasted%20image%2020231005164618.png"></p><p>profile 的内容粘贴下面的问文本, 替换自己的名字</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Copyright (c) <span class="hljs-symbol">$origi</span>nalComment.match(<span class="hljs-string">&quot;Copyright \(c\) (\d+)&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;$today.year&quot;</span>)<span class="hljs-symbol">$today</span>.<span class="hljs-built_in">year</span> YOUR NAME. <span class="hljs-built_in">All</span> rights reserved.  <br>Author: YOUR NAME  <br>Description:  <br><span class="hljs-built_in">Date</span>: <span class="hljs-symbol">$today</span><br></code></pre></td></tr></table></figure><h1 id="点击Copyright-添加刚才的profile"><a href="#点击Copyright-添加刚才的profile" class="headerlink" title="点击Copyright 添加刚才的profile"></a>点击Copyright 添加刚才的profile</h1><p><img src="/../../imgs/Pasted%20image%2020231005165129.png"></p><h2 id="点击应用即可-右键-generate-Copyright-插入"><a href="#点击应用即可-右键-generate-Copyright-插入" class="headerlink" title="点击应用即可 右键-generate-Copyright 插入"></a>点击应用即可 右键-generate-Copyright 插入</h2><p><img src="/../../imgs/Pasted%20image%2020231005164944.png"></p><p><img src="/../../imgs/Pasted%20image%2020231005165025.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。&lt;/p&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode1603. 设计停车系统</title>
    <link href="https://leiqichn.github.io/2023-09-26-aeddfdb3bdac.html"/>
    <id>https://leiqichn.github.io/2023-09-26-aeddfdb3bdac.html</id>
    <published>2023-09-26T17:09:22.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/design-parking-system/description/">1603. 设计停车系统</a></p></blockquote><p>  [TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。</p></blockquote><p>虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>lastCar [3]int 添加上边的数组</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>添加空间复杂度, 示例： $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Go">  <br>  <span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<br>    lastCar [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(big <span class="hljs-type">int</span>, medium <span class="hljs-type">int</span>, small <span class="hljs-type">int</span>)</span></span> ParkingSystem &#123;<br>    <span class="hljs-keyword">var</span> parkingSystem  ParkingSystem<br>    parkingSystem.lastCar[<span class="hljs-number">0</span>] = big<br>    parkingSystem.lastCar[<span class="hljs-number">1</span>] = medium<br>    parkingSystem.lastCar[<span class="hljs-number">2</span>] = small<br>    <span class="hljs-keyword">return</span> parkingSystem<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *ParkingSystem)</span></span> AddCar(carType <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    carIdx := carType - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> this.lastCar[carIdx] &gt; <span class="hljs-number">0</span> &#123;<br>        this.lastCar[carIdx]--<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your ParkingSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver）</span><br><span class="hljs-comment"> * param_1 := obj.AddCar(carType);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/design-parking-system/description/&quot;&gt;1603. 设计停车系统&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  [</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux非root用户通过X11运行图形界面程序-以Rstudio为例</title>
    <link href="https://leiqichn.github.io/2023-09-24-4fe5badbd053.html"/>
    <id>https://leiqichn.github.io/2023-09-24-4fe5badbd053.html</id>
    <published>2023-09-24T12:36:53.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。<br>但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。<br>那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！</p><blockquote><p><strong>X11</strong>是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。</p></blockquote><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ol><li>使用mobaxTerm 登录对应服务器，需要显示X11 打开<img src="/../../imgs/Pasted%20image%2020230924203748.png"></li><li>创建虚拟环境<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建虚拟环境</span><br> conda create -n rstudio<br><span class="hljs-comment"># 安装Ｒ</span><br>conda activate rstudio <span class="hljs-comment"># 进入创建好的环境变量</span><br>conda install r-base<br><span class="hljs-comment"># 安装Rstudio</span><br>conda install rstudio-desktop<br></code></pre></td></tr></table></figure></li></ol><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p> 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面<br> <img src="/../../imgs/Pasted%20image%2020230924205521.png"><br><strong>画个图试试，顺利出图！开始愉快的coding吧！</strong><br><img src="/../../imgs/Pasted%20image%2020230924205559.png"></p><p><strong>已知问题：</strong> 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以通过<strong>X11</strong>来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Serv</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 将用户追加到对应用户组</title>
    <link href="https://leiqichn.github.io/2023-09-17-5141f57450ab.html"/>
    <id>https://leiqichn.github.io/2023-09-17-5141f57450ab.html</id>
    <published>2023-09-17T06:02:54.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文目的是为了将多个用户设置同组用户，并且同组内用户<strong>新建文件的默认权限</strong>是同组内用户可读写。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>将test 添加到GroupA</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">usermod -a -G GroupName UserName<br><span class="hljs-comment"># 例如将test 追加到GroupA</span><br>usermod -a -G GroupA <span class="hljs-built_in">test</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>修改新建文件的默认权限</li></ol><p>在.bashrc 里添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">umask</span> 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--)<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文目的是为了将多个用户设置同组用户，并且同组内用户&lt;strong&gt;新建文件的默认权限&lt;/strong&gt;是同组内用户可读写。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqichn.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 结构化设计</title>
    <link href="https://leiqichn.github.io/2023-09-13-476441b87811.html"/>
    <id>https://leiqichn.github.io/2023-09-13-476441b87811.html</id>
    <published>2023-09-13T15:21:57.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h1><p><strong>自顶向下的设计 是自顶向下的分解</strong> -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题<br><img src="/../../imgs/Pasted%20image%2020230913232308.png"></p><h1 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h1><p>自顶向上的实现，实现一个一个子问题</p><p>程序由三种基本结构组成，<strong>顺序-分支-循环</strong><img src="/../../imgs/Pasted%20image%2020230913232249.png"></p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="/../../imgs/Pasted%20image%2020230913232729.png"><br><img src="/../../imgs/Pasted%20image%2020230913232746.png"></p><p><img src="/../../imgs/Pasted%20image%2020230913232825.png"><br><img src="/../../imgs/Pasted%20image%2020230913232951.png"><br><img src="/../../imgs/Pasted%20image%2020230913232936.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构化程序设计&quot;&gt;&lt;a href=&quot;#结构化程序设计&quot; class=&quot;headerlink&quot; title=&quot;结构化程序设计&quot;&gt;&lt;/a&gt;结构化程序设计&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;自顶向下的设计 是自顶向下的分解&lt;/strong&gt; -&amp;gt; 找子问题 -&amp;gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://leiqichn.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>clash在终端设置代理</title>
    <link href="https://leiqichn.github.io/2023-09-12-b926f621cf15.html"/>
    <id>https://leiqichn.github.io/2023-09-12-b926f621cf15.html</id>
    <published>2023-09-12T15:38:32.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！</p><h1 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h1><p>前置条件：手动开打 clash 等VPN软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:7890<br><span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p>对应的网址是在settings- static-Host; 对应port 为General-Prot<br><img src="/../../imgs/Pasted%20image%2020230913000142.png"><br><img src="/../../imgs/Pasted%20image%2020230913000136.png"></p><h1 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">unset</span> http_proxy<br><span class="hljs-built_in">unset</span> http_proxy<br></code></pre></td></tr></table></figure><h1 id="git-里设置开启代理-alias-命令别名"><a href="#git-里设置开启代理-alias-命令别名" class="headerlink" title="git 里设置开启代理 alias 命令别名"></a>git 里设置开启代理 alias 命令别名</h1><h2 id="新建-bashrc"><a href="#新建-bashrc" class="headerlink" title="新建 .bashrc"></a>新建 .bashrc</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br>vi .bashrc<br><br><span class="hljs-comment"># 将以下内容复制进去</span><br><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="hljs-keyword">then</span><br>        . /etc/bash.bashrc<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:</span><br><span class="hljs-comment"># export SYSTEMD_PAGER=</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br>// 别名设置，其他别名设置也是类似<br><span class="hljs-built_in">alias</span> proxyon=<span class="hljs-string">&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;</span><br><span class="hljs-built_in">alias</span> proxyoff=<span class="hljs-string">&quot;unset http_proxy;unset http_proxy&quot;</span><br></code></pre></td></tr></table></figure><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p>可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。<br><img src="/../../imgs/Pasted%20image%2020230912235632.png"><br><img src="/../../imgs/Pasted%20image%2020230912235612.png"><br>可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。<br><img src="/../../imgs/Pasted%20image%2020230913000956.png" alt="图 push成功"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 2594修车的最少时间</title>
    <link href="https://leiqichn.github.io/2023-09-07-b8c038c07b41.html"/>
    <id>https://leiqichn.github.io/2023-09-07-b8c038c07b41.html</id>
    <published>2023-09-07T15:59:00.000Z</published>
    <updated>2023-10-22T09:56:49.109Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230908000057.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>能力值为 <code>r</code> 的机械工可以在 t&#x3D; <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。<br>可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repairCars</span><span class="hljs-params">(ranks []<span class="hljs-type">int</span>, cars <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    l , r := <span class="hljs-number">1</span>, ranks[<span class="hljs-number">0</span>] * cars * cars<br>    <span class="hljs-keyword">var</span> check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        cnt := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ranks &#123;<br>            cnt += <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(m / x)))<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt;= cars<br>    &#125;<br>        <br>    <span class="hljs-keyword">for</span> l &lt; r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> check(m) &#123;<br>            r = m<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int64</span>(l)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li><p><code>l</code> 和 <code>r</code> 的初始化：</p><ul><li><code>l</code> 初始化为1，表示最小可能的修理时间。</li><li><code>r</code> 初始化为 <code>ranks[0] * cars * cars</code>，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。</li></ul></li><li><p><code>check</code> 函数定义：</p><ul><li>这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 <code>m</code> 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 <code>m</code> 时间内能修理多少辆车，然后累加到 <code>cnt</code> 变量中。</li><li>如果 <code>cnt</code> 大于或等于需要修理的汽车数量 <code>cars</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><p>二分查找循环：</p><ul><li>使用一个二分查找循环来查找最小的修理时间。循环条件是 <code>l &lt; r</code>，即当最小时间小于最大时间时，继续循环。</li><li>在每次循环中，计算中间值 <code>m</code>，并调用 <code>check(m)</code> 检查是否满足修理所有汽车的条件。</li><li>如果满足条件，则将 <code>r</code> 更新为 <code>m</code>，因为我们希望找到更小的修理时间。</li><li>如果不满足条件，则将 <code>l</code> 更新为 <code>m + 1</code>，因为我们需要增加修理时间。</li><li>这样，不断地缩小时间范围，直到找到最小的修理时间。</li></ul></li><li><p>最终返回结果：</p><ul><li>一旦 <code>l</code> 不再小于 <code>r</code>，循环结束，说明已经找到了最小的修理时间，将其转换为 <code>int64</code> 类型并返回。</li></ul></li></ol><p>我们总结一下二分查找适用的场景</p><h1 id="二分查找算法适用场景"><a href="#二分查找算法适用场景" class="headerlink" title="二分查找算法适用场景"></a>二分查找算法适用场景</h1><p><strong>递增或递减规律</strong>：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。</p><p><strong>有序数据集合</strong>：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。</p><p><strong>快速查找</strong>：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。</p><p><strong>确定性问题</strong>：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。</p><p><strong>时间复杂度要求较高</strong>：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。</p><p><strong>可比较性数据</strong>：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。</p><p><strong>搜索范围可确定</strong>：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。</p><p><strong>内存连续性</strong>：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。</p><p>一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&amp;envId=2023-09-07&quot;&gt;2594. 修车的最少时间 - 力</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂</title>
    <link href="https://leiqichn.github.io/2023-09-03-c6ab66461699.html"/>
    <id>https://leiqichn.github.io/2023-09-03-c6ab66461699.html</id>
    <published>2023-09-03T12:39:19.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230903231353.png"></p><h1 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h1><p><img src="/../../imgs/Pasted%20image%2020230903231449.png"><br>多个工厂模式;</p><p>有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)</p><p><img src="/../../imgs/Pasted%20image%2020230903231857.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230903231353.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;抽象工厂模式结构&quot;&gt;&lt;a href=&quot;#抽象工厂模式结构&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂模式结构&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="https://leiqichn.github.io/2023-09-03-c58ee0dac51b.html"/>
    <id>https://leiqichn.github.io/2023-09-03-c58ee0dac51b.html</id>
    <published>2023-09-03T05:09:25.000Z</published>
    <updated>2023-10-22T09:56:49.113Z</updated>
    
    <content type="html"><![CDATA[<p>网站链接：<br><a href="https://refactoringguru.cn/design-patterns/factory-method">工厂方法设计模式 (refactoringguru.cn)</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。</p><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂<br><img src="/../../imgs/Pasted%20image%2020230903131943.png"><br><img src="/../../imgs/Pasted%20image%2020230903134040.png"><br><img src="/../../imgs/Pasted%20image%2020230903133944.png"><br>简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间.</p><h1 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h1><p><strong>不同的类实现相同的动作,例如运输等</strong><br><img src="/../../imgs/Pasted%20image%2020230903140955.png"></p><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p> 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p><p> 注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会<strong>重写基础工厂</strong>方法， 使其<strong>返回不同类型的产品</strong>。</p><p> 注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的<strong>已有对象</strong>。</p></li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/../../imgs/Pasted%20image%2020230903142906.png"><br>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。</p><p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。</p><p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p><p>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离<a href="https://refactoringguru.cn/design-patterns/abstract-factory">抽象工厂</a>模式更近一步。</p><h1 id="简单工厂和工厂模式的区别"><a href="#简单工厂和工厂模式的区别" class="headerlink" title="简单工厂和工厂模式的区别"></a>简单工厂和工厂模式的区别</h1><p><strong>1. 简单工厂设计模式（Simple Factory Design Pattern）：</strong></p><p>定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。<br>结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。<br>示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。<br><strong>2. 工厂方法设计模式（Factory Method Design Pattern）：</strong></p><p>定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。<br>结构： 工厂方法模式包括<strong>抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。</strong><br>示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。<br>主要区别：</p><p>复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。</p><p>责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。</p><p>扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。</p><p>灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。</p><p>选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。</p><h2 id="UML类图如何看"><a href="#UML类图如何看" class="headerlink" title="UML类图如何看"></a>UML类图如何看</h2><h2 id="看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"><a href="#看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；" class="headerlink" title="看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)</a><br><img src="/../../imgs/Pasted%20image%2020230903222357.png"><br>- 车的类图结构为abstract，表示车是一个抽象类；<br>- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；<br>- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；<br>- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；<br>- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；<br>- 学生与身份证之间为关联关系，使用一根实线表示；<br>- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</h2><p><img src="/../../imgs/Pasted%20image%2020230903132154.png"></p><p>首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”</p><p><img src="/../../imgs/Pasted%20image%2020230903134233.png"></p><p><strong>接口:</strong> </p><p><img src="https://res.weread.qq.com/wrepub/CB_85fDPzDPICld6ht6gW5IeD0Q_Image00017.jpg"></p><p>‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口.</p><p><strong>类和类之间的关系:</strong> 继承的关系，继承关系用空心三角形+实线来表示<br><img src="/../../imgs/Pasted%20image%2020230903134840.png"></p><p><strong>聚合:</strong> 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。</p><p><img src="/../../imgs/Pasted%20image%2020230903140037.png"><br><strong>合成</strong>（Composition，也有翻译成‘<strong>组合</strong>’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。<br><img src="/../../imgs/Pasted%20image%2020230903140113.png"></p><p><strong>依赖</strong><br><img src="/../../imgs/Pasted%20image%2020230903140305.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网站链接：&lt;br&gt;&lt;a href=&quot;https://refactoringguru.cn/design-patterns/factory-method&quot;&gt;工厂方法设计模式 (refactoringguru.cn)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="设计模式" scheme="https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
