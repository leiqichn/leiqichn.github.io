<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-07-31T15:33:02.561Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【新开发】GoToDo 四象限法待办谷歌插件</title>
    <link href="https://leiqi.top/2025-07-31-c1ada6c33858.html"/>
    <id>https://leiqi.top/2025-07-31-c1ada6c33858.html</id>
    <published>2025-07-31T15:25:28.000Z</published>
    <updated>2025-07-31T15:33:02.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GOTODO"><a href="#GOTODO" class="headerlink" title="GOTODO"></a>GOTODO</h1><blockquote><p>四象限法 TODO 管理 Chrome 插件<br>Eisenhower Matrix TODO Chrome Extension</p></blockquote><hr><h2 id="项目简介-Introduction"><a href="#项目简介-Introduction" class="headerlink" title="项目简介 | Introduction"></a>项目简介 | Introduction</h2><p>GOTODO 是一个基于四象限法（重要紧急矩阵&#x2F;Eisenhower Matrix）的 TODO 管理 Chrome 插件，帮助你高效管理任务，聚焦真正重要的事情。支持任务添加、优先级分类、象限视图、日视图、任务排序等功能。</p><p>GOTODO is a Chrome extension for managing your tasks using the Eisenhower Matrix (Important&#x2F;Urgent Quadrant). It helps you focus on what really matters. Features include task add&#x2F;edit, priority classification, quadrant view, day view, and task sorting.</p><p><img src="/../../imgs/Pasted%20image%2020250731233159.png"><br><img src="/../../imgs/Pasted%20image%2020250731233210.png"></p><hr><h2 id="主要功能-Features"><a href="#主要功能-Features" class="headerlink" title="主要功能 | Features"></a>主要功能 | Features</h2><ul><li>添加 TODO（名称、描述、优先级、截止时间）</li><li>四象限法分类（重要紧急、重要不紧急、紧急不重要、不重要不紧急）</li><li>总览模式（列表）与日模式（象限图）切换</li><li>TODO 项上下移动排序</li><li>本地持久化存储（无需账号）</li><li>简洁美观的界面</li></ul><hr><h2 id="安装与使用-Installation-Usage"><a href="#安装与使用-Installation-Usage" class="headerlink" title="安装与使用 | Installation &amp; Usage"></a>安装与使用 | Installation &amp; Usage</h2><ol><li><strong>下载插件安装包</strong><ul><li>前往 <a href="https://github.com/leiqichn/GOTODO/releases">Releases 页面</a> 下载最新的 <code>GOTODO-V1.0.0.zip</code> 文件。</li></ul></li><li><strong>解压安装包</strong><ul><li>右键压缩包，选择“解压到当前文件夹”或“解压到 GOTODO”</li></ul></li><li><strong>加载插件到 Chrome</strong><ul><li>打开 Chrome，访问 <code>chrome://extensions/</code></li><li>开启右上角“开发者模式”</li><li>点击“加载已解压的扩展程序”</li><li>选择刚刚解压出来的文件夹（里面应包含 manifest.json、index.html、assets 等文件）</li><li>安装完成后，浏览器右上角会出现 GOTODO 图标，点击即可使用</li></ul></li></ol><hr><h2 id="开发与构建-Development-Build"><a href="#开发与构建-Development-Build" class="headerlink" title="开发与构建 | Development &amp; Build"></a>开发与构建 | Development &amp; Build</h2><ul><li>开发预览：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line"><span class="comment"># 访问 http://localhost:5173 预览页面</span></span><br></pre></td></tr></table></figure></li><li>构建打包：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="comment"># 生成 dist 目录，供 Chrome 加载</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="技术栈-Tech-Stack"><a href="#技术栈-Tech-Stack" class="headerlink" title="技术栈 | Tech Stack"></a>技术栈 | Tech Stack</h2><ul><li>React 18</li><li>TypeScript</li><li>Vite 4</li><li>Chrome Extension Manifest V3</li></ul><hr><h2 id="目录结构-Directory-Structure"><a href="#目录结构-Directory-Structure" class="headerlink" title="目录结构 | Directory Structure"></a>目录结构 | Directory Structure</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GOTODO/</span><br><span class="line">├─ public/           # 静态资源（如 icon.png）</span><br><span class="line">├─ src/              # 源码</span><br><span class="line">│  ├─ components/    # 组件</span><br><span class="line">│  ├─ App.tsx</span><br><span class="line">│  ├─ main.tsx</span><br><span class="line">│  ├─ storage.ts</span><br><span class="line">│  └─ types.ts</span><br><span class="line">├─ manifest.json     # 插件清单</span><br><span class="line">├─ index.html        # 入口页面</span><br><span class="line">├─ package.json</span><br><span class="line">├─ vite.config.ts</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><hr><h2 id="贡献-Contributing"><a href="#贡献-Contributing" class="headerlink" title="贡献 | Contributing"></a>贡献 | Contributing</h2><p><a href="https://github.com/leiqichn">https://github.com/leiqichn</a><br>欢迎 PR 和 Issue！如有建议或 bug，欢迎提交。</p><p>Pull requests and issues are welcome!</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GOTODO&quot;&gt;&lt;a href=&quot;#GOTODO&quot; class=&quot;headerlink&quot; title=&quot;GOTODO&quot;&gt;&lt;/a&gt;GOTODO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;四象限法 TODO 管理 Chrome 插件&lt;br&gt;Eisenhower Matr</summary>
      
    
    
    
    <category term="作品集" scheme="https://leiqi.top/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>英文输入时再也不打出中文标点啦</title>
    <link href="https://leiqi.top/2025-07-23-c43371daa575.html"/>
    <id>https://leiqi.top/2025-07-23-c43371daa575.html</id>
    <published>2025-07-23T15:17:33.000Z</published>
    <updated>2025-07-31T15:33:02.562Z</updated>
    
    <content type="html"><![CDATA[<p>以微软拼音为例, 需要打开 <code>中文输入时使用英文标点</code><br><img src="/../../imgs/Pasted%20image%2020250723231812.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以微软拼音为例, 需要打开 &lt;code&gt;中文输入时使用英文标点&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250723231812.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【算法】链表</title>
    <link href="https://leiqi.top/2025-07-18-238daccb5ae9.html"/>
    <id>https://leiqi.top/2025-07-18-238daccb5ae9.html</id>
    <published>2025-07-18T15:22:31.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<p>   <code>206.</code>  反转链表 <a href="https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5zy/">https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5zy/</a><br>   <code>92.</code> 反转链表 II <a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-teqq/">https://leetcode.cn/problems/reverse-linked-list-ii/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-teqq/</a><br>   <code>25.</code> K 个一组翻转链表 <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/">https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;   &lt;code&gt;206.&lt;/code&gt;  反转链表 &lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/solution/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-o5</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【算法】二分法</title>
    <link href="https://leiqi.top/2025-07-10-ee05a539b560.html"/>
    <id>https://leiqi.top/2025-07-10-ee05a539b560.html</id>
    <published>2025-07-10T15:52:10.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<p>转化方式：<br><img src="/../../imgs/Pasted%20image%2020250710235247.png"><br>  <code>&gt;=x</code>  使用sort.SearchInts(nums, x)<br> <code>&gt;x</code> 使用 sort.SearchInts(nums, x+1)<br> <code>&lt;x</code> 使用sort.SearchInts(nums, x) -1<br> <code>&lt;=</code> 使用sort.SearchInts(nums, x +1) -1</p><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020250710235340.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right - left)/ <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2529-正整数和负整数的最大计数"><a href="#2529-正整数和负整数的最大计数" class="headerlink" title="2529. 正整数和负整数的最大计数"></a><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">2529. 正整数和负整数的最大计数</a></h1><p><img src="/../../imgs/Pasted%20image%2020250710235425.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumCount</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 返回反照非低价顺序排列的数组 nums ， 返回正整数数目和负整数数目中的最大值</span></span><br><span class="line"><span class="comment">// pos neg pos neg max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 &gt;0 =》 &gt;= target + 1 ;  &lt;0   &gt;=(target) -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 负整数个数：第一个大于等于0的索引位置（即所有小于0的元素数量）</span></span><br><span class="line">    negCount := sort.SearchInts(nums, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正整数个数：总长度减去第一个大于等于1的索引位置</span></span><br><span class="line">    posCount := n - sort.SearchInts(nums, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> negCount &gt; posCount &#123;</span><br><span class="line">        <span class="keyword">return</span> negCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1385-两个数组间的距离值"><a href="#1385-两个数组间的距离值" class="headerlink" title="1385. 两个数组间的距离值"></a><a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/">1385. 两个数组间的距离值</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func findTheDistanceValue(arr1, arr2 []<span class="built_in">int</span>, d <span class="built_in">int</span>) (ans <span class="built_in">int</span>) &#123;</span><br><span class="line">    sort.Ints(arr2)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="built_in">range</span> arr1 &#123;</span><br><span class="line">        i := sort.SearchInts(arr2, x - d) // </span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(arr2) || arr2[i] &gt; x + d &#123; // 不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d， 即都不在[x - d, x + d] 之间， 所以不能使用arr2[i] &gt;= x + d</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>  <span class="comment">// 左闭右闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;             <span class="comment">// 终止条件：left == right</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &#123;</span><br><span class="line">            right = mid           <span class="comment">// 最小值在 [left, mid]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>       <span class="comment">// 最小值在 [mid + 1, right]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]             <span class="comment">// 此时 left == right，指向最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(nums) <span class="number">-1</span> <span class="comment">// 左开右闭区间 (left, right]</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123;</span><br><span class="line">        mid := left + (right - left) /<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250717232854.png"></p><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p><img src="/../../imgs/Pasted%20image%2020250718000347.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    end := nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x := nums[i]</span><br><span class="line">        <span class="keyword">if</span> x &gt; end &#123;</span><br><span class="line">            <span class="keyword">return</span> target &gt; end &amp;&amp; x &gt;= target</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target &gt; end || x &gt;= target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 开区间 (-1, n-1)</span></span><br><span class="line">    <span class="keyword">for</span> left+<span class="number">1</span> &lt; right &#123; <span class="comment">// 开区间不为空</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[right] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> <ol start="34"><li>在排序数组中查找元素的第一个和最后一个位置 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/</a><br>课后作业：</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2529"><li>正整数和负整数的最大计数 <a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2300"><li>咒语和药水的成功对数 <a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2563"><li>统计公平数对的数目 <a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">https://leetcode.cn/problems/count-the-number-of-fair-pairs/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="275"><li>H 指数 II <a href="https://leetcode.cn/problems/h-index-ii/">https://leetcode.cn/problems/h-index-ii/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="875"><li>爱吃香蕉的珂珂 <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2187"><li>完成旅途的最少时间 <a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/">https://leetcode.cn/problems/minimum-time-to-complete-trips/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2861"><li>最大合金数 <a href="https://leetcode.cn/problems/maximum-number-of-alloys/">https://leetcode.cn/problems/maximum-number-of-alloys/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2439"><li>最小化数组中的最大值 <a href="https://leetcode.cn/problems/minimize-maximum-of-array/">https://leetcode.cn/problems/minimize-maximum-of-array/</a></li></ol></li><li><input disabled="" type="checkbox"> <ol start="2517"><li>礼盒的最大甜蜜度 <a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/">https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转化方式：&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020250710235247.png&quot;&gt;&lt;br&gt;  &lt;code&gt;&amp;gt;=x&lt;/code&gt;  使用sort.SearchInts(nums, x)&lt;br&gt; &lt;code&gt;&amp;gt;x</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go24种设计模式--创建型模式</title>
    <link href="https://leiqi.top/2025-07-09-7705ca14d931.html"/>
    <id>https://leiqi.top/2025-07-09-7705ca14d931.html</id>
    <published>2025-07-09T16:10:38.000Z</published>
    <updated>2025-07-31T15:33:02.563Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design Pattern）是软件工程中针对常见问题的通用解决方案。</p><p>它们不是具体的代码，而是经过验证的最佳实践，帮助开发者设计出灵活、可维护和可扩展的软件系统</p><h2 id="使用设计模式的好处"><a href="#使用设计模式的好处" class="headerlink" title="使用设计模式的好处"></a>使用设计模式的好处</h2><ol><li>面试</li><li>提高代码复用性，写出高质量代码</li><li>前人总结的最佳实践，在合适的地方用合适的设计模式，可以事半功倍</li></ol><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>在 Go 语言中，创建型模式（Creational Patterns）是一类用于处理对象创建的设计模式。它们的主要目标是提供一种灵活的方式来创建对象，同时隐藏对象创建的具体细节，从而降低代码的耦合度，并提高代码的可复用性和可维护性。</p><p>比如<code>http.NewRequest()</code>，<code>bytes.NewReader()</code>，<code>md5.New()</code></p><p>创建型模式的核心思想是将对象的创建与使用分离，使得系统不依赖于具体的对象创建方式，而是依赖于抽象。</p><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><p>确保一个类只有一个实例，并提供一个全局访问点。</p><p>适用场景：</p><ul><li>配置管理、日志记录、数据库连接池等需要全局唯一实例的场景。</li></ul><p>之前在项目里面，我们之前一直在用的global.DB，global.Config其实和这个差不多，但是它不是单例模式，因为是直接使用的对应的对象，而不是通过函数返回的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">  db = &amp;DB&#123;</span><br><span class="line">    Database: <span class="string">&quot;fengfeng&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := db</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前是直接使用全局变量，但是这个变量是存在为nil的情况的，这种情况下再使用它就是为出现空指针的情况</p><p><img src="https://image.fengfengzhidao.com/rj_102520250107110801.png"></p><p>那么可以使用一个函数，在里面判断一下，如果这个对象是nil，就去初始化对象，后续如果有的话，就直接返回之前的那个创建好的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">  Database <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *DB</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span></span> *DB &#123;</span><br><span class="line">  once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db = &amp;DB&#123;</span><br><span class="line">      Database: <span class="string">&quot;fengfeng&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d := GetDB()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">  d = GetDB()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, d, d.Database)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式 Simple Factory Pattern"></a>简单工厂模式 <strong>Simple Factory Pattern</strong></h3><p>它们的目标都是将对象的创建与使用分离，从而降低代码的耦合度</p><p>但是具体的工厂还是有区别</p><table><thead><tr><th>模式</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>简单工厂</strong></td><td>一个工厂类负责创建所有产品，通过条件判断决定创建哪种产品。</td><td>产品种类较少，创建逻辑简单。</td></tr><tr><td><strong>工厂方法模式</strong></td><td>每个产品对应一个工厂类，符合开闭原则。</td><td>产品种类较多，创建逻辑复杂。</td></tr><tr><td><strong>抽象工厂模式</strong></td><td>每个工厂类可以创建一组相关产品，强调产品族的概念。</td><td>需要创建一组相关对象的场景。</td></tr></tbody></table><p>简单工厂并不是一个正式的设计模式，而是一种编程习惯。它通过一个工厂类来封装对象的创建逻辑，客户端只需要传递参数给工厂类，由工厂类决定创建哪种对象。</p><p><strong>特点</strong>：</p><ul><li>只有一个工厂类，负责创建所有产品。</li><li>通过条件判断（如 <code>switch</code> 或 <code>if-else</code>）来决定创建哪种产品。</li></ul><p><strong>适用场景</strong>：</p><ul><li>产品种类较少，且创建逻辑简单的场景。</li></ul><blockquote><p>开闭原则：当需求发生变化时，可以通过增加新的代码来扩展系统的功能，而不是修改现有的代码。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">  Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span></span> Use() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Using Product A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span></span> Use() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Using Product B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateProduct</span><span class="params">(productType <span class="type">string</span>)</span></span> Product &#123;</span><br><span class="line">  <span class="keyword">switch</span> productType &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductA&#123;&#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> &amp;ProductB&#123;&#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  productA := CreateProduct(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">  productA.Use()</span><br><span class="line"></span><br><span class="line">  productB := CreateProduct(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">  productB.Use()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>简单易用，适合小型项目。</li></ul><p><strong>缺点</strong>：</p><ul><li>不符合开闭原则（OCP），新增产品时需要修改工厂类。</li></ul><h3 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h3><p>之前的简单工厂模式，一个工厂就负责了好几个产品的生产</p><p>工厂方法模式则是定义了一个创建对象的接口，但将具体的创建逻辑延迟到子类中。每个子类负责创建一种具体的产品。</p><p><strong>特点</strong>：</p><ul><li>每个产品对应一个工厂类。</li><li>符合开闭原则，新增产品时只需增加新的工厂类，无需修改现有代码。</li></ul><p><strong>适用场景</strong>：</p><ul><li>产品种类较多，且创建逻辑复杂的场景。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">  Connect() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 操作</span></span><br><span class="line"><span class="keyword">type</span> MySQL <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQL)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to MySQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQL 操作</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQL <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQL)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to PostgreSQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DatabaseFactory 工厂接口</span></span><br><span class="line"><span class="keyword">type</span> DatabaseFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  CreateDatabase() Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLFactory MySQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> MySQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateDatabase() Database &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQL&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateDatabase() Database &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQL&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UseDatabase 使用数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseDatabase</span><span class="params">(factory DatabaseFactory)</span></span> &#123;</span><br><span class="line">  db := factory.CreateDatabase()</span><br><span class="line">  fmt.Println(db.Connect())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 使用 MySQL</span></span><br><span class="line">  mysqlFactory := &amp;MySQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(mysqlFactory)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 PostgreSQL</span></span><br><span class="line">  postgresFactory := &amp;PostgreSQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(postgresFactory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>符合开闭原则，扩展性强。</li><li>每个工厂只负责一种产品的创建，职责单一。</li></ul><p><strong>缺点</strong>：</p><ul><li>类的数量会增加，系统复杂度提高。</li></ul><h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h3><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。它适用于需要创建一组相关产品的场景。</p><p><strong>特点</strong>：</p><ul><li>每个工厂类可以创建多个相关产品。</li><li>强调产品族的概念，例如 GUI 库中的不同风格组件（Windows 风格、Mac 风格）。</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要创建一组相关对象的场景。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DBConnection 抽象产品：数据库连接接口</span></span><br><span class="line"><span class="keyword">type</span> DBConnection <span class="keyword">interface</span> &#123;</span><br><span class="line">  Connect() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBCommand 抽象产品：数据库命令接口</span></span><br><span class="line"><span class="keyword">type</span> DBCommand <span class="keyword">interface</span> &#123;</span><br><span class="line">  Execute(query <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLConnection 具体产品：MySQL 连接</span></span><br><span class="line"><span class="keyword">type</span> MySQLConnection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLConnection)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to MySQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLCommand 具体产品：MySQL 命令</span></span><br><span class="line"><span class="keyword">type</span> MySQLCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLCommand)</span></span> Execute(query <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MySQL executing query: %s&quot;</span>, query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLConnection 具体产品：PostgreSQL 连接</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLConnection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLConnection)</span></span> Connect() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Connected to PostgreSQL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLCommand 具体产品：PostgreSQL 命令</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLCommand <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLCommand)</span></span> Execute(query <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;PostgreSQL executing query: %s&quot;</span>, query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DBFactory 抽象工厂接口</span></span><br><span class="line"><span class="keyword">type</span> DBFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">  CreateConnection() DBConnection</span><br><span class="line">  CreateCommand() DBCommand</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQLFactory 具体工厂：MySQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> MySQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateConnection() DBConnection &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQLConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLFactory)</span></span> CreateCommand() DBCommand &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;MySQLCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQLFactory 具体工厂：PostgreSQL 工厂</span></span><br><span class="line"><span class="keyword">type</span> PostgreSQLFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateConnection() DBConnection &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQLConnection&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PostgreSQLFactory)</span></span> CreateCommand() DBCommand &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;PostgreSQLCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UseDatabase</span><span class="params">(factory DBFactory)</span></span> &#123;</span><br><span class="line">  connection := factory.CreateConnection()</span><br><span class="line">  command := factory.CreateCommand()</span><br><span class="line"></span><br><span class="line">  fmt.Println(connection.Connect())</span><br><span class="line">  fmt.Println(command.Execute(<span class="string">&quot;SELECT * FROM users&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 使用 MySQL</span></span><br><span class="line">  mysqlFactory := &amp;MySQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(mysqlFactory)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 PostgreSQL</span></span><br><span class="line">  postgresFactory := &amp;PostgreSQLFactory&#123;&#125;</span><br><span class="line">  UseDatabase(postgresFactory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>可以创建一组相关对象，保证对象之间的兼容性。</li><li>符合开闭原则，扩展性强。</li></ul><p><strong>缺点</strong>：</p><ul><li>类的数量会增加，系统复杂度提高。</li><li>新增产品族或产品等级结构时，需要修改抽象工厂接口及其所有实现类。</li></ul><h4 id="抽象工厂模式和工厂方法模式的区别"><a href="#抽象工厂模式和工厂方法模式的区别" class="headerlink" title="抽象工厂模式和工厂方法模式的区别"></a>抽象工厂模式和工厂方法模式的区别</h4><table><thead><tr><th>特性</th><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td><strong>产品数量</strong></td><td>一个工厂方法只创建一个产品。</td><td>一个抽象工厂创建多个相关产品（产品族）。</td></tr><tr><td><strong>产品关系</strong></td><td>产品之间没有直接关系。</td><td>产品之间是相关的（属于同一个产品族）。</td></tr><tr><td><strong>扩展性</strong></td><td>扩展时需要新增具体工厂类。</td><td>扩展时需要新增具体工厂类和产品族。</td></tr><tr><td><strong>实现方式</strong></td><td>通过继承实现。</td><td>通过组合实现。</td></tr><tr><td><strong>适用场景</strong></td><td>单一产品的创建。</td><td>多个相关产品的创建。</td></tr></tbody></table><ul><li><strong>工厂方法模式</strong> 更简单，适用于单一产品的创建。</li><li><strong>抽象工厂模式</strong> 更强大，适用于创建多个相关产品，但实现也更复杂。</li></ul><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3><p>它用于分步构建复杂对象。建造者模式的核心思想是将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式特别适用于以下场景：</p><ul><li>对象的构建过程非常复杂，包含多个步骤。</li><li>对象的构建过程需要支持不同的配置或表示。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品：House</span></span><br><span class="line"><span class="keyword">type</span> House <span class="keyword">struct</span> &#123;</span><br><span class="line">  Walls   <span class="type">string</span></span><br><span class="line">  Roof    <span class="type">string</span></span><br><span class="line">  Windows <span class="type">string</span></span><br><span class="line">  Doors   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *House)</span></span> Show() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;House with %s walls, %s roof, %s windows, and %s doors\n&quot;</span>,</span><br><span class="line">    h.Walls, h.Roof, h.Windows, h.Doors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者接口</span></span><br><span class="line"><span class="keyword">type</span> HouseBuilder <span class="keyword">interface</span> &#123;</span><br><span class="line">  BuildWalls()</span><br><span class="line">  BuildRoof()</span><br><span class="line">  BuildWindows()</span><br><span class="line">  BuildDoors()</span><br><span class="line">  GetHouse() *House</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：ConcreteHouseBuilder</span></span><br><span class="line"><span class="keyword">type</span> ConcreteHouseBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">  house *House</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteHouseBuilder</span><span class="params">()</span></span> *ConcreteHouseBuilder &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;ConcreteHouseBuilder&#123;house: &amp;House&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildWalls() &#123;</span><br><span class="line">  b.house.Walls = <span class="string">&quot;concrete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildRoof() &#123;</span><br><span class="line">  b.house.Roof = <span class="string">&quot;tile&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildWindows() &#123;</span><br><span class="line">  b.house.Windows = <span class="string">&quot;glass&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> BuildDoors() &#123;</span><br><span class="line">  b.house.Doors = <span class="string">&quot;wooden&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteHouseBuilder)</span></span> GetHouse() *House &#123;</span><br><span class="line">  <span class="keyword">return</span> b.house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">  builder HouseBuilder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirector</span><span class="params">(builder HouseBuilder)</span></span> *Director &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Director&#123;builder: builder&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span></span> Construct() &#123;</span><br><span class="line">  d.builder.BuildWalls()</span><br><span class="line">  d.builder.BuildRoof()</span><br><span class="line">  d.builder.BuildWindows()</span><br><span class="line">  d.builder.BuildDoors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建具体建造者</span></span><br><span class="line">  builder := NewConcreteHouseBuilder()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建指挥者</span></span><br><span class="line">  director := NewDirector(builder)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指挥者构建产品</span></span><br><span class="line">  director.Construct()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最终产品</span></span><br><span class="line">  house := builder.GetHouse()</span><br><span class="line">  house.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>它通过复制现有对象来创建新对象，而不是通过新建类的方式。原型模式的核心思想是利用对象的克隆能力，避免重复初始化，特别适用于创建成本较高的对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototype 原型接口</span></span><br><span class="line"><span class="keyword">type</span> Prototype <span class="keyword">interface</span> &#123;</span><br><span class="line">  Clone() Prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcretePrototype 具体原型</span></span><br><span class="line"><span class="keyword">type</span> ConcretePrototype <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span></span> Clone() Prototype &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象，并复制当前对象的属性</span></span><br><span class="line">  <span class="keyword">return</span> &amp;ConcretePrototype&#123;</span><br><span class="line">    Name: p.Name,</span><br><span class="line">    Age:  p.Age,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcretePrototype)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建原型对象</span></span><br><span class="line">  prototype := &amp;ConcretePrototype&#123;</span><br><span class="line">    Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    Age:  <span class="number">25</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆原型对象</span></span><br><span class="line">  clone := prototype.Clone().(*ConcretePrototype)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改克隆对象的属性</span></span><br><span class="line">  clone.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">  clone.Age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出原型对象和克隆对象</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Prototype:&quot;</span>, prototype)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Clone:&quot;</span>, clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原型模式，如果有引用类型，则需要考虑深拷贝和浅拷贝的问题</p><p>浅拷贝只复制对象本身而不复制其引用的对象，深拷贝则会递归地复制整个对象图。</p><p>这需要根据需求选择适当的拷贝方式</p><p>参考：<br><a href="https://www.fengfengzhidao.com/article/JI33Q5QB8lppN5cbFPQR">Go24种设计模式——创建型模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式（Design Pattern）是软件工程中针对常见问题的通用解决方案。&lt;/p&gt;
&lt;p&gt;它们不是具体的代码，而是经过验证的最佳实践，帮助开发者设计出灵活、可维护和可扩展的软件系统&lt;/p&gt;
&lt;h2 id=&quot;使用设计模式的好处&quot;&gt;&lt;a href=&quot;#使用设计模式的好处&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="go" scheme="https://leiqi.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux任务忘挂后台？bg来救</title>
    <link href="https://leiqi.top/2025-06-27-10e3559d5a60.html"/>
    <id>https://leiqi.top/2025-06-27-10e3559d5a60.html</id>
    <published>2025-06-27T16:34:18.000Z</published>
    <updated>2025-07-31T15:33:02.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法-1：直接挂起当前任务到后台（推荐）"><a href="#方法-1：直接挂起当前任务到后台（推荐）" class="headerlink" title="方法 1：直接挂起当前任务到后台（推荐）"></a>方法 1：直接挂起当前任务到后台（推荐）</h3><ol><li><strong>暂停任务</strong>：<br> 按组合键 <code>Ctrl + Z</code>，将当前前台任务<strong>暂停</strong>（挂起），此时终端会显示类似：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  Stopped                 python code/bert_baseline.py</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>将任务切换到后台运行</strong>：<br> 输入命令 <code>bg</code>（将最近暂停的任务放到后台运行），终端显示：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) root@gpu-1092425eb65d87e4b97a1-1-b6nqycupjgmy:~/IDRsPredictor# bg</span><br><span class="line">[1]+ python code/bert_baseline.py &amp;</span><br></pre></td></tr></table></figure><p>此时任务会在后台继续运行<br><img src="/../../imgs/Pasted%20image%2020250628003523.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法-1：直接挂起当前任务到后台（推荐）&quot;&gt;&lt;a href=&quot;#方法-1：直接挂起当前任务到后台（推荐）&quot; class=&quot;headerlink&quot; title=&quot;方法 1：直接挂起当前任务到后台（推荐）&quot;&gt;&lt;/a&gt;方法 1：直接挂起当前任务到后台（推荐）&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>pycharm快速跳出括号</title>
    <link href="https://leiqi.top/2025-06-26-7823cd405765.html"/>
    <id>https://leiqi.top/2025-06-26-7823cd405765.html</id>
    <published>2025-06-26T16:16:46.000Z</published>
    <updated>2025-07-31T15:33:02.562Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8&spm=1001.2101.3001.7020">自动补全</a>括号，但是写到代码语句末尾，要跳出括号，还得向右下角方向移动一下，按右键<code>→</code>，再移手回来按分号<code>;</code>，再移到右下角，按<code>↓</code>向下键。这样手就脱离了键盘，降低了效率。<br>我们可以把上下左右改成<code>Alt+i/k/j/l</code>，爽到飞起！</p><p><img src="/../../imgs/Pasted%20image%2020250627001735.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8&amp;spm=1001.2101.3001.7020&quot;&gt;自动补全&lt;/a&gt;括号，但是写到代码语句末尾，要跳出括号，还得向右下角</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>下载huggingface模型</title>
    <link href="https://leiqi.top/2025-06-23-bf53e7543f79.html"/>
    <id>https://leiqi.top/2025-06-23-bf53e7543f79.html</id>
    <published>2025-06-23T14:53:29.000Z</published>
    <updated>2025-07-31T15:33:02.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-huggingface-hub-工具"><a href="#使用-huggingface-hub-工具" class="headerlink" title="使用 huggingface_hub 工具"></a>使用 <code>huggingface_hub</code> 工具</h3><ol><li><p><strong>安装工具库</strong>：</p><p> bash</p><p> 复制</p><p> 下载</p><p> pip install huggingface_hub</p></li><li><p><strong>通过命令行下载</strong>：</p><p> bash</p><p> 复制</p><p> 下载</p><p> huggingface-cli download Rostlab&#x2F;prot_bert –local-dir .&#x2F;prot_bert_model</p><ul><li><code>--local-dir</code>：指定本地保存路径（如 <code>./prot_bert_model</code>）。</li></ul></li></ol><p><img src="/../../imgs/Pasted%20image%2020250623225401.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用-huggingface-hub-工具&quot;&gt;&lt;a href=&quot;#使用-huggingface-hub-工具&quot; class=&quot;headerlink&quot; title=&quot;使用 huggingface_hub 工具&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;huggingface_hu</summary>
      
    
    
    
    <category term="AI学习" scheme="https://leiqi.top/categories/AI%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>sudo命令缺失解决</title>
    <link href="https://leiqi.top/2025-06-22-fbc6289be980.html"/>
    <id>https://leiqi.top/2025-06-22-fbc6289be980.html</id>
    <published>2025-06-22T10:50:58.000Z</published>
    <updated>2025-07-31T15:33:02.554Z</updated>
    
    <content type="html"><![CDATA[<p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@799b7657ed3c:/app# sudo apt update</span><br><span class="line">sudo apt install iputils-ping</span><br><span class="line">bash: sudo: command not found</span><br><span class="line">bash: sudo: command not found</span><br></pre></td></tr></table></figure><p>通过以下步骤在 Ubuntu（或 Debian 系统）中安装 <code>sudo</code> 命令：</p><ol><li><p><strong>切换到 root 用户</strong>（如果你还不是 root，提示符应该是 <code>#</code>，如果是 <code>$</code> 需要切换）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>然后输入 root 密码。</p></li><li><p><strong>更新软件包列表</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 sudo</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install sudo</span><br></pre></td></tr></table></figure></li><li><p><strong>（可选）将你的用户添加到 sudo 用户组</strong>（假设你的用户名是 <code>yourusername</code>，请替换为实际用户名）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo yourusername</span><br></pre></td></tr></table></figure><p>这样你下次用 <code>yourusername</code> 登录时就可以使用 <code>sudo</code> 了。</p></li><li><p><strong>重新登录</strong> 或者执行 <code>su - yourusername</code> 让组权限生效。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>主机密钥变更客户端无法ssh连接</title>
    <link href="https://leiqi.top/2025-06-22-ef8361a6bfbe.html"/>
    <id>https://leiqi.top/2025-06-22-ef8361a6bfbe.html</id>
    <published>2025-06-22T10:20:15.000Z</published>
    <updated>2025-07-31T15:33:02.554Z</updated>
    
    <content type="html"><![CDATA[<p> SSH 报告了“**REMOTE HOST IDENTIFICATION HAS CHANGED!**”这个错误。具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">...</span><br><span class="line">Offending ECDSA key in C:\\Users\\QiLei/.ssh/known_hosts:9</span><br><span class="line">Host key for [xxxxxx]:20032 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>这是 SSH 的安全机制。它检测到你之前连接的远程主机（10.152.255.101:20032）的主机密钥和现在的不一样。可能的原因有：</p><ul><li>远程主机重装过系统或 SSH 服务，主机密钥发生了变化。</li><li>你连接的其实不是同一台机器（IP 被复用）。</li><li>有人试图进行中间人攻击（一般内网环境下很少见）。</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>如果你确认远程主机的变更是正常的（比如重装过系统或 SSH 服务），可以按照如下步骤操作：</strong></p><ol><li><p>打开命令行，输入以下命令，删除有问题的 known_hosts 记录（第9行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -R [10.152.255.101]:20032</span><br></pre></td></tr></table></figure><p>或者手动编辑 <code>C:\Users\QiLei\.ssh\known_hosts</code> 文件，删除第9行。</p></li><li><p>重新用 VS Code Remote-SSH 连接远程主机，系统会提示你接受新的主机密钥，输入 <code>yes</code> 即可。</p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; SSH 报告了“**REMOTE HOST IDENTIFICATION HAS CHANGED!**”这个错误。具体内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】动态规划</title>
    <link href="https://leiqi.top/2025-06-17-97ef30d737ce.html"/>
    <id>https://leiqi.top/2025-06-17-97ef30d737ce.html</id>
    <published>2025-06-17T16:35:57.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（Dynamic Programming, DP）是算法中的经典题型，LeetCode 上有许多高频题目。以下是常见的 DP 分类、经典题目及 Golang 实现模板总结：</p><hr><h3 id="一、经典题目分类与-Golang-实现"><a href="#一、经典题目分类与-Golang-实现" class="headerlink" title="一、经典题目分类与 Golang 实现"></a><strong>一、经典题目分类与 Golang 实现</strong></h3><h4 id="1-线性-DP"><a href="#1-线性-DP" class="headerlink" title="1. 线性 DP"></a>1. <strong>线性 DP</strong></h4><ul><li><p><strong>题目</strong>：<a href="https://leetcode.com/problems/climbing-stairs/">70. 爬楼梯</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化空间</strong>（滚动数组）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>模板总结</strong>：</p><ul><li>状态定义：<code>dp[i]</code> 表示第 <code>i</code> 阶的方案数。</li><li>转移方程：<code>dp[i] = dp[i-1] + dp[i-2]</code>。</li><li>初始化：<code>dp[1] = 1</code>, <code>dp[2] = 2</code>。</li></ul></li></ul><h4 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. <strong>背包问题</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[j]</code> 表示能否凑出和为 <code>j</code>。</li><li>转移方程：<code>dp[j] = dp[j] || dp[j-num]</code>。</li><li>初始化：<code>dp[0] = true</code>（和为 0 不需要选任何数）。</li></ul></li></ul><h4 id="3-字符串-DP"><a href="#3-字符串-DP" class="headerlink" title="3. 字符串 DP"></a>3. <strong>字符串 DP</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][j]</code> 表示 <code>text1[0..i-1]</code> 和 <code>text2[0..j-1]</code> 的 LCS 长度。</li><li>转移方程：<ul><li>字符匹配：<code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li><li>不匹配：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li></ul></li></ul></li></ul><h4 id="4-股票买卖问题"><a href="#4-股票买卖问题" class="headerlink" title="4. 股票买卖问题"></a>4. <strong>股票买卖问题</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minPrice, maxProfit := math.MaxInt32, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, price := <span class="keyword">range</span> prices &#123;</span><br><span class="line">        <span class="keyword">if</span> price &lt; minPrice &#123;</span><br><span class="line">            minPrice = price</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> profit := price - minPrice; profit &gt; maxProfit &#123;</span><br><span class="line">            maxProfit = profit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][0]</code> 表示第 <code>i</code> 天不持股的最大利润，<code>dp[i][1]</code> 表示持股的最大利润。</li><li>转移方程：<ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></li><li><code>dp[i][1] = max(dp[i-1][1], -prices[i])</code></li></ul></li></ul></li></ul><h4 id="5-区间-DP"><a href="#5-区间-DP" class="headerlink" title="5. 区间 DP"></a>5. <strong>区间 DP</strong></h4><ul><li><strong>题目</strong>：<a href="https://leetcode.com/problems/longest-palindromic-substring/">5. 最长回文子串</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    start, maxLen := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">2</span>; l &lt;= n; l++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n-l; i++ &#123;</span><br><span class="line">            j := i + l - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                <span class="keyword">if</span> l == <span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> l &gt; maxLen &#123;</span><br><span class="line">                        start, maxLen = i, l</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : start+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>模板总结</strong>：<ul><li>状态定义：<code>dp[i][j]</code> 表示 <code>s[i..j]</code> 是否为回文。</li><li>转移方程：<code>dp[i][j] = (s[i] == s[j]) &amp;&amp; (j-i &lt;= 2 || dp[i+1][j-1])</code>。</li></ul></li></ul><hr><h3 id="二、动态规划通用解题模板（Golang）"><a href="#二、动态规划通用解题模板（Golang）" class="headerlink" title="二、动态规划通用解题模板（Golang）"></a><strong>二、动态规划通用解题模板（Golang）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dpProblem</span><span class="params">(input)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化 DP 数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 边界条件</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = baseCase</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、高频题目推荐"><a href="#三、高频题目推荐" class="headerlink" title="三、高频题目推荐"></a><strong>三、高频题目推荐</strong></h3><ol><li>简单：70（爬楼梯）、198（打家劫舍）、53（最大子数组和）</li><li>中等：322（零钱兑换）、300（最长递增子序列）、139（单词拆分）</li><li>困难：72（编辑距离）、312（戳气球）、10（正则表达式匹配）</li></ol><hr><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a><strong>四、注意事项</strong></h3><ol><li><strong>状态定义</strong>：明确 <code>dp[i]</code> 或 <code>dp[i][j]</code> 的含义。</li><li><strong>转移方程</strong>：分析问题如何分解为子问题。</li><li><strong>空间优化</strong>：滚动数组或逆序更新（如背包问题）。</li><li><strong>边界条件</strong>：如 <code>dp[0]</code> 或 <code>dp[0][0]</code> 的初始化。</li></ol><p>通过练习这些题目并总结模板，可以快速掌握动态规划的核心思想！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划（Dynamic Programming, DP）是算法中的经典题型，LeetCode 上有许多高频题目。以下是常见的 DP 分类、经典题目及 Golang 实现模板总结：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、经典题目分类与-Golang-实现&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】贪心</title>
    <link href="https://leiqi.top/2025-06-17-12ec7942da63.html"/>
    <id>https://leiqi.top/2025-06-17-12ec7942da63.html</id>
    <published>2025-06-17T16:33:41.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法经典题目及Golang实现"><a href="#贪心算法经典题目及Golang实现" class="headerlink" title="贪心算法经典题目及Golang实现"></a>贪心算法经典题目及Golang实现</h1><p>贪心算法是一种在每一步选择中都采取当前状态下最优的选择，从而希望导致全局最优解的算法策略。以下是一些LeetCode上经典的贪心算法题目及其Golang实现，并总结一个通用的解题模板。</p><h2 id="经典贪心题目及Golang实现"><a href="#经典贪心题目及Golang实现" class="headerlink" title="经典贪心题目及Golang实现"></a>经典贪心题目及Golang实现</h2><h3 id="1-分发饼干-455-Assign-Cookies"><a href="#1-分发饼干-455-Assign-Cookies" class="headerlink" title="1. 分发饼干 (455. Assign Cookies)"></a>1. 分发饼干 (455. Assign Cookies)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    </span><br><span class="line">    child, cookie := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> child &lt; <span class="built_in">len</span>(g) &amp;&amp; cookie &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[cookie] &gt;= g[child] &#123;</span><br><span class="line">            child++</span><br><span class="line">        &#125;</span><br><span class="line">        cookie++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-无重叠区间-435-Non-overlapping-Intervals"><a href="#2-无重叠区间-435-Non-overlapping-Intervals" class="headerlink" title="2. 无重叠区间 (435. Non-overlapping Intervals)"></a>2. 无重叠区间 (435. Non-overlapping Intervals)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按结束时间排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    end := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= end &#123;</span><br><span class="line">            count++</span><br><span class="line">            end = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#3-用最少数量的箭引爆气球-452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)"></a>3. 用最少数量的箭引爆气球 (452. Minimum Number of Arrows to Burst Balloons)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    arrows := <span class="number">1</span></span><br><span class="line">    pos := points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; pos &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            pos = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#4-买卖股票的最佳时机-II-122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)"></a>4. 买卖股票的最佳时机 II (122. Best Time to Buy and Sell Stock II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    profit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-跳跃游戏-55-Jump-Game"><a href="#5-跳跃游戏-55-Jump-Game" class="headerlink" title="5. 跳跃游戏 (55. Jump Game)"></a>5. 跳跃游戏 (55. Jump Game)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    farthest := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; farthest &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-跳跃游戏-II-45-Jump-Game-II"><a href="#6-跳跃游戏-II-45-Jump-Game-II" class="headerlink" title="6. 跳跃游戏 II (45. Jump Game II)"></a>6. 跳跃游戏 II (45. Jump Game II)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    jumps, curEnd, farthest := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        farthest = max(farthest, i+nums[i])</span><br><span class="line">        <span class="keyword">if</span> i == curEnd &#123;</span><br><span class="line">            jumps++</span><br><span class="line">            curEnd = farthest</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-加油站-134-Gas-Station"><a href="#7-加油站-134-Gas-Station" class="headerlink" title="7. 加油站 (134. Gas Station)"></a>7. 加油站 (134. Gas Station)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total, curr, start := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gas); i++ &#123;</span><br><span class="line">        total += gas[i] - cost[i]</span><br><span class="line">        curr += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> curr &lt; <span class="number">0</span> &#123;</span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> total &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-任务调度器-621-Task-Scheduler"><a href="#8-任务调度器-621-Task-Scheduler" class="headerlink" title="8. 任务调度器 (621. Task Scheduler)"></a>8. 任务调度器 (621. Task Scheduler)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leastInterval</span><span class="params">(tasks []<span class="type">byte</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    freq := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        freq[t-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(freq)</span><br><span class="line">    </span><br><span class="line">    maxFreq := freq[<span class="number">25</span>]</span><br><span class="line">    idleSlots := (maxFreq - <span class="number">1</span>) * n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; freq[i] &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        idleSlots -= min(freq[i], maxFreq<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> idleSlots &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idleSlots + <span class="built_in">len</span>(tasks)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tasks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法通用模板"><a href="#贪心算法通用模板" class="headerlink" title="贪心算法通用模板"></a>贪心算法通用模板</h2><p>虽然贪心算法没有固定的模板，但通常可以遵循以下步骤：</p><ol><li><strong>排序</strong>：很多贪心问题需要对输入数据进行排序</li><li><strong>初始化</strong>：设置必要的变量（如计数器、指针等）</li><li><strong>遍历处理</strong>：遍历排序后的数据，做出贪心选择</li><li><strong>验证结果</strong>：检查是否满足题目要求</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greedyAlgorithm</span><span class="params">(input []Type)</span></span> ResultType &#123;</span><br><span class="line">    <span class="comment">// 1. 排序（如果需要）</span></span><br><span class="line">    sort.Slice(input, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(input[i], input[j])</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化变量</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    current := initialValue</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 遍历处理</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> input &#123;</span><br><span class="line">        <span class="keyword">if</span> canMakeGreedyChoice(current, item) &#123;</span><br><span class="line">            <span class="comment">// 做出贪心选择</span></span><br><span class="line">            update(current, item)</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法适用场景"><a href="#贪心算法适用场景" class="headerlink" title="贪心算法适用场景"></a>贪心算法适用场景</h2><p>贪心算法通常适用于以下类型的问题：</p><ul><li>可以分解为子问题的问题</li><li>子问题的最优解能递推到最终问题的最优解</li><li>无后效性，即某个状态以后的过程不会影响以前的状态</li></ul><p>常见应用场景包括：</p><ul><li>分配问题（如分发饼干）</li><li>区间问题（如无重叠区间）</li><li>调度问题（如任务调度器）</li><li>股票买卖问题</li><li>跳跃游戏类问题</li></ul><p>贪心算法的关键在于证明贪心策略的正确性，这通常需要数学证明或直观理解。在实际应用中，如果无法确定贪心策略是否正确，可以先尝试，然后验证是否能够得到全局最优解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#贪心算法经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;贪心算法经典题目及Golang实现&quot;&gt;&lt;/a&gt;贪心算法经典题目及Golang实现&lt;/h1&gt;&lt;p&gt;贪心算法是一种在每一</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】优先队列</title>
    <link href="https://leiqi.top/2025-06-17-96c1b8914ef4.html"/>
    <id>https://leiqi.top/2025-06-17-96c1b8914ef4.html</id>
    <published>2025-06-17T16:29:57.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列在LeetCode上的经典题目及Golang实现"><a href="#优先队列在LeetCode上的经典题目及Golang实现" class="headerlink" title="优先队列在LeetCode上的经典题目及Golang实现"></a>优先队列在LeetCode上的经典题目及Golang实现</h1><p>优先队列（Priority Queue）是一种重要的数据结构，它在很多算法问题中都有广泛应用。以下是LeetCode上一些经典的优先队列题目，以及用Golang实现的解决方案和模板总结。</p><h2 id="优先队列的Golang实现"><a href="#优先队列的Golang实现" class="headerlink" title="优先队列的Golang实现"></a>优先队列的Golang实现</h2><p>在Golang中，我们可以使用<code>container/heap</code>包来实现优先队列。首先，我们需要定义一个实现heap.Interface的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个最小堆</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆只需修改Less方法</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 改为大于号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典题目及实现"><a href="#经典题目及实现" class="headerlink" title="经典题目及实现"></a>经典题目及实现</h2><h3 id="1-合并K个升序链表-LeetCode-23"><a href="#1-合并K个升序链表-LeetCode-23" class="headerlink" title="1. 合并K个升序链表 (LeetCode 23)"></a>1. 合并K个升序链表 (LeetCode 23)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h NodeHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *NodeHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    h := &amp;NodeHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有链表的头节点加入堆</span></span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    current := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := heap.Pop(h).(*ListNode)</span><br><span class="line">        current.Next = node</span><br><span class="line">        current = current.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, node.Next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组中的第K个最大元素-LeetCode-215"><a href="#2-数组中的第K个最大元素-LeetCode-215" class="headerlink" title="2. 数组中的第K个最大元素 (LeetCode 215)"></a>2. 数组中的第K个最大元素 (LeetCode 215)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := &amp;MinHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        heap.Push(h, num)</span><br><span class="line">        <span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-前K个高频元素-LeetCode-347"><a href="#3-前K个高频元素-LeetCode-347" class="headerlink" title="3. 前K个高频元素 (LeetCode 347)"></a>3. 前K个高频元素 (LeetCode 347)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> pq[i].count &lt; pq[j].count &#125; <span class="comment">// 最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; pq[i], pq[j] = pq[j], pq[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 统计频率</span></span><br><span class="line">    frequency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        frequency[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建优先队列</span></span><br><span class="line">    pq := &amp;PriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素加入队列</span></span><br><span class="line">    <span class="keyword">for</span> value, count := <span class="keyword">range</span> frequency &#123;</span><br><span class="line">        heap.Push(pq, &amp;Item&#123;value: value, count: count&#125;)</span><br><span class="line">        <span class="keyword">if</span> pq.Len() &gt; k &#123;</span><br><span class="line">            heap.Pop(pq)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集结果</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        result[i] = heap.Pop(pq).(*Item).value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-数据流的中位数-LeetCode-295"><a href="#4-数据流的中位数-LeetCode-295" class="headerlink" title="4. 数据流的中位数 (LeetCode 295)"></a>4. 数据流的中位数 (LeetCode 295)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxHeap *MaxHeap <span class="comment">// 存储较小的一半</span></span><br><span class="line">    minHeap *MinHeap <span class="comment">// 存储较大的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        maxHeap: &amp;MaxHeap&#123;&#125;,</span><br><span class="line">        minHeap: &amp;MinHeap&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 先加入maxHeap</span></span><br><span class="line">    heap.Push(this.maxHeap, num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平衡两个堆</span></span><br><span class="line">    heap.Push(this.minHeap, heap.Pop(this.maxHeap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;</span><br><span class="line">        heap.Push(this.maxHeap, heap.Pop(this.minHeap))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>((*this.maxHeap)[<span class="number">0</span>]+(*this.minHeap)[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列解题模板"><a href="#优先队列解题模板" class="headerlink" title="优先队列解题模板"></a>优先队列解题模板</h2><p>基于以上题目，可以总结出优先队列的通用解题模板：</p><ol><li><p><strong>定义堆类型</strong>：</p><ul><li>实现heap.Interface接口（Len, Less, Swap, Push, Pop方法）</li><li>根据需求决定是最小堆还是最大堆（通过Less方法控制）</li></ul></li><li><p><strong>初始化堆</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;CustomHeap&#123;&#125;</span><br><span class="line">heap.Init(h)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用堆</strong>：</p><ul><li>添加元素：<code>heap.Push(h, element)</code></li><li>弹出元素：<code>heap.Pop(h)</code></li><li>访问堆顶元素（不弹出）：对于最小堆是<code>h[0]</code>，注意要先检查长度</li></ul></li><li><p><strong>常见模式</strong>：</p><ul><li>维护一个大小为K的堆（求前K大&#x2F;小元素）</li><li>使用两个堆维护动态数据流的中位数</li><li>在贪心算法中使用优先队列选择最优解</li></ul></li></ol><h2 id="其他经典优先队列题目"><a href="#其他经典优先队列题目" class="headerlink" title="其他经典优先队列题目"></a>其他经典优先队列题目</h2><ol><li>滑动窗口最大值 (LeetCode 239)</li><li>任务调度器 (LeetCode 621)</li><li>最接近原点的K个点 (LeetCode 973)</li><li>重构字符串 (LeetCode 767)</li><li>网络延迟时间 (LeetCode 743)</li></ol><p>优先队列是解决许多复杂问题的有力工具，特别是在需要动态获取最大&#x2F;最小元素或前K个元素的场景中。掌握其实现和应用模式对算法面试非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;a href=&quot;#优先队列在LeetCode上的经典题目及Golang实现&quot; class=&quot;headerlink&quot; title=&quot;优先队列在LeetCode上的经典题目及Golang实现&quot;&gt;&lt;/a&gt;优先</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】sort.Search二分包</title>
    <link href="https://leiqi.top/2025-06-17-5b0e8e4ea44f.html"/>
    <id>https://leiqi.top/2025-06-17-5b0e8e4ea44f.html</id>
    <published>2025-06-17T16:26:45.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-中二分查找包的使用方法"><a href="#Golang-中二分查找包的使用方法" class="headerlink" title="Golang 中二分查找包的使用方法"></a>Golang 中二分查找包的使用方法</h1><p>Go 标准库中的 <code>sort</code> 包提供了二分查找的功能，主要通过 <code>sort.Search</code> 函数实现。下面详细介绍如何使用这个功能。</p><h3 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 初始化边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span> <span class="comment">// 防止溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">// 找到目标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 调整左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment">// 调整右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeftBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找右边界变体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRightBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            res = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-sort-Search-基本用法"><a href="#1-sort-Search-基本用法" class="headerlink" title="1. sort.Search 基本用法"></a>1. <code>sort.Search</code> 基本用法</h2><p><code>sort.Search</code> 函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure><p>它会在 <code>[0, n)</code> 范围内查找满足 <code>f(i)</code> 为 <code>true</code> 的最小索引 <code>i</code>。如果不存在这样的索引，则返回 <code>n</code>。</p><h3 id="基本示例：在有序切片中查找元素"><a href="#基本示例：在有序切片中查找元素" class="headerlink" title="基本示例：在有序切片中查找元素"></a>基本示例：在有序切片中查找元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找目标值的索引</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-查找特定条件的元素"><a href="#2-查找特定条件的元素" class="headerlink" title="2. 查找特定条件的元素"></a>2. 查找特定条件的元素</h2><p><code>sort.Search</code> 的强大之处在于可以查找满足任意条件的第一个元素。</p><h3 id="示例：查找第一个大于等于目标值的元素"><a href="#示例：查找第一个大于等于目标值的元素" class="headerlink" title="示例：查找第一个大于等于目标值的元素"></a>示例：查找第一个大于等于目标值的元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;第一个大于等于 %d 的元素是 %d，索引为 %d\n&quot;</span>, target, nums[index], index)</span><br></pre></td></tr></table></figure><h3 id="示例：查找第一个满足条件的偶数"><a href="#示例：查找第一个满足条件的偶数" class="headerlink" title="示例：查找第一个满足条件的偶数"></a>示例：查找第一个满足条件的偶数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i]%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;第一个偶数是 %d，索引为 %d\n&quot;</span>, nums[index], index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;没有找到偶数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-自定义类型的二分查找"><a href="#3-自定义类型的二分查找" class="headerlink" title="3. 自定义类型的二分查找"></a>3. 自定义类型的二分查找</h2><p>对于自定义类型，需要先实现 <code>sort.Interface</code> 接口，然后才能使用 <code>sort.Search</code>。</p><h3 id="示例：自定义结构体切片查找"><a href="#示例：自定义结构体切片查找" class="headerlink" title="示例：自定义结构体切片查找"></a>示例：自定义结构体切片查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := ByAge&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先排序</span></span><br><span class="line">    sort.Sort(people)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找年龄大于等于 33 的第一个人</span></span><br><span class="line">    targetAge := <span class="number">33</span></span><br><span class="line">    index := sort.Search(<span class="built_in">len</span>(people), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &gt;= targetAge</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(people) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;找到 %+v，索引为 %d\n&quot;</span>, people[index], index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有找到满足条件的人&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-查找浮点数近似值"><a href="#4-查找浮点数近似值" class="headerlink" title="4. 查找浮点数近似值"></a>4. 查找浮点数近似值</h2><p><code>sort.Search</code> 也可以用于浮点数近似查找。</p><h3 id="示例：查找平方根近似值"><a href="#示例：查找平方根近似值" class="headerlink" title="示例：查找平方根近似值"></a>示例：查找平方根近似值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 设置精度</span></span><br><span class="line">    precision := <span class="number">1e-6</span></span><br><span class="line">    low, high := <span class="number">0.0</span>, x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用二分查找逼近平方根</span></span><br><span class="line">    <span class="keyword">for</span> high-low &gt; precision &#123;</span><br><span class="line">        mid := (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid*mid &lt; x &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (low + high) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;√2 ≈&quot;</span>, sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-查找切片中的插入位置"><a href="#5-查找切片中的插入位置" class="headerlink" title="5. 查找切片中的插入位置"></a>5. 查找切片中的插入位置</h2><p><code>sort.Search</code> 非常适合用来查找元素应该插入的位置。</p><h3 id="示例：查找插入位置"><a href="#示例：查找插入位置" class="headerlink" title="示例：查找插入位置"></a>示例：查找插入位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">6</span></span><br><span class="line"></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d 应该插入到索引 %d 的位置\n&quot;</span>, target, index)</span><br><span class="line"><span class="comment">// 输出: 6 应该插入到索引 3 的位置</span></span><br></pre></td></tr></table></figure><h2 id="6-标准库中的其他相关函数"><a href="#6-标准库中的其他相关函数" class="headerlink" title="6. 标准库中的其他相关函数"></a>6. 标准库中的其他相关函数</h2><p>除了 <code>sort.Search</code>，标准库还提供了：</p><ul><li><code>sort.SearchInts(a []int, x int) int</code> - 在已排序的 int 切片中查找 x</li><li><code>sort.SearchFloat64s(a []float64, x float64) int</code> - 在已排序的 float64 切片中查找 x</li><li><code>sort.SearchStrings(a []string, x string) int</code> - 在已排序的 string 切片中查找 x</li></ul><h3 id="示例：使用-sort-SearchInts"><a href="#示例：使用-sort-SearchInts" class="headerlink" title="示例：使用 sort.SearchInts"></a>示例：使用 <code>sort.SearchInts</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">target := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">index := sort.SearchInts(nums, target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[index] == target &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;找到 %d，索引为 %d\n&quot;</span>, target, index)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;未找到 %d\n&quot;</span>, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-性能考虑"><a href="#7-性能考虑" class="headerlink" title="7. 性能考虑"></a>7. 性能考虑</h2><p><code>sort.Search</code> 的时间复杂度是 O(log n)，因为它使用的是二分查找算法。但需要注意：</p><ol><li>切片必须是已排序的，否则结果不可靠</li><li>比较函数 <code>f</code> 应该尽可能简单高效</li><li>对于非常大的数据集，考虑内存局部性和缓存效应</li></ol><h2 id="8-实际应用示例"><a href="#8-实际应用示例" class="headerlink" title="8. 实际应用示例"></a>8. 实际应用示例</h2><h3 id="示例：实现类似-C-的-lower-bound-和-upper-bound"><a href="#示例：实现类似-C-的-lower-bound-和-upper-bound" class="headerlink" title="示例：实现类似 C++ 的 lower_bound 和 upper_bound"></a>示例：实现类似 C++ 的 lower_bound 和 upper_bound</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowerBound 返回第一个 &gt;= target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowerBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upperBound 返回第一个 &gt; target 的元素的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upperBound</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    target := <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    lb := lowerBound(nums, target)</span><br><span class="line">    ub := upperBound(nums, target)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;lowerBound: %d, upperBound: %d\n&quot;</span>, lb, ub)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;元素 %d 的出现次数: %d\n&quot;</span>, target, ub-lb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-中二分查找包的使用方法&quot;&gt;&lt;a href=&quot;#Golang-中二分查找包的使用方法&quot; class=&quot;headerlink&quot; title=&quot;Golang 中二分查找包的使用方法&quot;&gt;&lt;/a&gt;Golang 中二分查找包的使用方法&lt;/h1&gt;&lt;p&gt;Go 标准库</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】DFS</title>
    <link href="https://leiqi.top/2025-06-17-8ecaae2ca2b5.html"/>
    <id>https://leiqi.top/2025-06-17-8ecaae2ca2b5.html</id>
    <published>2025-06-17T16:21:34.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结"><a href="#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结" class="headerlink" title="LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结"></a>LeetCode 上经典的 DFS 题目及 Golang 实现与模板总结</h1><p>DFS（深度优先搜索）是算法面试中的常见题型，下面我将总结 LeetCode 上一些经典的 DFS 题目，并用 Golang 实现，最后提炼出通用的 DFS 解题模板。</p><h2 id="经典-DFS-题目分类及-Golang-实现"><a href="#经典-DFS-题目分类及-Golang-实现" class="headerlink" title="经典 DFS 题目分类及 Golang 实现"></a>经典 DFS 题目分类及 Golang 实现</h2><h3 id="1-二叉树遍历类"><a href="#1-二叉树遍历类" class="headerlink" title="1. 二叉树遍历类"></a>1. 二叉树遍历类</h3><h4 id="题目-94-二叉树的中序遍历"><a href="#题目-94-二叉树的中序遍历" class="headerlink" title="题目 94. 二叉树的中序遍历"></a>题目 94. 二叉树的中序遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-排列组合类"><a href="#2-排列组合类" class="headerlink" title="2. 排列组合类"></a>2. 排列组合类</h3><h4 id="题目-46-全排列"><a href="#题目-46-全排列" class="headerlink" title="题目 46. 全排列"></a>题目 46. 全排列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[i] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            dfs(path)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-岛屿问题类"><a href="#3-岛屿问题类" class="headerlink" title="3. 岛屿问题类"></a>3. 岛屿问题类</h3><h4 id="题目-200-岛屿数量"><a href="#题目-200-岛屿数量" class="headerlink" title="题目 200. 岛屿数量"></a>题目 200. 岛屿数量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-回溯类问题"><a href="#4-回溯类问题" class="headerlink" title="4. 回溯类问题"></a>4. 回溯类问题</h3><h4 id="题目-39-组合总和"><a href="#题目-39-组合总和" class="headerlink" title="题目 39. 组合总和"></a>题目 39. 组合总和</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            dfs(i, path, sum+candidates[i])</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, []<span class="type">int</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Golang-DFS-通用模板"><a href="#Golang-DFS-通用模板" class="headerlink" title="Golang DFS 通用模板"></a>Golang DFS 通用模板</h2><p>根据以上题目，可以总结出 DFS 的通用模板：</p><h3 id="递归回溯模板"><a href="#递归回溯模板" class="headerlink" title="递归回溯模板"></a>递归回溯模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">problemFunction</span><span class="params">(params)</span></span> [][]resultType &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]resultType</span><br><span class="line">    <span class="comment">// 可能需要 visited 数组或其他辅助数据结构</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(path []resultType, otherParams...)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> meetCondition &#123;</span><br><span class="line">            <span class="comment">// 可能需要深拷贝 path</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]resultType, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> _, choice := <span class="keyword">range</span> choices &#123;</span><br><span class="line">            <span class="comment">// 剪枝：跳过不满足条件的选项</span></span><br><span class="line">            <span class="keyword">if</span> !isValid(choice) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, choice)</span><br><span class="line">            markAsVisited(choice)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            dfs(path, updatedParams...)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            markAsUnvisited(choice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(initialPath, initialParams...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格-矩阵DFS模板"><a href="#网格-矩阵DFS模板" class="headerlink" title="网格&#x2F;矩阵DFS模板"></a>网格&#x2F;矩阵DFS模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gridProblem</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] != targetValue &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记已访问</span></span><br><span class="line">        grid[i][j] = markedValue</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四个方向扩散</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要8个方向，可以加上对角线方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历整个网格</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == targetValue &#123;</span><br><span class="line">                count++</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他经典DFS题目推荐"><a href="#其他经典DFS题目推荐" class="headerlink" title="其他经典DFS题目推荐"></a>其他经典DFS题目推荐</h2><ol><li><ol start="78"><li>子集</li></ol></li><li><ol start="17"><li>电话号码的字母组合</li></ol></li><li><ol start="79"><li>单词搜索</li></ol></li><li><ol start="207"><li>课程表 (拓扑排序)</li></ol></li><li><ol start="437"><li>路径总和 III</li></ol></li><li><ol start="494"><li>目标和</li></ol></li><li><ol start="695"><li>岛屿的最大面积</li></ol></li><li><ol start="733"><li>图像渲染</li></ol></li><li><ol start="113"><li>路径总和 II</li></ol></li><li><ol start="129"><li>求根到叶子节点数字和</li></ol></li></ol><p>DFS的关键在于理解递归的思想，明确递归的终止条件，以及在递归前后做好状态的保存和恢复（回溯）。掌握这些模板后，可以解决大部分DFS相关问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot;&gt;&lt;a href=&quot;#LeetCode-上经典的-DFS-题目及-Golang-实现与模板总结&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 上经典的 DFS 题目</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】BFS</title>
    <link href="https://leiqi.top/2025-06-17-e53745bb0899.html"/>
    <id>https://leiqi.top/2025-06-17-e53745bb0899.html</id>
    <published>2025-06-17T16:12:10.000Z</published>
    <updated>2025-07-31T15:33:02.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-BFS-练习题单与模板总结-Golang-实现"><a href="#LeetCode-BFS-练习题单与模板总结-Golang-实现" class="headerlink" title="LeetCode BFS 练习题单与模板总结 (Golang 实现)"></a>LeetCode BFS 练习题单与模板总结 (Golang 实现)</h1><p>BFS（广度优先搜索）是一种重要的图遍历算法，特别适合解决最短路径、层次遍历等问题。以下是 Golang 实现的 BFS 模板和分类练习题单。</p><h2 id="BFS-通用模板-Golang"><a href="#BFS-通用模板-Golang" class="headerlink" title="BFS 通用模板 (Golang)"></a>BFS 通用模板 (Golang)</h2><h3 id="1-树的-BFS-模板"><a href="#1-树的-BFS-模板" class="headerlink" title="1. 树的 BFS 模板"></a>1. 树的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">        currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, levelSize)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            currentLevel = <span class="built_in">append</span>(currentLevel, node.Val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-图的-BFS-模板"><a href="#2-图的-BFS-模板" class="headerlink" title="2. 图的 BFS 模板"></a>2. 图的 BFS 模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsGraph</span><span class="params">(start Node)</span></span> []Node &#123;</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[Node]<span class="type">bool</span>)</span><br><span class="line">    visited[start] = <span class="literal">true</span></span><br><span class="line">    queue := []Node&#123;start&#125;</span><br><span class="line">    result := []Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, node)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> getNeighbors(node) &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-BFS-练习题单-Golang"><a href="#LeetCode-BFS-练习题单-Golang" class="headerlink" title="LeetCode BFS 练习题单 (Golang)"></a>LeetCode BFS 练习题单 (Golang)</h2><h3 id="基础练习"><a href="#基础练习" class="headerlink" title="基础练习"></a>基础练习</h3><ol><li><p><strong>二叉树的层次遍历</strong></p><ul><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></li><li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li><li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N叉树的层序遍历</a></li></ul></li><li><p><strong>简单图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/number-of-islands/">200. 岛屿数量</a></li><li><a href="https://leetcode.com/problems/flood-fill/">733. 图像渲染</a></li><li><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></li></ul></li></ol><h3 id="进阶练习"><a href="#进阶练习" class="headerlink" title="进阶练习"></a>进阶练习</h3><ol><li><p><strong>最短路径问题</strong></p><ul><li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li><li><a href="https://leetcode.com/problems/open-the-lock/">752. 打开转盘锁</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></li><li><a href="https://leetcode.com/problems/01-matrix/">542. 01 矩阵</a></li></ul></li><li><p><strong>复杂图&#x2F;BFS应用</strong></p><ul><li><a href="https://leetcode.com/problems/word-ladder/">127. 单词接龙</a></li><li><a href="https://leetcode.com/problems/clone-graph/">133. 克隆图</a></li><li><a href="https://leetcode.com/problems/minimum-height-trees/">310. 最小高度树</a></li></ul></li><li><p><strong>多源BFS</strong></p><ul><li><a href="https://leetcode.com/problems/rotting-oranges/">994. 腐烂的橘子</a></li><li><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a> (付费题)</li></ul></li></ol><h3 id="困难级别挑战"><a href="#困难级别挑战" class="headerlink" title="困难级别挑战"></a>困难级别挑战</h3><ol><li><a href="https://leetcode.com/problems/bus-routes/">815. 公交路线</a></li><li><a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></li></ol><h2 id="Golang-BFS-实现技巧"><a href="#Golang-BFS-实现技巧" class="headerlink" title="Golang BFS 实现技巧"></a>Golang BFS 实现技巧</h2><ol><li><p><strong>队列实现</strong>：Golang 中可以用 slice 实现队列，但要注意 dequeue 操作是 O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:] <span class="comment">// 这会创建新的 slice，可能影响性能</span></span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong>：对于大型队列，可以使用链表或固定大小的循环队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes []*TreeNode</span><br><span class="line">    head  <span class="type">int</span></span><br><span class="line">    tail  <span class="type">int</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>visited 记录</strong>：对于图问题，使用 map 记录已访问节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>方向数组</strong>：处理网格问题时很有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例题解：200-岛屿数量-Golang"><a href="#示例题解：200-岛屿数量-Golang" class="headerlink" title="示例题解：200. 岛屿数量 (Golang)"></a>示例题解：200. 岛屿数量 (Golang)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                queue := [][]<span class="type">int</span>&#123;&#123;i, j&#125;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    cell := queue[<span class="number">0</span>]</span><br><span class="line">                    queue = queue[<span class="number">1</span>:]</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                        x, y := cell[<span class="number">0</span>]+dir[<span class="number">0</span>], cell[<span class="number">1</span>]+dir[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                            grid[x][y] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                            queue = <span class="built_in">append</span>(queue, []<span class="type">int</span>&#123;x, y&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-BFS-练习题单与模板总结-Golang-实现&quot;&gt;&lt;a href=&quot;#LeetCode-BFS-练习题单与模板总结-Golang-实现&quot; class=&quot;headerlink&quot; title=&quot;LeetCode BFS 练习题单与模板总结 (Gola</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】滑动窗口</title>
    <link href="https://leiqi.top/2025-06-17-d8f0a4d6b8c7.html"/>
    <id>https://leiqi.top/2025-06-17-d8f0a4d6b8c7.html</id>
    <published>2025-06-17T15:52:02.000Z</published>
    <updated>2025-07-31T15:33:02.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-滑动窗口模板与套路详解"><a href="#Golang-滑动窗口模板与套路详解" class="headerlink" title="Golang 滑动窗口模板与套路详解"></a>Golang 滑动窗口模板与套路详解</h1><p>针对 LeetCode 1004（最大连续1的个数 III）这类问题，以下是专门为 Golang 开发者准备的滑动窗口实现模板、适用场景和常见变种：</p><h2 id="Golang-滑动窗口模板（1004-类型）"><a href="#Golang-滑动窗口模板（1004-类型）" class="headerlink" title="Golang 滑动窗口模板（1004 类型）"></a>Golang 滑动窗口模板（1004 类型）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, maxLen, zeroCount := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        <span class="comment">// 1. 右指针移动：更新窗口状态</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span> &#123;</span><br><span class="line">            zeroCount++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 左指针移动：当窗口不合法时收缩</span></span><br><span class="line">        <span class="keyword">for</span> zeroCount &gt; k &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span> &#123;</span><br><span class="line">                zeroCount--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 更新结果（此时窗口合法）</span></span><br><span class="line">        <span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心套路与技巧（Golang-实现）"><a href="#核心套路与技巧（Golang-实现）" class="headerlink" title="核心套路与技巧（Golang 实现）"></a>核心套路与技巧（Golang 实现）</h2><ol><li><p><strong>双指针初始化</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">maxLen := <span class="number">0</span></span><br><span class="line">counter := <span class="number">0</span> <span class="comment">// 根据问题定义计数器</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右指针移动逻辑</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">    <span class="comment">// 更新计数器</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[right]) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>窗口收缩条件</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> counter &gt; k &#123; <span class="comment">// k 是允许的阈值</span></span><br><span class="line">    <span class="keyword">if</span> condition(nums[left]) &#123;</span><br><span class="line">        counter--</span><br><span class="line">    &#125;</span><br><span class="line">    left++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>结果更新</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> windowSize := right - left + <span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">    maxLen = windowSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Golang-常见变种实现"><a href="#Golang-常见变种实现" class="headerlink" title="Golang 常见变种实现"></a>Golang 常见变种实现</h2><h3 id="1-替换后的最长重复字符（LeetCode-424）"><a href="#1-替换后的最长重复字符（LeetCode-424）" class="headerlink" title="1. 替换后的最长重复字符（LeetCode 424）"></a>1. 替换后的最长重复字符（LeetCode 424）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">characterReplacement</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    left, maxCount, maxLen := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        count[ch-<span class="string">&#x27;A&#x27;</span>]++</span><br><span class="line">        <span class="keyword">if</span> count[ch-<span class="string">&#x27;A&#x27;</span>] &gt; maxCount &#123;</span><br><span class="line">            maxCount = count[ch-<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：窗口大小 - 最大计数 &gt; k</span></span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>)-maxCount &gt; k &#123;</span><br><span class="line">            count[s[left]-<span class="string">&#x27;A&#x27;</span>]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxLen &#123;</span><br><span class="line">            maxLen = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-水果成篮（LeetCode-904）"><a href="#2-水果成篮（LeetCode-904）" class="headerlink" title="2. 水果成篮（LeetCode 904）"></a>2. 水果成篮（LeetCode 904）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    basket := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    left, maxFruits := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right, fruit := <span class="keyword">range</span> fruits &#123;</span><br><span class="line">        basket[fruit]++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收缩条件：水果种类超过2种</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(basket) &gt; <span class="number">2</span> &#123;</span><br><span class="line">            basket[fruits[left]]--</span><br><span class="line">            <span class="keyword">if</span> basket[fruits[left]] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(basket, fruits[left])</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> windowSize := right-left+<span class="number">1</span>; windowSize &gt; maxFruits &#123;</span><br><span class="line">            maxFruits = windowSize</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxFruits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最小覆盖子串（LeetCode-76）"><a href="#3-最小覆盖子串（LeetCode-76）" class="headerlink" title="3. 最小覆盖子串（LeetCode 76）"></a>3. 最小覆盖子串（LeetCode 76）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> t &#123;</span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left, valid := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    start, length := <span class="number">0</span>, math.MaxInt32</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="keyword">if</span> _, exists := need[c]; exists &#123;</span><br><span class="line">            window[c]++</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当窗口满足条件时尝试收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> right-left+<span class="number">1</span> &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 收缩窗口</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _, exists := need[d]; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> length == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : start+length]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口适用场景总结"><a href="#滑动窗口适用场景总结" class="headerlink" title="滑动窗口适用场景总结"></a>滑动窗口适用场景总结</h2><table><thead><tr><th>问题特征</th><th>示例题目</th><th>Golang 实现要点</th></tr></thead><tbody><tr><td><strong>有限修改连续序列</strong></td><td>1004, 424, 2024</td><td>使用计数器跟踪修改需求</td></tr><tr><td><strong>不同元素数量限制</strong></td><td>904, 340</td><td>使用 map 跟踪元素种类</td></tr><tr><td><strong>最短满足条件子串</strong></td><td>209, 76</td><td>收缩时更新最小值</td></tr><tr><td><strong>固定窗口大小</strong></td><td>643, 1343</td><td>维护固定大小的窗口</td></tr><tr><td><strong>无重复字符</strong></td><td>3, 159</td><td>使用 map 或 set 检测重复</td></tr></tbody></table><h2 id="Golang-实现技巧"><a href="#Golang-实现技巧" class="headerlink" title="Golang 实现技巧"></a>Golang 实现技巧</h2><ol><li><p><strong>计数器选择</strong>：</p><ul><li>简单计数：<code>int</code> 变量</li><li>字符频率：<code>[26]int</code> 或 <code>[128]int</code></li><li>通用元素：<code>map[type]int</code></li></ul></li><li><p><strong>边界处理</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理空输入情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>性能优化</strong>：</p><ul><li>避免不必要的内存分配（预分配 map 大小）</li><li>使用数组代替 map 当键范围有限时</li><li>减少循环内部的计算</li></ul></li><li><p><strong>复杂条件处理</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用辅助函数判断窗口合法性</span></span><br><span class="line"><span class="keyword">for</span> !isValid(window, condition) &#123;</span><br><span class="line">    <span class="comment">// 收缩窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>掌握这些 Golang 实现的滑动窗口模式和变种，能高效解决 LeetCode 上大部分滑动窗口问题。关键是根据问题特征选择合适的计数器类型和窗口收缩条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-滑动窗口模板与套路详解&quot;&gt;&lt;a href=&quot;#Golang-滑动窗口模板与套路详解&quot; class=&quot;headerlink&quot; title=&quot;Golang 滑动窗口模板与套路详解&quot;&gt;&lt;/a&gt;Golang 滑动窗口模板与套路详解&lt;/h1&gt;&lt;p&gt;针对 Lee</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】slice append 和copy对比</title>
    <link href="https://leiqi.top/2025-06-16-fa2f5d4a144d.html"/>
    <id>https://leiqi.top/2025-06-16-fa2f5d4a144d.html</id>
    <published>2025-06-16T15:53:12.000Z</published>
    <updated>2025-07-31T15:33:02.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, info)</span><br><span class="line"><span class="built_in">copy</span>(result[info[<span class="number">1</span>] +<span class="number">1</span>:], result[info[<span class="number">1</span>]:])<span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">result[info[<span class="number">1</span>]] = info<span class="comment">//将插入元素位置插入元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unc reconstructQueue(people [][]<span class="type">int</span>) [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//先将身高从大到小排序，确定最大个子的相对位置</span></span><br><span class="line">    sort.Slice(people,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>]==people[j][<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>]&lt;people[j][<span class="number">1</span>]<span class="comment">//这个才是当身高相同时，将K按照从小到大排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>]&gt;people[j][<span class="number">0</span>]<span class="comment">//这个只是确保身高按照由大到小的顺序来排，并不确定K是按照从小到大排序的</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//再按照K进行插入排序，优先插入K小的</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, info)</span><br><span class="line">pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 在 pos 处分割并拼接</span></span><br><span class="line">        result[pos] = info      <span class="comment">//将插入位置之后的元素后移动一位（意思是腾出空间）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020250616235439.png"><br>两个 <code>reconstructQueue</code> 函数的主要区别在于 <strong>插入元素的方式</strong>，而第二个版本能通过是因为它正确处理了 <strong>切片的动态扩容和元素移动</strong></p><hr><h3 id="关键问题分析"><a href="#关键问题分析" class="headerlink" title="关键问题分析"></a><strong>关键问题分析</strong></h3><h4 id="1-第一个版本的问题（Slice-操作）"><a href="#1-第一个版本的问题（Slice-操作）" class="headerlink" title="1. 第一个版本的问题（Slice 操作）"></a>1. <strong>第一个版本的问题（Slice 操作）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line">pos := info[<span class="number">1</span>]</span><br><span class="line">result = <span class="built_in">append</span>(result[:pos+<span class="number">1</span>], result[pos:]...)  <span class="comment">// 尝试在 pos 处腾出位置</span></span><br><span class="line">result[pos] = info                     <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：</p><ul><li><strong><code>append(result[:pos+1], result[pos:]...)</code> 会导致数据错乱</strong><br>当 <code>pos</code> 不是最后一个位置时，<code>result[pos:]</code> 会包含刚刚追加的 <code>info</code>（因为上一步 <code>append(result, info)</code> 已经增加了长度），导致切片拼接时重复复制元素，最终结果错误。</li></ul><h4 id="2-第二个版本的正确性（copy-操作）"><a href="#2-第二个版本的正确性（copy-操作）" class="headerlink" title="2. 第二个版本的正确性（copy 操作）"></a>2. <strong>第二个版本的正确性（copy 操作）</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">append</span>(result, info)          <span class="comment">// 先追加元素（长度+1）</span></span><br><span class="line"><span class="built_in">copy</span>(result[info[<span class="number">1</span>]+<span class="number">1</span>:], result[info[<span class="number">1</span>]:]) <span class="comment">// 正确后移元素</span></span><br><span class="line">result[info[<span class="number">1</span>]] = info                 <span class="comment">// 插入元素</span></span><br></pre></td></tr></table></figure><p><strong>为什么正确</strong>：</p><ul><li><code>copy</code> <strong>直接覆盖内存</strong>，不会因 <code>append</code> 的嵌套调用引发数据错乱。</li><li>逻辑清晰：先扩展切片，再移动元素，最后插入新值。</li></ul><hr><h3 id="修复第一个版本的方法"><a href="#修复第一个版本的方法" class="headerlink" title="修复第一个版本的方法"></a><strong>修复第一个版本的方法</strong></h3><p>如果仍想用 <strong>Slice 操作</strong>，需避免提前追加元素，改为直接插入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> people[i][<span class="number">0</span>] == people[j][<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> people[i][<span class="number">1</span>] &lt; people[j][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i][<span class="number">0</span>] &gt; people[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> people &#123;</span><br><span class="line">        pos := info[<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">append</span>(result[:pos], <span class="built_in">append</span>([][]<span class="type">int</span>&#123;info&#125;, result[pos:]...)...) <span class="comment">// 直接插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键修改</strong>：</p><ul><li>使用 <code>append([][]int&#123;info&#125;, result[pos:]...)</code> 一次性完成插入，避免提前扩展切片。</li></ul><hr><h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a><strong>两种方式的对比</strong></h3><table><thead><tr><th>操作方式</th><th>代码示例</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>copy</strong></td><td><code>copy(result[pos+1:], result[pos:])</code></td><td>内存操作直接，不易出错</td><td>代码稍显冗长</td></tr><tr><td><strong>Slice 拼接</strong></td><td><code>append(result[:pos], append([][]int&#123;info&#125;, result[pos:]...)...)</code></td><td>代码简洁</td><td>嵌套 <code>append</code> 可读性略低</td></tr></tbody></table><hr><h3 id="为什么第二个版本更鲁棒？"><a href="#为什么第二个版本更鲁棒？" class="headerlink" title="为什么第二个版本更鲁棒？"></a><strong>为什么第二个版本更鲁棒？</strong></h3><ol><li><strong><code>copy</code> 是底层内存复制</strong><br>不会受切片共享或嵌套 <code>append</code> 的影响，适合需要精确控制内存的场景。</li><li><strong><code>append</code> 的嵌套可能导致临时切片</strong><br>在复杂逻辑中容易引入错误（如你的第一个版本）。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>推荐使用 <code>copy</code> 的版本</strong>：逻辑清晰，适合大多数场景。</li><li>如果追求代码简洁，可以用修复后的 <strong>Slice 拼接</strong>，但需注意 <code>append</code> 的副作用。</li></ul><blockquote><p><strong>关键教训</strong>：在操作切片时，**避免在同一个逻辑块中混合多次 <code>append</code>**，除非你能确保切片长度的变化不会影响后续操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正确&quot;&gt;&lt;a href=&quot;#正确&quot; class=&quot;headerlink&quot; title=&quot;正确&quot;&gt;&lt;/a&gt;正确&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 switch使用</title>
    <link href="https://leiqi.top/2025-06-16-ba6b39f2d873.html"/>
    <id>https://leiqi.top/2025-06-16-ba6b39f2d873.html</id>
    <published>2025-06-16T15:23:08.000Z</published>
    <updated>2025-07-31T15:33:02.554Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，<code>switch</code> 语句提供了灵活的条件分支控制，相比其他语言有更多特性。以下是详细用法和示例：</p><hr><h3 id="1-基础值匹配"><a href="#1-基础值匹配" class="headerlink" title="1. 基础值匹配"></a>1. <strong>基础值匹配</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">day := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> day &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Wednesday&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Thursday&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Weekend&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-多值匹配（逗号分隔）"><a href="#2-多值匹配（逗号分隔）" class="headerlink" title="2. 多值匹配（逗号分隔）"></a>2. <strong>多值匹配（逗号分隔）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char := <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Vowel&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sometimes vowel&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Consonant&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-无表达式（替代-if-else）"><a href="#3-无表达式（替代-if-else）" class="headerlink" title="3. 无表达式（替代 if-else）"></a>3. <strong>无表达式（替代 if-else）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score := <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">80</span>: <span class="comment">// 满足条件</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;B&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-类型判断（Type-Switch）"><a href="#4-类型判断（Type-Switch）" class="headerlink" title="4. 类型判断（Type Switch）"></a>4. <strong>类型判断（Type Switch）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">switch</span> v := data.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Integer:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;String:&quot;</span>, v) <span class="comment">// 输出: String: hello</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unknown type&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-穿透执行（fallthrough）"><a href="#5-穿透执行（fallthrough）" class="headerlink" title="5. 穿透执行（fallthrough）"></a>5. <strong>穿透执行（fallthrough）</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;One&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Two&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">fallthrough</span>        <span class="comment">// 强制执行下一个 case</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Three&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Two\nThree</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-初始化语句"><a href="#6-初始化语句" class="headerlink" title="6. 初始化语句"></a>6. <strong>初始化语句</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> lang := <span class="string">&quot;Go&quot;</span>; lang &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Java&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Enterprise&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Go&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Efficient&quot;</span>) <span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关键特性总结："><a href="#关键特性总结：" class="headerlink" title="关键特性总结："></a>关键特性总结：</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>自动终止</strong></td><td>无需 <code>break</code>，执行完 case 后自动退出 switch</td></tr><tr><td><strong>多值匹配</strong></td><td>用逗号分隔多个值（如 <code>case 1, 2, 3</code>）</td></tr><tr><td><strong>无表达式模式</strong></td><td>类似 <code>if-else</code> 链，更简洁的条件分支</td></tr><tr><td><strong>类型判断</strong></td><td>通过 <code>data.(type)</code> 检测接口值的实际类型</td></tr><tr><td><strong>fallthrough</strong></td><td>显式声明继续执行下一个 case（<strong>不判断条件</strong>）</td></tr><tr><td><strong>作用域隔离</strong></td><td>支持在 <code>switch</code> 后初始化局部变量（如 <code>switch x := 10; &#123; ... &#125;</code>）</td></tr></tbody></table><hr><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> hour := time.Now().Hour(); &#123;</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Morning&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> hour &lt; <span class="number">18</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Afternoon&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Night&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 的 <code>switch</code> 设计强调简洁和安全，避免 C&#x2F;C++ 中因忘记 <code>break</code> 导致的错误。根据场景选择合适用法可大幅提升代码可读性。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，&lt;code&gt;switch&lt;/code&gt; 语句提供了灵活的条件分支控制，相比其他语言有更多特性。以下是详细用法和示例：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-基础值匹配&quot;&gt;&lt;a href=&quot;#1-基础值匹配&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】Golang 新手可能会踩的 50 个坑</title>
    <link href="https://leiqi.top/2025-06-15-bd60604455f8.html"/>
    <id>https://leiqi.top/2025-06-15-bd60604455f8.html</id>
    <published>2025-06-15T16:58:17.000Z</published>
    <updated>2025-07-31T15:33:02.554Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://github.com/wuYin">wuYin</a>&#x2F;<a href="https://github.com/wuYin/blog">blog</a> </p><p>原文：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">50 Shades of Go: Traps, Gotchas, and Common Mistakes</a>，翻译已获作者 <a href="https://twitter.com/kcqon">kcqon</a> 授权。</p><span id="more"></span><p>不久前发现在知乎这篇质量很高的文章，打算加上自己的理解翻译一遍。文章分为三部分：初级篇 1-34，中级篇 35-50，高级篇 51-57</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p><p>如果花时间学习官方 doc、wiki、<a href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p><h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-一般不能单独放一行"><a href="#1-左大括号-一般不能单独放一行" class="headerlink" title="1. 左大括号 { 一般不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 一般不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;<span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>.&#x2F;main.go: missing function body<br>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>注意代码块等特殊情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; 并不遵守分号注入规则，不会在其后边自动加分，此时可换行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="http://blog.csdn.net/icyday/article/details/8265864?hmsr=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">Golang中自动加分号的特殊分隔符</a></p><h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p><p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span> <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> one <span class="type">int</span> <span class="comment">// error: one declared and not used</span></span><br><span class="line">two := <span class="number">2</span><span class="comment">// error: two declared and not used</span></span><br><span class="line"><span class="keyword">var</span> three <span class="type">int</span><span class="comment">// error: three declared and not used</span></span><br><span class="line">three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">_ = one</span><br><span class="line"></span><br><span class="line">two := <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">one = three</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p><p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span><span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span><span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span><span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = log.Println</span><br><span class="line">_ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span><span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">one := <span class="number">0</span></span><br><span class="line">one, two := <span class="number">1</span>, <span class="number">2</span><span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">one, two = two, one<span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data info</span><br><span class="line">data.result, err := work()<span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data info</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span><span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">data.result, err = work()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p><p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">x := <span class="number">2</span></span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 2// 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(x)<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Go 开发者常犯的错，而且不易被发现。</p><p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go tool vet -shadow main.go</span></span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure><p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$GOPATH</span>/bin/go-nyet main.go</span></span><br><span class="line">main.go:10:3:Shadowing variable `x`</span><br></pre></td></tr></table></figure><h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span><span class="comment">// error: use of untyped nil</span></span><br><span class="line">_ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">_ = x</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span><span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="built_in">cap</span>(m)) <span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11.  string 类型的变量值不能为 nil"></a>11.  string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span><span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;<span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">s = <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span><span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">s = <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p><p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;(x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [1 2 3]// 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想修改参数数组：</p><ul><li>直接传递指向这个数组的指针类型：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">(*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr)<span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">&#125;(&amp;x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;(x)</span><br><span class="line">fmt.Println(x)<span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">fmt.Println(v)<span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;<span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p><p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p><p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p><ol><li><p>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</p></li><li><p>使用“独立”的切片分两步：</p></li></ol><ul><li><p>创建外部 slice</p><ul><li><p>对每个内部 slice 进行内存分配</p><p>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">2</span></span><br><span class="line">y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line"><span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用“共享底层数组”的切片</li></ol><ul><li><p>创建一个存放原始数据的容器 slice</p></li><li><p>创建其他的 slice</p></li><li><p>切割原始 slice 来初始化其他的 slice</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">raw[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化原始 slice</span></span><br><span class="line">fmt.Println(raw, &amp;raw[<span class="number">4</span>])<span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120 </span></span><br><span class="line">    </span><br><span class="line">table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">table[i] = raw[i*w : i*w + w]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])<span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于多维数组的参考</p><p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p><p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p><h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span></span></span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p><p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)<span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p><p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span><span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span><span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">x = <span class="type">string</span>(xBytes)</span><br><span class="line">fmt.Println(x)<span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p><p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;text&quot;</span></span><br><span class="line">xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">x = <span class="type">string</span>(xRunes)</span><br><span class="line">fmt.Println(x)<span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p><p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p><ul><li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li><li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li></ul><p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p><h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p><p>这种处理方式和其他语言一样，比如 PHP 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span><span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span></span><br><span class="line">string(6) &quot;中文&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span></span><br><span class="line">string(1) &quot;�&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span></span><br><span class="line">string(3) &quot;中&quot;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">fmt.Println(x[<span class="number">0</span>])<span class="comment">// 97</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p><h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str1))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str2))<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">fmt.Println(utf8.ValidString(str3))<span class="comment">// true// 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>然而在 Go 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(char))<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的内建函数 <code>len()</code> 返回的是字符串的  byte 数量，而不是像 Python  中那样是计算 Unicode 字符数。</p><p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(char))<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">char := <span class="string">&quot;é&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(char))<span class="comment">// 3</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(char))<span class="comment">// 2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;cafe\u0301&quot;</span>)<span class="comment">// café// 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p><h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := []<span class="type">int</span> &#123;</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span><span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p><h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)<span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p><p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p><h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p><p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p><p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)<span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4// 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)<span class="comment">// 0x41 0xfe 0x2 0xff 0x4// 正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p><p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p><p> <img src="https://contents.yinzige.com/map-range.png"></p><h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:<span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line"><span class="comment">// fallthrough// 返回 true</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))<span class="comment">// true</span></span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p><p>也可以改写 case 为多条件判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> char &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))<span class="comment">// true</span></span><br><span class="line">fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code>  只作为运算符而非表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">++i<span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">fmt.Println(data[i++])<span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i++</span><br><span class="line">fmt.Println(data[i])<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(~<span class="number">2</span>)<span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)<span class="comment">// 00000010</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)<span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p><p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p><p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10000010 [A]</span><br><span class="line">00000010 [B]</span><br><span class="line">11111101 (NOT B)</span><br><span class="line">00000010 ^ 11111111 = 11111101 [B XOR 0xff]</span><br><span class="line">10000010 ^ 00000010 = 10000000 [A XOR B]</span><br><span class="line">10000010 &amp; 00000010 = 00000010 [A AND B]</span><br><span class="line">10000010 &amp;^00000010 = 10000000 [A &#x27;AND NOT&#x27; B]</span><br><span class="line">10000010&amp;(^00000010)= 10000000 [A AND (NOT B)]</span><br></pre></td></tr></table></figure><h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)<span class="comment">// &amp; 优先 +</span></span><br><span class="line"><span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line"><span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line"><span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)<span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line"><span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line"><span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line"><span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)<span class="comment">// | 优先 ^</span></span><br><span class="line"><span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line"><span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line"><span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure><h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以  <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)<span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">encoded, _ := json.Marshal(in)</span><br><span class="line">fmt.Println(<span class="type">string</span>(encoded))<span class="comment">// &#123;&quot;One&quot;:1&#125;// 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> out MyData</span><br><span class="line">json.Unmarshal(encoded, &amp;out)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out) <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> doIt(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)<span class="comment">// 模拟 goroutine 正在执行 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p><p> <img src="https://contents.yinzige.com/goroutine-exits.png"></p><p>常用解决办法：使用 “WaitGroup”  变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p><p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-done</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p> <img src="https://contents.yinzige.com/dead-goroutine.png"></p><p>看起来好像 goroutine 都执行完了，然而报错：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p><p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">workerCount := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)<span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;<span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/right-goroutine.png"></p><h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)<span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/unbuffed-chan.png"></p><h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p><p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p><p>向已关闭的 channel 中发送数据会造成 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- idx</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)<span class="comment">// 输出第一个发送的值</span></span><br><span class="line"><span class="built_in">close</span>(ch)<span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)<span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://contents.yinzige.com/channnel.png"></p><p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的  goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行效果：</p><p> <img src="https://contents.yinzige.com/normal-channel.png"></p><h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil  的 channel"></a>34. 使用了值为 <code>nil </code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtime 死锁错误：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p></blockquote><p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line"><span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- val:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">out = <span class="literal">nil</span></span><br><span class="line">in = inCh</span><br><span class="line"><span class="keyword">case</span> val = &lt;-in:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">out = outCh</span><br><span class="line">in = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">0</span>)</span><br><span class="line">inCh &lt;- <span class="number">1</span></span><br><span class="line">inCh &lt;- <span class="number">2</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br> <img src="https://contents.yinzige.com/runns.png"></p><h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num   <span class="type">int</span></span><br><span class="line">key   *<span class="type">string</span></span><br><span class="line">items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">this.num = <span class="number">8</span></span><br><span class="line">*this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">d.pointerFunc()<span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">d.valueFunc()<span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p> <img src="https://contents.yinzige.com/change-origal.png"></p><h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p><blockquote><p>panic: runtime error: invalid memory address or nil pointer dereference</p></blockquote><p>应该先检查 HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">checkError(err)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=json</a>: x509: certificate signed by unknown authority</p></blockquote><p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p><ul><li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li><li>手动调用 <code>defer</code> 来关闭响应体：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p><p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)<span class="comment">// 手动丢弃读取完毕的数据</span></span><br></pre></td></tr></table></figure><p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)  </span><br></pre></td></tr></table></figure><h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p><ul><li>直接设置请求变量的 <code>Close </code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li><li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">req.Close = <span class="literal">true</span></span><br><span class="line"><span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)// 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(resp.StatusCode)<span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据需求选择使用场景：</p><ul><li><p>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</p></li><li><p>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</p></li></ul><h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])<span class="comment">// float64</span></span><br><span class="line"><span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)<span class="comment">// 类型断言错误</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>panic: interface conversion: interface {} is float64, not int</p></blockquote><p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p><ul><li><p>将 int 值转为 float 统一使用</p></li><li><p>将 decode 后需要的 float 值转为 int 使用</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">decoder.UseNumber()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">  decoder.UseNumber()</span><br><span class="line">  <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalln(err)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">checkError(err)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">  checkError(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型</p><p>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">[]<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">StatusCode <span class="type">uint64</span></span><br><span class="line">StatusName <span class="type">string</span></span><br><span class="line">Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">checkError(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">result.StatusName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">result.StatusCode = code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num     <span class="type">int</span></span><br><span class="line">fp      <span class="type">float32</span></span><br><span class="line"><span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">str     <span class="type">string</span></span><br><span class="line">char    <span class="type">rune</span></span><br><span class="line">yes     <span class="type">bool</span></span><br><span class="line">events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ref     *<span class="type">byte</span></span><br><span class="line">raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">num    <span class="type">int</span></span><br><span class="line">checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span><span class="comment">// 无法比较</span></span><br><span class="line">doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span><span class="comment">// 无法比较</span></span><br><span class="line">m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span><span class="comment">// 无法比较</span></span><br><span class="line">bytes  []<span class="type">byte</span><span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p></blockquote><p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := data&#123;&#125;</span><br><span class="line">v2 := data&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>DeepEqual()</code> 并不总适合于比较 slice</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line"><span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">encoded, _ := json.Marshal(data)</span><br><span class="line"><span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code>  和 <code>strings.EqualFold()</code> </p><p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p><ul><li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()<span class="comment">// 什么都不会捕捉</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)<span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line"><span class="built_in">recover</span>()<span class="comment">// 不会被执行</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">doRecover()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>recobered:  <nil>   panic: not good</p></blockquote><h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v *= <span class="number">10</span><span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;data: &quot;</span>, data)<span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改原有元素的值，应该使用索引直接访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">data[i] = v * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;data: &quot;</span>, data)<span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v.num *= <span class="number">10</span><span class="comment">// 直接使用指针更新</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])<span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line"><span class="keyword">return</span> raw[:<span class="number">3</span>]<span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := get()</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])<span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])<span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := get()</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])<span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p><p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">dir1 := path[:sepIndex]</span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAA</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line">    </span><br><span class="line">path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAAsuffix</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffix/uffixBBBB// 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改 </p><p>解决方法：</p><ul><li>重新分配新的 slice 并拷贝你需要的数据</li><li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]<span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))<span class="comment">// AAAAsuffix</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))<span class="comment">// BBBBBBBBB</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))<span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p><h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p><p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)<span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">s2 := s1[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)<span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">s2[i] += <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">fmt.Println(s1)<span class="comment">// [1 22 23]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)<span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">s2[i] += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1)<span class="comment">// [1 22 23]// 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">fmt.Println(s2)<span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mtx myMutex</span><br><span class="line">mtx.Lock()</span><br><span class="line">mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p></blockquote><p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> locker myLocker</span><br><span class="line">locker.Lock()</span><br><span class="line">locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 类型声明也保留它的方法集：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> locker myLocker</span><br><span class="line">locker.Lock()</span><br><span class="line">locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line"><span class="comment">//break// 死循环，一直打印 breaking out...</span></span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p><h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">vCopy := v</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(vCopy)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(in)</span><br><span class="line">&#125;(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意下边这个稍复杂的 3 个示例区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 three three three </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">v := v</span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;<span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line"><span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>result:  2</p></blockquote><h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p><p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dir := os.Args[<span class="number">1</span>]</span><br><span class="line">start, err := os.Stat(dir)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">f, err := os.Open(target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)<span class="comment">//error:too many open files</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()<span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 f 资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 10000 个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for n in &#123;1..10000&#125;; do</span><br><span class="line">echo content &gt; &quot;file$&#123;n&#125;.txt&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/file-open-errors.png"></p><p>解决办法：defer 延迟执行的函数写入匿名函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.Open(target)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span><span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()<span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 f 资源</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p><h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line"><span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)<span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)<span class="comment">// [not an int], data:  great</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line"><span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p><p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p><p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p><p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p><ul><li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel  <code>default</code> 语句：</p><p><code>default</code> 的缓冲 channel  保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p><h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p><p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">d1.<span class="built_in">print</span>()<span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">in.<span class="built_in">print</span>()<span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()<span class="comment">// m[&quot;x&quot;] 是不可寻址的// 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cannot use data literal (type data) as type printer in assignment:</p><p>data does not implement printer (print method has pointer receiver)</p><p>cannot call pointer method on m[“x”]<br>cannot take the address of m[“x”]</p></blockquote><h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cannot assign to struct field m[“x”].name in map</p></blockquote><p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">fmt.Println(s)<span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p><p>更新 map 中 struct 元素的字段值，有 2 个方法：</p><ul><li>使用局部变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">fmt.Println(m)<span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用指向元素的 map 指针</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span><span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;x&quot;</span>])<span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意下边这种误用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line"><span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span> </span><br><span class="line">fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>panic: runtime error: invalid memory address or nil pointer dereference</p></blockquote><h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p><p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(data, data == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">fmt.Println(in, in == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">in = data</span><br><span class="line">fmt.Println(in, in == <span class="literal">nil</span>)<span class="comment">// &lt;nil&gt; false// data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的函数返回值类型是 interface，更要小心这个坑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)<span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)<span class="comment">// *struct &#123;&#125;// res 不是 nil，它的值为 nil</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)<span class="comment">// &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span><span class="comment">// 明确指明返回 nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)<span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p><p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p><p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p><p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置： <img src="https://contents.yinzige.com/allocation.png"></p><h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p><p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p><p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p><p><code>GOMAXPROCS</code>  的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// 4</span></span><br><span class="line">fmt.Println(runtime.NumCPU())<span class="comment">// 4</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// 20</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))<span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line"><span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> u1()<span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line"><span class="keyword">go</span> u2()</span><br><span class="line"><span class="keyword">go</span> p()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/reorder.png"></p><p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p><h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p><p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)<span class="comment">// 并不内联执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p><p> <img src="https://contents.yinzige.com/not-inlined.png"></p><p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p> <img src="https://contents.yinzige.com/gosched.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p><p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p><p>后续再更新类似高质量文章的翻译 😍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载：&lt;a href=&quot;https://github.com/wuYin&quot;&gt;wuYin&lt;/a&gt;&amp;#x2F;&lt;a href=&quot;https://github.com/wuYin/blog&quot;&gt;blog&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&quot;&gt;50 Shades of Go: Traps, Gotchas, and Common Mistakes&lt;/a&gt;，翻译已获作者 &lt;a href=&quot;https://twitter.com/kcqon&quot;&gt;kcqon&lt;/a&gt; 授权。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
</feed>
