<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  <subtitle>Lei Qi博客</subtitle>
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-04-13T14:12:55.125Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>更新网页url后，恢复valine网页评论</title>
    <link href="https://leiqi.top/2025-04-13-8c397fc87827.html"/>
    <id>https://leiqi.top/2025-04-13-8c397fc87827.html</id>
    <published>2025-04-13T04:28:35.000Z</published>
    <updated>2025-04-13T14:12:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。<br>具体步骤：登录&gt;选择你创建的应用&gt;数据存储&gt;结构化数据&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><p>修改 对应url 列为当前url<br><img src="/../../imgs/Pasted%20image%2020250413122851.png"><img src="/../../imgs/Pasted%20image%2020250413123508.png"></p><p>参考：<br><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。&lt;br&gt;具体步骤：登录&amp;gt;选择你创建的应用&amp;gt;数据存储&amp;gt;结构化数据&amp;gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构设计专题</title>
    <link href="https://leiqi.top/2025-03-06-dab119f1439d.html"/>
    <id>https://leiqi.top/2025-03-06-dab119f1439d.html</id>
    <published>2025-03-06T14:56:44.000Z</published>
    <updated>2025-04-13T14:12:55.126Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th><th>是否完成</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td><td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td><td>🟠</td><td>202050306🟢</td></tr><tr><td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td><td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td><td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td><td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td><td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td><td>🟢</td><td>202050307🟢</td></tr><tr><td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td><td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td><td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td><td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td><td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td><td>🟠</td><td>🔴</td></tr></tbody></table><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请设计 最近 最少使用 约束的数据结构<br><img src="/../../imgs/Pasted%20image%2020250309231207.png"></p><p>20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">orderList []<span class="type">int</span></span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">orderList: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, capacity), <span class="comment">// 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</span></span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, capacity),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// key 存在与单独的环境中</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.Update(key)</span><br><span class="line"><span class="keyword">return</span> this.cacheMaps[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Update(key <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 更新key 到最新位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.orderList); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this.orderList[i] == key &#123;</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList[:i], <span class="built_in">append</span>(this.orderList[i+<span class="number">1</span>:], this.orderList[i])...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.Update(key)</span><br><span class="line">&#125;  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &gt;= this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=&quot;</span>,<span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line">oldKey := this.orderList[<span class="number">0</span>]</span><br><span class="line">this.orderList = this.orderList[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, oldKey)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &lt; this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;&lt;&quot;</span>, <span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-1-方法双向列表，map-中直接保存列表元素指针，"><a href="#O-1-方法双向列表，map-中直接保存列表元素指针，" class="headerlink" title="O(1) 方法双向列表，map 中直接保存列表元素指针，"></a>O(1) 方法双向列表，map 中直接保存列表元素指针，</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">orderList *list.List</span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element, capacity),</span><br><span class="line">orderList: list.New(),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(entry).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新已存在的键</span></span><br><span class="line">elem.Value = entry&#123;key: key, value: value&#125;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入新键</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) == this.capacity &#123;</span><br><span class="line"><span class="comment">// 删除最久未使用的键</span></span><br><span class="line">frontElem := this.orderList.Front()</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, frontElem.Value.(entry).key)</span><br><span class="line">this.orderList.Remove(frontElem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入新键到链表末尾</span></span><br><span class="line">newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;)</span><br><span class="line">this.cacheMaps[key] = newElem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p><img src="/../../imgs/Pasted%20image%2020250307231252.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1700  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9分钟完成  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStudents</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 栈模拟  </span></span><br><span class="line">    <span class="comment">// 结束条件  </span></span><br><span class="line">    <span class="comment">// 同学中数字都相同，且不等于栈顶元素 [0]  </span></span><br><span class="line">    <span class="keyword">for</span> !isEnd(students, sandwiches) &#123;  </span><br><span class="line">       <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>] &#123;  </span><br><span class="line">          sandwiches = sandwiches[<span class="number">1</span>:]  </span><br><span class="line">          students = students[<span class="number">1</span>:]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          students = <span class="built_in">append</span>(students[<span class="number">1</span>:], students[<span class="number">0</span>])  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(students)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnd</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> students &#123;  </span><br><span class="line">       <span class="keyword">if</span> val == sandwiches[<span class="number">0</span>] &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据结构设计&quot;&gt;&lt;a href=&quot;#数据结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据结构设计&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://labuladong.online/algo/intro/quick-learning-plan/#%</summary>
      
    
    
    
    <category term="速刷记录" scheme="https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>系统序列图 - 时序图</title>
    <link href="https://leiqi.top/2025-02-19-05250c3f88f5.html"/>
    <id>https://leiqi.top/2025-02-19-05250c3f88f5.html</id>
    <published>2025-02-19T12:07:47.000Z</published>
    <updated>2025-04-13T14:12:55.126Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219200803.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>如何画好一个架构图</title>
    <link href="https://leiqi.top/2025-02-19-d829d1f5a9ea.html"/>
    <id>https://leiqi.top/2025-02-19-d829d1f5a9ea.html</id>
    <published>2025-02-19T11:39:54.000Z</published>
    <updated>2025-04-13T14:12:55.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p><h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p><ul><li>通过不同的颜色白标识不同颜色</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p><h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p><p>使用场景：</p><ul><li>项目开发和测试</li><li>部署发布</li><li>子领域项目架构，下方就是个会员中心*</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p><h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p><p>使用场景</p><ul><li>总体架构设计</li><li>运维规划和优化</li><li>画图技巧</li><li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li></ul><p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务架构&quot;&gt;&lt;a href=&quot;#业务架构&quot; class=&quot;headerlink&quot; title=&quot;业务架构&quot;&gt;&lt;/a&gt;业务架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219195041.png&quot;&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <link href="https://leiqi.top/2025-01-13-1b5c01477594.html"/>
    <id>https://leiqi.top/2025-01-13-1b5c01477594.html</id>
    <published>2025-01-13T15:40:59.000Z</published>
    <updated>2025-04-13T14:12:55.119Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *</span><br></pre></td></tr></table></figure><p>解释一下这个命令：</p><ul><li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li><li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li><li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul><li><code>s</code> 表示替换操作。</li><li><code>hide: true</code> 是要被替换的字符串。</li><li><code>hide: false</code> 是替换后的字符串。</li><li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li></ul></li><li><code>*</code> 表示当前文件夹下的所有文件。</li></ul><p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure><p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Linux 中，可以使用以下命令来实现这个需求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-04-13T14:12:55.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】for range 数组指针遍历</title>
    <link href="https://leiqi.top/2024-12-03-90d19c862e9c.html"/>
    <id>https://leiqi.top/2024-12-03-90d19c862e9c.html</id>
    <published>2024-12-03T16:55:24.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，使用<code>for range</code>遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如<code>[]*Student</code>）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。</p><p>这意味着，即使<code>for range</code>对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    students := []*Student&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;Bob&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用for range遍历指针数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        <span class="comment">// 修改指向的结构体的内容</span></span><br><span class="line">        student.Age += <span class="number">1</span> <span class="comment">// 给每个学生的年龄加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的students数组</span></span><br><span class="line">    <span class="keyword">for</span> _, student := <span class="keyword">range</span> students &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Name: %s, Age: %d\n&quot;</span>, student.Name, student.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管<code>for range</code>对每个<code>*Student</code>指针进行了拷贝，但通过这个拷贝的指针修改<code>Age</code>字段时，修改的是原始<code>Student</code>结构体的内容。因此，当再次遍历<code>students</code>数组时，你会看到每个学生的年龄都已经增加了。</p><p>总结来说，当你使用<code>for range</code>遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，使用&lt;code&gt;for range&lt;/code&gt;遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如&lt;code&gt;[]*Student&lt;/code&gt;）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Go 浮点数次方</title>
    <link href="https://leiqi.top/2024-12-03-3d026e7b5bec.html"/>
    <id>https://leiqi.top/2024-12-03-3d026e7b5bec.html</id>
    <published>2024-12-03T15:46:08.000Z</published>
    <updated>2025-04-13T14:12:55.118Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，计算一个数的几次方可以通过标准库中的<code>math</code>包来实现。<code>math</code>包提供了一个<code>Pow</code>函数，用于计算x的y次方。</p><h3 id="使用math-Pow函数"><a href="#使用math-Pow函数" class="headerlink" title="使用math.Pow函数"></a>使用<code>math.Pow</code>函数</h3><p><code>math.Pow</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pow</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>这个函数接受两个<code>float64</code>类型的参数：<code>x</code>是底数，<code>y</code>是指数，返回<code>x</code>的<code>y</code>次方的结果。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个使用<code>math.Pow</code>函数的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算2的3次方</span></span><br><span class="line">    result := math.Pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;2的3次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算3的2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;3的2次方是: %v\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算10的-2次方</span></span><br><span class="line">    result = math.Pow(<span class="number">10</span>, <span class="number">-2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;10的-2次方是: %v\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2的3次方是: 8</span><br><span class="line">3的2次方是: 9</span><br><span class="line">10的-2次方是: 0.01</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>math.Pow</code>函数的参数和返回值都是<code>float64</code>类型，因此如果你需要计算整数的次方，可能需要先将整数转换为<code>float64</code>，然后再进行计算。</li><li>如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，计算一个数的几次方可以通过标准库中的&lt;code&gt;math&lt;/code&gt;包来实现。&lt;code&gt;math&lt;/code&gt;包提供了一个&lt;code&gt;Pow&lt;/code&gt;函数，用于计算x的y次方。&lt;/p&gt;
&lt;h3 id=&quot;使用math-Pow函数&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>【基础知识】Golang  sort.Slice 复杂排序</title>
    <link href="https://leiqi.top/2024-11-24-24291296f81a.html"/>
    <id>https://leiqi.top/2024-11-24-24291296f81a.html</id>
    <published>2024-11-24T04:47:52.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，你可以使用 <code>sort.Slice</code> 对 <code>slice</code> 按照复杂条件进行排序。 <code>sort.Slice</code> 函数接受一个 <code>slice</code> 和一个比较函数，该比较函数定义了两个元素之间的排序关系。</p><p>以下是实现复杂条件排序的步骤和示例：</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(slice, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 比较 slice[i] 和 slice[j]</span></span><br><span class="line">    <span class="keyword">return</span> 条件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-示例：对结构体切片进行多条件排序"><a href="#2-示例：对结构体切片进行多条件排序" class="headerlink" title="2. 示例：对结构体切片进行多条件排序"></a>2. 示例：对结构体切片进行多条件排序</h3><p>假设有一个包含多个 <code>Person</code> 的切片，我们希望按以下规则排序：</p><ol><li>年龄从小到大排序。</li><li>如果年龄相同，则按名字的字母顺序排序。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">people := []Person&#123;</span><br><span class="line">&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Dave&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sort.Slice 按多个条件排序</span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 优先按年龄排序</span></span><br><span class="line"><span class="keyword">if</span> people[i].Age != people[j].Age &#123;</span><br><span class="line"><span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果年龄相同，则按名字排序</span></span><br><span class="line"><span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-更复杂条件：按多个字段权重排序"><a href="#3-更复杂条件：按多个字段权重排序" class="headerlink" title="3. 更复杂条件：按多个字段权重排序"></a>3. 更复杂条件：按多个字段权重排序</h3><p>如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Price <span class="type">float64</span></span><br><span class="line">Rating <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">products := []Product&#123;</span><br><span class="line">&#123;<span class="string">&quot;Laptop&quot;</span>, <span class="number">1000</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Phone&quot;</span>, <span class="number">800</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Tablet&quot;</span>, <span class="number">800</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Watch&quot;</span>, <span class="number">400</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序</span></span><br><span class="line">sort.Slice(products, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 按价格降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Price != products[j].Price &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Price &gt; products[j].Price</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果价格相同，按评分降序</span></span><br><span class="line"><span class="keyword">if</span> products[i].Rating != products[j].Rating &#123;</span><br><span class="line"><span class="keyword">return</span> products[i].Rating &gt; products[j].Rating</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果评分也相同，按名称升序</span></span><br><span class="line"><span class="keyword">return</span> products[i].Name &lt; products[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(products)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li>如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。</li><li><code>sort.Slice</code> 是不稳定的。如果需要稳定排序，可以使用 <code>sort.SliceStable</code>。</li><li>对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。</li></ul><p>通过 <code>sort.Slice</code> 的灵活性，可以轻松实现各种复杂条件的排序逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，你可以使用 &lt;code&gt;sort.Slice&lt;/code&gt; 对 &lt;code&gt;slice&lt;/code&gt; 按照复杂条件进行排序。 &lt;code&gt;sort.Slice&lt;/code&gt; 函数接受一个 &lt;code&gt;slice&lt;/code&gt; 和一个比较函数，该比较函数定义</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】创建slice是否填第二个参数0的区别</title>
    <link href="https://leiqi.top/2024-11-23-b80d94088ccd.html"/>
    <id>https://leiqi.top/2024-11-23-b80d94088ccd.html</id>
    <published>2024-11-23T05:10:49.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，创建切片（slice）时使用<code>make</code>函数有两种常见的方式，它们之间有细微的差别：</p><ol><li><p><code>slice := make([]string, 0)</code></p><p> 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是<code>[]string</code>），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。</p></li><li><p><code>slice := make([]string)</code></p><p> 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，<code>make</code>函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。</p></li></ol><p>两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用<code>make([]string)</code>（或者等价的<code>make([]string, 0)</code>）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。</p><p>总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，创建切片（slice）时使用&lt;code&gt;make&lt;/code&gt;函数有两种常见的方式，它们之间有细微的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;slice := make([]string, 0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 这种方式明确指定了切片的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting</title>
    <link href="https://leiqi.top/2024-11-23-cf0eba4d8369.html"/>
    <id>https://leiqi.top/2024-11-23-cf0eba4d8369.html</id>
    <published>2024-11-23T05:05:23.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>确实，如果我们按照缩写的逻辑来看，<code>Itos</code>（Integer to String）可能更直观地表达了<code>Itoa</code>函数的功能，即把整数转换为字符串。</p><p>然而，<code>Itoa</code>这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，<code>Itoa</code>这个术语已经被广泛接受和使用。以下是一些可能的原因：</p><ol><li><p><strong>历史原因</strong>：<code>Itoa</code>这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，<code>Itoa</code>（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。</p></li><li><p><strong>约定俗成</strong>：在编程社区中，<code>Itoa</code>已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。</p></li><li><p><strong>ASCII与字符串的关系</strong>：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字<code>123</code>的ASCII表示和字符串表示都是<code>&quot;123&quot;</code>。因此，<code>Itoa</code>这个名字仍然适用。</p></li><li><p><strong>简洁性</strong>：<code>Itoa</code>这个名称比较简洁，易于记忆。如果使用<code>Itos</code>，虽然直观，但可能不如<code>Itoa</code>简洁。</p></li></ol><p><code>Itoa</code>这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管<code>Itos</code>可能更直观地表示整数到字符串的转换，但<code>Itoa</code>已经成为一个广泛接受和使用的术语。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;确实，如果我们按照缩写的逻辑来看，&lt;code&gt;Itos&lt;/code&gt;（Integer to String）可能更直观地表达了&lt;code&gt;Itoa&lt;/code&gt;函数的功能，即把整数转换为字符串。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;Itoa&lt;/code&gt;这个名称的由来实际上与历史</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
    <category term="刨根问底" scheme="https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"/>
    
  </entry>
  
  <entry>
    <title>【基础知识】符号整数和非符号整数</title>
    <link href="https://leiqi.top/2024-11-23-dce4118b03a7.html"/>
    <id>https://leiqi.top/2024-11-23-dce4118b03a7.html</id>
    <published>2024-11-23T04:47:02.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p><code>uint8</code> <code>uint16</code>和<code>uint32</code>是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。</p><ol><li><p><code>unit8</code> : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255</p></li><li><p>**<code>uint16</code>**：</p><ul><li><code>uint16</code>是一个16位的无符号整数。</li><li>它可以存储的数字数量是 2^16。</li><li>计算得出：216&#x3D;65536216&#x3D;65536。</li><li>因此，<code>uint16</code>能存储的数字范围是从0到65535。</li></ul></li><li><p>**<code>uint32</code>**：</p><ul><li><code>uint32</code>是一个32位的无符号整数。</li><li>它可以存储的数字数量是 2^32。</li><li>计算得出：232&#x3D;4294967296232&#x3D;4294967296。</li><li>因此，<code>uint32</code>能存储的数字范围是从0到4294967295。</li></ul></li></ol><p>总结：</p><ul><li><code>uint16</code>能存储的数字数量是 216216，即65536个数字。</li><li><code>uint32</code>能存储的数字数量是 232232，即4294967296个数字。</li></ul><p><code>int32</code>是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。</p><p>具体来说：</p><ul><li>对于正数，<strong>最高位是0</strong>，剩下的31位可以表示 231231 个不同的正数值。</li><li>对于负数，<strong>最高位是1</strong>，剩下的31位可以表示 231231 个不同的负数值。</li><li>由于0既不是正数也不是负数，它单独占用了一个数值。</li></ul><p>因此，<code>int32</code>的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说<code>int32</code>的范围是31次方而不是32次方的原因。<br><img src="/../../imgs/Pasted%20image%2020241123132832.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;uint8&lt;/code&gt; &lt;code&gt;uint16&lt;/code&gt;和&lt;code&gt;uint32&lt;/code&gt;是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unit8&lt;/code&gt; : 是8位无</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Golang】 byte和rune 有什么区别</title>
    <link href="https://leiqi.top/2024-11-23-ff51ba651704.html"/>
    <id>https://leiqi.top/2024-11-23-ff51ba651704.html</id>
    <published>2024-11-23T04:38:13.000Z</published>
    <updated>2025-04-13T14:12:55.124Z</updated>
    
    <content type="html"><![CDATA[<p>byte 和rune 有什么区别？<br>    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：</p><p>byte：</p><p>byte是uint8的别名，即一个无符号的8位整数。<br>在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。<br>byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。<br>rune：</p><p>rune是int32的别名，即一个有符号的32位整数。<br>rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。<br>rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。<br>由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。<br>区别：</p><p>大小：byte是8位的，而rune是32位的。<br>用途：byte用于处理字节数据，rune用于处理Unicode字符。<br>范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。<br>编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。<br>在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;byte 和rune 有什么区别？&lt;br&gt;    在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义：&lt;/p&gt;
&lt;p&gt;byte：&lt;/p&gt;
&lt;p&gt;byte是uint8的别名，即一个无符号的8位整数。&lt;br&gt;在Go语言中</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>申请域名绑定github pages</title>
    <link href="https://leiqi.top/2024-09-01-ed1bf9078b39.html"/>
    <id>https://leiqi.top/2024-09-01-ed1bf9078b39.html</id>
    <published>2024-09-01T02:17:17.000Z</published>
    <updated>2025-04-13T14:12:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！</p><h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><ol><li>在<a href="https://www.namesilo.com/">Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo</a>完成了域名的购买</li><li>完成了GitHub Pages的设置，有了可用的<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>库之后，可以访问 Github Pages</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-进入我的账户"><a href="#0-进入我的账户" class="headerlink" title="0. 进入我的账户"></a>0. 进入我的账户</h3><p><img src="/../../imgs/Pasted%20image%2020240901102308.png"></p><h3 id="1-无论是什么域名服务商，找到DNS-Management页面"><a href="#1-无论是什么域名服务商，找到DNS-Management页面" class="headerlink" title="1. 无论是什么域名服务商，找到DNS Management页面"></a><strong>1. 无论是什么域名服务商，找到DNS Management页面</strong></h3><p>如果是namesilo购买的域名，可以通过以下步骤：<br><img src="/../../imgs/Pasted%20image%2020240901102340.png"><br>点击“domain manager”<br><img src="/../../imgs/Pasted%20image%2020240901102510.png"><br>点击这个蓝色的小球（Manage DNS for this domain）</p><h3 id="2-写入-type-A-的DNS记录"><a href="#2-写入-type-A-的DNS记录" class="headerlink" title="2. 写入 type A 的DNS记录"></a><strong>2. 写入 type A 的DNS记录</strong></h3><ul><li><strong>如果厂商提供了写入模板</strong>，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 <strong>DNS Templates</strong>。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-b84d88c38c06b6081f02cafbd0dac24b_720w.webp"></p><p>找到GitHub的template，点击“<strong>Apply Template</strong>”，然后在弹出的窗口里直接点击“<strong>Accept</strong>”，你就会发现4条A记录已经自动写入了。</p><p><img src="https://pic1.zhimg.com/80/v2-c731fadefaf3d3a2268e6566d6196558_720w.webp"></p><ul><li><strong>如果厂商不能自动添加</strong>，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图</li></ul><p>[Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain!</p><p><img src="https://pica.zhimg.com/80/v2-1a618fec2900e4f23039c153d8ab03da_720w.webp"></p><p>上面圈起来的四个地址就是需要等会儿手动输入的。</p><p>不同厂商之间的手动添加方法不一样，但只要记住 <strong>type 后填“A”</strong>，<strong>address&#x2F;points to或其他同义表达后填这四个地址中的一个</strong>，<strong>其他默认</strong>就好了，一共需要添加<strong>四条</strong>，可以复制粘贴。</p><p>添加之后会多出四个<img src="/../../imgs/Pasted%20image%2020240901102815.png">### 3. 创建CNAME文件</p><p>这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，</p><blockquote><p>上面的方法 save 之后看到报错不要慌，<a href="https://zhida.zhihu.com/search?q=%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E&zhida_source=entity&is_preview=1">让子弹飞</a>一会儿就好了</p></blockquote><p><img src="/../../imgs/Pasted%20image%2020240901102714.png"><br><img src="/../../imgs/Pasted%20image%2020240901102745.png"></p><p>最终有这些配置即可：<br><img src="/../../imgs/Pasted%20image%2020240901102848.png"></p><h3 id="github-填写域名地址"><a href="#github-填写域名地址" class="headerlink" title="github 填写域名地址"></a>github 填写域名地址</h3><p>在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。<br><img src="/../../imgs/Pasted%20image%2020240901103216.png"><br><img src="/../../imgs/Pasted%20image%2020240901103241.png"></p><h3 id="即刻访问你自己的域名网站吧！"><a href="#即刻访问你自己的域名网站吧！" class="headerlink" title="即刻访问你自己的域名网站吧！"></a>即刻访问你自己的域名网站吧！</h3><p><img src="/../../imgs/Pasted%20image%2020240901103553.png"></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/448781791">将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！&lt;/p&gt;
&lt;h2 id=&quot;前置需求&quot;&gt;&lt;a href=&quot;#前置需求&quot; class=&quot;headerlink&quot; title=&quot;前置需求&quot;&gt;&lt;/a&gt;前置需求&lt;/h2&gt;&lt;o</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>git stash</title>
    <link href="https://leiqi.top/2024-08-21-f4ccab39149e.html"/>
    <id>https://leiqi.top/2024-08-21-f4ccab39149e.html</id>
    <published>2024-08-21T16:26:46.000Z</published>
    <updated>2025-04-13T14:12:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：</p><p>放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。</p><p>bash<br>git checkout – .obsidian&#x2F;workspace.json<br>再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。</p><p>bash<br>git pull<br>如果不想放弃这些更改，而是想将它们保存起来，可以使用 git stash 命令：</p><p>保存更改：使用 git stash 将更改保存到一个临时区域。</p><p>git stash<br>拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>请注意，使用 git stash apply 可能不会总是成功，在这种情况下，可能需要手动解决冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：&lt;/p&gt;
&lt;p&gt;放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。&lt;/p&gt;</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode  1.两数之和</title>
    <link href="https://leiqi.top/2024-08-21-64c0a1f316e6.html"/>
    <id>https://leiqi.top/2024-08-21-64c0a1f316e6.html</id>
    <published>2024-08-21T15:53:21.000Z</published>
    <updated>2025-04-13T14:12:55.122Z</updated>
    
    <content type="html"><![CDATA[<p>有两种思路：</p><ol><li>使用暴力遍历， 复杂度的是 O(n ^2)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:= i+<span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>使用哈希表，是O(n)<br>  使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">maps[num] = idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; <span class="comment">// 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;idx, idx2&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用暴力遍历， 复杂度的是 O(n ^2)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqi.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>docker容器打包成本地压缩镜像并load</title>
    <link href="https://leiqi.top/2024-08-11-a8e2c27fed87.html"/>
    <id>https://leiqi.top/2024-08-11-a8e2c27fed87.html</id>
    <published>2024-08-11T03:59:34.000Z</published>
    <updated>2025-04-13T14:12:55.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器打包成镜像和压缩"><a href="#docker容器打包成镜像和压缩" class="headerlink" title="docker容器打包成镜像和压缩"></a>docker容器打包成镜像和压缩</h1><p>（1）将容器保存成新的镜像<br>相当于加了一层，使用docker commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -a &#x27;run_code&#x27; b4293c3b9202  myimage:v2</span><br></pre></td></tr></table></figure><p>（2）将镜像打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o mask_detection_v5.tar myimage:v5</span><br></pre></td></tr></table></figure><p>(3) 将镜像包压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zcvf myimage.tar.gz myimage.tar</span><br></pre></td></tr></table></figure><p><strong>还有一种容器的打包和压缩一步到位的方法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save myimage:v5 | gzip &gt; myimage.tar.gz</span><br></pre></td></tr></table></figure><p>docker镜像压缩包解压及镜像载入</p><p>一步加载压缩的镜像命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; myimage.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）压缩包解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf myimage.tar.gz</span><br></pre></td></tr></table></figure><p>得到.tar格式的镜像包</p><p>（2）镜像载入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker load -i myimage.tar</span><br></pre></td></tr></table></figure><p>载入后查看已经加载的镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><h1 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互式运行</span></span><br><span class="line">docker run -it myimage:v1 bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="进入已经运行的容器"><a href="#进入已经运行的容器" class="headerlink" title="进入已经运行的容器"></a>进入已经运行的容器</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it [imagesID] bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;a href=&quot;#docker容器打包成镜像和压缩&quot; class=&quot;headerlink&quot; title=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;/a&gt;docker容器打包成镜像和压缩&lt;/h1&gt;&lt;p&gt;（1）将容器保存成新的镜像&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://leiqi.top/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>查询深度学习环境python torch cuda版本</title>
    <link href="https://leiqi.top/2024-08-08-efa703ec12d7.html"/>
    <id>https://leiqi.top/2024-08-08-efa703ec12d7.html</id>
    <published>2024-08-08T14:55:03.000Z</published>
    <updated>2025-04-13T14:12:55.125Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys模块提供了一系列有关Python运行环境的变量和函数。</span></span><br><span class="line"><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240808225509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>开机自启WSL</title>
    <link href="https://leiqi.top/2024-08-07-117ef9b8f4c6.html"/>
    <id>https://leiqi.top/2024-08-07-117ef9b8f4c6.html</id>
    <published>2024-08-07T14:09:47.000Z</published>
    <updated>2025-04-13T14:12:55.125Z</updated>
    
    <content type="html"><![CDATA[<p>在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件</p><p><img src="/../../imgs/Pasted%20image%2020240807221008.png"></p><p>文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set ws = WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">cmd = &quot;C:\Windows\System32\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;</span><br><span class="line">&#x27;运行命令不显示cmd窗口</span><br><span class="line">ws.Run cmd, 0, false</span><br><span class="line">Set ws = Nothing</span><br><span class="line">WScript.quit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C:&#92;ProgramData&#92;Microsoft&#92;Windows&#92;Start Menu&#92;Programs&#92;StartUp 目录下，新建vbs文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240807221008.pn</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git更新仓库地址</title>
    <link href="https://leiqi.top/2024-07-23-764a3cd05cde.html"/>
    <id>https://leiqi.top/2024-07-23-764a3cd05cde.html</id>
    <published>2024-07-23T15:34:45.000Z</published>
    <updated>2025-04-13T14:12:55.121Z</updated>
    
    <content type="html"><![CDATA[<p>使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://gitee.com/xxxxx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用如下命令&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co</summary>
      
    
    
    
    <category term="git" scheme="https://leiqi.top/categories/git/"/>
    
    
  </entry>
  
</feed>
