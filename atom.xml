<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-04-11T10:25:48.930Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件架构</title>
    <link href="https://leiqi.top/2025-03-27-b83e03130cb8.html"/>
    <id>https://leiqi.top/2025-03-27-b83e03130cb8.html</id>
    <published>2025-03-27T16:14:59.000Z</published>
    <updated>2025-04-11T10:25:48.930Z</updated>
    
    <content type="html"><![CDATA[<ul><li>架构的概念</li></ul><h1 id="架构的本质"><a href="#架构的本质" class="headerlink" title="架构的本质"></a>架构的本质</h1><ol><li>提供一个结构、行为和属性的高级抽象</li><li>架构是特定应用领域的惯用模式，架构定义一个词汇表和一组约束</li></ol><p>架构的作用：</p><ol><li>软件架构是项目相关人进行交流的手段</li><li>软件架构的可传递和可复用的模型， 通过研究软件架构可能通过研究软件架构可能预测软件的质量</li><li>软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。<br><img src="/../../../imgs/Pasted%20image%2020250328002035.png"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;架构的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;架构的本质&quot;&gt;&lt;a href=&quot;#架构的本质&quot; class=&quot;headerlink&quot; title=&quot;架构的本质&quot;&gt;&lt;/a&gt;架构的本质&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;提供一个结构、行为和属性的高级抽象&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="软件架构" scheme="https://leiqi.top/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>本地生成hexo 网页</title>
    <link href="https://leiqi.top/2025-03-09-ad4b68dc69ca.html"/>
    <id>https://leiqi.top/2025-03-09-ad4b68dc69ca.html</id>
    <published>2025-03-09T15:28:49.000Z</published>
    <updated>2025-04-11T10:25:48.929Z</updated>
    
    <content type="html"><![CDATA[<p>npm install hexo-all-minifier –save</p><p><a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><p>npm set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h2 id="本地部署调测"><a href="#本地部署调测" class="headerlink" title="本地部署调测"></a>本地部署调测</h2><p><code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code></p><p>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</p><p>hexo new page guestbook</p><p>hexo-generator-json-content</p><p>安装：npm install –save hexo-generator-json-content</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;npm install hexo-all-minifier –save&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://registry.npmjs.org/&quot;&gt;https://registry.npmjs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;npm set registry </summary>
      
    
    
    
    <category term="前端" scheme="https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构设计专题</title>
    <link href="https://leiqi.top/2025-03-06-dab119f1439d.html"/>
    <id>https://leiqi.top/2025-03-06-dab119f1439d.html</id>
    <published>2025-03-06T14:56:44.000Z</published>
    <updated>2025-04-11T10:25:48.931Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th><th>是否完成</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td><td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td><td>🟠</td><td>202050306🟢</td></tr><tr><td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td><td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td><td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td><td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td><td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td><td>🟢</td><td>202050307🟢</td></tr><tr><td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td><td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td><td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td><td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td><td>🔴</td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td><td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td><td>🟠</td><td>🔴</td></tr></tbody></table><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请设计 最近 最少使用 约束的数据结构<br><img src="/../../imgs/Pasted%20image%2020250309231207.png"></p><p>20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">orderList []<span class="type">int</span></span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">orderList: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, capacity), <span class="comment">// 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0</span></span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, capacity),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// key 存在与单独的环境中</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.Update(key)</span><br><span class="line"><span class="keyword">return</span> this.cacheMaps[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Update(key <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 更新key 到最新位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.orderList); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this.orderList[i] == key &#123;</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList[:i], <span class="built_in">append</span>(this.orderList[i+<span class="number">1</span>:], this.orderList[i])...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.Update(key)</span><br><span class="line">&#125;  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &gt;= this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=&quot;</span>,<span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line">oldKey := this.orderList[<span class="number">0</span>]</span><br><span class="line">this.orderList = this.orderList[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, oldKey)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) &lt; this.capacity &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;&lt;&quot;</span>, <span class="built_in">len</span>(this.orderList), <span class="built_in">len</span>(this.cacheMaps), this.capacity)</span><br><span class="line"><span class="comment">// 新建key</span></span><br><span class="line">this.cacheMaps[key] = value</span><br><span class="line">this.orderList = <span class="built_in">append</span>(this.orderList, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-1-方法双向列表，map-中直接保存列表元素指针，"><a href="#O-1-方法双向列表，map-中直接保存列表元素指针，" class="headerlink" title="O(1) 方法双向列表，map 中直接保存列表元素指针，"></a>O(1) 方法双向列表，map 中直接保存列表元素指针，</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">cacheMaps <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">orderList *list.List</span><br><span class="line">capacity  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">cacheMaps: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element, capacity),</span><br><span class="line">orderList: list.New(),</span><br><span class="line">capacity:  capacity,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line"><span class="keyword">return</span> elem.Value.(entry).value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.cacheMaps[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新已存在的键</span></span><br><span class="line">elem.Value = entry&#123;key: key, value: value&#125;</span><br><span class="line">this.orderList.MoveToBack(elem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 插入新键</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.cacheMaps) == this.capacity &#123;</span><br><span class="line"><span class="comment">// 删除最久未使用的键</span></span><br><span class="line">frontElem := this.orderList.Front()</span><br><span class="line"><span class="built_in">delete</span>(this.cacheMaps, frontElem.Value.(entry).key)</span><br><span class="line">this.orderList.Remove(frontElem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入新键到链表末尾</span></span><br><span class="line">newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;)</span><br><span class="line">this.cacheMaps[key] = newElem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><p><img src="/../../imgs/Pasted%20image%2020250307231252.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1700  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 9分钟完成  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStudents</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 栈模拟  </span></span><br><span class="line">    <span class="comment">// 结束条件  </span></span><br><span class="line">    <span class="comment">// 同学中数字都相同，且不等于栈顶元素 [0]  </span></span><br><span class="line">    <span class="keyword">for</span> !isEnd(students, sandwiches) &#123;  </span><br><span class="line">       <span class="keyword">if</span> sandwiches[<span class="number">0</span>] == students[<span class="number">0</span>] &#123;  </span><br><span class="line">          sandwiches = sandwiches[<span class="number">1</span>:]  </span><br><span class="line">          students = students[<span class="number">1</span>:]  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          students = <span class="built_in">append</span>(students[<span class="number">1</span>:], students[<span class="number">0</span>])  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(students)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEnd</span><span class="params">(students []<span class="type">int</span>, sandwiches []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> students &#123;  </span><br><span class="line">       <span class="keyword">if</span> val == sandwiches[<span class="number">0</span>] &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据结构设计&quot;&gt;&lt;a href=&quot;#数据结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据结构设计&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://labuladong.online/algo/intro/quick-learning-plan/#%</summary>
      
    
    
    
    <category term="速刷记录" scheme="https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>golang 设计题</title>
    <link href="https://leiqi.top/2025-02-27-419b1b8b5279.html"/>
    <id>https://leiqi.top/2025-02-27-419b1b8b5279.html</id>
    <published>2025-02-27T16:12:49.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<p>要高效解决 LeetCode 的设计题（如设计 LRU 缓存、设计数据结构等），需要抓住 <strong>问题建模、数据结构选择、接口设计、边界处理</strong> 四大核心环节。以下是系统化的方法论和 Golang 实现技巧：</p><p><a href="https://labuladong.online/algo/problem-set/ds-design/">【强化练习】更多经典设计习题 | labuladong 的算法笔记</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="/../../imgs/Pasted%20image%2020250304232815.png"><br><img src="/../../imgs/Pasted%20image%2020250304232749.png"></p><h1 id="速成目录的题目列表"><a href="#速成目录的题目列表" class="headerlink" title="速成目录的题目列表"></a>速成目录的题目列表</h1><h4 id="链表双指针技巧"><a href="#链表双指针技巧" class="headerlink" title="链表双指针技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">链表双指针技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/merge-two-sorted-lists/?show=1">21. Merge Two Sorted Lists</a></td><td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/?show=1">21. 合并两个有序链表</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/partition-list/?show=1">86. Partition List</a></td><td><a href="https://leetcode.cn/problems/partition-list/?show=1">86. 分隔链表</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/merge-k-sorted-lists/?show=1">23. Merge k Sorted Lists</a></td><td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?show=1">23. 合并K个升序链表</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/linked-list-cycle/?show=1">141. Linked List Cycle</a></td><td><a href="https://leetcode.cn/problems/linked-list-cycle/?show=1">141. 环形链表</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/linked-list-cycle-ii/?show=1">142. Linked List Cycle II</a></td><td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/?show=1">142. 环形链表 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/middle-of-the-linked-list/?show=1">876. Middle of the Linked List</a></td><td><a href="https://leetcode.cn/problems/middle-of-the-linked-list/?show=1">876. 链表的中间结点</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/?show=1">19. Remove Nth Node From End of List</a></td><td><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?show=1">19. 删除链表的倒数第 N 个结点</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/?show=1">160. Intersection of Two Linked Lists</a></td><td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?show=1">160. 相交链表</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/ugly-number-ii/?show=1">264. Ugly Number II</a></td><td><a href="https://leetcode.cn/problems/ugly-number-ii/?show=1">264. 丑数 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/?show=1">378. Kth Smallest Element in a Sorted Matrix</a></td><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/?show=1">378. 有序矩阵中第 K 小的元素</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/?show=1">373. Find K Pairs with Smallest Sums</a></td><td><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/?show=1">373. 查找和最小的 K 对数字</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/?show=1">82. Remove Duplicates from Sorted List II</a></td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?show=1">82. 删除排序链表中的重复元素 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/add-two-numbers/?show=1">2. Add Two Numbers</a></td><td><a href="https://leetcode.cn/problems/add-two-numbers/?show=1">2. 两数相加</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/add-two-numbers-ii/?show=1">445. Add Two Numbers II</a></td><td><a href="https://leetcode.cn/problems/add-two-numbers-ii/?show=1">445. 两数相加 II</a></td><td>🟠</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="递归操作链表"><a href="#递归操作链表" class="headerlink" title="递归操作链表"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E9%80%92%E5%BD%92%E6%93%8D%E4%BD%9C%E9%93%BE%E8%A1%A8">递归操作链表</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/palindrome-linked-list/?show=1">234. Palindrome Linked List</a></td><td><a href="https://leetcode.cn/problems/palindrome-linked-list/?show=1">234. 回文链表</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/reverse-linked-list/?show=1">206. Reverse Linked List</a></td><td><a href="https://leetcode.cn/problems/reverse-linked-list/?show=1">206. 反转链表</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/reverse-linked-list-ii/?show=1">92. Reverse Linked List II</a></td><td><a href="https://leetcode.cn/problems/reverse-linked-list-ii/?show=1">92. 反转链表 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/?show=1">25. Reverse Nodes in k-Group</a></td><td><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?show=1">25. K 个一组翻转链表</a></td><td>🔴</td></tr></tbody></table><h4 id="数组双指针技巧"><a href="#数组双指针技巧" class="headerlink" title="数组双指针技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">数组双指针技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/?show=1">26. Remove Duplicates from Sorted Array</a></td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/?show=1">26. 删除有序数组中的重复项</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/?show=1">83. Remove Duplicates from Sorted List</a></td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/?show=1">83. 删除排序链表中的重复元素</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/remove-element/?show=1">27. Remove Element</a></td><td><a href="https://leetcode.cn/problems/remove-element/?show=1">27. 移除元素</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/move-zeroes/?show=1">283. Move Zeroes</a></td><td><a href="https://leetcode.cn/problems/move-zeroes/?show=1">283. 移动零</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/?show=1">167. Two Sum II - Input Array Is Sorted</a></td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?show=1">167. 两数之和 II - 输入有序数组</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/reverse-string/?show=1">344. Reverse String</a></td><td><a href="https://leetcode.cn/problems/reverse-string/?show=1">344. 反转字符串</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/longest-palindromic-substring/?show=1">5. Longest Palindromic Substring</a></td><td><a href="https://leetcode.cn/problems/longest-palindromic-substring/?show=1">5. 最长回文子串</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/?show=1">80. Remove Duplicates from Sorted Array II</a></td><td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?show=1">80. 删除有序数组中的重复项 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/valid-palindrome/?show=1">125. Valid Palindrome</a></td><td><a href="https://leetcode.cn/problems/valid-palindrome/?show=1">125. 验证回文串</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/sort-colors/?show=1">75. Sort Colors</a></td><td><a href="https://leetcode.cn/problems/sort-colors/?show=1">75. 颜色分类</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/merge-sorted-array/?show=1">88. Merge Sorted Array</a></td><td><a href="https://leetcode.cn/problems/merge-sorted-array/?show=1">88. 合并两个有序数组</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/squares-of-a-sorted-array/?show=1">977. Squares of a Sorted Array</a></td><td><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/?show=1">977. 有序数组的平方</a></td><td>🟢</td></tr></tbody></table><h4 id="二维数组操作技巧"><a href="#二维数组操作技巧" class="headerlink" title="二维数组操作技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7">二维数组操作技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/reverse-words-in-a-string/?show=1">151. Reverse Words in a String</a></td><td><a href="https://leetcode.cn/problems/reverse-words-in-a-string/?show=1">151. 反转字符串中的单词</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/rotate-image/?show=1">48. Rotate Image</a></td><td><a href="https://leetcode.cn/problems/rotate-image/?show=1">48. 旋转图像</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/spiral-matrix/?show=1">54. Spiral Matrix</a></td><td><a href="https://leetcode.cn/problems/spiral-matrix/?show=1">54. 螺旋矩阵</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/spiral-matrix-ii/?show=1">59. Spiral Matrix II</a></td><td><a href="https://leetcode.cn/problems/spiral-matrix-ii/?show=1">59. 螺旋矩阵 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/sort-the-matrix-diagonally/?show=1">1329. Sort the Matrix Diagonally</a></td><td><a href="https://leetcode.cn/problems/sort-the-matrix-diagonally/?show=1">1329. 将矩阵按对角线排序</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/shift-2d-grid/?show=1">1260. Shift 2D Grid</a></td><td><a href="https://leetcode.cn/problems/shift-2d-grid/?show=1">1260. 二维网格迁移</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/transpose-matrix/?show=1">867. Transpose Matrix</a></td><td><a href="https://leetcode.cn/problems/transpose-matrix/?show=1">867. 转置矩阵</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/longest-common-prefix/?show=1">14. Longest Common Prefix</a></td><td><a href="https://leetcode.cn/problems/longest-common-prefix/?show=1">14. 最长公共前缀</a></td><td>🟢</td></tr></tbody></table><h4 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95">滑动窗口算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/minimum-window-substring/?show=1">76. Minimum Window Substring</a></td><td><a href="https://leetcode.cn/problems/minimum-window-substring/?show=1">76. 最小覆盖子串</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/permutation-in-string/?show=1">567. Permutation in String</a></td><td><a href="https://leetcode.cn/problems/permutation-in-string/?show=1">567. 字符串的排列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/?show=1">438. Find All Anagrams in a String</a></td><td><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/?show=1">438. 找到字符串中所有字母异位词</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/?show=1">3. Longest Substring Without Repeating Characters</a></td><td><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?show=1">3. 无重复字符的最长子串</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/?show=1">1658. Minimum Operations to Reduce X to Zero</a></td><td><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/?show=1">1658. 将 x 减到 0 的最小操作数</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/subarray-product-less-than-k/?show=1">713. Subarray Product Less Than K</a></td><td><a href="https://leetcode.cn/problems/subarray-product-less-than-k/?show=1">713. 乘积小于 K 的子数组</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/contains-duplicate-ii/?show=1">219. Contains Duplicate II</a></td><td><a href="https://leetcode.cn/problems/contains-duplicate-ii/?show=1">219. 存在重复元素 II</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/contains-duplicate-iii/?show=1">220. Contains Duplicate III</a></td><td><a href="https://leetcode.cn/problems/contains-duplicate-iii/?show=1">220. 存在重复元素 III</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/minimum-size-subarray-sum/?show=1">209. Minimum Size Subarray Sum</a></td><td><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/?show=1">209. 长度最小的子数组</a></td><td>🟠</td></tr></tbody></table><h4 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">二分搜索算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/binary-search/?show=1">704. Binary Search</a></td><td><a href="https://leetcode.cn/problems/binary-search/?show=1">704. 二分查找</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/?show=1">34. Find First and Last Position of Element in Sorted Array</a></td><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?show=1">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/koko-eating-bananas/?show=1">875. Koko Eating Bananas</a></td><td><a href="https://leetcode.cn/problems/koko-eating-bananas/?show=1">875. 爱吃香蕉的珂珂</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/?show=1">1011. Capacity To Ship Packages Within D Days</a></td><td><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/?show=1">1011. 在 D 天内送达包裹的能力</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/split-array-largest-sum/?show=1">410. Split Array Largest Sum</a></td><td><a href="https://leetcode.cn/problems/split-array-largest-sum/?show=1">410. 分割数组的最大值</a></td><td>🔴</td></tr></tbody></table><h4 id="前缀和-x2F-差分技巧"><a href="#前缀和-x2F-差分技巧" class="headerlink" title="前缀和&#x2F;差分技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86%E6%8A%80%E5%B7%A7">前缀和&#x2F;差分技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/range-sum-query-immutable/?show=1">303. Range Sum Query - Immutable</a></td><td><a href="https://leetcode.cn/problems/range-sum-query-immutable/?show=1">303. 区域和检索 - 数组不可变</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/?show=1">304. Range Sum Query 2D - Immutable</a></td><td><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/?show=1">304. 二维区域和检索 - 矩阵不可变</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/corporate-flight-bookings/?show=1">1109. Corporate Flight Bookings</a></td><td><a href="https://leetcode.cn/problems/corporate-flight-bookings/?show=1">1109. 航班预订统计</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/car-pooling/?show=1">1094. Car Pooling</a></td><td><a href="https://leetcode.cn/problems/car-pooling/?show=1">1094. 拼车</a></td><td>🟠</td></tr></tbody></table><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%A0%88">栈</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/simplify-path/?show=1">71. Simplify Path</a></td><td><a href="https://leetcode.cn/problems/simplify-path/?show=1">71. 简化路径</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/reorder-list/?show=1">143. Reorder List</a></td><td><a href="https://leetcode.cn/problems/reorder-list/?show=1">143. 重排链表</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/valid-parentheses/?show=1">20. Valid Parentheses</a></td><td><a href="https://leetcode.cn/problems/valid-parentheses/?show=1">20. 有效的括号</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/?show=1">150. Evaluate Reverse Polish Notation</a></td><td><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?show=1">150. 逆波兰表达式求值</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/implement-stack-using-queues/?show=1">225. Implement Stack using Queues</a></td><td><a href="https://leetcode.cn/problems/implement-stack-using-queues/?show=1">225. 用队列实现栈</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/longest-absolute-file-path/?show=1">388. Longest Absolute File Path</a></td><td><a href="https://leetcode.cn/problems/longest-absolute-file-path/?show=1">388. 文件的最长绝对路径</a></td><td>🟠</td></tr></tbody></table><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E9%98%9F%E5%88%97">队列</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/number-of-recent-calls/?show=1">933. Number of Recent Calls</a></td><td><a href="https://leetcode.cn/problems/number-of-recent-calls/?show=1">933. 最近的请求次数</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/design-circular-queue/?show=1">622. Design Circular Queue</a></td><td><a href="https://leetcode.cn/problems/design-circular-queue/?show=1">622. 设计循环队列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/design-circular-deque/?show=1">641. Design Circular Deque</a></td><td><a href="https://leetcode.cn/problems/design-circular-deque/?show=1">641. 设计循环双端队列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/time-needed-to-buy-tickets/?show=1">2073. Time Needed to Buy Tickets</a></td><td><a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/?show=1">2073. 买票需要的时间</a></td><td>🟢</td></tr></tbody></table><h4 id="单调栈技巧"><a href="#单调栈技巧" class="headerlink" title="单调栈技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%8D%95%E8%B0%83%E6%A0%88%E6%8A%80%E5%B7%A7">单调栈技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/?show=1">1019. Next Greater Node In Linked List</a></td><td><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/?show=1">1019. 链表中的下一个更大节点</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-visible-people-in-a-queue/?show=1">1944. Number of Visible People in a Queue</a></td><td><a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/?show=1">1944. 队列中可以看到的人数</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/?show=1">1475. Final Prices With a Special Discount in a Shop</a></td><td><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/?show=1">1475. 商品折扣后的最终价格</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/online-stock-span/?show=1">901. Online Stock Span</a></td><td><a href="https://leetcode.cn/problems/online-stock-span/?show=1">901. 股票价格跨度</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/remove-k-digits/?show=1">402. Remove K Digits</a></td><td><a href="https://leetcode.cn/problems/remove-k-digits/?show=1">402. 移掉 K 位数字</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/car-fleet/?show=1">853. Car Fleet</a></td><td><a href="https://leetcode.cn/problems/car-fleet/?show=1">853. 车队</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/?show=1">581. Shortest Unsorted Continuous Subarray</a></td><td><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/?show=1">581. 最短无序连续子数组</a></td><td>🟠</td></tr></tbody></table><h4 id="单调队列技巧"><a href="#单调队列技巧" class="headerlink" title="单调队列技巧"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E6%8A%80%E5%B7%A7">单调队列技巧</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/sliding-window-maximum/?show=1">239. Sliding Window Maximum</a></td><td><a href="https://leetcode.cn/problems/sliding-window-maximum/?show=1">239. 滑动窗口最大值</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/?show=1">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></td><td><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/?show=1">1438. 绝对差不超过限制的最长连续子数组</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/?show=1">862. Shortest Subarray with Sum at Least K</a></td><td><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/?show=1">862. 和至少为 K 的最短子数组</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/?show=1">918. Maximum Sum Circular Subarray</a></td><td><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/?show=1">918. 环形子数组的最大和</a></td><td>🟠</td></tr></tbody></table><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/invert-binary-tree/?show=1">226. Invert Binary Tree</a></td><td><a href="https://leetcode.cn/problems/invert-binary-tree/?show=1">226. 翻转二叉树</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/?show=1">114. Flatten Binary Tree to Linked List</a></td><td><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?show=1">114. 二叉树展开为链表</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/?show=1">116. Populating Next Right Pointers in Each Node</a></td><td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/?show=1">116. 填充每个节点的下一个右侧节点指针</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-binary-tree/?show=1">654. Maximum Binary Tree</a></td><td><a href="https://leetcode.cn/problems/maximum-binary-tree/?show=1">654. 最大二叉树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?show=1">105. Construct Binary Tree from Preorder and Inorder Traversal</a></td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?show=1">105. 从前序与中序遍历序列构造二叉树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?show=1">106. Construct Binary Tree from Inorder and Postorder Traversal</a></td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?show=1">106. 从中序与后序遍历序列构造二叉树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/?show=1">889. Construct Binary Tree from Preorder and Postorder Traversal</a></td><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/?show=1">889. 根据前序和后序遍历构造二叉树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/?show=1">297. Serialize and Deserialize Binary Tree</a></td><td><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?show=1">297. 二叉树的序列化与反序列化</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/?show=1">236. Lowest Common Ancestor of a Binary Tree</a></td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?show=1">236. 二叉树的最近公共祖先</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/?show=1">235. Lowest Common Ancestor of a Binary Search Tree</a></td><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/?show=1">235. 二叉搜索树的最近公共祖先</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/count-complete-tree-nodes/?show=1">222. Count Complete Tree Nodes</a></td><td><a href="https://leetcode.cn/problems/count-complete-tree-nodes/?show=1">222. 完全二叉树的节点个数</a></td><td>🟠</td></tr></tbody></table><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/?show=1">230. Kth Smallest Element in a BST</a></td><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?show=1">230. 二叉搜索树中第K小的元素</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/?show=1">538. Convert BST to Greater Tree</a></td><td><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/?show=1">538. 把二叉搜索树转换为累加树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/?show=1">1038. Binary Search Tree to Greater Sum Tree</a></td><td><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/?show=1">1038. 从二叉搜索树到更大和树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/delete-node-in-a-bst/?show=1">450. Delete Node in a BST</a></td><td><a href="https://leetcode.cn/problems/delete-node-in-a-bst/?show=1">450. 删除二叉搜索树中的节点</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/?show=1">701. Insert into a Binary Search Tree</a></td><td><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/?show=1">701. 二叉搜索树中的插入操作</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/?show=1">700. Search in a Binary Search Tree</a></td><td><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/?show=1">700. 二叉搜索树中的搜索</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/validate-binary-search-tree/?show=1">98. Validate Binary Search Tree</a></td><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/?show=1">98. 验证二叉搜索树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/unique-binary-search-trees/?show=1">96. Unique Binary Search Trees</a></td><td><a href="https://leetcode.cn/problems/unique-binary-search-trees/?show=1">96. 不同的二叉搜索树</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/?show=1">95. Unique Binary Search Trees II</a></td><td><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/?show=1">95. 不同的二叉搜索树 II</a></td><td>🟠</td></tr></tbody></table><h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/lru-cache/?show=1">146. LRU Cache</a></td><td><a href="https://leetcode.cn/problems/lru-cache/?show=1">146. LRU 缓存</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/lfu-cache/?show=1">460. LFU Cache</a></td><td><a href="https://leetcode.cn/problems/lfu-cache/?show=1">460. LFU 缓存</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/my-calendar-i/?show=1">729. My Calendar I</a></td><td><a href="https://leetcode.cn/problems/my-calendar-i/?show=1">729. 我的日程安排表 I</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/?show=1">950. Reveal Cards In Increasing Order</a></td><td><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/?show=1">950. 按递增顺序显示卡牌</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. Number of Students Unable to Eat Lunch</a></td><td><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/?show=1">1700. 无法吃午餐的学生数量</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/min-stack/?show=1">155. Min Stack</a></td><td><a href="https://leetcode.cn/problems/min-stack/?show=1">155. 最小栈</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/design-front-middle-back-queue/?show=1">1670. Design Front Middle Back Queue</a></td><td><a href="https://leetcode.cn/problems/design-front-middle-back-queue/?show=1">1670. 设计前中后队列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-frequency-stack/?show=1">895. Maximum Frequency Stack</a></td><td><a href="https://leetcode.cn/problems/maximum-frequency-stack/?show=1">895. 最大频率栈</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator/?show=1">224. Basic Calculator</a></td><td><a href="https://leetcode.cn/problems/basic-calculator/?show=1">224. 基本计算器</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/basic-calculator-ii/?show=1">227. Basic Calculator II</a></td><td><a href="https://leetcode.cn/problems/basic-calculator-ii/?show=1">227. 基本计算器 II</a></td><td>🟠</td></tr></tbody></table><h4 id="图相关算法"><a href="#图相关算法" class="headerlink" title="图相关算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95">图相关算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/course-schedule/?show=1">207. Course Schedule</a></td><td><a href="https://leetcode.cn/problems/course-schedule/?show=1">207. 课程表</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/course-schedule-ii/?show=1">210. Course Schedule II</a></td><td><a href="https://leetcode.cn/problems/course-schedule-ii/?show=1">210. 课程表 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/?show=1">990. Satisfiability of Equality Equations</a></td><td><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/?show=1">990. 等式方程的可满足性</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/redundant-connection/?show=1">684. Redundant Connection</a></td><td><a href="https://leetcode.cn/problems/redundant-connection/?show=1">684. 冗余连接</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/?show=1">1584. Min Cost to Connect All Points</a></td><td><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/?show=1">1584. 连接所有点的最小费用</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/network-delay-time/?show=1">743. Network Delay Time</a></td><td><a href="https://leetcode.cn/problems/network-delay-time/?show=1">743. 网络延迟时间</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/path-with-minimum-effort/?show=1">1631. Path With Minimum Effort</a></td><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/?show=1">1631. 最小体力消耗路径</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/path-with-maximum-probability/?show=1">1514. Path with Maximum Probability</a></td><td><a href="https://leetcode.cn/problems/path-with-maximum-probability/?show=1">1514. 概率最大的路径</a></td><td>🟠</td></tr></tbody></table><h4 id="DFS-x2F-回溯算法"><a href="#DFS-x2F-回溯算法" class="headerlink" title="DFS&#x2F;回溯算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#dfs-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">DFS&#x2F;回溯算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/subsets/?show=1">78. Subsets</a></td><td><a href="https://leetcode.cn/problems/subsets/?show=1">78. 子集</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/subsets-ii/?show=1">90. Subsets II</a></td><td><a href="https://leetcode.cn/problems/subsets-ii/?show=1">90. 子集 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/combinations/?show=1">77. Combinations</a></td><td><a href="https://leetcode.cn/problems/combinations/?show=1">77. 组合</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/combination-sum/?show=1">39. Combination Sum</a></td><td><a href="https://leetcode.cn/problems/combination-sum/?show=1">39. 组合总和</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/combination-sum-ii/?show=1">40. Combination Sum II</a></td><td><a href="https://leetcode.cn/problems/combination-sum-ii/?show=1">40. 组合总和 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/combination-sum-iii/?show=1">216. Combination Sum III</a></td><td><a href="https://leetcode.cn/problems/combination-sum-iii/?show=1">216. 组合总和 III</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/permutations/?show=1">46. Permutations</a></td><td><a href="https://leetcode.cn/problems/permutations/?show=1">46. 全排列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/permutations-ii/?show=1">47. Permutations II</a></td><td><a href="https://leetcode.cn/problems/permutations-ii/?show=1">47. 全排列 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/sudoku-solver/?show=1">37. Sudoku Solver</a></td><td><a href="https://leetcode.cn/problems/sudoku-solver/?show=1">37. 解数独</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/n-queens/?show=1">51. N-Queens</a></td><td><a href="https://leetcode.cn/problems/n-queens/?show=1">51. N 皇后</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/n-queens-ii/?show=1">52. N-Queens II</a></td><td><a href="https://leetcode.cn/problems/n-queens-ii/?show=1">52. N皇后 II</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-islands/?show=1">200. Number of Islands</a></td><td><a href="https://leetcode.cn/problems/number-of-islands/?show=1">200. 岛屿数量</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/number-of-closed-islands/?show=1">1254. Number of Closed Islands</a></td><td><a href="https://leetcode.cn/problems/number-of-closed-islands/?show=1">1254. 统计封闭岛屿的数目</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/max-area-of-island/?show=1">695. Max Area of Island</a></td><td><a href="https://leetcode.cn/problems/max-area-of-island/?show=1">695. 岛屿的最大面积</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/count-sub-islands/?show=1">1905. Count Sub Islands</a></td><td><a href="https://leetcode.cn/problems/count-sub-islands/?show=1">1905. 统计子岛屿</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/?show=1">967. Numbers With Same Consecutive Differences</a></td><td><a href="https://leetcode.cn/problems/numbers-with-same-consecutive-differences/?show=1">967. 连续差相同的数字</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/non-decreasing-subsequences/?show=1">491. Non-decreasing Subsequences</a></td><td><a href="https://leetcode.cn/problems/non-decreasing-subsequences/?show=1">491. 递增子序列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/unique-paths-iii/?show=1">980. Unique Paths III</a></td><td><a href="https://leetcode.cn/problems/unique-paths-iii/?show=1">980. 不同路径 III</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/palindrome-partitioning/?show=1">131. Palindrome Partitioning</a></td><td><a href="https://leetcode.cn/problems/palindrome-partitioning/?show=1">131. 分割回文串</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/restore-ip-addresses/?show=1">93. Restore IP Addresses</a></td><td><a href="https://leetcode.cn/problems/restore-ip-addresses/?show=1">93. 复原 IP 地址</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/?show=1">17. Letter Combinations of a Phone Number</a></td><td><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?show=1">17. 电话号码的字母组合</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/word-search/?show=1">79. Word Search</a></td><td><a href="https://leetcode.cn/problems/word-search/?show=1">79. 单词搜索</a></td><td>🟠</td></tr></tbody></table><h4 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#bfs-%E7%AE%97%E6%B3%95">BFS 算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/open-the-lock/?show=1">752. Open the Lock</a></td><td><a href="https://leetcode.cn/problems/open-the-lock/?show=1">752. 打开转盘锁</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/sliding-puzzle/?show=1">773. Sliding Puzzle</a></td><td><a href="https://leetcode.cn/problems/sliding-puzzle/?show=1">773. 滑动谜题</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/complete-binary-tree-inserter/?show=1">919. Complete Binary Tree Inserter</a></td><td><a href="https://leetcode.cn/problems/complete-binary-tree-inserter/?show=1">919. 完全二叉树插入器</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/keys-and-rooms/?show=1">841. Keys and Rooms</a></td><td><a href="https://leetcode.cn/problems/keys-and-rooms/?show=1">841. 钥匙和房间</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/minimum-genetic-mutation/?show=1">433. Minimum Genetic Mutation</a></td><td><a href="https://leetcode.cn/problems/minimum-genetic-mutation/?show=1">433. 最小基因变化</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/?show=1">1926. Nearest Exit from Entrance in Maze</a></td><td><a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/?show=1">1926. 迷宫中离入口最近的出口</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/?show=1">1091. Shortest Path in Binary Matrix</a></td><td><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/?show=1">1091. 二进制矩阵中的最短路径</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/rotting-oranges/?show=1">994. Rotting Oranges</a></td><td><a href="https://leetcode.cn/problems/rotting-oranges/?show=1">994. 腐烂的橘子</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/accounts-merge/?show=1">721. Accounts Merge</a></td><td><a href="https://leetcode.cn/problems/accounts-merge/?show=1">721. 账户合并</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/word-ladder/?show=1">127. Word Ladder</a></td><td><a href="https://leetcode.cn/problems/word-ladder/?show=1">127. 单词接龙</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/water-and-jug-problem/?show=1">365. Water and Jug Problem</a></td><td><a href="https://leetcode.cn/problems/water-and-jug-problem/?show=1">365. 水壶问题</a></td><td>🟠</td></tr></tbody></table><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/fibonacci-number/?show=1">509. Fibonacci Number</a></td><td><a href="https://leetcode.cn/problems/fibonacci-number/?show=1">509. 斐波那契数</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/coin-change/?show=1">322. Coin Change</a></td><td><a href="https://leetcode.cn/problems/coin-change/?show=1">322. 零钱兑换</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/longest-increasing-subsequence/?show=1">300. Longest Increasing Subsequence</a></td><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/?show=1">300. 最长递增子序列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/russian-doll-envelopes/?show=1">354. Russian Doll Envelopes</a></td><td><a href="https://leetcode.cn/problems/russian-doll-envelopes/?show=1">354. 俄罗斯套娃信封问题</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/edit-distance/?show=1">72. Edit Distance</a></td><td><a href="https://leetcode.cn/problems/edit-distance/?show=1">72. 编辑距离</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/maximum-subarray/?show=1">53. Maximum Subarray</a></td><td><a href="https://leetcode.cn/problems/maximum-subarray/?show=1">53. 最大子数组和</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/longest-common-subsequence/?show=1">1143. Longest Common Subsequence</a></td><td><a href="https://leetcode.cn/problems/longest-common-subsequence/?show=1">1143. 最长公共子序列</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/delete-operation-for-two-strings/?show=1">583. Delete Operation for Two Strings</a></td><td><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/?show=1">583. 两个字符串的删除操作</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/?show=1">712. Minimum ASCII Delete Sum for Two Strings</a></td><td><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/?show=1">712. 两个字符串的最小ASCII删除和</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/partition-equal-subset-sum/?show=1">416. Partition Equal Subset Sum</a></td><td><a href="https://leetcode.cn/problems/partition-equal-subset-sum/?show=1">416. 分割等和子集</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/coin-change-ii/?show=1">518. Coin Change II</a></td><td><a href="https://leetcode.cn/problems/coin-change-ii/?show=1">518. 零钱兑换 II</a></td><td>🟠</td></tr></tbody></table><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/jump-game/?show=1">55. Jump Game</a></td><td><a href="https://leetcode.cn/problems/jump-game/?show=1">55. 跳跃游戏</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/jump-game-ii/?show=1">45. Jump Game II</a></td><td><a href="https://leetcode.cn/problems/jump-game-ii/?show=1">45. 跳跃游戏 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/gas-station/?show=1">134. Gas Station</a></td><td><a href="https://leetcode.cn/problems/gas-station/?show=1">134. 加油站</a></td><td>🟠</td></tr></tbody></table><h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">分治算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/merge-k-sorted-lists/?show=1">23. Merge k Sorted Lists</a></td><td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?show=1">23. 合并K个升序链表</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/?show=1">241. Different Ways to Add Parentheses</a></td><td><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/?show=1">241. 为运算表达式设计优先级</a></td><td>🟠</td></tr></tbody></table><h4 id="数学算法"><a href="#数学算法" class="headerlink" title="数学算法"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95">数学算法</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/nim-game/?show=1">292. Nim Game</a></td><td><a href="https://leetcode.cn/problems/nim-game/?show=1">292. Nim 游戏</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/stone-game/?show=1">877. Stone Game</a></td><td><a href="https://leetcode.cn/problems/stone-game/?show=1">877. 石子游戏</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/bulb-switcher/?show=1">319. Bulb Switcher</a></td><td><a href="https://leetcode.cn/problems/bulb-switcher/?show=1">319. 灯泡开关</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/linked-list-random-node/?show=1">382. Linked List Random Node</a></td><td><a href="https://leetcode.cn/problems/linked-list-random-node/?show=1">382. 链表随机节点</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/random-pick-index/?show=1">398. Random Pick Index</a></td><td><a href="https://leetcode.cn/problems/random-pick-index/?show=1">398. 随机数索引</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/shuffle-an-array/?show=1">384. Shuffle an Array</a></td><td><a href="https://leetcode.cn/problems/shuffle-an-array/?show=1">384. 打乱数组</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/count-primes/?show=1">204. Count Primes</a></td><td><a href="https://leetcode.cn/problems/count-primes/?show=1">204. 计数质数</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/super-pow/?show=1">372. Super Pow</a></td><td><a href="https://leetcode.cn/problems/super-pow/?show=1">372. 超级次方</a></td><td>🟠</td></tr></tbody></table><h4 id="其他经典面试题"><a href="#其他经典面试题" class="headerlink" title="其他经典面试题"></a><a href="https://labuladong.online/algo/intro/quick-learning-plan/#%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98">其他经典面试题</a></h4><table><thead><tr><th>LeetCode</th><th>力扣</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode.com/problems/trapping-rain-water/?show=1">42. Trapping Rain Water</a></td><td><a href="https://leetcode.cn/problems/trapping-rain-water/?show=1">42. 接雨水</a></td><td>🔴</td></tr><tr><td><a href="https://leetcode.com/problems/container-with-most-water/?show=1">11. Container With Most Water</a></td><td><a href="https://leetcode.cn/problems/container-with-most-water/?show=1">11. 盛最多水的容器</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/ugly-number/?show=1">263. Ugly Number</a></td><td><a href="https://leetcode.cn/problems/ugly-number/?show=1">263. 丑数</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/ugly-number-ii/?show=1">264. Ugly Number II</a></td><td><a href="https://leetcode.cn/problems/ugly-number-ii/?show=1">264. 丑数 II</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/ugly-number-iii/?show=1">1201. Ugly Number III</a></td><td><a href="https://leetcode.cn/problems/ugly-number-iii/?show=1">1201. 丑数 III</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/super-ugly-number/?show=1">313. Super Ugly Number</a></td><td><a href="https://leetcode.cn/problems/super-ugly-number/?show=1">313. 超级丑数</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/random-pick-with-weight/?show=1">528. Random Pick with Weight</a></td><td><a href="https://leetcode.cn/problems/random-pick-with-weight/?show=1">528. 按权重随机选择</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/two-sum/?show=1">1. Two Sum</a></td><td><a href="https://leetcode.cn/problems/two-sum/?show=1">1. 两数之和</a></td><td>🟢</td></tr><tr><td><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/?show=1">167. Two Sum II - Input Array Is Sorted</a></td><td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?show=1">167. 两数之和 II - 输入有序数组</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/3sum/?show=1">15. 3Sum</a></td><td><a href="https://leetcode.cn/problems/3sum/?show=1">15. 三数之和</a></td><td>🟠</td></tr><tr><td><a href="https://leetcode.com/problems/4sum/?show=1">18. 4Sum</a></td><td><a href="https://leetcode.cn/problems/4sum/?show=1">18. 四数之和</a></td><td>🟠</td></tr></tbody></table><h1 id="刷题范围"><a href="#刷题范围" class="headerlink" title="刷题范围"></a>刷题范围</h1><p><img src="/../../imgs/Pasted%20image%2020250304232540.png"><br><img src="/../../imgs/Pasted%20image%2020250304232604.png"><br><img src="/../../imgs/Pasted%20image%2020250304232633.png"><br><img src="/../../imgs/Pasted%20image%2020250304232518.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../../imgs/Pasted%20image%2020250304232719.png"></h2><h3 id="一、设计题解题方法论"><a href="#一、设计题解题方法论" class="headerlink" title="一、设计题解题方法论"></a><strong>一、设计题解题方法论</strong></h3><h4 id="1-理解问题本质（5分钟）"><a href="#1-理解问题本质（5分钟）" class="headerlink" title="1. 理解问题本质（5分钟）"></a>1. <strong>理解问题本质（5分钟）</strong></h4><ul><li><strong>明确需求</strong>：将题目抽象为实际系统问题（如 LRU &#x3D; 缓存淘汰策略 + 快速查询）</li><li><strong>输入输出</strong>：明确操作接口（如 <code>Get(key)</code>, <code>Put(key, value)</code>）</li><li><strong>约束条件</strong>：容量限制、时间复杂度要求（如 O(1) 的 Get&#x2F;Put）</li></ul><h4 id="2-设计数据结构（核心！）"><a href="#2-设计数据结构（核心！）" class="headerlink" title="2. 设计数据结构（核心！）"></a>2. <strong>设计数据结构（核心！）</strong></h4><ul><li><strong>经典组合</strong>：<ul><li><strong>哈希表 + 双向链表</strong>：用于 LRU（哈希表快速定位，链表维护顺序）</li><li><strong>前缀树（Trie）</strong>：处理字符串匹配（如实现字典树）</li><li><strong>堆（优先队列）</strong>：用于实时获取最大值&#x2F;最小值（如设计股票交易系统）</li></ul></li><li><strong>Golang 选择</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表用 map</span></span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*ListNode)</span><br><span class="line"><span class="comment">// 双向链表自定义结构体</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key, Val  <span class="type">int</span></span><br><span class="line">    Prev, Next *ListNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-接口与方法拆分"><a href="#3-接口与方法拆分" class="headerlink" title="3. 接口与方法拆分"></a>3. <strong>接口与方法拆分</strong></h4><ul><li><strong>面向对象设计</strong>：定义结构体（类）和方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache    <span class="keyword">map</span>[<span class="type">int</span>]*ListNode</span><br><span class="line">    head, tail *ListNode <span class="comment">// 虚拟头尾节点简化操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123; <span class="comment">/* 初始化 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123; <span class="comment">/* 实现 */</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-处理边界条件"><a href="#4-处理边界条件" class="headerlink" title="4. 处理边界条件"></a>4. <strong>处理边界条件</strong></h4><ul><li><strong>特殊输入</strong>：容量为0、重复操作、超出容量时的淘汰策略</li><li><strong>并发问题</strong>：若题目要求线程安全，需加锁（Golang 中用 <code>sync.Mutex</code>） 并发不用考虑</li></ul><hr><h3 id="二、Golang-实现技巧"><a href="#二、Golang-实现技巧" class="headerlink" title="二、Golang 实现技巧"></a><strong>二、Golang 实现技巧</strong></h3><h4 id="1-利用结构体封装状态"><a href="#1-利用结构体封装状态" class="headerlink" title="1. 利用结构体封装状态"></a>1. <strong>利用结构体封装状态</strong></h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：设计哈希集合</span></span><br><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashSet &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashSet&#123;<span class="built_in">make</span>([]<span class="type">bool</span>, <span class="number">1e6</span>+<span class="number">1</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span></span> Add(key <span class="type">int</span>) &#123; s.data[key] = <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-预定义工具函数"><a href="#2-预定义工具函数" class="headerlink" title="2. 预定义工具函数"></a>2. <strong>预定义工具函数</strong></h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LRU 缓存中移动节点到头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *ListNode) &#123;</span><br><span class="line">    <span class="comment">// 1. 从原位置删除</span></span><br><span class="line">    node.Prev.Next = node.Next</span><br><span class="line">    node.Next.Prev = node.Prev</span><br><span class="line">    <span class="comment">// 2. 插入头部</span></span><br><span class="line">    node.Next = lru.head.Next</span><br><span class="line">    lru.head.Next.Prev = node</span><br><span class="line">    lru.head.Next = node</span><br><span class="line">    node.Prev = lru.head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-复杂度优化"><a href="#3-复杂度优化" class="headerlink" title="3. 复杂度优化"></a>3. <strong>复杂度优化</strong></h4><ul><li><strong>空间换时间</strong>：用冗余数据结构（如哈希表+链表）</li><li><strong>惰性删除</strong>：某些场景延迟处理（如设计过期缓存时）</li></ul><h4 id="4-并发安全设计"><a href="#4-并发安全设计" class="headerlink" title="4. 并发安全设计"></a>4. <strong>并发安全设计</strong></h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、实战案例：设计-LRU-缓存（Golang-实现）"><a href="#三、实战案例：设计-LRU-缓存（Golang-实现）" class="headerlink" title="三、实战案例：设计 LRU 缓存（Golang 实现）"></a><strong>三、实战案例：设计 LRU 缓存（Golang 实现）</strong></h3><h4 id="1-数据结构选择"><a href="#1-数据结构选择" class="headerlink" title="1. 数据结构选择"></a>1. <strong>数据结构选择</strong></h4><ul><li><code>map[int]*ListNode</code>：快速查找键值对</li><li><strong>双向链表</strong>：维护访问顺序，头部最新，尾部最旧</li></ul><h4 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2. 完整代码"></a>2. <strong>完整代码</strong></h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key, Val  <span class="type">int</span></span><br><span class="line">    Prev, Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache    <span class="keyword">map</span>[<span class="type">int</span>]*ListNode</span><br><span class="line">    head, tail *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    lru := LRUCache&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*ListNode),</span><br><span class="line">        head:     &amp;ListNode&#123;&#125;,</span><br><span class="line">        tail:     &amp;ListNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    lru.head.Next = lru.tail</span><br><span class="line">    lru.tail.Prev = lru.head</span><br><span class="line">    <span class="keyword">return</span> lru</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line">        lru.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line">        node.Val = value</span><br><span class="line">        lru.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) == lru.capacity &#123;</span><br><span class="line">        removed := lru.removeTail()</span><br><span class="line">        <span class="built_in">delete</span>(lru.cache, removed.Key)</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;ListNode&#123;Key: key, Val: value&#125;</span><br><span class="line">    lru.cache[key] = newNode</span><br><span class="line">    lru.addToHead(newNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *ListNode) &#123;</span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *ListNode) &#123;</span><br><span class="line">    node.Prev = lru.head</span><br><span class="line">    node.Next = lru.head.Next</span><br><span class="line">    lru.head.Next.Prev = node</span><br><span class="line">    lru.head.Next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *ListNode) &#123;</span><br><span class="line">    node.Prev.Next = node.Next</span><br><span class="line">    node.Next.Prev = node.Prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() *ListNode &#123;</span><br><span class="line">    node := lru.tail.Prev</span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试用例验证"><a href="#3-测试用例验证" class="headerlink" title="3. 测试用例验证"></a>3. <strong>测试用例验证</strong></h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lru := Constructor(<span class="number">2</span>)</span><br><span class="line">    lru.Put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    lru.Put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(lru.Get(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line">    lru.Put(<span class="number">3</span>, <span class="number">3</span>)          <span class="comment">// 淘汰2</span></span><br><span class="line">    fmt.Println(lru.Get(<span class="number">2</span>)) <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、快速编码训练建议"><a href="#四、快速编码训练建议" class="headerlink" title="四、快速编码训练建议"></a><strong>四、快速编码训练建议</strong></h3><ol><li><strong>模板化代码</strong>：预先练习常见设计题（LRU、Trie、API限流器）</li><li><strong>画图辅助</strong>：在草稿纸上画出数据流和结构关系</li><li><strong>分模块实现</strong>：先写接口，再填充方法，最后处理边界</li><li><strong>复杂度自查</strong>：每写一个操作，检查是否符合题目要求的时间复杂度</li></ol><p>通过以上方法，可在 30 分钟内完成大多数 LeetCode 设计题的 Golang 实现，重点关注 <strong>数据结构选择</strong> 和 <strong>边界处理</strong> 两大核心难点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要高效解决 LeetCode 的设计题（如设计 LRU 缓存、设计数据结构等），需要抓住 &lt;strong&gt;问题建模、数据结构选择、接口设计、边界处理&lt;/strong&gt; 四大核心环节。以下是系统化的方法论和 Golang 实现技巧：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqi.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>架构师</title>
    <link href="https://leiqi.top/2025-02-23-017614f23543.html"/>
    <id>https://leiqi.top/2025-02-23-017614f23543.html</id>
    <published>2025-02-23T09:57:51.000Z</published>
    <updated>2025-04-11T10:25:48.930Z</updated>
    
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>系统序列图 - 时序图</title>
    <link href="https://leiqi.top/2025-02-19-05250c3f88f5.html"/>
    <id>https://leiqi.top/2025-02-19-05250c3f88f5.html</id>
    <published>2025-02-19T12:07:47.000Z</published>
    <updated>2025-04-11T10:25:48.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../../imgs/Pasted%20image%2020250219200803.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219200803.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>chrome 插件</title>
    <link href="https://leiqi.top/2025-02-19-4f7f0e2c1d64.html"/>
    <id>https://leiqi.top/2025-02-19-4f7f0e2c1d64.html</id>
    <published>2025-02-19T11:42:36.000Z</published>
    <updated>2025-04-11T10:25:48.929Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://link.zhihu.com/?target=https://link.jianshu.com/?t=http://markdown-here.com/">markdown here</a> <strong>超好用的一款插件，强烈推荐！！</strong>有个它再也不用担心编辑器不支持markdown语法了，写好以后直接一键转换。而且也是一个跨平台神器，<strong>比如我们可以把简书写好的文章（带md语法）直接复制到微信公众号，然后一键转换，格式几乎无变化！</strong></p><p><img src="https://pic1.zhimg.com/v2-8a387e976e816e48e907ff42efb91b90_1440w.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https://link.jianshu.com/?t=http://markdown-here.com/&quot;&gt;markdown here&lt;/a&gt; &lt;strong&gt;超好用的一款插件，强烈推荐！！&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>如何画好一个架构图</title>
    <link href="https://leiqi.top/2025-02-19-d829d1f5a9ea.html"/>
    <id>https://leiqi.top/2025-02-19-d829d1f5a9ea.html</id>
    <published>2025-02-19T11:39:54.000Z</published>
    <updated>2025-04-11T10:25:48.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h1><p><img src="/../../../imgs/Pasted%20image%2020250219195041.png"></p><h1 id="客户端架构、前端架构"><a href="#客户端架构、前端架构" class="headerlink" title="客户端架构、前端架构"></a>客户端架构、前端架构</h1><p>类似于逻辑视图</p><ul><li>通过不同的颜色白标识不同颜色</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219195111.png"></p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>技术架构或者是后端架构，后端的逻辑架构<br>后端架构是核心架构<br><img src="/../../../imgs/Pasted%20image%2020250219195326.png"><img src="/../../../imgs/Pasted%20image%2020250219195934.png"><br>两张图 左边说明功能，右边说明交互。和业务架构有区别。</p><h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>描述后端系统有哪些应用组成</p><p>使用场景：</p><ul><li>项目开发和测试</li><li>部署发布</li><li>子领域项目架构，下方就是个会员中心*</li></ul><p><img src="/../../../imgs/Pasted%20image%2020250219200124.png"><img src="/../../../imgs/Pasted%20image%2020250219200345.png"></p><h1 id="部署架构-物理视图"><a href="#部署架构-物理视图" class="headerlink" title="部署架构 - 物理视图"></a>部署架构 - 物理视图</h1><p>描述后端系统具体是如何部署的，对应4+1 视图中的物理视图</p><p>使用场景</p><ul><li>总体架构设计</li><li>运维规划和优化</li><li>画图技巧</li><li>使用图标代替区块*<br><img src="/../../../imgs/Pasted%20image%2020250219200529.png"><br>上边的球是网络加速点</li></ul><p><a href="https://www.bilibili.com/video/BV1764y1a7PD/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=8d35f023c28f4bba76bb3fadea08f222">前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务架构&quot;&gt;&lt;a href=&quot;#业务架构&quot; class=&quot;headerlink&quot; title=&quot;业务架构&quot;&gt;&lt;/a&gt;业务架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../imgs/Pasted%20image%2020250219195041.png&quot;&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>【sed】快速替换当前文件夹下文件中指定内容</title>
    <link href="https://leiqi.top/2025-01-13-1b5c01477594.html"/>
    <id>https://leiqi.top/2025-01-13-1b5c01477594.html</id>
    <published>2025-01-13T15:40:59.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，可以使用以下命令来实现这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *</span><br></pre></td></tr></table></figure><p>解释一下这个命令：</p><ul><li><code>sed</code> 是流编辑器，用于对文本进行过滤和转换。</li><li><code>-i</code> 选项表示直接修改文件，而不是输出到终端。</li><li><code>&#39;s/hide: true/hide: false/g&#39;</code> 是 sed 的替换命令，其中：<ul><li><code>s</code> 表示替换操作。</li><li><code>hide: true</code> 是要被替换的字符串。</li><li><code>hide: false</code> 是替换后的字符串。</li><li><code>g</code> 表示全局替换，即在每一行中将所有匹配的 <code>hide: true</code> 都替换为 <code>hide: false</code>。</li></ul></li><li><code>*</code> 表示当前文件夹下的所有文件。</li></ul><p>需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 <code>.txt</code> 文件中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure><p>另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 <code>find</code> 命令结合 <code>sed</code> 来实现，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/hide: true/hide: false/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>这个命令会递归查找当前文件夹及其子文件夹下的所有文件（<code>-type f</code>），然后对每个文件执行 <code>sed</code> 命令进行替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Linux 中，可以使用以下命令来实现这个需求：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    <category term="Linux" scheme="https://leiqi.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-04-11T10:25:48.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>day34</title>
    <link href="https://leiqi.top/2025-01-05-fd59568f4fb6.html"/>
    <id>https://leiqi.top/2025-01-05-fd59568f4fb6.html</id>
    <published>2025-01-05T14:58:46.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-动态规划part02"><a href="#第九章-动态规划part02" class="headerlink" title="第九章 动态规划part02"></a>第九章 动态规划part02</h1><p>今天开始逐渐有 dp的感觉了，前 两题 不同路径，可以好好研究一下，适合进阶</p><p>详细布置</p><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。</p><p><a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1ve4y1x7Eu">https://www.bilibili.com/video/BV1ve4y1x7Eu</a></p><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p><a href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html">https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.htmlhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Ld4y1k7c6">https://www.bilibili.com/video/BV1Ld4y1k7c6</a></p><h3 id="343-整数拆分-（可跳过）"><a href="#343-整数拆分-（可跳过）" class="headerlink" title="343.  整数拆分 （可跳过）"></a>343.  整数拆分 （可跳过）</h3><p>本题思路并不容易想，一刷建议可以跳过。如果学有余力，可以看视频理解一波。</p><p><a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html">https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Mg411q7YJ">https://www.bilibili.com/video/BV1Mg411q7YJ</a></p><h3 id="96-不同的二叉搜索树-（可跳过）"><a href="#96-不同的二叉搜索树-（可跳过）" class="headerlink" title="96.  .不同的二叉搜索树 （可跳过）"></a>96.  .不同的二叉搜索树 （可跳过）</h3><p>本题思路并不容易想，一刷建议可以跳过。 如果学有余力，可以看视频理解一波。</p><p><a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1eK411o7QA">https://www.bilibili.com/video/BV1eK411o7QA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-动态规划part02&quot;&gt;&lt;a href=&quot;#第九章-动态规划part02&quot; class=&quot;headerlink&quot; title=&quot;第九章 动态规划part02&quot;&gt;&lt;/a&gt;第九章 动态规划part02&lt;/h1&gt;&lt;p&gt;今天开始逐渐有 dp的感觉了，前 两题 不同</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>day32</title>
    <link href="https://leiqi.top/2025-01-05-73019d21cf33.html"/>
    <id>https://leiqi.top/2025-01-05-73019d21cf33.html</id>
    <published>2025-01-05T14:46:55.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-动态规划part01"><a href="#第九章-动态规划part01" class="headerlink" title="第九章 动态规划part01"></a>第九章 动态规划part01</h1><p>今天正式开始动态规划！</p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。</p><p>如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？</p><p>其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！</p><p>如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。</p><p><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a></p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><p>很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。</p><p><a href="https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html">https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV1f5411K7mo">https://www.bilibili.com/video/BV1f5411K7mo</a></p><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。</p><p><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV17h411h7UH">https://www.bilibili.com/video/BV17h411h7UH</a></p><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。</p><p>更改题目描述之后，相当于是 文章中 「拓展」的解法</p><p><a href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV16G411c7yZ">https://www.bilibili.com/video/BV16G411c7yZ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-动态规划part01&quot;&gt;&lt;a href=&quot;#第九章-动态规划part01&quot; class=&quot;headerlink&quot; title=&quot;第九章 动态规划part01&quot;&gt;&lt;/a&gt;第九章 动态规划part01&lt;/h1&gt;&lt;p&gt;今天正式开始动态规划！&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 25</title>
    <link href="https://leiqi.top/2025-01-05-7bbcb5258390.html"/>
    <id>https://leiqi.top/2025-01-05-7bbcb5258390.html</id>
    <published>2025-01-05T14:42:38.000Z</published>
    <updated>2025-04-11T10:25:48.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法-part04"><a href="#第七章-回溯算法-part04" class="headerlink" title="第七章 回溯算法 part04"></a>第七章 回溯算法 part04</h1><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p>本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。</p><p><a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html">https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1EG4y1h78v">https://www.bilibili.com/video/BV1EG4y1h78v</a></p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex</p><p><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV19v4y1S79W">https://www.bilibili.com/video/BV19v4y1S79W</a></p><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p>本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容： used[i - 1] &#x3D;&#x3D; true 也行，used[i - 1] &#x3D;&#x3D; false 也行</p><p><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html">https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1R84y1i7Tm">https://www.bilibili.com/video/BV1R84y1i7Tm</a></p><p>下面这三道题都非常难，建议大家一刷的时候 可以适当选择跳过。</p><p>因为 一刷 也不求大家能把这么难的问题解决，大家目前能了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。</p><h2 id="332-重新安排行程（可跳过）"><a href="#332-重新安排行程（可跳过）" class="headerlink" title="332.  重新安排行程（可跳过）"></a>332.  重新安排行程（可跳过）</h2><p>本题很难，一刷的录友刷起来 比较费力，可以留给二刷的时候再去解决。</p><p>本题没有录制视频，当初录视频是按照 《代码随想录》出版的目录来的，当时没有这道题所以就没有录制。</p><p><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html">https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html</a></p><h2 id="51-N皇后（适当跳过）"><a href="#51-N皇后（适当跳过）" class="headerlink" title="51.  N皇后（适当跳过）"></a>51.  N皇后（适当跳过）</h2><p>N皇后这道题目还是很经典的，一刷的录友们建议看看视频了解了解大体思路 就可以 （如果没时间本次就直接跳过） ，先有个印象，二刷的时候重点解决。</p><p><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Rd4y1c7Bq">https://www.bilibili.com/video/BV1Rd4y1c7Bq</a></p><h2 id="37-解数独（适当跳过）"><a href="#37-解数独（适当跳过）" class="headerlink" title="37.  解数独（适当跳过）"></a>37.  解数独（适当跳过）</h2><p>同样，一刷的录友们建议看看视频了解了解大体思路（如果没时间本次就直接跳过），先有个印象，二刷的时候重点解决。</p><p>。</p><p><a href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html">https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1TW4y1471V">https://www.bilibili.com/video/BV1TW4y1471V</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刷了这么多回溯算法的题目，可以做一做总结了！</p><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法-part04&quot;&gt;&lt;a href=&quot;#第七章-回溯算法-part04&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法 part04&quot;&gt;&lt;/a&gt;第七章 回溯算法 part04&lt;/h1&gt;&lt;h2 id=&quot;491-递增子序列&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 24</title>
    <link href="https://leiqi.top/2025-01-05-919f81267a1c.html"/>
    <id>https://leiqi.top/2025-01-05-919f81267a1c.html</id>
    <published>2025-01-05T14:40:19.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法part03"><a href="#第七章-回溯算法part03" class="headerlink" title="第七章 回溯算法part03"></a>第七章 回溯算法part03</h1><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1XP4y1U73i/">https://www.bilibili.com/video/BV1XP4y1U73i/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    path []<span class="type">string</span></span><br><span class="line">    res  []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    path, res = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)), <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    dfs(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">4</span> &#123;    <span class="comment">// 够四段后就不再继续往下递归</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(s) &#123;      </span><br><span class="line">            str := strings.Join(path, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">            res = <span class="built_in">append</span>(res, str)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != start &amp;&amp; s[start] == <span class="string">&#x27;0&#x27;</span> &#123; <span class="comment">// 含有前导 0，无效</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        str := s[start : i+<span class="number">1</span>]</span><br><span class="line">        num, _ := strconv.Atoi(str)</span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span> &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, str)  <span class="comment">// 符合条件的就进入下一层</span></span><br><span class="line">            dfs(s, i+<span class="number">1</span>)</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 如果不满足条件，再往后也不可能满足条件，直接退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1U84y1q7Ci">https://www.bilibili.com/video/BV1U84y1q7Ci</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    path   []<span class="type">int</span></span><br><span class="line">    res  [][]<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res, path = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dfs(nums, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(nums []<span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">    <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">    res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        dfs(nums, i+<span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1vm4y1F71J">https://www.bilibili.com/video/BV1vm4y1F71J</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    result [][]<span class="type">int</span></span><br><span class="line">    path []<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    result = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    path = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    used := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    sort.Ints(nums) <span class="comment">// 去重需要排序</span></span><br><span class="line">    backtracing(nums, <span class="number">0</span>, used)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracing</span><span class="params">(nums []<span class="type">int</span>, startIndex <span class="type">int</span>, used []<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">    <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">    result = <span class="built_in">append</span>(result, tmp)</span><br><span class="line">    <span class="keyword">for</span> i := startIndex; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// 而我们要对同一树层使用过的元素进行跳过</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        backtracing(nums, i + <span class="number">1</span>, used)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法part03&quot;&gt;&lt;a href=&quot;#第七章-回溯算法part03&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法part03&quot;&gt;&lt;/a&gt;第七章 回溯算法part03&lt;/h1&gt;&lt;h3 id=&quot;93-复原IP地址&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 22 回溯算法 part01</title>
    <link href="https://leiqi.top/2025-01-05-b394fdddf846.html"/>
    <id>https://leiqi.top/2025-01-05-b394fdddf846.html</id>
    <published>2025-01-05T14:36:08.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法part01"><a href="#第七章-回溯算法part01" class="headerlink" title="第七章 回溯算法part01"></a>第七章 回溯算法part01</h1><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1cy4y167mM">https://www.bilibili.com/video/BV1cy4y167mM</a></p><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。</p><p>在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。</p><p>本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1ti4y1L7cv">https://www.bilibili.com/video/BV1ti4y1L7cv</a></p><p>剪枝操作：<a href="https://www.bilibili.com/video/BV1wi4y157er">https://www.bilibili.com/video/BV1wi4y157er</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    path []<span class="type">int</span></span><br><span class="line">    res  [][]<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    path, res = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, k), <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    dfs(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;  <span class="comment">// 说明已经满足了k个数的要求</span></span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">        <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt;= n; i++ &#123;  <span class="comment">// 从start开始，不往回走，避免出现重复组合</span></span><br><span class="line">        <span class="keyword">if</span> n - i + <span class="number">1</span> &lt; k - <span class="built_in">len</span>(path) &#123;  <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path, i)</span><br><span class="line">        dfs(n, k, i+<span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>如果把 组合问题理解了，本题就容易一些了。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1wg411873x">https://www.bilibili.com/video/BV1wg411873x</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    res [][]<span class="type">int</span></span><br><span class="line">    path  []<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum3</span><span class="params">(k <span class="type">int</span>, n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    res, path = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, k)</span><br><span class="line">    dfs(k, n, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(k, n <span class="type">int</span>, start <span class="type">int</span>, sum <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == n &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sum + i &gt; n || <span class="number">9</span>-i+<span class="number">1</span> &lt; k-<span class="built_in">len</span>(path) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path, i)</span><br><span class="line">        dfs(k, n, i+<span class="number">1</span>, sum+i)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1yV4y1V7Ug">https://www.bilibili.com/video/BV1yV4y1V7Ug</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    m []<span class="type">string</span></span><br><span class="line">    path []<span class="type">byte</span></span><br><span class="line">    res []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    m = []<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    path, res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(digits, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(digits <span class="type">string</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits) &#123;  <span class="comment">//终止条件，字符串长度等于digits的长度</span></span><br><span class="line">        tmp := <span class="type">string</span>(path)</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    digit := <span class="type">int</span>(digits[start] - <span class="string">&#x27;0&#x27;</span>)  <span class="comment">// 将index指向的数字转为int（确定下一个数字）</span></span><br><span class="line">    str := m[digit<span class="number">-2</span>]   <span class="comment">// 取数字对应的字符集（注意和map中的对应）</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(str); j++ &#123;</span><br><span class="line">        path = <span class="built_in">append</span>(path, str[j])</span><br><span class="line">        dfs(digits, start+<span class="number">1</span>)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法part01&quot;&gt;&lt;a href=&quot;#第七章-回溯算法part01&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法part01&quot;&gt;&lt;/a&gt;第七章 回溯算法part01&lt;/h1&gt;&lt;h3 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 8  字符串 part 01</title>
    <link href="https://leiqi.top/2025-01-05-ec41d1d27b42.html"/>
    <id>https://leiqi.top/2025-01-05-ec41d1d27b42.html</id>
    <published>2025-01-05T14:26:21.000Z</published>
    <updated>2025-04-11T10:25:48.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-字符串part01"><a href="#第四章-字符串part01" class="headerlink" title="第四章 字符串part01"></a>第四章 字符串part01</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  344.反转字符串</p><p>●  541. 反转字符串II</p><p>●  卡码网：54.替换数字</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        s[left], s[right] = s[right], s[left]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ss := []<span class="type">byte</span>(s)</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i += <span class="number">2</span> * k &#123;</span><br><span class="line">     <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">     <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">        <span class="keyword">if</span> i + k &lt;= length &#123;</span><br><span class="line">            reverse(ss[i:i+k])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reverse(ss[i:length])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(b []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        b[left], b[right] = b[right], b[left]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#JavaScript:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> strByte []<span class="type">byte</span></span><br><span class="line">    </span><br><span class="line">    fmt.Scanln(&amp;strByte)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strByte); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> strByte[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; strByte[i] &gt;= <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">            inserElement := []<span class="type">byte</span>&#123;<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line">            strByte = <span class="built_in">append</span>(strByte[:i], <span class="built_in">append</span>(inserElement, strByte[i+<span class="number">1</span>:]...)...)</span><br><span class="line">            i = i + <span class="built_in">len</span>(inserElement) <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="type">string</span>(strByte))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章-字符串part01&quot;&gt;&lt;a href=&quot;#第四章-字符串part01&quot; class=&quot;headerlink&quot; title=&quot;第四章 字符串part01&quot;&gt;&lt;/a&gt;第四章 字符串part01&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 6  哈希表 part01</title>
    <link href="https://leiqi.top/2025-01-05-69753cd7e9a4.html"/>
    <id>https://leiqi.top/2025-01-05-69753cd7e9a4.html</id>
    <published>2025-01-05T14:22:36.000Z</published>
    <updated>2025-04-11T10:25:48.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-哈希表part01"><a href="#第三章-哈希表part01" class="headerlink" title="第三章 哈希表part01"></a>第三章 哈希表part01</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  哈希表理论基础</p><p>●  242.有效的字母异位词</p><p>●  349. 两个数组的交集</p><p>●  202. 快乐数</p><p>●  1. 两数之和</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p>建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。</p><p>什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。</p><p>文章讲解：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    record := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        record[r-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> t &#123;</span><br><span class="line">        record[r-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> record == [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;   <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    count1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1001</span>, <span class="number">1001</span>)</span><br><span class="line">    count2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1001</span>, <span class="number">1001</span>)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">        count1[v] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">        count2[v] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> count1[i] + count2[i] == <span class="number">2</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">1</span> &amp;&amp; !m[n] &#123;</span><br><span class="line">        n, m[n] = getSum(n), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>)</span><br><span class="line">        n = n / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。</p><p>建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k1, _ := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> k2 := k1 + <span class="number">1</span>; k2 &lt; <span class="built_in">len</span>(nums); k2++ &#123;</span><br><span class="line">            <span class="keyword">if</span> target == nums[k1] + nums[k2] &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;k1, k2&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-哈希表part01&quot;&gt;&lt;a href=&quot;#第三章-哈希表part01&quot; class=&quot;headerlink&quot; title=&quot;第三章 哈希表part01&quot;&gt;&lt;/a&gt;第三章 哈希表part01&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 4  链表 part02</title>
    <link href="https://leiqi.top/2025-01-05-1621131dcfb5.html"/>
    <id>https://leiqi.top/2025-01-05-1621131dcfb5.html</id>
    <published>2025-01-05T14:19:48.000Z</published>
    <updated>2025-04-11T10:25:48.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-链表part02"><a href="#第二章-链表part02" class="headerlink" title="第二章 链表part02"></a>第二章 链表part02</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>用虚拟头结点，这样会方便很多。</p><p>本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//head=list[i]</span></span><br><span class="line">    <span class="comment">//pre=list[i-1]</span></span><br><span class="line">    pre := dummy </span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        pre.Next = head.Next</span><br><span class="line">        next := head.Next.Next</span><br><span class="line">        head.Next.Next = head</span><br><span class="line">        head.Next = next</span><br><span class="line">        <span class="comment">//pre=list[(i+2)-1]</span></span><br><span class="line">        pre = head </span><br><span class="line">        <span class="comment">//head=list[(i+2)]</span></span><br><span class="line">        head = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">dummyNode := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">fast, slow := dummyNode, dummyNode</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123; <span class="comment">// 注意&lt;=，否则快指针为空时，慢指针正好在倒数第n个上面</span></span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line">slow.Next = slow.Next.Next</span><br><span class="line"><span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>本题没有视频讲解，大家注意 数值相同，不代表指针相同。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    l1,l2 := headA, headB</span><br><span class="line">    <span class="keyword">for</span> l1 != l2 &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l1 = headB</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2 = headA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="keyword">for</span> slow != head &#123;</span><br><span class="line">                slow = slow.Next</span><br><span class="line">                head = head.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于链表的题目，大家最大的困惑可能就是 什么使用用虚拟头结点，什么时候不用虚拟头结点？</p><p>一般涉及到 增删改操作，用虚拟头结点都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</p><p>当然大家也可以为了方便记忆，统一都用虚拟头结点。</p><p><a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html">https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-链表part02&quot;&gt;&lt;a href=&quot;#第二章-链表part02&quot; class=&quot;headerlink&quot; title=&quot;第二章 链表part02&quot;&gt;&lt;/a&gt;第二章 链表part02&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot; cla</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 3  链表 part01</title>
    <link href="https://leiqi.top/2025-01-05-78490681613a.html"/>
    <id>https://leiqi.top/2025-01-05-78490681613a.html</id>
    <published>2025-01-05T14:16:31.000Z</published>
    <updated>2025-04-11T10:25:48.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-链表part01"><a href="#第二章-链表part01" class="headerlink" title="第二章 链表part01"></a>第二章 链表part01</h1><p>day1 任务以及具体安排：<a href="https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY">https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY</a></p><p>day 2 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG">https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG</a></p><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  链表理论基础</p><p>●  203.移除链表元素</p><p>●  707.设计链表</p><p>●  206.反转链表</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>建议：了解一下链表基础，以及链表和数组的区别</p><p>文章链接：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    dummyHead.Next = head</span><br><span class="line">    cur := dummyHead</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Next.Val == val &#123;</span><br><span class="line">            cur.Next = cur.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//单链表实现</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SingleNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="type">int</span>         <span class="comment">// 节点的值</span></span><br><span class="line">Next *SingleNode <span class="comment">// 下一个节点的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">dummyHead *SingleNode <span class="comment">// 虚拟头节点</span></span><br><span class="line">Size      <span class="type">int</span>         <span class="comment">// 链表大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">list := Constructor()     <span class="comment">// 初始化链表</span></span><br><span class="line">list.AddAtHead(<span class="number">100</span>)       <span class="comment">// 在头部添加元素</span></span><br><span class="line">list.AddAtTail(<span class="number">242</span>)       <span class="comment">// 在尾部添加元素</span></span><br><span class="line">list.AddAtTail(<span class="number">777</span>)       <span class="comment">// 在尾部添加元素</span></span><br><span class="line">list.AddAtIndex(<span class="number">1</span>, <span class="number">99999</span>) <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">list.printLinkedList()    <span class="comment">// 打印链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyLinkedList &#123;</span><br><span class="line">newNode := &amp;SingleNode&#123; <span class="comment">// 创建新节点</span></span><br><span class="line"><span class="number">-999</span>,</span><br><span class="line"><span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MyLinkedList&#123; <span class="comment">// 返回链表</span></span><br><span class="line">dummyHead: newNode,</span><br><span class="line">Size:      <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is</span></span><br><span class="line"><span class="comment">  invalid, return -1. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> Get(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">/*if this != nil || index &lt; 0 || index &gt; this.Size &#123;</span></span><br><span class="line"><span class="comment">return -1</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> this == <span class="literal">nil</span> || index &lt; <span class="number">0</span> || index &gt;= this.Size &#123; <span class="comment">// 如果索引无效则返回-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让cur等于真正头节点</span></span><br><span class="line">cur := this.dummyHead.Next   <span class="comment">// 设置当前节点为真实头节点</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123; <span class="comment">// 遍历到索引所在的节点</span></span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur.Val <span class="comment">// 返回节点值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After</span></span><br><span class="line"><span class="comment">  the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 以下两行代码可用一行代替</span></span><br><span class="line"><span class="comment">// newNode := new(SingleNode)</span></span><br><span class="line"><span class="comment">// newNode.Val = val</span></span><br><span class="line">newNode := &amp;SingleNode&#123;Val: val&#125;   <span class="comment">// 创建新节点</span></span><br><span class="line">newNode.Next = this.dummyHead.Next <span class="comment">// 新节点指向当前头节点</span></span><br><span class="line">this.dummyHead.Next = newNode      <span class="comment">// 新节点变为头节点</span></span><br><span class="line">this.Size++                        <span class="comment">// 链表大小增加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="type">int</span>) &#123;</span><br><span class="line">newNode := &amp;SingleNode&#123;Val: val&#125; <span class="comment">// 创建新节点</span></span><br><span class="line">cur := this.dummyHead            <span class="comment">// 设置当前节点为虚拟头节点</span></span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123;            <span class="comment">// 遍历到最后一个节点</span></span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">cur.Next = newNode <span class="comment">// 在尾部添加新节点</span></span><br><span class="line">this.Size++        <span class="comment">// 链表大小增加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If</span></span><br><span class="line"><span class="comment">  index equals to the length of linked list, the node will be appended to the</span></span><br><span class="line"><span class="comment">  end of linked list. If index is greater than the length, the node will not be</span></span><br><span class="line"><span class="comment">  inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="type">int</span>, val <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> &#123; <span class="comment">// 如果索引小于0，设置为0</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> index &gt; this.Size &#123; <span class="comment">// 如果索引大于链表长度，直接返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newNode := &amp;SingleNode&#123;Val: val&#125; <span class="comment">// 创建新节点</span></span><br><span class="line">cur := this.dummyHead            <span class="comment">// 设置当前节点为虚拟头节点</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;     <span class="comment">// 遍历到指定索引的前一个节点</span></span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">newNode.Next = cur.Next <span class="comment">// 新节点指向原索引节点</span></span><br><span class="line">cur.Next = newNode      <span class="comment">// 原索引的前一个节点指向新节点</span></span><br><span class="line">this.Size++             <span class="comment">// 链表大小增加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.Size &#123; <span class="comment">// 如果索引无效则直接返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cur := this.dummyHead        <span class="comment">// 设置当前节点为虚拟头节点</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123; <span class="comment">// 遍历到要删除节点的前一个节点</span></span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">cur.Next = cur.Next.Next <span class="comment">// 当前节点直接指向下下个节点，即删除了下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">this.Size-- <span class="comment">// 注意删除节点后应将链表大小减一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *MyLinkedList)</span></span> printLinkedList() &#123;</span><br><span class="line">cur := list.dummyHead <span class="comment">// 设置当前节点为虚拟头节点</span></span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">fmt.Println(cur.Next.Val) <span class="comment">// 打印节点值</span></span><br><span class="line">cur = cur.Next            <span class="comment">// 切换到下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//双指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">return</span> help(<span class="literal">nil</span>, head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">help</span><span class="params">(pre, head *ListNode)</span></span>*ListNode&#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">    next := head.Next</span><br><span class="line">    head.Next = pre</span><br><span class="line">    <span class="keyword">return</span> help(head, next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-链表part01&quot;&gt;&lt;a href=&quot;#第二章-链表part01&quot; class=&quot;headerlink&quot; title=&quot;第二章 链表part01&quot;&gt;&lt;/a&gt;第二章 链表part01&lt;/h1&gt;&lt;p&gt;day1 任务以及具体安排：&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>day63 总结</title>
    <link href="https://leiqi.top/2025-01-05-363590304609.html"/>
    <id>https://leiqi.top/2025-01-05-363590304609.html</id>
    <published>2025-01-05T14:11:59.000Z</published>
    <updated>2025-04-11T10:25:48.923Z</updated>
    
    <content type="html"><![CDATA[<p>总结的一句话就是：唯手熟尔，专业知识还要不断精深，代码能力需要不断的增强，然后还要不断的提升架构设计能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结的一句话就是：唯手熟尔，专业知识还要不断精深，代码能力需要不断的增强，然后还要不断的提升架构设计能力。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
</feed>
