<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqi.top/atom.xml" rel="self"/>
  
  <link href="https://leiqi.top/"/>
  <updated>2025-01-13T15:35:14.511Z</updated>
  <id>https://leiqi.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leiqi.top/2025-01-13-bca61020ebe8.html"/>
    <id>https://leiqi.top/2025-01-13-bca61020ebe8.html</id>
    <published>2025-01-13T15:35:14.511Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-代码随想录-day60-第十一章-图论part10date-2025-01-05-22-04-51modificationDate-2025-一月-5日-星期日-22-04-51categories-carltags-sticky-hide-falsecategory-bar-true"><a href="#title-代码随想录-day60-第十一章-图论part10date-2025-01-05-22-04-51modificationDate-2025-一月-5日-星期日-22-04-51categories-carltags-sticky-hide-falsecategory-bar-true" class="headerlink" title="title: 代码随想录 day60 第十一章 图论part10date: 2025-01-05 22:04:51modificationDate: 2025 一月 5日 星期日 22:04:51categories:    - carltags: []sticky: []hide: falsecategory_bar: true"></a>title: 代码随想录 day60 第十一章 图论part10<br>date: 2025-01-05 22:04:51<br>modificationDate: 2025 一月 5日 星期日 22:04:51<br>categories:<br>    - carl<br>tags: []<br>sticky: []<br>hide: false<br>category_bar: true</h2><h1 id="第十一章：图论part10"><a href="#第十一章：图论part10" class="headerlink" title="第十一章：图论part10"></a>第十一章：图论part10</h1><p>今天大家会感受到 Bellman_ford 算法系列在不同场景下的应用。</p><p>建议依然是：一刷的时候，能理解 原理，知道Bellman_ford 解决不同场景的问题 ，照着代码随想录能抄下来代码就好，就算达标。</p><p>二刷的时候自己尝试独立去写，三刷的时候 才能有一定深度理解各个最短路算法。</p><h3 id="Bellman-ford-队列优化算法（又名SPFA）"><a href="#Bellman-ford-队列优化算法（又名SPFA）" class="headerlink" title="Bellman_ford 队列优化算法（又名SPFA）"></a>Bellman_ford 队列优化算法（又名SPFA）</h3><p><a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA.html">https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split())<br>    edges = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        src, dest, weight = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split())<br>        edges[src].append([dest, weight])<br>    <br>    minDist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)] * (n + <span class="hljs-number">1</span>)<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    que = collections.deque([<span class="hljs-number">1</span>])<br>    visited = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br>    visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br>    <br>    <span class="hljs-keyword">while</span> que:<br>        cur = que.popleft()<br>        visited[cur] = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> dest, weight <span class="hljs-keyword">in</span> edges[cur]:<br>            <span class="hljs-keyword">if</span> minDist[cur] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">and</span> minDist[cur] + weight &lt; minDist[dest]:<br>                minDist[dest] = minDist[cur] + weight<br>                <span class="hljs-keyword">if</span> visited[dest] == <span class="hljs-literal">False</span>:<br>                    que.append(dest)<br>                    visited[dest] = <span class="hljs-literal">True</span><br>    <br>    <span class="hljs-keyword">if</span> minDist[-<span class="hljs-number">1</span>] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unconnected&quot;</span><br>    <span class="hljs-keyword">return</span> minDist[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(main())<br><br></code></pre></td></tr></table></figure><h3 id="bellman-ford之判断负权回路"><a href="#bellman-ford之判断负权回路" class="headerlink" title="bellman_ford之判断负权回路"></a>bellman_ford之判断负权回路</h3><p><a href="https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html">https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">input</span> = sys.stdin.read<br>    data = <span class="hljs-built_in">input</span>().split()<br>    index = <span class="hljs-number">0</span><br>    <br>    n = <span class="hljs-built_in">int</span>(data[index])<br>    index += <span class="hljs-number">1</span><br>    m = <span class="hljs-built_in">int</span>(data[index])<br>    index += <span class="hljs-number">1</span><br>    <br>    grid = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        p1 = <span class="hljs-built_in">int</span>(data[index])<br>        index += <span class="hljs-number">1</span><br>        p2 = <span class="hljs-built_in">int</span>(data[index])<br>        index += <span class="hljs-number">1</span><br>        val = <span class="hljs-built_in">int</span>(data[index])<br>        index += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># p1 指向 p2，权值为 val</span><br>        grid.append([p1, p2, val])<br><br>    start = <span class="hljs-number">1</span>  <span class="hljs-comment"># 起点</span><br>    end = n    <span class="hljs-comment"># 终点</span><br><br>    minDist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (n + <span class="hljs-number">1</span>)<br>    minDist[start] = <span class="hljs-number">0</span><br>    flag = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 这里我们松弛n次，最后一次判断负权回路</span><br>        <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> grid:<br>            from_node = side[<span class="hljs-number">0</span>]<br>            to = side[<span class="hljs-number">1</span>]<br>            price = side[<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">if</span> i &lt; n:<br>                <span class="hljs-keyword">if</span> minDist[from_node] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">and</span> minDist[to] &gt; minDist[from_node] + price:<br>                    minDist[to] = minDist[from_node] + price<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 多加一次松弛判断负权回路</span><br>                <span class="hljs-keyword">if</span> minDist[from_node] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">and</span> minDist[to] &gt; minDist[from_node] + price:<br>                    flag = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">if</span> flag:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;circle&quot;</span>)<br>    <span class="hljs-keyword">elif</span> minDist[end] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unconnected&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(minDist[end])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><h3 id="bellman-ford之单源有限最短路"><a href="#bellman-ford之单源有限最短路" class="headerlink" title="bellman_ford之单源有限最短路"></a>bellman_ford之单源有限最短路</h3><p><a href="https://www.programmercarl.com/kamacoder/0096.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93III.html">https://www.programmercarl.com/kamacoder/0096.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93III.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) &#123;&#125;  <span class="hljs-comment">// 构造函数</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    &#125;<br>    <span class="hljs-type">int</span> start, end, k;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; k;<br><br>    k++;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span> , INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist_copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用来记录每一次遍历的结果</span><br><br>    minDist[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点</span><br><br>    <span class="hljs-type">int</span> que_size;<br>    <span class="hljs-keyword">while</span> (k-- &amp;&amp; !que.<span class="hljs-built_in">empty</span>()) &#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 每一轮松弛中，控制节点不用重复入队列</span><br>        minDist_copy = minDist; <br>        que_size = que.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-keyword">while</span> (que_size--) &#123; <br>            <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (Edge edge : grid[node]) &#123;<br>                <span class="hljs-type">int</span> from = node;<br>                <span class="hljs-type">int</span> to = edge.to;<br>                <span class="hljs-type">int</span> price = edge.val;<br>                <span class="hljs-keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) &#123;<br>                    minDist[to] = minDist_copy[from] + price;<br>                    <span class="hljs-keyword">if</span>(visited[to]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不用重复放入队列，但需要重复松弛，所以放在这里位置</span><br>                    visited[to] = <span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">&quot;unreachable&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-代码随想录-day60-第十一章-图论part10date-2025-01-05-22-04-51modificationDate-2025-一月-5日-星期日-22-04-51categories-carltags-sticky-hide-</summary>
      
    
    
    
    <category term="c" scheme="https://leiqi.top/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leiqi.top/2025-01-13-03eb288cbf31.html"/>
    <id>https://leiqi.top/2025-01-13-03eb288cbf31.html</id>
    <published>2025-01-13T15:35:14.509Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-day32date-2025-01-05-22-46-55modificationDate-2025-一月-5日-星期日-22-46-55categories-carltags-sticky-hide-falsecategory-bar-true"><a href="#title-day32date-2025-01-05-22-46-55modificationDate-2025-一月-5日-星期日-22-46-55categories-carltags-sticky-hide-falsecategory-bar-true" class="headerlink" title="title: day32date: 2025-01-05 22:46:55modificationDate: 2025 一月 5日 星期日 22:46:55categories:    - carltags: []sticky: []hide: falsecategory_bar: true"></a>title: day32<br>date: 2025-01-05 22:46:55<br>modificationDate: 2025 一月 5日 星期日 22:46:55<br>categories:<br>    - carl<br>tags: []<br>sticky: []<br>hide: false<br>category_bar: true</h2><h1 id="第九章-动态规划part01"><a href="#第九章-动态规划part01" class="headerlink" title="第九章 动态规划part01"></a>第九章 动态规划part01</h1><p>今天正式开始动态规划！</p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。</p><p>如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？</p><p>其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！</p><p>如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。</p><p><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a></p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><p>很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。</p><p><a href="https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html">https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV1f5411K7mo">https://www.bilibili.com/video/BV1f5411K7mo</a></p><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。</p><p><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html</a></p><p>视频：<a href="https://www.bilibili.com/video/BV17h411h7UH">https://www.bilibili.com/video/BV17h411h7UH</a></p><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。</p><p>更改题目描述之后，相当于是 文章中 「拓展」的解法</p><p><a href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html">https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV16G411c7yZ">https://www.bilibili.com/video/BV16G411c7yZ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-day32date-2025-01-05-22-46-55modificationDate-2025-一月-5日-星期日-22-46-55categories-carltags-sticky-hide-falsecategory-bar-tr</summary>
      
    
    
    
    <category term="c" scheme="https://leiqi.top/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>【最强春节抢票攻略】火车票抢票攻略</title>
    <link href="https://leiqi.top/2025-01-13-facf42a009b6.html"/>
    <id>https://leiqi.top/2025-01-13-facf42a009b6.html</id>
    <published>2025-01-13T15:06:26.000Z</published>
    <updated>2025-01-13T15:35:14.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载分流抢票（windows-，并安装"><a href="#1-下载分流抢票（windows-，并安装" class="headerlink" title="1. 下载分流抢票（windows) ，并安装"></a>1. 下载分流抢票（windows) ，并安装</h1><p><a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p><h1 id="2-登录，查询目标车票放票时间"><a href="#2-登录，查询目标车票放票时间" class="headerlink" title="2.  登录，查询目标车票放票时间"></a>2.  登录，查询目标车票放票时间</h1><p>需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。<br><img src="/../../imgs/Pasted%20image%2020250113231147.png"></p><h1 id="3-先同步服务器时间"><a href="#3-先同步服务器时间" class="headerlink" title="3 先同步服务器时间"></a>3 先同步服务器时间</h1><p><img src="/../../imgs/Pasted%20image%2020250113230630.png"><br>其他设置小黑屋设置为100秒&#x2F;次。<img src="/../../imgs/Pasted%20image%2020250113231508.png"></p><h1 id="4-设置微信通知"><a href="#4-设置微信通知" class="headerlink" title="4.设置微信通知"></a>4.设置微信通知</h1><p>扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。</p><p><img src="/../../imgs/Pasted%20image%2020250113231735.png"></p><h1 id="5-设置自动支付"><a href="#5-设置自动支付" class="headerlink" title="5.设置自动支付"></a>5.设置自动支付</h1><p>绑定支付宝，抢到票自动支付。<br><img src="/../../imgs/Pasted%20image%2020250113231928.png"></p><h1 id="6-设置定时抢票提前两秒"><a href="#6-设置定时抢票提前两秒" class="headerlink" title="6. 设置定时抢票提前两秒"></a>6. 设置定时抢票提前两秒</h1><p>时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击<font color="#00b0f0">开始抢票</font>！等待抢票成功吧！<br><img src="/../../imgs/Pasted%20image%2020250113231359.png"></p><h1 id="抢到啦"><a href="#抢到啦" class="headerlink" title="抢到啦"></a>抢到啦</h1><p><img src="/../../imgs/56b7445f8dd9a71eb1cd751e0030567.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载分流抢票（windows-，并安装&quot;&gt;&lt;a href=&quot;#1-下载分流抢票（windows-，并安装&quot; class=&quot;headerlink&quot; title=&quot;1. 下载分流抢票（windows) ，并安装&quot;&gt;&lt;/a&gt;1. 下载分流抢票（windows) ，并</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>day34</title>
    <link href="https://leiqi.top/2025-01-05-fd59568f4fb6.html"/>
    <id>https://leiqi.top/2025-01-05-fd59568f4fb6.html</id>
    <published>2025-01-05T14:58:46.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-动态规划part02"><a href="#第九章-动态规划part02" class="headerlink" title="第九章 动态规划part02"></a>第九章 动态规划part02</h1><p>今天开始逐渐有 dp的感觉了，前 两题 不同路径，可以好好研究一下，适合进阶</p><p>详细布置</p><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。</p><p><a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1ve4y1x7Eu">https://www.bilibili.com/video/BV1ve4y1x7Eu</a></p><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p><a href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html">https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.htmlhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Ld4y1k7c6">https://www.bilibili.com/video/BV1Ld4y1k7c6</a></p><h3 id="343-整数拆分-（可跳过）"><a href="#343-整数拆分-（可跳过）" class="headerlink" title="343.  整数拆分 （可跳过）"></a>343.  整数拆分 （可跳过）</h3><p>本题思路并不容易想，一刷建议可以跳过。如果学有余力，可以看视频理解一波。</p><p><a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html">https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Mg411q7YJ">https://www.bilibili.com/video/BV1Mg411q7YJ</a></p><h3 id="96-不同的二叉搜索树-（可跳过）"><a href="#96-不同的二叉搜索树-（可跳过）" class="headerlink" title="96.  .不同的二叉搜索树 （可跳过）"></a>96.  .不同的二叉搜索树 （可跳过）</h3><p>本题思路并不容易想，一刷建议可以跳过。 如果学有余力，可以看视频理解一波。</p><p><a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1eK411o7QA">https://www.bilibili.com/video/BV1eK411o7QA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-动态规划part02&quot;&gt;&lt;a href=&quot;#第九章-动态规划part02&quot; class=&quot;headerlink&quot; title=&quot;第九章 动态规划part02&quot;&gt;&lt;/a&gt;第九章 动态规划part02&lt;/h1&gt;&lt;p&gt;今天开始逐渐有 dp的感觉了，前 两题 不同</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 25</title>
    <link href="https://leiqi.top/2025-01-05-7bbcb5258390.html"/>
    <id>https://leiqi.top/2025-01-05-7bbcb5258390.html</id>
    <published>2025-01-05T14:42:38.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法-part04"><a href="#第七章-回溯算法-part04" class="headerlink" title="第七章 回溯算法 part04"></a>第七章 回溯算法 part04</h1><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p>本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。</p><p><a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html">https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1EG4y1h78v">https://www.bilibili.com/video/BV1EG4y1h78v</a></p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex</p><p><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV19v4y1S79W">https://www.bilibili.com/video/BV19v4y1S79W</a></p><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p>本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容： used[i - 1] &#x3D;&#x3D; true 也行，used[i - 1] &#x3D;&#x3D; false 也行</p><p><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html">https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1R84y1i7Tm">https://www.bilibili.com/video/BV1R84y1i7Tm</a></p><p>下面这三道题都非常难，建议大家一刷的时候 可以适当选择跳过。</p><p>因为 一刷 也不求大家能把这么难的问题解决，大家目前能了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。</p><h2 id="332-重新安排行程（可跳过）"><a href="#332-重新安排行程（可跳过）" class="headerlink" title="332.  重新安排行程（可跳过）"></a>332.  重新安排行程（可跳过）</h2><p>本题很难，一刷的录友刷起来 比较费力，可以留给二刷的时候再去解决。</p><p>本题没有录制视频，当初录视频是按照 《代码随想录》出版的目录来的，当时没有这道题所以就没有录制。</p><p><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html">https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html</a></p><h2 id="51-N皇后（适当跳过）"><a href="#51-N皇后（适当跳过）" class="headerlink" title="51.  N皇后（适当跳过）"></a>51.  N皇后（适当跳过）</h2><p>N皇后这道题目还是很经典的，一刷的录友们建议看看视频了解了解大体思路 就可以 （如果没时间本次就直接跳过） ，先有个印象，二刷的时候重点解决。</p><p><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1Rd4y1c7Bq">https://www.bilibili.com/video/BV1Rd4y1c7Bq</a></p><h2 id="37-解数独（适当跳过）"><a href="#37-解数独（适当跳过）" class="headerlink" title="37.  解数独（适当跳过）"></a>37.  解数独（适当跳过）</h2><p>同样，一刷的录友们建议看看视频了解了解大体思路（如果没时间本次就直接跳过），先有个印象，二刷的时候重点解决。</p><p>。</p><p><a href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html">https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1TW4y1471V">https://www.bilibili.com/video/BV1TW4y1471V</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刷了这么多回溯算法的题目，可以做一做总结了！</p><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法-part04&quot;&gt;&lt;a href=&quot;#第七章-回溯算法-part04&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法 part04&quot;&gt;&lt;/a&gt;第七章 回溯算法 part04&lt;/h1&gt;&lt;h2 id=&quot;491-递增子序列&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 24</title>
    <link href="https://leiqi.top/2025-01-05-919f81267a1c.html"/>
    <id>https://leiqi.top/2025-01-05-919f81267a1c.html</id>
    <published>2025-01-05T14:40:19.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法part03"><a href="#第七章-回溯算法part03" class="headerlink" title="第七章 回溯算法part03"></a>第七章 回溯算法part03</h1><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><p>本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1XP4y1U73i/">https://www.bilibili.com/video/BV1XP4y1U73i/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    path []<span class="hljs-type">string</span><br>    res  []<span class="hljs-type">string</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    path, res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)), <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    dfs(s, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, start <span class="hljs-type">int</span>)</span></span> &#123;  <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-number">4</span> &#123;    <span class="hljs-comment">// 够四段后就不再继续往下递归</span><br>        <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(s) &#123;      <br>            str := strings.Join(path, <span class="hljs-string">&quot;.&quot;</span>)<br>            res = <span class="hljs-built_in">append</span>(res, str)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">if</span> i != start &amp;&amp; s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &#123; <span class="hljs-comment">// 含有前导 0，无效</span><br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        str := s[start : i+<span class="hljs-number">1</span>]<br>        num, _ := strconv.Atoi(str)<br>        <span class="hljs-keyword">if</span> num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt;= <span class="hljs-number">255</span> &#123;<br>            path = <span class="hljs-built_in">append</span>(path, str)  <span class="hljs-comment">// 符合条件的就进入下一层</span><br>            dfs(s, i+<span class="hljs-number">1</span>)<br>            path = path[:<span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// 如果不满足条件，再往后也不可能满足条件，直接退出</span><br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1U84y1q7Ci">https://www.bilibili.com/video/BV1U84y1q7Ci</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> (<br>    path   []<span class="hljs-type">int</span><br>    res  [][]<span class="hljs-type">int</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res, path = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums))<br>    dfs(nums, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, start <span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>    <span class="hljs-built_in">copy</span>(tmp, path)<br>    res = <span class="hljs-built_in">append</span>(res, tmp)<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        path = <span class="hljs-built_in">append</span>(path, nums[i])<br>        dfs(nums, i+<span class="hljs-number">1</span>)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h3><p>大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1vm4y1F71J">https://www.bilibili.com/video/BV1vm4y1F71J</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> (<br>    result [][]<span class="hljs-type">int</span><br>    path []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    result = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    used := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    sort.Ints(nums) <span class="hljs-comment">// 去重需要排序</span><br>    backtracing(nums, <span class="hljs-number">0</span>, used)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, startIndex <span class="hljs-type">int</span>, used []<span class="hljs-type">bool</span>)</span></span> &#123;<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<br>    <span class="hljs-built_in">copy</span>(tmp, path)<br>    result = <span class="hljs-built_in">append</span>(result, tmp)<br>    <span class="hljs-keyword">for</span> i := startIndex; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>        <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>        <span class="hljs-comment">// 而我们要对同一树层使用过的元素进行跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &amp;&amp; used[i<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        path = <span class="hljs-built_in">append</span>(path, nums[i])<br>        used[i] = <span class="hljs-literal">true</span><br>        backtracing(nums, i + <span class="hljs-number">1</span>, used)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>        used[i] = <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法part03&quot;&gt;&lt;a href=&quot;#第七章-回溯算法part03&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法part03&quot;&gt;&lt;/a&gt;第七章 回溯算法part03&lt;/h1&gt;&lt;h3 id=&quot;93-复原IP地址&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 22 回溯算法 part01</title>
    <link href="https://leiqi.top/2025-01-05-b394fdddf846.html"/>
    <id>https://leiqi.top/2025-01-05-b394fdddf846.html</id>
    <published>2025-01-05T14:36:08.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-回溯算法part01"><a href="#第七章-回溯算法part01" class="headerlink" title="第七章 回溯算法part01"></a>第七章 回溯算法part01</h1><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1cy4y167mM">https://www.bilibili.com/video/BV1cy4y167mM</a></p><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。</p><p>在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。</p><p>本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1ti4y1L7cv">https://www.bilibili.com/video/BV1ti4y1L7cv</a></p><p>剪枝操作：<a href="https://www.bilibili.com/video/BV1wi4y157er">https://www.bilibili.com/video/BV1wi4y157er</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> (<br>    path []<span class="hljs-type">int</span><br>    res  [][]<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    path, res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, k), <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    dfs(n, k, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, start <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;  <span class="hljs-comment">// 说明已经满足了k个数的要求</span><br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>        <span class="hljs-built_in">copy</span>(tmp, path)<br>        res = <span class="hljs-built_in">append</span>(res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n; i++ &#123;  <span class="hljs-comment">// 从start开始，不往回走，避免出现重复组合</span><br>        <span class="hljs-keyword">if</span> n - i + <span class="hljs-number">1</span> &lt; k - <span class="hljs-built_in">len</span>(path) &#123;  <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        path = <span class="hljs-built_in">append</span>(path, i)<br>        dfs(n, k, i+<span class="hljs-number">1</span>)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><p>如果把 组合问题理解了，本题就容易一些了。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1wg411873x">https://www.bilibili.com/video/BV1wg411873x</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    res [][]<span class="hljs-type">int</span><br>    path  []<span class="hljs-type">int</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum3</span><span class="hljs-params">(k <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res, path = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, k)<br>    dfs(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(k, n <span class="hljs-type">int</span>, start <span class="hljs-type">int</span>, sum <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>        <span class="hljs-keyword">if</span> sum == n &#123;<br>            tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>            <span class="hljs-built_in">copy</span>(tmp, path)<br>            res = <span class="hljs-built_in">append</span>(res, tmp)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := start; i &lt;= <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> sum + i &gt; n || <span class="hljs-number">9</span>-i+<span class="hljs-number">1</span> &lt; k-<span class="hljs-built_in">len</span>(path) &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        path = <span class="hljs-built_in">append</span>(path, i)<br>        dfs(k, n, i+<span class="hljs-number">1</span>, sum+i)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html</a></p><p>视频讲解：<a href="https://www.bilibili.com/video/BV1yV4y1V7Ug">https://www.bilibili.com/video/BV1yV4y1V7Ug</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><br><span class="hljs-keyword">var</span> (<br>    m []<span class="hljs-type">string</span><br>    path []<span class="hljs-type">byte</span><br>    res []<span class="hljs-type">string</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    m = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>    path, res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> digits == <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    dfs(digits, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(digits <span class="hljs-type">string</span>, start <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(digits) &#123;  <span class="hljs-comment">//终止条件，字符串长度等于digits的长度</span><br>        tmp := <span class="hljs-type">string</span>(path)<br>        res = <span class="hljs-built_in">append</span>(res, tmp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    digit := <span class="hljs-type">int</span>(digits[start] - <span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment">// 将index指向的数字转为int（确定下一个数字）</span><br>    str := m[digit<span class="hljs-number">-2</span>]   <span class="hljs-comment">// 取数字对应的字符集（注意和map中的对应）</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(str); j++ &#123;<br>        path = <span class="hljs-built_in">append</span>(path, str[j])<br>        dfs(digits, start+<span class="hljs-number">1</span>)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-回溯算法part01&quot;&gt;&lt;a href=&quot;#第七章-回溯算法part01&quot; class=&quot;headerlink&quot; title=&quot;第七章 回溯算法part01&quot;&gt;&lt;/a&gt;第七章 回溯算法part01&lt;/h1&gt;&lt;h3 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 8  字符串 part 01</title>
    <link href="https://leiqi.top/2025-01-05-ec41d1d27b42.html"/>
    <id>https://leiqi.top/2025-01-05-ec41d1d27b42.html</id>
    <published>2025-01-05T14:26:21.000Z</published>
    <updated>2025-01-13T15:35:14.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-字符串part01"><a href="#第四章-字符串part01" class="headerlink" title="第四章 字符串part01"></a>第四章 字符串part01</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  344.反转字符串</p><p>●  541. 反转字符串II</p><p>●  卡码网：54.替换数字</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        s[left], s[right] = s[right], s[left]<br>        left++<br>        right--<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(s <span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    ss := []<span class="hljs-type">byte</span>(s)<br>    length := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i += <span class="hljs-number">2</span> * k &#123;<br>     <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>     <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>        <span class="hljs-keyword">if</span> i + k &lt;= length &#123;<br>            reverse(ss[i:i+k])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            reverse(ss[i:length])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ss)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    left := <span class="hljs-number">0</span><br>    right := <span class="hljs-built_in">len</span>(b) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        b[left], b[right] = b[right], b[left]<br>        left++<br>        right--<br>    &#125;<br>&#125;<br>#JavaScript:<br><br><br></code></pre></td></tr></table></figure><h3 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h3><p>建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> strByte []<span class="hljs-type">byte</span><br>    <br>    fmt.Scanln(&amp;strByte)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(strByte); i++&#123;<br>        <span class="hljs-keyword">if</span> strByte[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; strByte[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>            inserElement := []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>&#125;<br>            strByte = <span class="hljs-built_in">append</span>(strByte[:i], <span class="hljs-built_in">append</span>(inserElement, strByte[i+<span class="hljs-number">1</span>:]...)...)<br>            i = i + <span class="hljs-built_in">len</span>(inserElement) <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <br>    fmt.Printf(<span class="hljs-type">string</span>(strByte))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章-字符串part01&quot;&gt;&lt;a href=&quot;#第四章-字符串part01&quot; class=&quot;headerlink&quot; title=&quot;第四章 字符串part01&quot;&gt;&lt;/a&gt;第四章 字符串part01&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 6  哈希表 part01</title>
    <link href="https://leiqi.top/2025-01-05-69753cd7e9a4.html"/>
    <id>https://leiqi.top/2025-01-05-69753cd7e9a4.html</id>
    <published>2025-01-05T14:22:36.000Z</published>
    <updated>2025-01-13T15:35:14.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-哈希表part01"><a href="#第三章-哈希表part01" class="headerlink" title="第三章 哈希表part01"></a>第三章 哈希表part01</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  哈希表理论基础</p><p>●  242.有效的字母异位词</p><p>●  349. 两个数组的交集</p><p>●  202. 快乐数</p><p>●  1. 两数之和</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h3><p>建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。</p><p>什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。</p><p>文章讲解：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p>建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    record := [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br>        record[r-<span class="hljs-type">rune</span>(<span class="hljs-string">&#x27;a&#x27;</span>)]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> t &#123;<br>        record[r-<span class="hljs-type">rune</span>(<span class="hljs-string">&#x27;a&#x27;</span>)]--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> record == [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;   <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intersection</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    count1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1001</span>)<br>    count2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1001</span>)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums1 &#123;<br>        count1[v] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums2 &#123;<br>        count2[v] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1000</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> count1[i] + count2[i] == <span class="hljs-number">2</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">1</span> &amp;&amp; !m[n] &#123;<br>        n, m[n] = getSum(n), <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>        sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>)<br>        n = n / <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。</p><p>建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> k1, _ := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> k2 := k1 + <span class="hljs-number">1</span>; k2 &lt; <span class="hljs-built_in">len</span>(nums); k2++ &#123;<br>            <span class="hljs-keyword">if</span> target == nums[k1] + nums[k2] &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;k1, k2&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-哈希表part01&quot;&gt;&lt;a href=&quot;#第三章-哈希表part01&quot; class=&quot;headerlink&quot; title=&quot;第三章 哈希表part01&quot;&gt;&lt;/a&gt;第三章 哈希表part01&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 4  链表 part02</title>
    <link href="https://leiqi.top/2025-01-05-1621131dcfb5.html"/>
    <id>https://leiqi.top/2025-01-05-1621131dcfb5.html</id>
    <published>2025-01-05T14:19:48.000Z</published>
    <updated>2025-01-13T15:35:14.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-链表part02"><a href="#第二章-链表part02" class="headerlink" title="第二章 链表part02"></a>第二章 链表part02</h1><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>用虚拟头结点，这样会方便很多。</p><p>本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解： <a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;<br>        Next: head,<br>    &#125;<br>    <span class="hljs-comment">//head=list[i]</span><br>    <span class="hljs-comment">//pre=list[i-1]</span><br>    pre := dummy <br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &amp;&amp; head.Next != <span class="hljs-literal">nil</span> &#123;<br>        pre.Next = head.Next<br>        next := head.Next.Next<br>        head.Next.Next = head<br>        head.Next = next<br>        <span class="hljs-comment">//pre=list[(i+2)-1]</span><br>        pre = head <br>        <span class="hljs-comment">//head=list[(i+2)]</span><br>        head = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>dummyNode := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>fast, slow := dummyNode, dummyNode<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 注意&lt;=，否则快指针为空时，慢指针正好在倒数第n个上面</span><br>fast = fast.Next<br>&#125;<br><span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>fast = fast.Next<br>slow = slow.Next<br>&#125;<br>slow.Next = slow.Next.Next<br><span class="hljs-keyword">return</span> dummyNode.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>本题没有视频讲解，大家注意 数值相同，不代表指针相同。</p><p>题目链接&#x2F;文章讲解：<a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    l1,l2 := headA, headB<br>    <span class="hljs-keyword">for</span> l1 != l2 &#123;<br>        <span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>            l1 = l1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l1 = headB<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>            l2 = l2.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2 = headA<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l1<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>        <span class="hljs-keyword">if</span> slow == fast &#123;<br>            <span class="hljs-keyword">for</span> slow != head &#123;<br>                slow = slow.Next<br>                head = head.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于链表的题目，大家最大的困惑可能就是 什么使用用虚拟头结点，什么时候不用虚拟头结点？</p><p>一般涉及到 增删改操作，用虚拟头结点都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</p><p>当然大家也可以为了方便记忆，统一都用虚拟头结点。</p><p><a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html">https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-链表part02&quot;&gt;&lt;a href=&quot;#第二章-链表part02&quot; class=&quot;headerlink&quot; title=&quot;第二章 链表part02&quot;&gt;&lt;/a&gt;第二章 链表part02&lt;/h1&gt;&lt;h2 id=&quot;今日任务&quot;&gt;&lt;a href=&quot;#今日任务&quot; cla</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day 3  链表 part01</title>
    <link href="https://leiqi.top/2025-01-05-78490681613a.html"/>
    <id>https://leiqi.top/2025-01-05-78490681613a.html</id>
    <published>2025-01-05T14:16:31.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-链表part01"><a href="#第二章-链表part01" class="headerlink" title="第二章 链表part01"></a>第二章 链表part01</h1><p>day1 任务以及具体安排：<a href="https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY">https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY</a></p><p>day 2 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG">https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG</a></p><h2 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h2><p>●  链表理论基础</p><p>●  203.移除链表元素</p><p>●  707.设计链表</p><p>●  206.反转链表</p><h2 id="详细布置"><a href="#详细布置" class="headerlink" title="详细布置"></a>详细布置</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>建议：了解一下链表基础，以及链表和数组的区别</p><p>文章链接：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p>建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElements</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummyHead := &amp;ListNode&#123;&#125;<br>    dummyHead.Next = head<br>    cur := dummyHead<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Next.Val == val &#123;<br>            cur.Next = cur.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html">https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//单链表实现</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> SingleNode <span class="hljs-keyword">struct</span> &#123;<br>Val  <span class="hljs-type">int</span>         <span class="hljs-comment">// 节点的值</span><br>Next *SingleNode <span class="hljs-comment">// 下一个节点的指针</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyLinkedList <span class="hljs-keyword">struct</span> &#123;<br>dummyHead *SingleNode <span class="hljs-comment">// 虚拟头节点</span><br>Size      <span class="hljs-type">int</span>         <span class="hljs-comment">// 链表大小</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := Constructor()     <span class="hljs-comment">// 初始化链表</span><br>list.AddAtHead(<span class="hljs-number">100</span>)       <span class="hljs-comment">// 在头部添加元素</span><br>list.AddAtTail(<span class="hljs-number">242</span>)       <span class="hljs-comment">// 在尾部添加元素</span><br>list.AddAtTail(<span class="hljs-number">777</span>)       <span class="hljs-comment">// 在尾部添加元素</span><br>list.AddAtIndex(<span class="hljs-number">1</span>, <span class="hljs-number">99999</span>) <span class="hljs-comment">// 在指定位置添加元素</span><br>list.printLinkedList()    <span class="hljs-comment">// 打印链表</span><br>&#125;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyLinkedList &#123;<br>newNode := &amp;SingleNode&#123; <span class="hljs-comment">// 创建新节点</span><br><span class="hljs-number">-999</span>,<br><span class="hljs-literal">nil</span>,<br>&#125;<br><span class="hljs-keyword">return</span> MyLinkedList&#123; <span class="hljs-comment">// 返回链表</span><br>dummyHead: newNode,<br>Size:      <span class="hljs-number">0</span>,<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is</span><br><span class="hljs-comment">  invalid, return -1. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> Get(index <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">/*if this != nil || index &lt; 0 || index &gt; this.Size &#123;</span><br><span class="hljs-comment">return -1</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">if</span> this == <span class="hljs-literal">nil</span> || index &lt; <span class="hljs-number">0</span> || index &gt;= this.Size &#123; <span class="hljs-comment">// 如果索引无效则返回-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// 让cur等于真正头节点</span><br>cur := this.dummyHead.Next   <span class="hljs-comment">// 设置当前节点为真实头节点</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123; <span class="hljs-comment">// 遍历到索引所在的节点</span><br>cur = cur.Next<br>&#125;<br><span class="hljs-keyword">return</span> cur.Val <span class="hljs-comment">// 返回节点值</span><br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After</span><br><span class="hljs-comment">  the insertion, the new node will be the first node of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtHead(val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 以下两行代码可用一行代替</span><br><span class="hljs-comment">// newNode := new(SingleNode)</span><br><span class="hljs-comment">// newNode.Val = val</span><br>newNode := &amp;SingleNode&#123;Val: val&#125;   <span class="hljs-comment">// 创建新节点</span><br>newNode.Next = this.dummyHead.Next <span class="hljs-comment">// 新节点指向当前头节点</span><br>this.dummyHead.Next = newNode      <span class="hljs-comment">// 新节点变为头节点</span><br>this.Size++                        <span class="hljs-comment">// 链表大小增加1</span><br>&#125;<br><br><span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtTail(val <span class="hljs-type">int</span>) &#123;<br>newNode := &amp;SingleNode&#123;Val: val&#125; <span class="hljs-comment">// 创建新节点</span><br>cur := this.dummyHead            <span class="hljs-comment">// 设置当前节点为虚拟头节点</span><br><span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-comment">// 遍历到最后一个节点</span><br>cur = cur.Next<br>&#125;<br>cur.Next = newNode <span class="hljs-comment">// 在尾部添加新节点</span><br>this.Size++        <span class="hljs-comment">// 链表大小增加1</span><br>&#125;<br><br><span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If</span><br><span class="hljs-comment">  index equals to the length of linked list, the node will be appended to the</span><br><span class="hljs-comment">  end of linked list. If index is greater than the length, the node will not be</span><br><span class="hljs-comment">  inserted. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> AddAtIndex(index <span class="hljs-type">int</span>, val <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果索引小于0，设置为0</span><br>index = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> index &gt; this.Size &#123; <span class="hljs-comment">// 如果索引大于链表长度，直接返回</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br>newNode := &amp;SingleNode&#123;Val: val&#125; <span class="hljs-comment">// 创建新节点</span><br>cur := this.dummyHead            <span class="hljs-comment">// 设置当前节点为虚拟头节点</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123;     <span class="hljs-comment">// 遍历到指定索引的前一个节点</span><br>cur = cur.Next<br>&#125;<br>newNode.Next = cur.Next <span class="hljs-comment">// 新节点指向原索引节点</span><br>cur.Next = newNode      <span class="hljs-comment">// 原索引的前一个节点指向新节点</span><br>this.Size++             <span class="hljs-comment">// 链表大小增加1</span><br>&#125;<br><br><span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyLinkedList)</span></span> DeleteAtIndex(index <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> || index &gt;= this.Size &#123; <span class="hljs-comment">// 如果索引无效则直接返回</span><br><span class="hljs-keyword">return</span><br>&#125;<br>cur := this.dummyHead        <span class="hljs-comment">// 设置当前节点为虚拟头节点</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; index; i++ &#123; <span class="hljs-comment">// 遍历到要删除节点的前一个节点</span><br>cur = cur.Next<br>&#125;<br><span class="hljs-keyword">if</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>cur.Next = cur.Next.Next <span class="hljs-comment">// 当前节点直接指向下下个节点，即删除了下一个节点</span><br>&#125;<br>this.Size-- <span class="hljs-comment">// 注意删除节点后应将链表大小减一</span><br>&#125;<br><br><span class="hljs-comment">// 打印链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *MyLinkedList)</span></span> printLinkedList() &#123;<br>cur := list.dummyHead <span class="hljs-comment">// 设置当前节点为虚拟头节点</span><br><span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 遍历链表</span><br>fmt.Println(cur.Next.Val) <span class="hljs-comment">// 打印节点值</span><br>cur = cur.Next            <span class="hljs-comment">// 切换到下一个节点</span><br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。</p><p>题目链接&#x2F;文章讲解&#x2F;视频讲解：<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre *ListNode<br>    cur := head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> help(<span class="hljs-literal">nil</span>, head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">help</span><span class="hljs-params">(pre, head *ListNode)</span></span>*ListNode&#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> pre<br>    &#125;<br>    next := head.Next<br>    head.Next = pre<br>    <span class="hljs-keyword">return</span> help(head, next)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-链表part01&quot;&gt;&lt;a href=&quot;#第二章-链表part01&quot; class=&quot;headerlink&quot; title=&quot;第二章 链表part01&quot;&gt;&lt;/a&gt;第二章 链表part01&lt;/h1&gt;&lt;p&gt;day1 任务以及具体安排：&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>day63 总结</title>
    <link href="https://leiqi.top/2025-01-05-363590304609.html"/>
    <id>https://leiqi.top/2025-01-05-363590304609.html</id>
    <published>2025-01-05T14:11:59.000Z</published>
    <updated>2025-01-13T15:35:14.509Z</updated>
    
    <content type="html"><![CDATA[<p>总结的一句话就是：唯手熟尔，专业知识还要不断精深，代码能力需要不断的增强，然后还要不断的提升架构设计能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结的一句话就是：唯手熟尔，专业知识还要不断精深，代码能力需要不断的增强，然后还要不断的提升架构设计能力。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day62 第十一章 图论part11</title>
    <link href="https://leiqi.top/2025-01-05-28ad0b8af774.html"/>
    <id>https://leiqi.top/2025-01-05-28ad0b8af774.html</id>
    <published>2025-01-05T14:08:53.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part11"><a href="#第十一章：图论part11" class="headerlink" title="第十一章：图论part11"></a>第十一章：图论part11</h1><h3 id="Floyd-算法精讲"><a href="#Floyd-算法精讲" class="headerlink" title="Floyd 算法精讲"></a>Floyd 算法精讲</h3><p>Floyd 算法代码很简单，但真正理解起原理 还是需要花点功夫，大家在看代码的时候，会发现 Floyd 的代码很简单，甚至看一眼就背下来了，但我为了讲清楚原理，本篇还是花了大篇幅来讲解。</p><p><a href="https://www.programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html">https://www.programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    max_int = <span class="hljs-number">10005</span>  <span class="hljs-comment"># 设置最大路径，因为边最大距离为10^4</span><br><br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>    grid = [[[max_int] * (n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 初始化三维dp数组</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        p1, p2, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        grid[p1][p2][<span class="hljs-number">0</span>] = w<br>        grid[p2][p1][<span class="hljs-number">0</span>] = w<br><br>    <span class="hljs-comment"># 开始floyd</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>                grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k-<span class="hljs-number">1</span>], grid[i][k][k-<span class="hljs-number">1</span>] + grid[k][j][k-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-comment"># 输出结果</span><br>    z = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(z):<br>        start, end = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> grid[start][end][n] == max_int:<br>            <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(grid[start][end][n])<br><br></code></pre></td></tr></table></figure><h3 id="A-算法精讲-（A-star算法）"><a href="#A-算法精讲-（A-star算法）" class="headerlink" title="A * 算法精讲 （A star算法）"></a>A * 算法精讲 （A star算法）</h3><p>一般 笔试或者 面试的时候，不会考察A<em>， 都是会结合具体业务场景问 A</em>算法，例如：地图导航，游戏开发 等等。</p><p>其实基础版的A* 并不难，所以大家不要畏惧，理解本篇内容，甚至独立写出代码，大家可以做到，加油</p><p><a href="https://www.programmercarl.com/kamacoder/0126.%E9%AA%91%E5%A3%AB%E7%9A%84%E6%94%BB%E5%87%BBastar.html">https://www.programmercarl.com/kamacoder/0126.%E9%AA%91%E5%A3%AB%E7%9A%84%E6%94%BB%E5%87%BBastar.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> heapq<br> <br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br> <br>moves = [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>), (-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>), (-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)]<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> ((a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> + (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>) ** <span class="hljs-number">0.5</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start, end</span>):<br>    q = [(distance(start, end), start)]<br>    step = &#123;start: <span class="hljs-number">0</span>&#125;<br>     <br>    <span class="hljs-keyword">while</span> q:<br>        d, cur = heapq.heappop(q)<br>        <span class="hljs-keyword">if</span> cur == end:<br>            <span class="hljs-keyword">return</span> step[cur]<br>        <span class="hljs-keyword">for</span> move <span class="hljs-keyword">in</span> moves:<br>            new = (move[<span class="hljs-number">0</span>] + cur[<span class="hljs-number">0</span>], move[<span class="hljs-number">1</span>] + cur[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &lt;= new[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">1000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> &lt;= new[<span class="hljs-number">1</span>] &lt;= <span class="hljs-number">1000</span>:<br>                step_new = step[cur] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> step_new &lt; step.get(new, <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)):<br>                    step[new] = step_new<br>                    heapq.heappush(q, (distance(new, end) + step_new, new))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                     <br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a1, a2, b1, b2 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-built_in">print</span>(bfs((a1, a2), (b1, b2)))<br></code></pre></td></tr></table></figure><h3 id="最短路算法总结篇"><a href="#最短路算法总结篇" class="headerlink" title="最短路算法总结篇"></a>最短路算法总结篇</h3><p>最各个最短路算法有个全面的了解</p><p><a href="https://www.programmercarl.com/kamacoder/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html">https://www.programmercarl.com/kamacoder/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html</a></p><p><strong>如果遇到单源且边为正数，直接Dijkstra</strong>。</p><p>至于 <strong>使用朴素版还是 堆优化版 还是取决于图的稠密度</strong>， 多少节点多少边算是稠密图，多少算是稀疏图，这个没有量化，如果想量化只能写出两个版本然后做实验去测试，不同的判题机得出的结果还不太一样。</p><p>一般情况下，可以直接用堆优化版本。</p><p><strong>如果遇到单源边可为负数，直接 Bellman-Ford</strong>，同样 SPFA 还是 Bellman-Ford 取决于图的稠密度。</p><p>一般情况下，直接用 SPFA。</p><p><strong>如果有负权回路，优先 Bellman-Ford</strong>， 如果是有限节点最短路 也优先 Bellman-Ford，理由是写代码比较方便。</p><p><strong>如果是遇到多源点求最短路，直接 Floyd</strong>。</p><h3 id="图论总结"><a href="#图论总结" class="headerlink" title="图论总结"></a>图论总结</h3><p><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93%E7%AF%87.html">https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93%E7%AF%87.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part11&quot;&gt;&lt;a href=&quot;#第十一章：图论part11&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part11&quot;&gt;&lt;/a&gt;第十一章：图论part11&lt;/h1&gt;&lt;h3 id=&quot;Floyd-算法精讲&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day59 第十一章 图论part09</title>
    <link href="https://leiqi.top/2025-01-05-5314163e2a3e.html"/>
    <id>https://leiqi.top/2025-01-05-5314163e2a3e.html</id>
    <published>2025-01-05T14:02:10.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part09"><a href="#第十一章：图论part09" class="headerlink" title="第十一章：图论part09"></a>第十一章：图论part09</h1><p>今天的建议依然是，一刷的时候，能了解 原理，照着代码随想录能抄下来代码就好，就算达标。</p><p>二刷的时候自己尝试独立去写，三刷的时候 才能有一定深度理解各个最短路算法。</p><h3 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h3><p><a href="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html">https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;container/heap&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// Edge 表示带权重的边</span><br><span class="hljs-keyword">type</span> Edge <span class="hljs-keyword">struct</span> &#123;<br>    to, val <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// PriorityQueue 实现一个小顶堆</span><br><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>    node, dist <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PriorityQueue []*Item<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> pq[i].dist &lt; pq[j].dist<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *pq = <span class="hljs-built_in">append</span>(*pq, x.(*Item))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *pq<br>    n := <span class="hljs-built_in">len</span>(old)<br>    item := old[n<span class="hljs-number">-1</span>]<br>    *pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> item<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(n, m <span class="hljs-type">int</span>, edges [][]<span class="hljs-type">int</span>, start, end <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    grid := <span class="hljs-built_in">make</span>([][]Edge, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>        p1, p2, val := edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]<br>        grid[p1] = <span class="hljs-built_in">append</span>(grid[p1], Edge&#123;to: p2, val: val&#125;)<br>    &#125;<br><br>    minDist := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> minDist &#123;<br>        minDist[i] = math.MaxInt64<br>    &#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">1</span>)<br><br>    pq := &amp;PriorityQueue&#123;&#125;<br>    heap.Init(pq)<br>    heap.Push(pq, &amp;Item&#123;node: start, dist: <span class="hljs-number">0</span>&#125;)<br>    minDist[start] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> pq.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        cur := heap.Pop(pq).(*Item)<br><br>        <span class="hljs-keyword">if</span> visited[cur.node] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        visited[cur.node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> grid[cur.node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[edge.to] &amp;&amp; minDist[cur.node]+edge.val &lt; minDist[edge.to] &#123;<br>                minDist[edge.to] = minDist[cur.node] + edge.val<br>                heap.Push(pq, &amp;Item&#123;node: edge.to, dist: minDist[edge.to]&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> minDist[end] == math.MaxInt64 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> minDist[end]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n, m <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n, &amp;m)<br><br>    edges := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">var</span> p1, p2, val <span class="hljs-type">int</span><br>        fmt.Scan(&amp;p1, &amp;p2, &amp;val)<br>        edges[i] = []<span class="hljs-type">int</span>&#123;p1, p2, val&#125;<br>    &#125;<br><br>    start := <span class="hljs-number">1</span>  <span class="hljs-comment">// 起点</span><br>    end := n    <span class="hljs-comment">// 终点</span><br><br>    result := dijkstra(n, m, edges, start, end)<br>    fmt.Println(result)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="Bellman-ford-算法精讲"><a href="#Bellman-ford-算法精讲" class="headerlink" title="Bellman_ford 算法精讲"></a>Bellman_ford 算法精讲</h3><p><a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split())<br>    edges = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        src, dest, weight = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split())<br>        edges.append([src, dest, weight])<br>    <br>    minDist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)] * (n + <span class="hljs-number">1</span>)<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 起点处距离为0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        updated = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> src, dest, weight <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> minDist[src] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">and</span> minDist[src] + weight &lt; minDist[dest]:<br>                minDist[dest] = minDist[src] + weight<br>                updated = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> updated:  <span class="hljs-comment"># 若边不再更新，即停止回圈</span><br>            <span class="hljs-keyword">break</span><br>    <br>    <span class="hljs-keyword">if</span> minDist[-<span class="hljs-number">1</span>] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>):  <span class="hljs-comment"># 返还终点权重</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unconnected&quot;</span><br>    <span class="hljs-keyword">return</span> minDist[-<span class="hljs-number">1</span>]<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(main())<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part09&quot;&gt;&lt;a href=&quot;#第十一章：图论part09&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part09&quot;&gt;&lt;/a&gt;第十一章：图论part09&lt;/h1&gt;&lt;p&gt;今天的建议依然是，一刷的时候，能了解 原理，照着代码</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day58 第十一章 图论part08</title>
    <link href="https://leiqi.top/2025-01-05-e90cac159cd5.html"/>
    <id>https://leiqi.top/2025-01-05-e90cac159cd5.html</id>
    <published>2025-01-05T14:00:15.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part08"><a href="#第十一章：图论part08" class="headerlink" title="第十一章：图论part08"></a>第十一章：图论part08</h1><h3 id="拓扑排序精讲"><a href="#拓扑排序精讲" class="headerlink" title="拓扑排序精讲"></a>拓扑排序精讲</h3><p>拓扑排序看上去很复杂，其实了解其原理之后，代码不难</p><p><a href="https://www.programmercarl.com/kamacoder/0117.%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA.html">https://www.programmercarl.com/kamacoder/0117.%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque, defaultdict<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topological_sort</span>(<span class="hljs-params">n, edges</span>):<br>    inDegree = [<span class="hljs-number">0</span>] * n <span class="hljs-comment"># inDegree 记录每个文件的入度</span><br>    umap = defaultdict(<span class="hljs-built_in">list</span>) <span class="hljs-comment"># 记录文件依赖关系</span><br><br>    <span class="hljs-comment"># 构建图和入度表</span><br>    <span class="hljs-keyword">for</span> s, t <span class="hljs-keyword">in</span> edges:<br>        inDegree[t] += <span class="hljs-number">1</span><br>        umap[s].append(t)<br><br>    <span class="hljs-comment"># 初始化队列，加入所有入度为0的节点</span><br>    queue = deque([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> inDegree[i] == <span class="hljs-number">0</span>])<br>    result = []<br><br>    <span class="hljs-keyword">while</span> queue:<br>        cur = queue.popleft()  <span class="hljs-comment"># 当前选中的文件</span><br>        result.append(cur)<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> umap[cur]:  <span class="hljs-comment"># 获取该文件指向的文件</span><br>            inDegree[file] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># cur的指向的文件入度-1</span><br>            <span class="hljs-keyword">if</span> inDegree[file] == <span class="hljs-number">0</span>:<br>                queue.append(file)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) == n:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, result)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    edges = [<span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>    topological_sort(n, edges)<br><br></code></pre></td></tr></table></figure><h3 id="dijkstra（朴素版）精讲"><a href="#dijkstra（朴素版）精讲" class="headerlink" title="dijkstra（朴素版）精讲"></a>dijkstra（朴素版）精讲</h3><p>后面几天都是最短路系列了，对于最短路系列，我的建议是，如果第一次接触最短路算法的话，能看懂原理，能照着代码随想录把代码抄下来就可以了，二刷的时候 再尝试自己去写出来。 三刷的时候，差不多才能把最短路吃透。</p><p>对于一刷的录友们，不要强行去逼迫自己去学透，很难刚接触到最短路算法就学透。</p><p><a href="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E6%9C%B4%E7%B4%A0.html">https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E6%9C%B4%E7%B4%A0.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">n, m, edges, start, end</span>):<br>    <span class="hljs-comment"># 初始化邻接矩阵</span><br>    grid = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> p1, p2, val <span class="hljs-keyword">in</span> edges:<br>        grid[p1][p2] = val<br><br>    <span class="hljs-comment"># 初始化距离数组和访问数组</span><br>    minDist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (n + <span class="hljs-number">1</span>)<br>    visited = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)<br><br>    minDist[start] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历所有节点</span><br>        minVal = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        cur = -<span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 选择距离源点最近且未访问过的节点</span><br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v] <span class="hljs-keyword">and</span> minDist[v] &lt; minVal:<br>                minVal = minDist[v]<br>                cur = v<br><br>        <span class="hljs-keyword">if</span> cur == -<span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果找不到未访问过的节点，提前结束</span><br>            <span class="hljs-keyword">break</span><br><br>        visited[cur] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 标记该节点已被访问</span><br><br>        <span class="hljs-comment"># 更新未访问节点到源点的距离</span><br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v] <span class="hljs-keyword">and</span> grid[cur][v] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">and</span> minDist[cur] + grid[cur][v] &lt; minDist[v]:<br>                minDist[v] = minDist[cur] + grid[cur][v]<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> minDist[end] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> minDist[end]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">input</span> = sys.stdin.read<br>    data = <span class="hljs-built_in">input</span>().split()<br>    n, m = <span class="hljs-built_in">int</span>(data[<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>(data[<span class="hljs-number">1</span>])<br>    edges = []<br>    index = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        p1 = <span class="hljs-built_in">int</span>(data[index])<br>        p2 = <span class="hljs-built_in">int</span>(data[index + <span class="hljs-number">1</span>])<br>        val = <span class="hljs-built_in">int</span>(data[index + <span class="hljs-number">2</span>])<br>        edges.append((p1, p2, val))<br>        index += <span class="hljs-number">3</span><br>    start = <span class="hljs-number">1</span>  <span class="hljs-comment"># 起点</span><br>    end = n    <span class="hljs-comment"># 终点</span><br><br>    result = dijkstra(n, m, edges, start, end)<br>    <span class="hljs-built_in">print</span>(result)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part08&quot;&gt;&lt;a href=&quot;#第十一章：图论part08&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part08&quot;&gt;&lt;/a&gt;第十一章：图论part08&lt;/h1&gt;&lt;h3 id=&quot;拓扑排序精讲&quot;&gt;&lt;a href=&quot;#拓扑排</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day57 第十一章 图论part07</title>
    <link href="https://leiqi.top/2025-01-05-a0b5241802ae.html"/>
    <id>https://leiqi.top/2025-01-05-a0b5241802ae.html</id>
    <published>2025-01-05T13:53:42.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part07"><a href="#第十一章：图论part07" class="headerlink" title="第十一章：图论part07"></a>第十一章：图论part07</h1><p>今天在学习prim 和 kruskal的同时，也要清楚这两个算法的区别所在。</p><h3 id="prim算法精讲"><a href="#prim算法精讲" class="headerlink" title="prim算法精讲"></a>prim算法精讲</h3><p><a href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html">https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 接收输入</span><br>v, e = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()))<br><span class="hljs-comment"># 按照常规的邻接矩阵存储图信息，不可达的初始化为10001</span><br>graph = [[<span class="hljs-number">10001</span>] * (v+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(v+<span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(e):<br>    x, y, w = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()))<br>    graph[x][y] = w<br>    graph[y][x] = w<br><br><span class="hljs-comment"># 定义加入生成树的标记数组和未加入生成树的最近距离</span><br>visited = [<span class="hljs-literal">False</span>] * (v + <span class="hljs-number">1</span>)<br>minDist = [<span class="hljs-number">10001</span>] * (v + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 循环 n - 1 次，建立 n - 1 条边</span><br><span class="hljs-comment"># 从节点视角来看：每次选中一个节点加入树，更新剩余的节点到树的最短距离，</span><br><span class="hljs-comment"># 这一步其实蕴含了确定下一条选取的边，计入总路程 ans 的计算</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, v + <span class="hljs-number">1</span>):<br>    min_val = <span class="hljs-number">10002</span><br>    cur = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, v + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> visited[j] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> minDist[j] &lt; min_val:<br>            cur = j<br>            min_val = minDist[j]<br>    visited[cur] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, v + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> visited[j] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> minDist[j] &gt; graph[cur][j]:<br>            minDist[j] = graph[cur][j]<br><br>ans = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, v + <span class="hljs-number">1</span>):<br>    ans += minDist[i]<br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><h3 id="kruskal算法精讲"><a href="#kruskal算法精讲" class="headerlink" title="kruskal算法精讲"></a>kruskal算法精讲</h3><p><a href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html">https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, l, r, val</span>):<br>        self.l = l<br>        self.r = r<br>        self.val = val<br><br>n = <span class="hljs-number">10001</span><br>father = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>    <span class="hljs-keyword">global</span> father<br>    father = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-keyword">if</span> u != father[u]:<br>        father[u] = find(father[u])<br>    <span class="hljs-keyword">return</span> father[u]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">u, v</span>):<br>    u = find(u)<br>    v = find(v)<br>    <span class="hljs-keyword">if</span> u != v:<br>        father[v] = u<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kruskal</span>(<span class="hljs-params">v, edges</span>):<br>    edges.sort(key=<span class="hljs-keyword">lambda</span> edge: edge.val)<br>    init()<br>    result_val = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        x = find(edge.l)<br>        y = find(edge.r)<br>        <span class="hljs-keyword">if</span> x != y:<br>            result_val += edge.val<br>            join(x, y)<br><br>    <span class="hljs-keyword">return</span> result_val<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> sys<br>    <span class="hljs-built_in">input</span> = sys.stdin.read<br>    data = <span class="hljs-built_in">input</span>().split()<br><br>    v = <span class="hljs-built_in">int</span>(data[<span class="hljs-number">0</span>])<br>    e = <span class="hljs-built_in">int</span>(data[<span class="hljs-number">1</span>])<br><br>    edges = []<br>    index = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(e):<br>        v1 = <span class="hljs-built_in">int</span>(data[index])<br>        v2 = <span class="hljs-built_in">int</span>(data[index + <span class="hljs-number">1</span>])<br>        val = <span class="hljs-built_in">int</span>(data[index + <span class="hljs-number">2</span>])<br>        edges.append(Edge(v1, v2, val))<br>        index += <span class="hljs-number">3</span><br><br>    result_val = kruskal(v, edges)<br>    <span class="hljs-built_in">print</span>(result_val)<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part07&quot;&gt;&lt;a href=&quot;#第十一章：图论part07&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part07&quot;&gt;&lt;/a&gt;第十一章：图论part07&lt;/h1&gt;&lt;p&gt;今天在学习prim 和 kruskal的同时，也要清</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day56 第十一章 图论part056</title>
    <link href="https://leiqi.top/2025-01-05-fcd714ee88f8.html"/>
    <id>https://leiqi.top/2025-01-05-fcd714ee88f8.html</id>
    <published>2025-01-05T13:47:28.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part06"><a href="#第十一章：图论part06" class="headerlink" title="第十一章：图论part06"></a>第十一章：图论part06</h1><h3 id="108-冗余连接"><a href="#108-冗余连接" class="headerlink" title="108.  冗余连接"></a>108.  冗余连接</h3><p>并查集应用类题目，关键是如何把题意转化成并查集问题</p><p><a href="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html">https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>father = <span class="hljs-built_in">list</span>()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-keyword">if</span> u == father[u]:<br>        <span class="hljs-keyword">return</span> u<br>    <span class="hljs-keyword">else</span>:<br>        father[u] = find(father[u])<br>        <span class="hljs-keyword">return</span> father[u]<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_same</span>(<span class="hljs-params">u, v</span>):<br>    u = find(u)<br>    v = find(v)<br>    <span class="hljs-keyword">return</span> u == v<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">u, v</span>):<br>    u = find(u)<br>    v = find(v)<br>    <span class="hljs-keyword">if</span> u != v:<br>        father[u] = v<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 輸入</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>        father.append(i)<br>    <span class="hljs-comment"># 尋找冗余邊    </span><br>    result = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        s, t = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> is_same(s, t):<br>            result = <span class="hljs-built_in">str</span>(s) + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(t)<br>        <span class="hljs-keyword">else</span>:<br>            join(s, t)<br>        <br>    <span class="hljs-comment"># 輸出</span><br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><h3 id="109-冗余连接II"><a href="#109-冗余连接II" class="headerlink" title="109.  冗余连接II"></a>109.  冗余连接II</h3><p>上面两道题目是不是感觉做出自信了，感觉并查集不过如此？</p><p>来这道题目 给大家适当一些打击， 难度上来了。</p><p><a href="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html">https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>father = <span class="hljs-built_in">list</span>()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-keyword">if</span> u == father[u]:<br>        <span class="hljs-keyword">return</span> u<br>    <span class="hljs-keyword">else</span>:<br>        father[u] = find(father[u])<br>        <span class="hljs-keyword">return</span> father[u]<br>        <br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_same</span>(<span class="hljs-params">u, v</span>):<br>    u = find(u)<br>    v = find(v)<br>    <span class="hljs-keyword">return</span> u == v<br>    <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">u, v</span>):<br>    u = find(u)<br>    v = find(v)<br>    <span class="hljs-keyword">if</span> u != v:<br>        father[u] = v<br>    <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_tree_after_remove_edge</span>(<span class="hljs-params">edges, edge, n</span>):<br>    <span class="hljs-comment"># 初始化并查集</span><br>    <span class="hljs-keyword">global</span> father <br>    father = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(edges)):<br>        <span class="hljs-keyword">if</span> i == edge:<br>            <span class="hljs-keyword">continue</span><br>        s, t = edges[i]<br>        <span class="hljs-keyword">if</span> is_same(s, t): <span class="hljs-comment"># 成環，即不是有向樹</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 將s,t放入集合中</span><br>            join(s, t)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_remove_edge</span>(<span class="hljs-params">edges</span>):<br>    <span class="hljs-comment"># 初始化并查集</span><br>    <span class="hljs-keyword">global</span> father<br>    father = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <br>    <span class="hljs-keyword">for</span> s, t <span class="hljs-keyword">in</span> edges:<br>        <span class="hljs-keyword">if</span> is_same(s, t):<br>            <span class="hljs-built_in">print</span>(s, t)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">else</span>:<br>            join(s, t)<br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 輸入</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    edges = <span class="hljs-built_in">list</span>()<br>    in_degree = defaultdict(<span class="hljs-built_in">int</span>)<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        s, t = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        in_degree[t] += <span class="hljs-number">1</span><br>        edges.append([s, t])<br>        <br>    <span class="hljs-comment"># 尋找入度為2的邊，並紀錄其下標(index)</span><br>    vec = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> in_degree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>:<br>            vec.append(i)<br>            <br>    <span class="hljs-comment"># 輸出</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vec) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 情況一：刪除輸出順序靠後的邊 </span><br>        <span class="hljs-keyword">if</span> is_tree_after_remove_edge(edges, vec[<span class="hljs-number">0</span>], n):<br>            <span class="hljs-built_in">print</span>(edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>], edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>])<br>        <span class="hljs-comment"># 情況二：只能刪除特定的邊</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>], edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 情況三： 原圖有環</span><br>        get_remove_edge(edges)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part06&quot;&gt;&lt;a href=&quot;#第十一章：图论part06&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part06&quot;&gt;&lt;/a&gt;第十一章：图论part06&lt;/h1&gt;&lt;h3 id=&quot;108-冗余连接&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day55 第十一章 图论part05</title>
    <link href="https://leiqi.top/2025-01-05-d289514fd119.html"/>
    <id>https://leiqi.top/2025-01-05-d289514fd119.html</id>
    <published>2025-01-05T13:26:28.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并查集理论基础"><a href="#并查集理论基础" class="headerlink" title="并查集理论基础"></a>并查集理论基础</h3><p>并查集理论基础很重要，明确并查集解决什么问题，代码如何写，对后面做并查集类题目很有帮助。</p><p><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>并查集 可以解决什么问题呢？<br>主要有两个功能：</p><ol><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合中<br><img src="/../../imgs/Pasted%20image%2020250105213812.png"></li></ol><p><img src="/../../imgs/Pasted%20image%2020250105213834.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>代码模板</p><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>&#125;<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h3><p>并查集裸题，学会理论基础后，本题直接可以直接刷过</p><p><a href="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MaxNodes = <span class="hljs-number">101</span><br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> father [MaxNodes]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 初始化并查集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        father[i] = i<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(u <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> u == father[u] &#123;<br>        <span class="hljs-keyword">return</span> u<br>    &#125;<br>    father[u] = find(father[u])<br>    <span class="hljs-keyword">return</span> father[u]<br>&#125;<br><br><span class="hljs-comment">// 判断 u 和 v 是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSame</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> find(u) == find(v)<br>&#125;<br><br><span class="hljs-comment">// 将 v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">join</span><span class="hljs-params">(u, v <span class="hljs-type">int</span>)</span></span> &#123;<br>    rootU := find(u)<br>    rootV := find(v)<br>    <span class="hljs-keyword">if</span> rootU != rootV &#123;<br>        father[rootV] = rootU<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m, s, t, source, destination <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n, &amp;m)<br>    initialize()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        fmt.Scan(&amp;s, &amp;t)<br>        join(s, t)<br>    &#125;<br>    fmt.Scan(&amp;source, &amp;destination)<br>    <span class="hljs-keyword">if</span> isSame(source, destination) &#123;<br>        fmt.Println(<span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;并查集理论基础&quot;&gt;&lt;a href=&quot;#并查集理论基础&quot; class=&quot;headerlink&quot; title=&quot;并查集理论基础&quot;&gt;&lt;/a&gt;并查集理论基础&lt;/h3&gt;&lt;p&gt;并查集理论基础很重要，明确并查集解决什么问题，代码如何写，对后面做并查集类题目很有帮助。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day52 第十一章 图论part03</title>
    <link href="https://leiqi.top/2024-12-22-c7c9bbc04318.html"/>
    <id>https://leiqi.top/2024-12-22-c7c9bbc04318.html</id>
    <published>2024-12-22T17:35:07.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part03"><a href="#第十一章：图论part03" class="headerlink" title="第十一章：图论part03"></a>第十一章：图论part03</h1><h3 id="101-孤岛的总面积"><a href="#101-孤岛的总面积" class="headerlink" title="101.  孤岛的总面积"></a>101.  孤岛的总面积</h3><p>基础题目 可以自己尝试做一做 。</p><p><a href="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> dir = [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;x, y&#125;&#125;<br>    grid[x][y] = <span class="hljs-number">0</span> <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    count++<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        cur := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        curx, cury := cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>            nextx := curx + dir[i][<span class="hljs-number">0</span>]<br>            nexty := cury + dir[i][<span class="hljs-number">1</span>]<br>            <br>            <span class="hljs-keyword">if</span> nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= <span class="hljs-built_in">len</span>(grid) || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 越界了，直接跳过</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> grid[nextx][nexty] == <span class="hljs-number">1</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;nextx, nexty&#125;)<br>                count++<br>                grid[nextx][nexty] = <span class="hljs-number">0</span> <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n, m <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n, &amp;m)<br>    <br>    grid := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> grid &#123;<br>        grid[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            fmt.Scan(&amp;grid[i][j])<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从左侧边，和右侧边向中间遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br>            bfs(grid, i, <span class="hljs-number">0</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> grid[i][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &#123;<br>            bfs(grid, i, m<span class="hljs-number">-1</span>)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从上边和下边向中间遍历</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> &#123;<br>            bfs(grid, <span class="hljs-number">0</span>, j)<br>        &#125;<br>        <span class="hljs-keyword">if</span> grid[n<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span> &#123;<br>            bfs(grid, n<span class="hljs-number">-1</span>, j)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 清空之前的计数</span><br>    count = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">// 遍历所有位置</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &#123;<br>                bfs(grid, i, j)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    fmt.Println(count)<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="102-沉没孤岛"><a href="#102-沉没孤岛" class="headerlink" title="102.  沉没孤岛"></a>102.  沉没孤岛</h3><p>和上一题差不多，尝试自己做做</p><p><a href="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html</a></p><h3 id="103-水流问题"><a href="#103-水流问题" class="headerlink" title="103.  水流问题"></a>103.  水流问题</h3><p>需要点优化思路，建议先自己读题，相处一个解题方法，有时间就自己写代码，没时间就直接看题解，优化方式 会让你 耳目一新。</p><p><a href="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html">https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html</a></p><h3 id="104-建造最大岛屿"><a href="#104-建造最大岛屿" class="headerlink" title="104.建造最大岛屿"></a>104.建造最大岛屿</h3><p>同样优化思路也会让你耳目一新，自己想比较难想出来。</p><p><a href="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html">https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part03&quot;&gt;&lt;a href=&quot;#第十一章：图论part03&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part03&quot;&gt;&lt;/a&gt;第十一章：图论part03&lt;/h1&gt;&lt;h3 id=&quot;101-孤岛的总面积&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 day51 第十一章 图论part02</title>
    <link href="https://leiqi.top/2024-12-22-4fb27f021208.html"/>
    <id>https://leiqi.top/2024-12-22-4fb27f021208.html</id>
    <published>2024-12-22T17:34:38.000Z</published>
    <updated>2025-01-13T15:35:14.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章：图论part02"><a href="#第十一章：图论part02" class="headerlink" title="第十一章：图论part02"></a>第十一章：图论part02</h1><h1 id="99-岛屿数量-深搜"><a href="#99-岛屿数量-深搜" class="headerlink" title="99.  岛屿数量 深搜"></a>99.  岛屿数量 深搜</h1><p>注意深搜的两种写法，熟练掌握这两种写法 以及 知道区别在哪里，才算掌握的深搜。</p><p><a href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html">https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html</a></p><h1 id="99-岛屿数量-广搜"><a href="#99-岛屿数量-广搜" class="headerlink" title="99.  岛屿数量 广搜"></a>99.  岛屿数量 广搜</h1><p>注意广搜的两种写法，第一种写法为什么会超时， 如果自己做的录友，题目通过了，也要仔细看第一种写法的超时版本，弄清楚为什么会超时，因为你第一次 幸运 没那么想，第二次可就不一定了。</p><p><a href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html">https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> dir = [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, visited [][]<span class="hljs-type">bool</span>, x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>        nextx := x + dir[i][<span class="hljs-number">0</span>]<br>        nexty := y + dir[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= <span class="hljs-built_in">len</span>(grid) || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 越界了，直接跳过</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> !visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span><br>            dfs(grid, visited, nextx, nexty)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    reader := bufio.NewReader(os.Stdin)<br>    <span class="hljs-keyword">var</span> n, m <span class="hljs-type">int</span><br>    fmt.Scanf(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)<br><br>    grid := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        grid[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        line, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        line = strings.TrimSpace(line)<br>        elements := strings.Split(line, <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            grid[i][j], _ = strconv.Atoi(elements[j])<br>        &#125;<br>    &#125;<br><br>    visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, m)<br>    &#125;<br><br>    result := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> !visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span> &#123;<br>                visited[i][j] = <span class="hljs-literal">true</span><br>                result++ <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                dfs(grid, visited, i, j) <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    fmt.Println(result)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="100-岛屿的最大面积"><a href="#100-岛屿的最大面积" class="headerlink" title="100.  岛屿的最大面积"></a>100.  岛屿的最大面积</h1><p>本题就是基础题了，做过上面的题目，本题很快。</p><p><a href="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html">https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> dir = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, visited [][]<span class="hljs-type">bool</span>, x, y <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>nextx := x + dir[i][<span class="hljs-number">0</span>]<br>nexty := y + dir[i][<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= <span class="hljs-built_in">len</span>(grid) || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-keyword">continue</span> <span class="hljs-comment">// 越界了，直接跳过</span><br>&#125;<br><span class="hljs-keyword">if</span> !visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br>visited[nextx][nexty] = <span class="hljs-literal">true</span><br>count++<br>dfs(grid, visited, nextx, nexty)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> n, m <span class="hljs-type">int</span><br>fmt.Scan(&amp;n, &amp;m)<br><br>grid := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>grid[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>fmt.Scan(&amp;grid[i][j])<br>&#125;<br>&#125;<br><br>visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, m)<br>&#125;<br><br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br><span class="hljs-keyword">if</span> !visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span> &#123;<br>count = <span class="hljs-number">1</span> <span class="hljs-comment">// 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地</span><br>visited[i][j] = <span class="hljs-literal">true</span><br>dfs(grid, visited, i, j)<br><span class="hljs-keyword">if</span> count &gt; result &#123;<br>result = count<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>fmt.Println(result)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章：图论part02&quot;&gt;&lt;a href=&quot;#第十一章：图论part02&quot; class=&quot;headerlink&quot; title=&quot;第十一章：图论part02&quot;&gt;&lt;/a&gt;第十一章：图论part02&lt;/h1&gt;&lt;h1 id=&quot;99-岛屿数量-深搜&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="carl" scheme="https://leiqi.top/categories/carl/"/>
    
    
  </entry>
  
</feed>
