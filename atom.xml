<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.top/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.top/"/>
  <updated>2024-09-07T11:07:03.636Z</updated>
  <id>https://leiqichn.top/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leiqichn.top/2024-09-07-b145566b8f78.html"/>
    <id>https://leiqichn.top/2024-09-07-b145566b8f78.html</id>
    <published>2024-09-07T11:07:03.636Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240803223718.png"></p><p><img src="/../../imgs/Pasted%20image%2020240803224158.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240803223718.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240803224158.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="比" scheme="https://leiqichn.top/categories/%E6%AF%94/"/>
    
    
  </entry>
  
  <entry>
    <title>申请域名绑定github pages</title>
    <link href="https://leiqichn.top/2024-09-01-ed1bf9078b39.html"/>
    <id>https://leiqichn.top/2024-09-01-ed1bf9078b39.html</id>
    <published>2024-09-01T02:17:17.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p>你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！</p><h2 id="前置需求"><a href="#前置需求" class="headerlink" title="前置需求"></a>前置需求</h2><ol><li>在<a href="https://www.namesilo.com/">Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo</a>完成了域名的购买</li><li>完成了GitHub Pages的设置，有了可用的<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>库之后，可以访问 Github Pages</li></ol><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-进入我的账户"><a href="#0-进入我的账户" class="headerlink" title="0. 进入我的账户"></a>0. 进入我的账户</h3><p><img src="/../../imgs/Pasted%20image%2020240901102308.png"></p><h3 id="1-无论是什么域名服务商，找到DNS-Management页面"><a href="#1-无论是什么域名服务商，找到DNS-Management页面" class="headerlink" title="1. 无论是什么域名服务商，找到DNS Management页面"></a><strong>1. 无论是什么域名服务商，找到DNS Management页面</strong></h3><p>如果是namesilo购买的域名，可以通过以下步骤：<br><img src="/../../imgs/Pasted%20image%2020240901102340.png"><br>点击“domain manager”<br><img src="/../../imgs/Pasted%20image%2020240901102510.png"><br>点击这个蓝色的小球（Manage DNS for this domain）</p><h3 id="2-写入-type-A-的DNS记录"><a href="#2-写入-type-A-的DNS记录" class="headerlink" title="2. 写入 type A 的DNS记录"></a><strong>2. 写入 type A 的DNS记录</strong></h3><ul><li><strong>如果厂商提供了写入模板</strong>，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 <strong>DNS Templates</strong>。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-b84d88c38c06b6081f02cafbd0dac24b_720w.webp"></p><p>找到GitHub的template，点击“<strong>Apply Template</strong>”，然后在弹出的窗口里直接点击“<strong>Accept</strong>”，你就会发现4条A记录已经自动写入了。</p><p><img src="https://pic1.zhimg.com/80/v2-c731fadefaf3d3a2268e6566d6196558_720w.webp"></p><ul><li><strong>如果厂商不能自动添加</strong>，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图</li></ul><p>[Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain!</p><p><img src="https://pica.zhimg.com/80/v2-1a618fec2900e4f23039c153d8ab03da_720w.webp"></p><p>上面圈起来的四个地址就是需要等会儿手动输入的。</p><p>不同厂商之间的手动添加方法不一样，但只要记住 <strong>type 后填“A”</strong>，<strong>address&#x2F;points to或其他同义表达后填这四个地址中的一个</strong>，<strong>其他默认</strong>就好了，一共需要添加<strong>四条</strong>，可以复制粘贴。</p><p>添加之后会多出四个<img src="/../../imgs/Pasted%20image%2020240901102815.png">### 3. 创建CNAME文件</p><p>这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成<a href="https://link.zhihu.com/?target=http://username.github.io">http://username.github.io</a>，</p><blockquote><p>上面的方法 save 之后看到报错不要慌，<a href="https://zhida.zhihu.com/search?q=%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E&zhida_source=entity&is_preview=1">让子弹飞</a>一会儿就好了</p></blockquote><p><img src="/../../imgs/Pasted%20image%2020240901102714.png"><br><img src="/../../imgs/Pasted%20image%2020240901102745.png"></p><p>最终有这些配置即可：<br><img src="/../../imgs/Pasted%20image%2020240901102848.png"></p><h3 id="github-填写域名地址"><a href="#github-填写域名地址" class="headerlink" title="github 填写域名地址"></a>github 填写域名地址</h3><p>在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。<br><img src="/../../imgs/Pasted%20image%2020240901103216.png"><br><img src="/../../imgs/Pasted%20image%2020240901103241.png"></p><h3 id="即刻访问你自己的域名网站吧！"><a href="#即刻访问你自己的域名网站吧！" class="headerlink" title="即刻访问你自己的域名网站吧！"></a>即刻访问你自己的域名网站吧！</h3><p><img src="/../../imgs/Pasted%20image%2020240901103553.png"></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/448781791">将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！&lt;/p&gt;
&lt;h2 id=&quot;前置需求&quot;&gt;&lt;a href=&quot;#前置需求&quot; class=&quot;headerlink&quot; title=&quot;前置需求&quot;&gt;&lt;/a&gt;前置需求&lt;/h2&gt;&lt;o</summary>
      
    
    
    
    <category term="前端" scheme="https://leiqichn.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>git stash</title>
    <link href="https://leiqichn.top/2024-08-21-f4ccab39149e.html"/>
    <id>https://leiqichn.top/2024-08-21-f4ccab39149e.html</id>
    <published>2024-08-21T16:26:46.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：</p><p>放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。</p><p>bash<br>git checkout – .obsidian&#x2F;workspace.json<br>再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。</p><p>bash<br>git pull<br>如果不想放弃这些更改，而是想将它们保存起来，可以使用 git stash 命令：</p><p>保存更改：使用 git stash 将更改保存到一个临时区域。</p><p>git stash<br>拉取远程更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply<br></code></pre></td></tr></table></figure><p>请注意，使用 git stash apply 可能不会总是成功，在这种情况下，可能需要手动解决冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作：&lt;/p&gt;
&lt;p&gt;放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。&lt;/p&gt;</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode  1.两数之和</title>
    <link href="https://leiqichn.top/2024-08-21-64c0a1f316e6.html"/>
    <id>https://leiqichn.top/2024-08-21-64c0a1f316e6.html</id>
    <published>2024-08-21T15:53:21.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>有两种思路：</p><ol><li>使用暴力遍历， 复杂度的是 O(n ^2)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> j:= i+<span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[i] + nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, j&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>使用哈希表，是O(n)<br>  使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>maps := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br><span class="hljs-keyword">for</span> idx, num := <span class="hljs-keyword">range</span> nums &#123;<br>maps[num] = idx<br>&#125;<br><br><span class="hljs-keyword">for</span> idx, num := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; <span class="hljs-comment">// 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx</span><br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;idx, idx2&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用暴力遍历， 复杂度的是 O(n ^2)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>docker容器打包成本地压缩镜像并load</title>
    <link href="https://leiqichn.top/2024-08-11-a8e2c27fed87.html"/>
    <id>https://leiqichn.top/2024-08-11-a8e2c27fed87.html</id>
    <published>2024-08-11T03:59:34.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器打包成镜像和压缩"><a href="#docker容器打包成镜像和压缩" class="headerlink" title="docker容器打包成镜像和压缩"></a>docker容器打包成镜像和压缩</h1><p>（1）将容器保存成新的镜像<br>相当于加了一层，使用docker commit</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo docker commit -<span class="hljs-keyword">a</span> <span class="hljs-string">&#x27;run_code&#x27;</span> b4293c3b9202  myimage:v2<br></code></pre></td></tr></table></figure><p>（2）将镜像打包</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">docker save -o mask_detection_v5.tar myimage:v5<br></code></pre></td></tr></table></figure><p>(3) 将镜像包压缩</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo tar -zcvf myimage<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> myimage.tar<br></code></pre></td></tr></table></figure><p><strong>还有一种容器的打包和压缩一步到位的方法</strong>：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker save myimage:v5 <span class="hljs-string">| gzip &gt; myimage.tar.gz</span><br></code></pre></td></tr></table></figure><p>docker镜像压缩包解压及镜像载入</p><p>一步加载压缩的镜像命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load &lt; myimage.tar.gz<br><br></code></pre></td></tr></table></figure><p>（1）压缩包解压</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> -zxvf myimage.tar.gz<br></code></pre></td></tr></table></figure><p>得到.tar格式的镜像包</p><p>（2）镜像载入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo docker load -<span class="hljs-selector-tag">i</span> myimage<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure><p>载入后查看已经加载的镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo docker images</span><br></code></pre></td></tr></table></figure><h1 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 交互式运行</span><br>docker run -it myimage:v1 bash<br><br></code></pre></td></tr></table></figure><h1 id="进入已经运行的容器"><a href="#进入已经运行的容器" class="headerlink" title="进入已经运行的容器"></a>进入已经运行的容器</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>docker <span class="hljs-built_in">exec</span> -it [imagesID] bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;a href=&quot;#docker容器打包成镜像和压缩&quot; class=&quot;headerlink&quot; title=&quot;docker容器打包成镜像和压缩&quot;&gt;&lt;/a&gt;docker容器打包成镜像和压缩&lt;/h1&gt;&lt;p&gt;（1）将容器保存成新的镜像&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://leiqichn.top/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>查询深度学习环境python torch cuda版本</title>
    <link href="https://leiqichn.top/2024-08-08-efa703ec12d7.html"/>
    <id>https://leiqichn.top/2024-08-08-efa703ec12d7.html</id>
    <published>2024-08-08T14:55:03.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment">#sys模块提供了一系列有关Python运行环境的变量和函数。</span><br><span class="hljs-built_in">print</span>(sys.version)<br><span class="hljs-built_in">print</span>(torch.__version__)<br><span class="hljs-built_in">print</span>(torch.cuda.is_available())<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240808225509.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>开机自启WSL</title>
    <link href="https://leiqichn.top/2024-08-07-117ef9b8f4c6.html"/>
    <id>https://leiqichn.top/2024-08-07-117ef9b8f4c6.html</id>
    <published>2024-08-07T14:09:47.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p>在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件</p><p><img src="/../../imgs/Pasted%20image%2020240807221008.png"></p><p>文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Set</span> ws = WScript.CreateObject(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)<br>cmd = <span class="hljs-string">&quot;C:\Windows\System32\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;</span><br><span class="hljs-comment">&#x27;运行命令不显示cmd窗口</span><br>ws.Run cmd, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span><br><span class="hljs-keyword">Set</span> ws = <span class="hljs-literal">Nothing</span><br>WScript.quit<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录下，新建vbs文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240807221008.pn</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git更新仓库地址</title>
    <link href="https://leiqichn.top/2024-07-23-764a3cd05cde.html"/>
    <id>https://leiqichn.top/2024-07-23-764a3cd05cde.html</id>
    <published>2024-07-23T15:34:45.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>使用如下命令</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">https</span>://<span class="hljs-string">gitee</span>.<span class="hljs-string">com</span>/<span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用如下命令&lt;/p&gt;
&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>设置github 同步到gitee</title>
    <link href="https://leiqichn.top/2024-07-21-3ee37da7ed1c.html"/>
    <id>https://leiqichn.top/2024-07-21-3ee37da7ed1c.html</id>
    <published>2024-07-21T14:15:47.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<ol><li>复制自己电脑的<strong>私钥</strong>到github</li><li>复制自己电脑的<strong>公钥</strong>到gitee<img src="/../../imgs/Pasted%20image%2020240721222254.png"></li><li>获取gitee 的私人令牌</li><li>创建.github&#x2F;workflows&#x2F;xxx.ymal<br><img src="/../../imgs/Pasted%20image%2020240721221805.png"></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">to</span> <span class="hljs-string">Gitee</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">wearerequired/git-mirror-action@master</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span><br>          <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 注意替换为你的 GitHub 源仓库地址</span><br>          <span class="hljs-attr">source-repo:</span> <span class="hljs-string">git@github.com:leiqichn/novelBigModel.git</span><br>          <span class="hljs-comment"># 注意替换为你的 Gitee 目标仓库地址</span><br>          <span class="hljs-attr">destination-repo:</span> <span class="hljs-string">git@gitee.com:leiqichn/novelBigModel.git</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;复制自己电脑的&lt;strong&gt;私钥&lt;/strong&gt;到github&lt;/li&gt;
&lt;li&gt;复制自己电脑的&lt;strong&gt;公钥&lt;/strong&gt;到gitee&lt;img src=&quot;/../../imgs/Pasted%20image%2020240721222254.pn</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang 使用new创建slice</title>
    <link href="https://leiqichn.top/2024-07-21-01f71b57e534.html"/>
    <id>https://leiqichn.top/2024-07-21-01f71b57e534.html</id>
    <published>2024-07-21T06:14:35.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。</p><p>然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s *[]<span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个指向int类型slice的指针</span><br>s = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 分配一个int类型的slice，并将其地址赋给s</span><br></code></pre></td></tr></table></figure><p>但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length, capacity) <span class="hljs-comment">// 创建一个长度为 length，容量为 capacity 的int类型slice</span><br></code></pre></td></tr></table></figure><p>如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*s = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length, capacity) <span class="hljs-comment">// 通过解引用指针并使用make来初始化slice</span><br></code></pre></td></tr></table></figure><p>在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 sli</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>依赖注入</title>
    <link href="https://leiqichn.top/2024-07-21-618c8c29b962.html"/>
    <id>https://leiqichn.top/2024-07-21-618c8c29b962.html</id>
    <published>2024-07-21T05:03:46.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>使用接口来实现依赖注入，降低模块间的耦合。<br><strong>概念</strong>： 依赖注入是一种设计模式，它允许你将组件的依赖关系（即其他组件或服务）从组件本身中分离出来，并在组件外部进行配置。这样做可以减少组件之间的耦合，使得代码更加模块化，易于测试和维护。</p><p><strong>Go 语言实现</strong>： 在 Go 语言中，可以通过接口来实现依赖注入。接口定义了组件所需的行为，然后你可以在运行时注入任何实现了这些行为的具体类型。</p><p><strong>优点</strong>：</p><ol><li><strong>降低耦合</strong>：组件不直接依赖于具体的实现类，而是依赖于接口，这降低了组件之间的耦合度。</li><li><strong>提高灵活性</strong>：可以轻易地替换依赖的具体实现，而不需要修改组件的代码。</li><li><strong>易于测试</strong>：可以为测试注入模拟对象（mocks），从而可以隔离测试组件，不依赖于外部服务或组件。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">interface</span> &#123;<br>    Log(message <span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> ConsoleLogger <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l ConsoleLogger)</span></span> Log(message <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Log-DEBUG:&quot;</span>, message)<br>&#125;<br><br><span class="hljs-keyword">type</span> ConsoleLoggerINFO <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l ConsoleLoggerINFO)</span></span> Log(message <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Log-INFO:&quot;</span>, message)<br>&#125;<br><br><br><span class="hljs-keyword">type</span> Application <span class="hljs-keyword">struct</span> &#123;<br>    logger Logger<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Application)</span></span> SetLogger(logger Logger) &#123;<br>    a.logger = logger<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    app := Application&#123;&#125;<br>    consoleLogger := ConsoleLogger&#123;&#125;<br>    app.SetLogger(consoleLogger)<br>    app.logger.Log(<span class="hljs-string">&quot;Application started&quot;</span>)<br>    consoleLoggerInfo := ConsoleLoggerINFO&#123;&#125;<br>    app.SetLogger(consoleLoggerInfo)<br>&#125;<br></code></pre></td></tr></table></figure><p>上边通过Go语言的Logger接口包含了Log方法, Application包含了Logger接口。  Application可以通过SetLogger来设置任何实现接口中Log 方法的就，可以方便切换日志类型。这就是依赖注入，每个部分都是个组件，可以随意方便的更换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;依赖注入&quot;&gt;&lt;a href=&quot;#依赖注入&quot; class=&quot;headerlink&quot; title=&quot;依赖注入&quot;&gt;&lt;/a&gt;依赖注入&lt;/h1&gt;&lt;p&gt;使用接口来实现依赖注入，降低模块间的耦合。&lt;br&gt;&lt;strong&gt;概念&lt;/strong&gt;： 依赖注入是一种设计模式，它允许你</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>回调函数和直接调用的区别</title>
    <link href="https://leiqichn.top/2024-07-21-023e6a227482.html"/>
    <id>https://leiqichn.top/2024-07-21-023e6a227482.html</id>
    <published>2024-07-21T04:51:05.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异：</p><ol><li><p><strong>调用时机</strong>：</p><ul><li><strong>直接调用</strong>：函数A直接调用函数B，函数B的执行是立即的，并且是在函数A的控制下进行的。</li><li><strong>回调函数</strong>：函数A接收函数B作为参数，但函数B的执行时机可能由外部事件或条件触发，不一定立即执行。</li></ul></li><li><p><strong>控制流</strong>：</p><ul><li><strong>直接调用</strong>：控制流是线性的，函数B执行完毕后，控制权返回给函数A。</li><li><strong>回调函数</strong>：控制流可能会中断，函数A执行到某个点后，将控制权交给函数B，函数B执行完毕后，控制权可能不会直接返回给函数A，而是等待某个条件满足后才继续执行。</li></ul></li><li><p><strong>执行环境</strong>：</p><ul><li><strong>直接调用</strong>：函数B在函数A的上下文中执行，可以访问函数A的局部变量。</li><li><strong>回调函数</strong>：函数B可能在不同的上下文中执行，例如在异步操作完成后，此时它可能无法访问函数A的局部变量。</li></ul></li><li><p><strong>目的和用途</strong>：</p><ul><li><strong>直接调用</strong>：通常用于直接执行某个操作或计算。</li><li><strong>回调函数</strong>：通常用于响应事件、处理异步操作的结果或在特定条件下触发后续操作。</li></ul></li><li><p><strong>编程模式</strong>：</p><ul><li><strong>直接调用</strong>：更符合同步编程模式，代码执行顺序明确。</li><li><strong>回调函数</strong>：常用于异步编程模式，代码的执行顺序可能不那么明确，需要更多的控制结构来管理。</li></ul></li><li><p><strong>函数定义</strong>：</p><ul><li><strong>直接调用</strong>：函数B在被调用时不需要特定的定义或约束。</li><li><strong>回调函数</strong>：函数B可能需要符合特定的接口或签名，以便作为回调被其他函数使用。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li><strong>直接调用</strong>：错误处理通常在调用者（函数A）中进行。</li><li><strong>回调函数</strong>：错误处理可能需要在回调函数本身中进行，调用者可能不知道回调函数何时被调用。</li></ul></li><li><p><strong>代码组织</strong>：</p><ul><li><strong>直接调用</strong>：代码组织可能更直观，因为函数调用关系清晰。</li><li><strong>回调函数</strong>：代码组织可能需要更多的设计考虑，以确保回调函数在适当的时机被调用，并且逻辑清晰。</li></ul></li></ol><p>使用回调函数而不是直接调用的原因通常与程序设计的复杂性、灵活性和可扩展性有关。例如，在处理异步事件、网络请求或用户界面操作时，回调函数提供了一种有效的方式来处理这些操作的结果，而不需要阻塞主程序流程。此外，回调函数还可以帮助实现更高层次的抽象，如事件监听器、中间件等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;调用时机&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接调用&lt;/strong&gt;：</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.top/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>github同步gitee</title>
    <link href="https://leiqichn.top/2024-07-18-e17dac938cf8.html"/>
    <id>https://leiqichn.top/2024-07-18-e17dac938cf8.html</id>
    <published>2024-07-18T16:38:12.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240719003858.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240719003858.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.top/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>vue3快速实践</title>
    <link href="https://leiqichn.top/2024-06-24-1130f46a1ad4.html"/>
    <id>https://leiqichn.top/2024-06-24-1130f46a1ad4.html</id>
    <published>2024-06-24T14:32:19.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/tutorial/#step-7">教程 | Vue.js (vuejs.org)</a></p><h1 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h1><p>你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。SFC 是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 <code>.vue</code> 后缀的文件中。</p><p>Vue 的核心功能是<strong>声明式渲染</strong>：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。<br>能在改变时触发更新的状态被称作是<strong>响应式</strong>的。我们可以使用 Vue 的 <code>reactive()</code> API 来声明响应式状态。由 <code>reactive()</code> 创建的对象都是 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>const counter = reactive(&#123;<br>  count: 0<br>&#125;)<br><br>console.log(counter.count) // 0<br>counter.count++<br><br></code></pre></td></tr></table></figure><p><code>reactive()</code> 只适用于对象 (包括数组和内置类型，如 <code>Map</code> 和 <code>Set</code>)。而另一个 API <code>ref()</code> 则可以接受任何值类型。<code>ref</code> 会返回一个包裹对象，并在 <code>.value</code> 属性下暴露内部值。</p><p>在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。</p><p>template</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message.split</span>(<span class="hljs-name">&#x27;&#x27;</span>).reverse().join(<span class="hljs-name">&#x27;&#x27;</span>) &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>现在，试着自己创建一些响应式状态，</p><h1 id="Attribute-绑定-v-bind"><a href="#Attribute-绑定-v-bind" class="headerlink" title="Attribute 绑定 v-bind"></a>Attribute 绑定 v-bind</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const titleClass = ref(&#x27;title&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br>.title &#123;<br>  color: red;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p><img src="/../../../../imgs/Pasted%20image%2020240624225914.png"></p><h1 id="时间监听-v-on-click"><a href="#时间监听-v-on-click" class="headerlink" title="时间监听 v-on : click"></a>时间监听 v-on : click</h1><p>v-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br><br>function increment() &#123;<br>  // 更新组件状态<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;!-- 使此按钮生效 --&gt;<br><br>  &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../../../imgs/Pasted%20image%2020240624225635.png"></p><h1 id="表单绑定-v-model"><a href="#表单绑定-v-model" class="headerlink" title="表单绑定 v-model"></a>表单绑定 v-model</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230352.png"><br><code>v-model</code> 会将被绑定的值与 <code>&lt;input&gt;</code> 的值自动同步，这样我们就不必再使用事件处理函数了。</p><p><code>v-model</code> 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在<a href="https://cn.vuejs.org/guide/essentials/forms.html">指南 - 表单绑定</a>中讨论了更多的细节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const text = ref(&#x27;&#x27;)<br><br>function onInput(e) &#123;<br>  text.value = e.target.value<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br><br><br># 使用v-model 简化<br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const text = ref(&#x27;&#x27;)<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p><img src="/../../../../imgs/Pasted%20image%2020240624230722.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const awesome = ref(true)<br><br>function toggle() &#123;<br>  awesome.value = !awesome.value # 做取反<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt;<br>  &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/tutorial/#step-7&quot;&gt;教程 | Vue.js (vuejs.org)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;声明式渲染&quot;&gt;&lt;a href=&quot;#声明式渲染&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="vue3 入门" scheme="https://leiqichn.top/categories/vue3-%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>jupyter</title>
    <link href="https://leiqichn.top/2024-06-21-02cd02e81f22.html"/>
    <id>https://leiqichn.top/2024-06-21-02cd02e81f22.html</id>
    <published>2024-06-21T14:26:04.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pip install notebook</p><p>用于启动 Jupyter Notebook 服务的一系列命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">jupyter-notebook stop 8888<br>JUPYTER_TOKEN=$(&lt; /dev/urandom <span class="hljs-built_in">tr</span> -dc A-Za-z0-9 | <span class="hljs-built_in">head</span> -c16; <span class="hljs-built_in">echo</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$JUPYTER_TOKEN</span><br><span class="hljs-built_in">nohup</span> jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=<span class="hljs-variable">$JUPYTER_TOKEN</span> &amp;<br>jupyter-notebook list<br></code></pre></td></tr></table></figure><p>这里是每条命令的简要说明：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jupyter-notebook stop <span class="hljs-number">8888</span>：停止端口为 <span class="hljs-number">8888</span> 的 Jupyter Notebook 服务。<br>JUPYTER_TOKEN=<span class="hljs-constructor">$(&lt; <span class="hljs-operator">/</span><span class="hljs-params">dev</span><span class="hljs-operator">/</span><span class="hljs-params">urandom</span> <span class="hljs-params">tr</span> -<span class="hljs-params">dc</span> A-Za-<span class="hljs-params">z0</span>-9 | <span class="hljs-params">head</span> -<span class="hljs-params">c16</span>; <span class="hljs-params">echo</span>)</span>：生成一个随机的 <span class="hljs-number">16</span> 位的 token，用于 Jupyter Notebook 的安全认证。<br>nohup jupyter-notebook --ip <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> --port <span class="hljs-number">8888</span> --no-browser --allow-root --<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NotebookApp</span>.</span></span>token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。<br>jupyter-notebook <span class="hljs-built_in">list</span>：列出当前运行的 Jupyter Notebook 服务。<br><br></code></pre></td></tr></table></figure><h1 id="conda-对应版本"><a href="#conda-对应版本" class="headerlink" title="conda　对应版本"></a>conda　对应版本</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br><span class="hljs-comment"># 创建glm4-demo python 3.10的虚拟环境</span><br>conda create --name glm4-demo python=3.10<br><br>conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch<br></code></pre></td></tr></table></figure><p><a href="https://pytorch.org/">PyTorch</a></p><p><img src="/../../imgs/Pasted%20image%2020240721120138.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>conda install python=3.10 pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia<br></code></pre></td></tr></table></figure><p>指定python版本：<br><img src="/../../imgs/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1721534117437.png"><br>conda install python&#x3D;3.10 pytorch&#x3D;2.3.0 torchvision torchaudio pytorch-cuda&#x3D;12.1 -c pytorch -c nvidia</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;pip install notebook&lt;/p&gt;
&lt;p&gt;用于启动 Jupyter Notebook 服务的一系列命令&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.top/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 每日温度 单调栈</title>
    <link href="https://leiqichn.top/2024-05-20-1fbf9ee2486f.html"/>
    <id>https://leiqichn.top/2024-05-20-1fbf9ee2486f.html</id>
    <published>2024-05-20T16:16:04.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240521001833.png"><br>栈里边存放的是还没有找到后边更大值的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    st := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, t := <span class="hljs-keyword">range</span> temperatures &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(st) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]] &#123;<br>            j := st[<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]<br>            st = st[:<span class="hljs-built_in">len</span>(st)<span class="hljs-number">-1</span>]<br>            ans[j] = i - j<br>        &#125;<br>        st = <span class="hljs-built_in">append</span>(st, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125; <br><br></code></pre></td></tr></table></figure><p>这段代码是一个Go语言编写的函数，名为<code>dailyTemperatures</code>，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表<code>temperatures</code>，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。</p><h3 id="代码思想解释："><a href="#代码思想解释：" class="headerlink" title="代码思想解释："></a>代码思想解释：</h3><ol><li><p><strong>问题定义</strong>：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。</p></li><li><p><strong>单调栈的应用</strong>：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个索引栈，栈内元素代表尚未找到更大温度的天的索引。</p></li><li><p><strong>初始化</strong>：</p><ul><li><code>n</code>：记录输入温度数组的长度。</li><li><code>ans</code>：初始化一个长度为<code>n</code>的数组，用于存储结果，初始值设为0。</li><li><code>st</code>：初始化一个空的切片，用作单调栈。</li></ul></li><li><p><strong>遍历温度数组</strong>：</p><ul><li>通过<code>range</code>关键字遍历<code>temperatures</code>数组，同时获取索引<code>i</code>和对应的温度值<code>t</code>。</li></ul></li><li><p><strong>维护单调栈</strong>：</p><ul><li>当前温度<code>t</code>大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作：<ul><li>弹出栈顶元素<code>j</code>，即<code>st[len(st)-1]</code>。</li><li>计算索引差<code>i - j</code>，并将这个差值赋给<code>ans[j]</code>。</li><li>更新栈<code>st</code>，移除栈顶元素。</li></ul></li></ul></li><li><p><strong>压栈操作</strong>：</p><ul><li>将当前索引<code>i</code>压入栈<code>st</code>中。这表示当前索引的天还没有找到之后的第一个更高温度。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>遍历结束后，返回<code>ans</code>数组，其中每个元素表示对应天之后第一个更高温度的天数。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked&quot;&gt;739. 每日温度 - 力扣（LeetCode）</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>go语言实现优先队列</title>
    <link href="https://leiqichn.top/2024-05-18-dfe0612e31db.html"/>
    <id>https://leiqichn.top/2024-05-18-dfe0612e31db.html</id>
    <published>2024-05-18T16:39:54.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。</p><h3 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1. 优先队列"></a>1. 优先队列</h3><p>优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。</p><h3 id="2-最大堆"><a href="#2-最大堆" class="headerlink" title="2. 最大堆"></a>2. 最大堆</h3><p>最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。</p><h3 id="3-最小堆"><a href="#3-最小堆" class="headerlink" title="3. 最小堆"></a>3. 最小堆</h3><p>最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="定义堆的元素类型"><a href="#定义堆的元素类型" class="headerlink" title="定义堆的元素类型"></a>定义堆的元素类型</h4><p>首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntHeap []<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h4 id="实现heap-Interface接口"><a href="#实现heap-Interface接口" class="headerlink" title="实现heap.Interface接口"></a>实现heap.Interface接口</h4><p>要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j] &#125; <span class="hljs-comment">// 对于最小堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IntHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>old := *h<br>n := <span class="hljs-built_in">len</span>(old)<br>x := old[n<span class="hljs-number">-1</span>]<br>*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用heap-Init初始化堆"><a href="#使用heap-Init初始化堆" class="headerlink" title="使用heap.Init初始化堆"></a>使用heap.Init初始化堆</h4><p>在使用堆之前，你需要调用heap.Init来初始化它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> h IntHeap <span class="hljs-comment">// 先声明h</span><br><br>heap.Init(&amp;h) <span class="hljs-comment">// 再使用heap.Init(&amp;h) 初始化h指针</span><br></code></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用heap.Push来添加元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">heap.Push(&amp;h, <span class="hljs-number">10</span>)<br>heap.Push(&amp;&amp;h, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用heap.Pop来移除并获取堆顶元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">top := heap.Pop(&amp;h)<br>fmt.Printf(<span class="hljs-string">&quot;top element: %v\n&quot;</span>, top)<br></code></pre></td></tr></table></figure><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。</p><h3 id="转换为最大堆"><a href="#转换为最大堆" class="headerlink" title="转换为最大堆"></a>转换为最大堆</h3><p>如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IntHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j] &#125; <span class="hljs-comment">// 对于最大堆</span><br></code></pre></td></tr></table></figure><p>以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=problem-list-v2&envId=IAmiWIlN">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240520000338.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2024 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * Date: 2024/5/20 上午12:00</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> leetcode215<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/heap&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>h := heapify(nums) <span class="hljs-comment">// 转化为heap 类型</span><br><span class="hljs-keyword">var</span> res any<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>res = heap.Pop(&amp;h)<br>&#125;<br><span class="hljs-keyword">return</span> res.(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> BigHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-keyword">return</span> h[i] &gt; h[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h BigHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>tmp := h[i]<br>h[i] = h[j]<br>h[j] = tmp<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BigHeap)</span></span> Push(x any) &#123; <span class="hljs-comment">// 使用any 或者interface</span><br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-comment">// 删除元素待定</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *BigHeap)</span></span> Pop() any &#123;<br>x := (*h)[h.Len()<span class="hljs-number">-1</span>]<br>*h = (*h)[:h.Len()<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 将 nums 转换成 BigHeap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapify</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> BigHeap &#123;<br><br>    h := BigHeap(nums) <span class="hljs-comment">// bigHeap 本身就是slice 的别名，所以可以转换</span><br>    <span class="hljs-comment">// 或者使用下边两行</span><br>h := <span class="hljs-built_in">make</span>(BigHeap, <span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 新建BigHeap，长度为lenNums</span><br><span class="hljs-built_in">copy</span>(h, nums)                 <span class="hljs-comment">// 将num copy 到 BigHeap 中去</span><br>heap.Init(&amp;h)                 <span class="hljs-comment">// 需要输入指针</span><br><span class="hljs-keyword">return</span> h<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240521004343.png"></p><p>涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//方法一：小顶堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    map_num:=<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">//记录每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> _,item:=<span class="hljs-keyword">range</span> nums&#123;<br>        map_num[item]++<br>    &#125;<br>    h:=&amp;IHeap&#123;&#125;<br>    heap.Init(h)<br>    <span class="hljs-comment">//所有元素入堆，堆的长度为k</span><br>    <span class="hljs-keyword">for</span> key,value:=<span class="hljs-keyword">range</span> map_num&#123;<br>        heap.Push(h,[<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key,value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len()&gt;k&#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    res:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,k)<br><br>    <span class="hljs-comment">//按顺序返回堆中的元素</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;<br>        res[k-i<span class="hljs-number">-1</span>]=heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">//构建小顶堆</span><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len()<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less (i,j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>]&lt;h[j][<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i,j <span class="hljs-type">int</span>) &#123;<br>    h[i],h[j]=h[j],h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;)&#123;<br>    *h=<span class="hljs-built_in">append</span>(*h,x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    old:=*h<br>    n:=<span class="hljs-built_in">len</span>(old)<br>    x:=old[n<span class="hljs-number">-1</span>]<br>    *h=old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&amp;#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。&lt;/p&gt;
&lt;h3 id=&quot;1-优先队列&quot;&gt;&lt;a href=&quot;#1-优先队列&quot; class=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 355设计推特</title>
    <link href="https://leiqichn.top/2024-05-10-b1491b9671d6.html"/>
    <id>https://leiqichn.top/2024-05-10-b1491b9671d6.html</id>
    <published>2024-05-10T15:26:56.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/design-twitter/description/">355. 设计推特</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Twitter <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>userId    <span class="hljs-type">int</span><br>followees <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br>tweets    []*Tweet<br>&#125;<br><br><span class="hljs-keyword">type</span> Tweet <span class="hljs-keyword">struct</span> &#123;<br>tweetId <span class="hljs-type">int</span><br>time    <span class="hljs-type">int</span><br>userId  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 推特时间排序</span><br><span class="hljs-keyword">var</span> tweetCount <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Twitter &#123;<br><span class="hljs-keyword">return</span> Twitter&#123;userMap: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*User)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> PostTweet(userId <span class="hljs-type">int</span>, tweetId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 新建tweet  将自己设置为关注</span><br><br><span class="hljs-comment">// 如果map 中不存在需要新建，因为User 类中存在map 和 slice</span><br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; !ok &#123;<br>t.userMap[userId] = &amp;User&#123;userId: userId, tweets: <span class="hljs-built_in">make</span>([]*Tweet, <span class="hljs-number">0</span>), followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)&#125;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br>t.userMap[userId].followees[userId] = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125;<br>t.userMap[userId].tweets = <span class="hljs-built_in">append</span>(t.userMap[userId].tweets, tweet)<br><br>&#125;<br><br><span class="hljs-comment">// 将tweetId 时间做一个新增</span><br>tweetCount++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Follow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 如果关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; !ok &#123;<br>        t.userMap[followerId] = &amp;User&#123;<br>            userId:        followerId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followerId].followees[followerId] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果被关注人不存在则新建</span><br>    <span class="hljs-keyword">if</span> _, ok := t.userMap[followeeId]; !ok &#123;<br>        t.userMap[followeeId] = &amp;User&#123;<br>            userId:        followeeId,<br>            followees: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>),<br>        &#125;<br>        <span class="hljs-comment">// 每次新建user的时候 将自己加入自己关注</span><br>        t.userMap[followeeId].followees[followeeId] = <span class="hljs-literal">true</span><br>    &#125;<br>    t.userMap[followerId].followees[followeeId] = <span class="hljs-literal">true</span><br><br>&#125;<br><br><span class="hljs-comment">// 形参上的Id 在使用数据结构的时候一般使用map查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> Unfollow(followerId <span class="hljs-type">int</span>, followeeId <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[followerId]; ok &#123;<br><span class="hljs-built_in">delete</span>(t.userMap[followerId].followees, followeeId)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Twitter)</span></span> GetNewsFeed(userId <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>resTop10 := []<span class="hljs-type">int</span>&#123;&#125;<br>tweeters := []*Tweet&#123;&#125;<br><span class="hljs-keyword">if</span> _, ok := t.userMap[userId]; ok &#123;<br><br><span class="hljs-keyword">for</span> followeeId, _ := <span class="hljs-keyword">range</span> t.userMap[userId].followees &#123;<br>tweeters = <span class="hljs-built_in">append</span>(tweeters, t.userMap[followeeId].tweets...)<br>&#125;<br><br>&#125;<br>sort.Slice(tweeters, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> tweeters[i].time &gt; tweeters[j].time &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tweeters) &amp;&amp; i &lt; <span class="hljs-number">10</span> ; i++ &#123;<br>resTop10 = <span class="hljs-built_in">append</span>(resTop10, tweeters[i].tweetId)<br>&#125;<br><br><span class="hljs-keyword">return</span> resTop10<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/design-twitter/description/&quot;&gt;355. 设计推特&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>设计题思考</title>
    <link href="https://leiqichn.top/2024-05-08-9a58f8b87168.html"/>
    <id>https://leiqichn.top/2024-05-08-9a58f8b87168.html</id>
    <published>2024-05-08T17:20:58.000Z</published>
    <updated>2024-09-07T11:07:03.636Z</updated>
    
    <content type="html"><![CDATA[<p>设计数据结构和算法时，通常需要遵循以下步骤来解决问题：</p><ol><li><p><strong>理解问题</strong>：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。</p></li><li><p><strong>确定需求</strong>：明确需要哪些<strong>数据结构</strong>来存储信息，以及如何使用这些数据结构来满足题目的需求。</p></li><li><p><strong>设计数据结构</strong>：</p><ul><li>确定实体类型：例如，用户（User）、推文（Tweet）等。</li><li>确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。</li></ul></li><li><p><strong>定义方法</strong>：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。</p></li><li><p><strong>实现逻辑</strong>：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。</p></li><li><p><strong>考虑边界条件和错误处理</strong>：确保你的代码可以处理各种边界情况和潜在的错误。</p></li><li><p><strong>优化</strong>：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。</p></li></ol><p>对于LeetCode题目 <strong>设计推特</strong>，思考过程如下：</p><ol><li><p><strong>理解题目</strong>：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。</p></li><li><p><strong>确定需求</strong>：</p><ul><li>需要存储用户信息，包括用户ID、关注列表和推文列表。</li><li>需要存储推文信息，包括推文ID和时间戳。</li></ul></li><li><p><strong>设计数据结构</strong>：</p><ul><li><code>Twitter</code>：包含用户映射，用于快速访问用户信息。</li><li><code>User</code>：包含用户ID、关注列表和推文列表。</li><li><code>Tweet</code>：包含推文ID和时间戳。</li></ul></li><li><p><strong>定义方法</strong>：</p><ul><li><code>Constructor</code>：初始化<code>Twitter</code>实例。</li><li><code>PostTweet</code>：实现用户发布推文的逻辑。</li><li><code>Follow</code>：实现用户关注其他用户的逻辑。</li><li><code>Unfollow</code>：实现用户取消关注的逻辑。</li><li><code>GetNewsFeed</code>：实现获取用户信息流的逻辑。</li></ul></li><li><p><strong>实现逻辑</strong>：</p><ul><li>对于<code>PostTweet</code>，检查用户是否存在，如果不存在则创建用户，然后添加推文。</li><li>对于<code>Follow</code>和<code>Unfollow</code>，更新用户的<code>followees</code>映射。</li><li>对于<code>GetNewsFeed</code>，收集并排序推文，然后返回结果。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>确保在添加推文或关注用户时，处理用户不存在的情况。</li><li>在获取信息流时，处理用户没有推文或关注任何人的情况。</li></ul></li><li><p><strong>优化</strong>：</p><ul><li>考虑是否可以使用更高效的数据结构或算法来提高性能。</li></ul></li></ol><p>在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计数据结构和算法时，通常需要遵循以下步骤来解决问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;理解问题&lt;/strong&gt;：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;确定需求&lt;/strong&gt;：明确</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.top/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用递归</title>
    <link href="https://leiqichn.top/2024-05-08-23291165e2d9.html"/>
    <id>https://leiqichn.top/2024-05-08-23291165e2d9.html</id>
    <published>2024-05-08T15:15:21.000Z</published>
    <updated>2024-09-07T11:07:03.632Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traversal(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义：返回nums root 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traversal</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,left <span class="hljs-type">int</span> , right <span class="hljs-type">int</span>)</span></span> *TreeNode&#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right)/<span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;nums[mid],<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.Left =  traversal(nums,left,mid<span class="hljs-number">-1</span>) <span class="hljs-comment">// 把后边 root 节点添加到当前root left 左节点上</span><br>    root.Right = traversal(nums,mid+<span class="hljs-number">1</span>,right) <span class="hljs-comment">// 把后边 root 节点添加到当前root right 左节点上</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤：</p><ol><li><p><strong>识别重复模式</strong>：</p><ul><li>确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。</li></ul></li><li><p><strong>定义递归函数</strong>：</p><ul><li>根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。</li></ul></li><li><p><strong>确定基本情况</strong>：</p><ul><li>找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。</li></ul></li><li><p><strong>分解问题</strong>：</p><ul><li>将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。</li></ul></li><li><p><strong>递归工作</strong>：</p><ul><li>描述递归如何工作，包括如何从子问题的解中构建出原问题的解。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>确定如何将子问题的解合并为原问题的解。</li></ul></li><li><p><strong>编写伪代码</strong>：</p><ul><li>在编写实际代码之前，先用伪代码描述递归逻辑。</li></ul></li><li><p><strong>考虑边界条件</strong>：</p><ul><li>考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。</li></ul></li><li><p><strong>优化性能</strong>：</p><ul><li>如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。</li></ul></li><li><p><strong>测试和调试</strong>：</p><ul><li>编写测试用例来验证递归逻辑，并调试任何出现的问题。</li></ul></li></ol><p>以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成：</p><ul><li><p><strong>重复模式</strong>：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。</p></li><li><p><strong>定义递归函数</strong>：<code>traversal</code> 函数接收一个数组和两个索引，表示当前考虑的子数组。</p></li><li><p><strong>确定基本情况</strong>：如果左索引大于右索引，说明子数组为空，返回 <code>nil</code>。</p></li><li><p><strong>分解问题</strong>：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 <code>traversal</code> 函数。</p></li><li><p><strong>递归工作</strong>：递归地构建左子树和右子树，然后将它们连接到当前根节点。</p></li><li><p><strong>合并结果</strong>：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。</p></li><li><p><strong>编写伪代码</strong>：在脑中或纸上概述递归调用的流程。</p></li><li><p><strong>考虑边界条件</strong>：确保数组索引不会超出数组边界。</p></li><li><p><strong>优化性能</strong>：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。</p></li><li><p><strong>测试和调试</strong>：通过在不同的数组输入上测试函数来确保其正确性。</p></li></ul><p>通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Golang" scheme="https://leiqichn.top/categories/Golang/"/>
    
    
  </entry>
  
</feed>
