<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="http://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="http://leiqichn.github.io/"/>
  <updated>2023-05-10T16:40:52.357Z</updated>
  <id>http://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言删除指定索引元素</title>
    <link href="http://leiqichn.github.io/2023-05-10-082c579e8beb.html"/>
    <id>http://leiqichn.github.io/2023-05-10-082c579e8beb.html</id>
    <published>2023-05-10T23:47:04.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。</p><p>以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    i := <span class="hljs-number">2</span> <span class="hljs-comment">// 要删除的索引</span><br><br>    <span class="hljs-comment">// 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片</span><br>    b := <span class="hljs-built_in">append</span>(a[:i], a[i+<span class="hljs-number">1</span>:]...)<br><br>    fmt.Println(b) <span class="hljs-comment">// 输出 [1 2 4 5]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。</p><p>接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。</p><p>最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。&lt;/p&gt;
&lt;p&gt;以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="Golang" scheme="http://leiqichn.github.io/categories/Golang/"/>
    
    
    <category term="golang" scheme="http://leiqichn.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言指定索引插入元素</title>
    <link href="http://leiqichn.github.io/2023-05-10-0daa2a6721f1.html"/>
    <id>http://leiqichn.github.io/2023-05-10-0daa2a6721f1.html</id>
    <published>2023-05-10T23:42:50.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。</p><p>下面是一个示例代码，它插入一个元素到切片的第二个位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    i := <span class="hljs-number">1</span> <span class="hljs-comment">// 要插入的位置</span><br>    b := <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>&#125;, a[i:]...)...) <span class="hljs-comment">// 在切片的第二个位置插入数字5</span><br>    fmt.Println(b) <span class="hljs-comment">// 输出 [1 5 2 3 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。</p><p>接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。</p><p>最后，我们将结果赋值给变量 b 并打印输出它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。&lt;/p&gt;
&lt;p&gt;下面是一个示例代码，它插入一个元素到切片的第二个位置：&lt;/p&gt;
&lt;figure class=&quot;highlight go</summary>
      
    
    
    
    <category term="Golang" scheme="http://leiqichn.github.io/categories/Golang/"/>
    
    
    <category term="golang" scheme="http://leiqichn.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://leiqichn.github.io/2023-05-10-a36a1183ef35.html"/>
    <id>http://leiqichn.github.io/2023-05-10-a36a1183ef35.html</id>
    <published>2023-05-10T16:40:52.357Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：<strong>go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？</strong><br>接下来让我们一起看看：</p><p>当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据</p><p>例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><br>x := <span class="hljs-number">1</span><br>p := &amp;x<br><br>m[p] = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-comment">// 添加数据</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br><br>*p = <span class="hljs-number">2</span> <span class="hljs-comment">// 修改变量x的值</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。</p><p>接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。</p><p>总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：&lt;strong&gt;go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？&lt;/strong&gt;&lt;br&gt;接下来让我们一起看看：&lt;/p&gt;
&lt;p&gt;当将指针作为 Map 的 Ke</summary>
      
    
    
    
    <category term="G" scheme="http://leiqichn.github.io/categories/G/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 108.将有序数组转换为二叉搜索树</title>
    <link href="http://leiqichn.github.io/2023-05-04-0a85ce0d0b0e.html"/>
    <id>http://leiqichn.github.io/2023-05-04-0a85ce0d0b0e.html</id>
    <published>2023-05-04T23:23:48.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230504232459.png"></p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑<br>注意递归函数定义，严格按照定义调用递归<br>使用前序遍历 中左右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traversal(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义：返回nums root 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traversal</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,left <span class="hljs-type">int</span> , right <span class="hljs-type">int</span>)</span></span> *TreeNode&#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right)/<span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;nums[mid],<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.Left =  traversal(nums,left,mid<span class="hljs-number">-1</span>) <span class="hljs-comment">// 把后边 root 节点添加到当前root left 左节点上</span><br>    root.Right = traversal(nums,mid+<span class="hljs-number">1</span>,right) <span class="hljs-comment">// 把后边 root 节点添加到当前root right 左节点上</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/&quot;&gt;108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>删除ppt所有批注和备注</title>
    <link href="http://leiqichn.github.io/2023-04-24-647ad7e06638.html"/>
    <id>http://leiqichn.github.io/2023-04-24-647ad7e06638.html</id>
    <published>2023-04-24T22:25:04.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230424222537.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222611.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222527.png"><br><img src="/../../imgs/Pasted%20image%2020230424222515.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222511.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230424222537.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230424222611.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言-接口</title>
    <link href="http://leiqichn.github.io/2023-04-21-326cad9621b7.html"/>
    <id>http://leiqichn.github.io/2023-04-21-326cad9621b7.html</id>
    <published>2023-04-21T00:42:26.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。</p><p>以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Printer <span class="hljs-keyword">interface</span> &#123;<br>    Print()<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span></span> Print() &#123;<br>    fmt.Println(u.name,<span class="hljs-string">&quot;我爱加班&quot;</span>)<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printAll</span><span class="hljs-params">(ps []Printer)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> ps &#123;<br>        p.Print()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ps []Printer<br>    ps = <span class="hljs-built_in">append</span>(ps, User&#123;<span class="hljs-string">&quot;Alice&quot;</span>&#125;)<br>    ps = <span class="hljs-built_in">append</span>(ps, User&#123;<span class="hljs-string">&quot;Bob&quot;</span>&#125;)<br>    printAll(ps)<br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Alice 我爱加班<br>Bob 我爱加班<br></code></pre></td></tr></table></figure><p>在这段代码中，我们通过接口将<strong>User类型</strong>与PrintAll() 函数解耦，这样当我们需要添加<strong>新的类型时，只需要实现Print()方法</strong>即可，而不需要修改<strong>PrintAll()函数实现</strong>。</p><p>比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改<strong>PrintAll()函数实现</strong>。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，<strong>有相同的特征</strong>，我们将其抽象出来，降低代码耦合性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Boss <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Boss)</span></span> Print() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;你明天不用来了&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照<strong>合同的规定</strong>进行处理。</p><p>同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。&lt;/p&gt;
&lt;p&gt;以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定</summary>
      
    
    
    
    <category term="Golang" scheme="http://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言-多态</title>
    <link href="http://leiqichn.github.io/2023-04-21-de97c2f605b0.html"/>
    <id>http://leiqichn.github.io/2023-04-21-de97c2f605b0.html</id>
    <published>2023-04-21T00:32:20.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。</p><p>我们来实现这样一个例子：</p><ul><li>实现猫和狗<strong>两个对象</strong>，并且他们都有动作：叫，<strong>但叫声不同</strong>。再实现一个<strong>对象鸟</strong>，他除了叫，还会<strong>飞</strong>。</li></ul><p>下面是基于Go语言，实现题目要求的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>    Cry()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;喵喵喵&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;汪汪汪&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Bird <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Bird)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;叽叽喳喳&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Bird)</span></span> Fly() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;我会飞&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> animal Animal<br><br>    <span class="hljs-comment">// 创建一只猫</span><br>    animal = Cat&#123;&#125;<br>    animal.Cry()<br><br>    <span class="hljs-comment">// 创建一只狗</span><br>    animal = Dog&#123;&#125;<br>    animal.Cry()<br><br>    <span class="hljs-comment">// 创建一只鸟</span><br>    bird := Bird&#123;&#125;<br>    animal = bird<br>    animal.Cry()<br>    bird.Fly()<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。</p><p>运行上述代码，输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">喵喵喵<br>汪汪汪<br>叽叽喳喳<br>我会飞<br></code></pre></td></tr></table></figure><p>在这段代码中，我们使用了<strong>接口的多态特性</strong>，通过定义<strong>Animal接口</strong>，实现了<strong>不同类型的对象之间的通用性</strong>，并且在<strong>Bird中新增了Fly() 方法</strong>，符合面向对象的<strong>开放封闭原则</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。&lt;/p&gt;
&lt;p&gt;我们来实现这样一个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现猫和狗&lt;strong&gt;两个对象&lt;/strong&gt;，并且他们都有动作：叫，&lt;strong&gt;但叫声不同&lt;/s</summary>
      
    
    
    
    <category term="Golang" scheme="http://leiqichn.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>波纹</title>
    <link href="http://leiqichn.github.io/2023-04-08-343cd8744ef0.html"/>
    <id>http://leiqichn.github.io/2023-04-08-343cd8744ef0.html</id>
    <published>2023-04-08T13:41:33.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/IMG_1502-01-01.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../../imgs/IMG_1502-01-01.jpeg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="记录" scheme="http://leiqichn.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="摄影" scheme="http://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 513.找树左下角的值</title>
    <link href="http://leiqichn.github.io/2023-04-03-d2d9a7e62e40.html"/>
    <id>http://leiqichn.github.io/2023-04-03-d2d9a7e62e40.html</id>
    <published>2023-04-03T22:44:37.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（Leetcode）</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg"></p><p><strong>输入:</strong> root &#x3D; [2,1,3]<br><strong>输出:</strong> 1</p><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg"></p><p><strong>输入:</strong> [1,2,3,4,null,5,6,null,null,7]<br><strong>输出:</strong> 7</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本题可以转化为什么呢？</p><blockquote><p>1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值<br>2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> depth <span class="hljs-type">int</span>   <span class="hljs-comment">// 全局变量 最大深度</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>     <span class="hljs-comment">// 记录最终结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    depth, res = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>   <br>    dfs(root, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, d <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//这里判断nil ,后边左右节点就不用判断了</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; depth &lt; d &#123; <br>        depth = d<br>        res = root.Val<br>    &#125;<br>    dfs(root.Left, d+<span class="hljs-number">1</span>)   <br>    dfs(root.Right, d+<span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 遍历每一层</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-comment">// 获取每一层的最左边的位置，更新res</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>res = top.Val<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Left)<br>&#125;<br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Right)<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br><span class="hljs-comment">// 迭代2 每层用一个切片</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// 通过另外一个切片来添加的解法也要尝试学习一下</span><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 使用nextqueue 保存每一层，然后追加到queue</span><br>nextqueue := []*TreeNode&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br>    res = nextqueue[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>nextqueue = <span class="hljs-built_in">append</span>(nextqueue, top.Left)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>nextqueue = <span class="hljs-built_in">append</span>(nextqueue, top.Right)<br>&#125;<br>&#125;<br>queue = <span class="hljs-built_in">append</span>(queue,nextqueue...)<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>如果要求最右边的值呢？这里该怎么求呢？</p><p>只需要将 遍历左右的顺序颠倒一下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 遍历每一层</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-comment">// 获取每一层的最左边的位置，更新res</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>res = top.Val<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Right)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Left)<br>&#125;<br><br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-bottom-left-tree-value/&quot;&gt;513. 找树左下角的值 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树的 &lt;strong&gt;根节点&lt;/strong&gt; </summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 404.左叶子之和</title>
    <link href="http://leiqichn.github.io/2023-03-29-318ae3533bef.html"/>
    <id>http://leiqichn.github.io/2023-03-29-318ae3533bef.html</id>
    <published>2023-03-29T22:44:37.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 递归</span><br>res := <span class="hljs-number">0</span><br><span class="hljs-comment">// 终止条件</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    leftNode := root.Left<br>leftNodeVal := sumOfLeftLeaves(root.Left) <span class="hljs-comment">// 左</span><br>    rightNodeVal := sumOfLeftLeaves(root.Right)<span class="hljs-comment">// 右</span><br><span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">nil</span> &amp;&amp; leftNode.Left == <span class="hljs-literal">nil</span> &amp;&amp; leftNode.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 中</span><br>leftNodeVal = leftNode.Val<br>&#125;<br><span class="hljs-comment">// 单次循环</span><br>    res = leftNodeVal + rightNodeVal <span class="hljs-comment">// 中，左边+右边</span><br><span class="hljs-keyword">return</span> res <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 257.二叉树的所有路径</title>
    <link href="http://leiqichn.github.io/2023-03-28-3849178edc04.html"/>
    <id>http://leiqichn.github.io/2023-03-28-3849178edc04.html</id>
    <published>2023-03-28T23:47:29.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">0</span>)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>backTracking(root)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;<br><span class="hljs-comment">// 终点 左右子节点都为nil</span><br><span class="hljs-keyword">if</span> isLeafNode(root) &#123;<br>        NodeValStr := strconv.Itoa(root.Val)<br>    path = <span class="hljs-built_in">append</span>(path, NodeValStr)<br>pathStr := strings.Join(path, <span class="hljs-string">&quot;-&gt;&quot;</span>)<br>res = <span class="hljs-built_in">append</span>(res, pathStr)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 前序遍历 中左右</span><br><span class="hljs-comment">// 遍历 每次递归的操作</span><br>NodeVal:= strconv.Itoa(root.Val)<span class="hljs-comment">// 中</span><br>path = <span class="hljs-built_in">append</span>(path, NodeVal)<br><span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 左</span><br>backTracking(root.Left)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 右</span><br>backTracking(root.Right)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isLeafNode</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">bool</span>&#123;<br><span class="hljs-keyword">if</span> node.Right==<span class="hljs-literal">nil</span> &amp;&amp; node.Left== <span class="hljs-literal">nil</span> &amp;&amp; node!= <span class="hljs-literal">nil</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 110.平衡二叉树</title>
    <link href="http://leiqichn.github.io/2023-03-28-40f110530226.html"/>
    <id>http://leiqichn.github.io/2023-03-28-40f110530226.html</id>
    <published>2023-03-28T11:18:47.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（Leetcode）</a></p><p><font color="#2DC26B">简单 </font><br>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p><p><strong>输入：</strong>root &#x3D; [3,9,20,null,null,15,7]<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p><p><strong>输入：</strong>root &#x3D; [1,2,2,3,3,null,null,4,4]<br><strong>输出：</strong>false</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root &#x3D; []<br><strong>输出：</strong>true</p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里是求<strong>高度</strong>： 节点到叶子节点的最长距离，使用<strong>后序遍历</strong><br><strong>深度</strong>是root 到该节点的最长距离（距离☞节点数），使用<strong>前序遍历</strong></p><p>因此只要分别计算左右子树的高度，并且做差不大于1就行</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用-1 记录 res 不是平衡二叉树<br>每次执行，都需要判断是不是等于-1，直接返回-1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/balanced-binary-tree/&quot;&gt;110. 平衡二叉树 - 力扣（Leetcode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#2DC26B&quot;&gt;简单 &lt;/font&gt;&lt;br&gt;给定一</summary>
      
    
    
    
    <category term="leetcode" scheme="http://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>快来压缩你的博客图片</title>
    <link href="http://leiqichn.github.io/2023-03-24-92a37bba7a46.html"/>
    <id>http://leiqichn.github.io/2023-03-24-92a37bba7a46.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没多大变化 哈哈哈<br><img src="/../../imgs/Pasted%20image%2020230324011438.png"><br>再试试 更大更高清的图片<br><img src="/../../imgs/code-wallpaper-6.png"></p><p><img src="/../../imgs/Pasted%20image%2020230325200454.png"><br>实测,效果不太行….<br>但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下<br>待更新…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然没多大变化 哈哈哈&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020230324011438.png&quot;&gt;&lt;br&gt;再试试 更大更高清的图片&lt;br&gt;&lt;img src=&quot;/../../imgs/code-wallpaper-6.png&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>给你的博客 安装上PWA吧</title>
    <link href="http://leiqichn.github.io/2023-03-24-554b8cbb674b.html"/>
    <id>http://leiqichn.github.io/2023-03-24-554b8cbb674b.html</id>
    <published>2023-03-24T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>TODO:</p><ul><li>什么是PWA，可以提示添加到主屏幕<br>渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站</li><li>安装 hexo-pwa</li><li>由于hexo-pwa停止维护，需要解决报错</li><li>设置全局_config.yml 文件(非主题)</li></ul><p><img src="/../../imgs/Pasted%20image%2020230324004739.png"></p><p><img src="/../../imgs/ad6c5ebfc9a6401cde512120b6ed719.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是PWA，可以提示添加到主屏幕&lt;br&gt;渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站&lt;/li&gt;
&lt;li&gt;安装 hexo-pwa&lt;/li&gt;
&lt;li&gt;由于hexo-pwa停止维护，需要解决报错&lt;/li&gt;
&lt;li&gt;设置全局_con</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 命令 将前台任务挂到后台运行</title>
    <link href="http://leiqichn.github.io/2023-03-19-aaf910b916ec.html"/>
    <id>http://leiqichn.github.io/2023-03-19-aaf910b916ec.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用<code>bg</code>  挂后台的命令。</p><p><strong>第一步：ctrl + z</strong></p><p><strong>第二步：jobs  查看任务id</strong></p><p><strong>第三步： bg %任务id</strong></p><p><img src="/../../imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用&lt;code</summary>
      
    
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/categories/Linux/"/>
    
    
    <category term="linux命令" scheme="http://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>博客设置 obsidian 上传图片</title>
    <link href="http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html"/>
    <id>http://leiqichn.github.io/2023-03-19-4d59bacf78a0.html</id>
    <published>2023-03-19T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的<strong>相对路径</strong>就可以读取并显示图片。</p><p>而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="1-打开obsidian-文件与链接"><a href="#1-打开obsidian-文件与链接" class="headerlink" title="1. 打开obsidian - 文件与链接"></a>1. 打开obsidian - 文件与链接</h2><h2 id="2-按照下图配置"><a href="#2-按照下图配置" class="headerlink" title="2. 按照下图配置"></a>2. 按照下图配置</h2><p>   *　将内部链接类型 设置为 “基于当前笔记的<strong>相对路径</strong>”<br>     &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用<strong>相对路径</strong></p><ul><li>取消wiki 链接 </li><li>指定图片的默认路径为 <code>source/imgs</code><br>&gt; 如果没有该文件夹，则需要先新建一下。</li></ul><p><img src="/../../imgs/Pasted%20image%2020230319131458.png"></p><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>网页可以成功显示图片</p><p><img src="/../../imgs/Pasted%20image%2020230319134051.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定</summary>
      
    
    
    
    <category term="工具" scheme="http://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>排版测试</title>
    <link href="http://leiqichn.github.io/2023-03-18-16129b89df14.html"/>
    <id>http://leiqichn.github.io/2023-03-18-16129b89df14.html</id>
    <published>2023-03-18T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<p>网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。</p><h1 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><h4 id="hello-world-1"><a href="#hello-world-1" class="headerlink" title="hello world"></a>hello world</h4><p><img src="/../../imgs/Pasted%20image%2020230408134405.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网页上显示和排版有时候比较麻烦，需要进行测试。本文档就是为测试网页排版格式的。&lt;/p&gt;
&lt;h1 id=&quot;HELLO-WORLD&quot;&gt;&lt;a href=&quot;#HELLO-WORLD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORLD&quot;&gt;&lt;/a&gt;HELLO </summary>
      
    
    
    
    <category term="Test" scheme="http://leiqichn.github.io/categories/Test/"/>
    
    
    <category term="Linux" scheme="http://leiqichn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://leiqichn.github.io/2023-03-14-2c94ed65547e.html"/>
    <id>http://leiqichn.github.io/2023-03-14-2c94ed65547e.html</id>
    <published>2023-03-14T00:00:00.000Z</published>
    <updated>2023-05-10T16:40:52.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h1><p><a href="https://leiqichn.github.io/">国外链接</a><br><a href="https://leiqicn.gitee.io/">国内链接</a><br>大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客链接&quot;&gt;&lt;a href=&quot;#博客链接&quot; class=&quot;headerlink&quot; title=&quot;博客链接&quot;&gt;&lt;/a&gt;博客链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leiqichn.github.io/&quot;&gt;国外链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="关于我" scheme="http://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
    
    <category term="about" scheme="http://leiqichn.github.io/tags/about/"/>
    
  </entry>
  
</feed>
