<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei Qi&#39;s Blog</title>
  
  
  <link href="https://leiqichn.github.io/atom.xml" rel="self"/>
  
  <link href="https://leiqichn.github.io/"/>
  <updated>2024-01-23T17:37:54.516Z</updated>
  <id>https://leiqichn.github.io/</id>
  
  <author>
    <name>Lei Qi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <link href="https://leiqichn.github.io/2024-01-23-1cb0809a7893.html"/>
    <id>https://leiqichn.github.io/2024-01-23-1cb0809a7893.html</id>
    <published>2024-01-23T16:13:30.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> people[i][<span class="hljs-number">0</span>] == people[j][<span class="hljs-number">0</span>]&#123;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">1</span>] &lt; people[j][<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">0</span>] &gt; people[j][<span class="hljs-number">0</span>] <span class="hljs-comment">// 身高由大到小排列</span><br><br>&#125;)i<br><span class="hljs-comment">// 再按照K进行插入排序，优先插入K小的</span><br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-built_in">copy</span>(people[p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span> :i+<span class="hljs-number">1</span>], people[p[<span class="hljs-number">1</span>] :i=<span class="hljs-number">1</span>])  <span class="hljs-comment">// 腾空出一个位置</span><br>        people[p[<span class="hljs-number">1</span>]] = pi<br>&#125;<br><span class="hljs-keyword">return</span> people<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p></li><li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p></li><li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p></li><li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p></li></ol><p>最终，返回重新排列后的队列 <code>people</code>。</p><p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p><p>让我们考虑一下为什么使用 <code>i+1</code>：</p><ol><li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li><li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li><li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/queue-reconstruction-by-height/description/&quot;&gt;406. 根据身高重建队列 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <link href="https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html"/>
    <id>https://leiqichn.github.io/2024-01-23-183e0ff5f5ef.html</id>
    <published>2024-01-23T15:17:11.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p><p>使用回溯的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>path := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// return </span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>) <span class="hljs-comment">// i+1 进行下一轮</span><br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p></li><li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p></li><li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p></li><li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p></li><li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p></li><li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combinations/description/&quot;&gt;77. 组合 - 力扣（LeetCode）&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%202024</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【BFS DFS通用模板】</title>
    <link href="https://leiqichn.github.io/2024-01-22-759654485d5d.html"/>
    <id>https://leiqichn.github.io/2024-01-22-759654485d5d.html</id>
    <published>2024-01-22T16:05:29.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 通用的深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node <span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> visited[node] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理当前节点</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 标记当前节点为已访问</span><br>    visited[node] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 递归处理相邻节点</span><br>    <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>        dfs(neighbor, visited, graph)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化节点、访问数组等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 遍历所有节点</span><br>    <span class="hljs-keyword">for</span> node := <span class="hljs-number">0</span>; node &lt; <span class="hljs-built_in">len</span>(graph); node++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[node] &#123;<br>            dfs(node, visited, graph)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通用的广度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(graph))<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 出队列</span><br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment">// 处理当前节点</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 标记当前节点为已访问</span><br>        visited[node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 将相邻节点入队列</span><br>        <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[neighbor] &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, neighbor)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化起始节点、图等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用BFS函数</span><br>    bfs(start, graph)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;a href=&quot;#深度优先搜索（DFS）通用模板&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索（DFS）通用模板&quot;&gt;&lt;/a&gt;深度优先搜索（DFS）通用模板&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <link href="https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html"/>
    <id>https://leiqichn.github.io/2024-01-22-f8790b7ced8e.html</id>
    <published>2024-01-22T15:01:59.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">var</span> traversal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traversal = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br>traversal(node.Left)<br>res = <span class="hljs-built_in">append</span>(res,node.Val)<br>traversal(node.Right)<br>    &#125;<br>    traversal(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br><br>    st := list.New()<br>    cur := root<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> || st.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            st.PushBack(cur)<br>            cur = cur.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = st.Remove(st.Back()).(*TreeNode)<br>            ans = <span class="hljs-built_in">append</span>(ans, cur.Val)<br>            cur = cur.Right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对代码的解释：</p><ol><li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p></li><li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p></li><li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p></li><li><p><code>cur := root</code>: 初始化当前节点为根节点。</p></li><li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p></li><li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p><ul><li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p></li><li><p><code>cur = cur.Left</code>: 移动到左子树。</p></li></ul></li><li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p><ul><li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p></li><li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p></li><li><p><code>cur = cur.Right</code>: 移动到右子树。</p></li></ul></li><li><p>循环回到第5步，直到栈为空。</p></li></ol><p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p><p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p><ul><li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p></li><li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p></li></ul><p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p><p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归方法&quot;&gt;&lt;a href=&quot;#递归方法&quot; class=&quot;headerlink&quot; title=&quot;递归方法&quot;&gt;&lt;/a&gt;递归方法&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【go】初始化双向列表List</title>
    <link href="https://leiqichn.github.io/2024-01-22-93119ce81a1c.html"/>
    <id>https://leiqichn.github.io/2024-01-22-93119ce81a1c.html</id>
    <published>2024-01-22T14:39:01.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p>在Go语言中，两种方法都可以用于初始化一个<code>list.List</code>。</p><ol><li><p><code>queue := &amp;list.List&#123;&#125;</code>: 这是使用结构体字面量的方式，创建一个 <code>list.List</code> 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。</p></li><li><p><code>queue := list.New()</code>: 这是使用 <code>list</code> 包中的 <code>New</code> 函数来创建一个新的 <code>list.List</code>。<code>New</code> 函数返回一个指向新创建的 <code>list.List</code> 实例的指针。同样，这种方式也创建了一个空的链表。</p></li></ol><p>两种方式都是有效的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Go语言中，两种方法都可以用于初始化一个&lt;code&gt;list.List&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;queue := &amp;amp;list.List&amp;#123;&amp;#125;&lt;/code&gt;: 这是使用结构体字面量的方式，创建一个 &lt;code&gt;l</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240114】LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="https://leiqichn.github.io/2024-01-14-e61755fec3db.html"/>
    <id>https://leiqichn.github.io/2024-01-14-e61755fec3db.html</id>
    <published>2024-01-14T10:10:30.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">for</span> i := head; i != <span class="hljs-literal">nil</span> &amp;&amp; i.Next != <span class="hljs-literal">nil</span> ; &#123;<br>        <span class="hljs-keyword">if</span> i.Next.Val == i.Val &#123;<br>            i.Next = i.Next.Next <span class="hljs-comment">// 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123;  i = i.Next不需要</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    current := head<br><br>    <span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &amp;&amp; current.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> current.Next.Val == current.Val &#123;<br>            <span class="hljs-comment">// 保存下一个节点的引用</span><br>            nextNode := current.Next<br>            <span class="hljs-comment">// 删除当前节点</span><br>            current.Next = nextNode.Next<br>            <span class="hljs-comment">// 释放内存</span><br>            nextNode = <span class="hljs-literal">nil</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非重复元素，继续遍历</span><br>            current = current.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/&quot;&gt;83. 删除排序链表中的重复元素&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Win】键盘下键坏了，使用组合键模拟下方向键</title>
    <link href="https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html"/>
    <id>https://leiqichn.github.io/2024-01-14-2aaa71f8e7be.html</id>
    <published>2024-01-14T09:05:02.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：</p><p>下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。<br><img src="/../../imgs/Pasted%20image%2020240114170655.png"><br>创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">!s::<span class="hljs-built_in">Send</span> &#123;Down&#125;<br></code></pre></td></tr></table></figure><p>这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。<br><img src="/../../imgs/Pasted%20image%2020240114170729.png"><br>保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。</p><p>运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。</p><p>现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：&lt;/p&gt;
&lt;p&gt;下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。&lt;br&gt;&lt;img src</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>【20240106】leetcode 2807. 在链表中插入最大公约数</title>
    <link href="https://leiqichn.github.io/2024-01-06-2b3ad028343c.html"/>
    <id>https://leiqichn.github.io/2024-01-06-2b3ad028343c.html</id>
    <published>2024-01-06T15:27:26.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&envId=2024-01-06">2807. 在链表中插入最大公约数 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240106233021.png"></p><p>最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。</p><p>计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下：</p><ol><li>用较大的数除以较小的数，得到余数。</li><li>将较小的数作为新的被除数，余数作为新的除数。</li><li>重复步骤 1 和 2，直到余数为零。</li><li>最后的非零余数即为最大公约数。</li></ol><p>这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。</p><p>以下是一个用 Go 语言实现的最大公约数的辗转相除法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 辗转相除法求最大公约数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        temp := b<br>        b = a % b<br>        a = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num1 := <span class="hljs-number">48</span><br>    num2 := <span class="hljs-number">18</span><br><br>    result := gcd(num1, num2)<br><br>    fmt.Println(<span class="hljs-string">&quot;最大公约数为:&quot;</span>, result)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>gcd</code> 函数使用了辗转相除法来计算两个整数的最大公约数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&amp;envId=2024-01-06</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1071. 字符串的最大公因子</title>
    <link href="https://leiqichn.github.io/2024-01-03-58e186a9065e.html"/>
    <id>https://leiqichn.github.io/2024-01-03-58e186a9065e.html</id>
    <published>2024-01-03T15:12:16.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></p><p><img src="/../../imgs/Pasted%20image%2020240103231323.png"></p><p><strong>解题思路：</strong></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n1, n2 := <span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2)<br><br>    <span class="hljs-comment">// 从最长的可能的子串长度开始尝试</span><br>    <span class="hljs-keyword">for</span> i := min(n1, n2); i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> n1%i == <span class="hljs-number">0</span> &amp;&amp; n2%i == <span class="hljs-number">0</span> &#123;<br>            commonSubstring := str1[:i]<br><br>            <span class="hljs-comment">// 检查是否满足条件</span><br>            <span class="hljs-keyword">if</span> checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123;<br>                <span class="hljs-keyword">return</span> commonSubstring<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 检查字符串是否能够整除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDivisible</span><span class="hljs-params">(s <span class="hljs-type">string</span>, sub <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    repeats := <span class="hljs-built_in">len</span>(s) / <span class="hljs-built_in">len</span>(sub)<br>    concatenated := repeatString(sub, repeats)<br>    <span class="hljs-keyword">return</span> s == concatenated<br>&#125;<br><br><span class="hljs-comment">// 重复字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    result := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>        result += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>辗转相除法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> str1 + str2 != str2 + str1 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    gcd := gcd(<span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2))<br>    <span class="hljs-keyword">return</span> str1[<span class="hljs-number">0</span>:gcd]<br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        a, b = b, a % b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/greatest-common-divisor-of-strings/&quot;&gt;1071. 字符串的最大公因子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20imag</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>windows新增wsl bash here键快捷方式</title>
    <link href="https://leiqichn.github.io/2024-01-01-38178c63ba17.html"/>
    <id>https://leiqichn.github.io/2024-01-01-38178c63ba17.html</id>
    <published>2024-01-01T10:23:10.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p>win + R 输入regedit<br><img src="/../../imgs/Pasted%20image%2020240101182355.png"><br>输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p><h1 id="新建wsl-bash-here目录-设置如下默认值"><a href="#新建wsl-bash-here目录-设置如下默认值" class="headerlink" title="新建wsl_bash_here目录, 设置如下默认值"></a>新建wsl_bash_here目录, 设置如下默认值</h1><p><img src="/../../imgs/Pasted%20image%2020240101183252.png"></p><h1 id="新建command新建项，输入wsl-exe-的地址"><a href="#新建command新建项，输入wsl-exe-的地址" class="headerlink" title="新建command新建项，输入wsl.exe 的地址"></a>新建command新建项，输入wsl.exe 的地址</h1><p><img src="/../../imgs/Pasted%20image%2020240101183246.png"></p><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>可以看到右侧是有wsl bash here的选项的<br><img src="/../../imgs/Pasted%20image%2020240101183634.png"><br><strong>在当面目录打开wsl 成功</strong><br><img src="/../../imgs/Pasted%20image%2020240101183645.png"><br>原理和添加git bash here 类似, 参考:<br><a href="https://blog.csdn.net/Passerby_Wang/article/details/120881670">手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;win + R 输入regedit&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted%20image%2020240101182355.png&quot;&gt;&lt;br&gt;输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git 设置免密配置-全局免密-单仓库免密-SSH免密</title>
    <link href="https://leiqichn.github.io/2024-01-01-91517aa963bc.html"/>
    <id>https://leiqichn.github.io/2024-01-01-91517aa963bc.html</id>
    <published>2024-01-01T06:56:28.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h1><p>我们要首先知道一个简单的概念:<br>https通过<strong>记住账号密码免登</strong>，ssh通过<strong>校验生成的密钥免登</strong>。 通常都用ssh校验。</p><p>查看通信方式</p><p>在项目目录中运行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote -v<br></code></pre></td></tr></table></figure><p>如果出现提示是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">origin  https://gitee.com/xxx/xxx.git (fetch)<br>origin  https://gitee.com/xxx/xxx.git (push)<br></code></pre></td></tr></table></figure><p>则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密<br>如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址<br><img src="/../../imgs/Pasted%20image%2020240101151457.png"></p><h1 id="一、https-方式及免密码配置"><a href="#一、https-方式及免密码配置" class="headerlink" title="一、https 方式及免密码配置"></a>一、https 方式及免密码配置</h1><h3 id="0-项目中-git-基本配置"><a href="#0-项目中-git-基本配置" class="headerlink" title="0. 项目中 git 基本配置"></a>0. 项目中 git 基本配置</h3><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text"># 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令<br>git init<br># 关联远程仓库<br>git remote add origin https://gitee.com/xxx/xxx.git<br>git add -A<br>git commit -m &quot;初始化&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。</p><p>这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。</p><h3 id="1-全局免密码配置"><a href="#1-全局免密码配置" class="headerlink" title="1.全局免密码配置"></a>1.全局免密码配置</h3><p>配置存储模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store</p><p>Linux 下查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.gitconfig<br></code></pre></td></tr></table></figure><p>windows10 下当前用户路径：<code>%USERPROFILE%</code><br>内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[user]<br>        name = lenovo<br>        email = xxxx@outlook.com<br>[credential]<br>        helper = store<br></code></pre></td></tr></table></figure><p>然后在项目目录，执行git pull&#x2F;git push命令，会提示输入<strong>账号密码</strong>。这次输入账号密码之后，就会<strong>记住</strong>账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。<br><img src="/../../imgs/Pasted%20image%2020240101145902.png"></p><h3 id="2、单项目免密码配置"><a href="#2、单项目免密码配置" class="headerlink" title="2、单项目免密码配置"></a>2、单项目免密码配置</h3><p>编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]<br>url = https://gitee.com/xxx/xxx.git<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]   <br>url = https://yourusername:password@gitee.com/xxx/xxxx.git<br></code></pre></td></tr></table></figure><p>也就是在 <code>https://</code> 之后，增加 <code>用户名:密码@</code></p><h1 id="二-SSH免密登录"><a href="#二-SSH免密登录" class="headerlink" title="二. SSH免密登录"></a>二. SSH免密登录</h1><p>如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式,</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote rm origin<br></code></pre></td></tr></table></figure><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>github 网页增加本机SSH key</p><p>git ssh 方式免密提交方式需要将 <code>ssh-keygen</code> 生成的公钥放到服务器上</p><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot; <br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置 ssh 远程项目地址。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 如果是新仓库需要git init ;否则不需要git init; git init<br># git 关联远程仓库<br>git remote add origin git@gitee.com:xxx/xxx.git<br></code></pre></td></tr></table></figure><h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><p>1、首先需要检查你电脑是否已经有 SSH key</p><p>运行 git Bash 客户端，检查本机的ssh密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">$ cd ~/.ssh <br>$ ls<br></code></pre></td></tr></table></figure><p>如果提示：No such file or directory ，说明是第一次使用 git。</p><p>如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ mkdir key_backup   <br>$ cp id_rsa* key_backup   <br>$ rm id_rsa*<br></code></pre></td></tr></table></figure><p>2、执行生成公钥和私钥的命令，生成新的密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;xxx&quot;<br></code></pre></td></tr></table></figure><p>代码参数：</p><p>-t 指定密钥类型，默认是 rsa ，可以省略。</p><p>-C 设置注释文字，比如邮箱。</p><p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p><p>按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p><p>执行查看公钥信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>Windows 系统，位置在用户目录下 .ssh文件夹中。<code>%USERPROFILE%</code></p><h2 id="复制公钥信息到远端仓库"><a href="#复制公钥信息到远端仓库" class="headerlink" title="复制公钥信息到远端仓库"></a>复制公钥信息到远端仓库</h2><p><strong>gitee</strong><br>打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p><p><img src="https://pic3.zhimg.com/80/v2-8c26fae5769cb56da5e20c884a33c702_720w.webp"></p><p><strong>github</strong><br>Settings -SSH and GPG keys - New SSH key<br><img src="app://db738d3bb1089e4d04f6eb022a68209f31bf/D:/obsidian_note/LeiQi_Blog/source/imgs/Pasted%20image%2020240101151324.png?1704093204312"><br>然后，提交时就不再需要用户名和密码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">git add -A<br>git commit -m &quot;ssh免密提交&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/358721423">https://zhuanlan.zhihu.com/p/358721423</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍之前&quot;&gt;&lt;a href=&quot;#介绍之前&quot; class=&quot;headerlink&quot; title=&quot;介绍之前&quot;&gt;&lt;/a&gt;介绍之前&lt;/h1&gt;&lt;p&gt;我们要首先知道一个简单的概念:&lt;br&gt;https通过&lt;strong&gt;记住账号密码免登&lt;/strong&gt;，ssh通过&lt;stro</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows设置Clion 下方Terminal为WSL linux 子系统</title>
    <link href="https://leiqichn.github.io/2023-12-30-397a0b919639.html"/>
    <id>https://leiqichn.github.io/2023-12-30-397a0b919639.html</id>
    <published>2023-12-30T15:49:39.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端上的小箭头下的设置"><a href="#终端上的小箭头下的设置" class="headerlink" title="终端上的小箭头下的设置"></a>终端上的小箭头下的设置</h1><p><img src="/../../imgs/Pasted%20image%2020231230235906.png"><br><img src="/../../imgs/Pasted%20image%2020231230234942.png"></p><h1 id="找到WSL的地址"><a href="#找到WSL的地址" class="headerlink" title="找到WSL的地址"></a>找到WSL的地址</h1><p><img src="/../../imgs/Pasted%20image%2020231231000039.png"></p><p>粘贴到对应地址中<br><img src="/../../imgs/Pasted%20image%2020231231000121.png"></p><h1 id="设置成功"><a href="#设置成功" class="headerlink" title="设置成功"></a>设置成功</h1><p>这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端上的小箭头下的设置&quot;&gt;&lt;a href=&quot;#终端上的小箭头下的设置&quot; class=&quot;headerlink&quot; title=&quot;终端上的小箭头下的设置&quot;&gt;&lt;/a&gt;终端上的小箭头下的设置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../imgs/Pasted%20ima</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>免费使用Jetbrain 全家桶-服务器激活码激活软件</title>
    <link href="https://leiqichn.github.io/2023-12-30-6a1e804ab992.html"/>
    <id>https://leiqichn.github.io/2023-12-30-6a1e804ab992.html</id>
    <published>2023-12-30T15:08:29.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.</p><p>Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。</p><ul><li><a href="https://search.censys.io/">https://search.censys.io/</a>     搜索：<code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></li><li><a href="https://www.shodan.io/">https://www.shodan.io</a>  搜索：<br><code>Location: https://account.jetbrains.com/fls-auth</code></li><li><a href="https://fofa.info/">https://fofa.info/</a>     搜索：<code>fls-auth</code></li></ul><p>随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是<a href="https://search.censys.io/">https://search.censys.io/</a> 网站, 搜索 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">services<span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.location</span>: account<span class="hljs-selector-class">.jetbrains</span>.com/fls-auth<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020231230231034.png"><br>例如上边就是 <a href="http://111.231.22.61:1024/">http://111.231.22.61:1024</a></p><p><img src="/../../imgs/Pasted%20image%2020231230231326.png"></p><h1 id="激活成功"><a href="#激活成功" class="headerlink" title="激活成功"></a>激活成功</h1><p>激活成功，请开始愉快的编码吧！<br><img src="/../../imgs/Pasted%20image%2020231230231349.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.&lt;/p&gt;
&lt;p&gt;Jetbrain 是针对公</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>WPS设置打开文件自动同步云文档</title>
    <link href="https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html"/>
    <id>https://leiqichn.github.io/2023-12-30-3a73bdfdd568.html</id>
    <published>2023-12-30T14:08:47.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<p>不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。<br>WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：</p><h1 id="打开首页，设置中心"><a href="#打开首页，设置中心" class="headerlink" title="打开首页，设置中心"></a>打开首页，设置中心</h1><p><img src="/../../imgs/Pasted%20image%2020231230221037.png"></p><p><img src="/../../imgs/Pasted%20image%2020231230220856.png"></p><h1 id="打开新文件会自动上传更新"><a href="#打开新文件会自动上传更新" class="headerlink" title="打开新文件会自动上传更新"></a>打开新文件会自动上传更新</h1><p><img src="/../../imgs/Pasted%20image%2020231230221311.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。&lt;br&gt;WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：&lt;/p&gt;
&lt;h1 id=&quot;打开首页，设置中心&quot;&gt;&lt;a href=&quot;#打开首页，设置中心&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="工具" scheme="https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git强制拉取远端</title>
    <link href="https://leiqichn.github.io/2023-10-22-9bf76366f18c.html"/>
    <id>https://leiqichn.github.io/2023-10-22-9bf76366f18c.html</id>
    <published>2023-10-22T09:53:57.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/&lt;branch_name&gt;<br></code></pre></td></tr></table></figure><p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p><p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p><p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p><p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td</summary>
      
    
    
    
    <category term="git" scheme="https://leiqichn.github.io/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1726.同积元组</title>
    <link href="https://leiqichn.github.io/2023-10-20-9599b5db4d91.html"/>
    <id>https://leiqichn.github.io/2023-10-20-9599b5db4d91.html</id>
    <published>2023-10-20T15:21:57.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>使用排列组合的方法，开始使用三种语言同时写leetcode.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p><img src="/../../imgs/Pasted%20image%2020231020003943.png"></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<span class="hljs-comment">// j +1 不要重复</span><br>            cnt[nums[i] * nums[j]]++ <span class="hljs-comment">// 使用map 遍历每次乘积对应次数</span><br>        &#125;<br>    &#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cnt &#123;<br>        ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>    &#125;<br>   <br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                cnt[nums[i] * nums[j]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : cnt) &#123;<br>            ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python3">class Solution:<br>    def tupleSameProduct(self, nums: List[int]) -&gt; int:<br>        n = len(nums)<br>        maps = dict()<br>        <br>        for i in range(n):<br>            for j in range(i+1,n):<br>                if nums[i]*nums[j] in maps:<br>                    maps[nums[i] * nums[j]] += 1<br>                else:<br>                    maps[nums[i] * nums[j]] = 1<br><br>        ans = 0<br>        for _, v in maps.items():<br>            ans += v*(v-1) *4<br>        return ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/tuple-with-same-product/description/&quot;&gt;1726. 同积元组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="C++" scheme="https://leiqichn.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>本地运行LeetCode的Python代码 调试</title>
    <link href="https://leiqichn.github.io/2023-10-19-6057db0e071e.html"/>
    <id>https://leiqichn.github.io/2023-10-19-6057db0e071e.html</id>
    <published>2023-10-19T16:57:22.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦</p><p>要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类：</p><p>创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。</p><p>导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br></code></pre></td></tr></table></figure><p>创建Solution类并在其中定义问题的解决方案。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 实现你的解决方案</span><br>        <span class="hljs-comment"># 例如，找到两个数的和等于目标，并返回它们的索引</span><br>        num_to_index = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> num_to_index:<br>                <span class="hljs-keyword">return</span> [num_to_index[complement], i]<br>            num_to_index[num] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>创建一个main函数来测试你的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    solution = Solution()<br>    <span class="hljs-comment"># 调用Solution类的方法进行测试</span><br>    result = solution.twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python leetcode_solution.py<br></code></pre></td></tr></table></figure><p>这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦&lt;/p&gt;
&lt;p&gt;要在本地运行LeetCode的Python代</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>三种Python3 判断字典中是否存在对应key的方法</title>
    <link href="https://leiqichn.github.io/2023-10-19-8f51ae9ef5a1.html"/>
    <id>https://leiqichn.github.io/2023-10-19-8f51ae9ef5a1.html</id>
    <published>2023-10-19T16:41:07.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一种：使用get-方法"><a href="#第一种：使用get-方法" class="headerlink" title="第一种：使用get()方法"></a>第一种：使用get()方法</h1><p> <strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p> <strong>打印返回值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>))  # 结果返回对应val<br><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;id&#x27;</span>))  # 结果返回None<br></code></pre></td></tr></table></figure><p>第二种：使用keys()方法</p><p> <strong>生成一个字典</strong><br>dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’}<br> <strong>判断是否存在，其中dict.keys()是列出字典所有的key</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><p>除了使用in也可以使用not in，用于判定这个key不存在</p><p>第三种：使用 in 关键字</p><p><strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong># 判断key是否存在于dict中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><h1 id="补充：生成默认字典（collections-defaultdict）"><a href="#补充：生成默认字典（collections-defaultdict）" class="headerlink" title="补充：生成默认字典（collections.defaultdict）"></a>补充：生成默认字典（<code>collections.defaultdict</code>）</h1><p>使用<code>defaultdict(int)</code>来创建<code>maps</code>，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        maps = defaultdict(<span class="hljs-built_in">int</span>)<br>        <br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>                product = nums[i] * nums[j]<br>                ans += maps[product] * <span class="hljs-number">4</span><br>                maps[product] += <span class="hljs-number">1</span><br>                <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一种：使用get-方法&quot;&gt;&lt;a href=&quot;#第一种：使用get-方法&quot; class=&quot;headerlink&quot; title=&quot;第一种：使用get()方法&quot;&gt;&lt;/a&gt;第一种：使用get()方法&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;生成一个字典&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://leiqichn.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构和操作的对比：Python vs. Go vs. C++</title>
    <link href="https://leiqichn.github.io/2023-10-19-86483682723b.html"/>
    <id>https://leiqichn.github.io/2023-10-19-86483682723b.html</id>
    <published>2023-10-19T16:25:56.000Z</published>
    <updated>2024-01-23T17:37:54.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python示例"><a href="#Python示例" class="headerlink" title="Python示例"></a>Python示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 切片</span><br>sub_list = my_list[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversed_list = my_list[::-1python]<br><br><span class="hljs-comment"># 字典</span><br>my_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;<br><br><span class="hljs-comment"># 双向链表（使用collections.deque）</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>my_linked_list = deque()<br>my_linked_list.append(<span class="hljs-number">1</span>)<br>my_linked_list.append(<span class="hljs-number">2</span>)<br>my_linked_list.append(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 最大堆和最小堆（需要使用第三方库heapq）</span><br><span class="hljs-keyword">import</span> heapq<br>max_heap = []<br>min_heap = []<br><br><span class="hljs-comment"># 二叉树（使用类或结构体）</span><br><br><span class="hljs-comment"># 字符串操作</span><br>my_string = <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring = my_string[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>my_int = <span class="hljs-number">42</span><br>my_str = <span class="hljs-built_in">str</span>(my_int)<br><br><span class="hljs-comment"># 深度拷贝和浅拷贝（使用copy模块）</span><br><span class="hljs-keyword">import</span> copy<br>original_list = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>]<br>shallow_copy = copy.copy(original_list)<br>deep_copy = copy.deepcopy(original_list)<br><br><span class="hljs-comment"># 删除元素</span><br>my_list.pop(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 删除第二个元素</span><br><br><span class="hljs-comment"># 查找小写字母</span><br><span class="hljs-keyword">if</span> my_string.islower():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;String contains only lowercase letters&quot;</span>)<br><br><span class="hljs-comment"># 遍历数组</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)<br><br><span class="hljs-comment"># 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br><br><span class="hljs-comment"># 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dictionary contains &#x27;name&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go示例</span><br><br><span class="hljs-comment">// 数组和切片</span><br>mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>subSlice := mySlice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversedSlice := reverseSlice(mySlice)<br><br><span class="hljs-comment">// 字典</span><br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>&#125;<br><br><span class="hljs-comment">// 双向链表（使用container/list）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br>myList := list.New()<br>myList.PushBack(<span class="hljs-number">1</span>)<br>myList.PushBack(<span class="hljs-number">2</span>)<br>myList.PushBack(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 最大堆和最小堆（需要使用heap包）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/heap&quot;</span><br>maxHeap := &amp;MaxHeap&#123;&#125;<br>minHeap := &amp;MinHeap&#123;&#125;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>myString := <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring := myString[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>myInt := <span class="hljs-number">42</span><br>myStr := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, myInt)<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝（使用复制切片或递归）</span><br>originalSlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>shallowCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(originalSlice))<br><span class="hljs-built_in">copy</span>(shallowCopy, originalSlice)<br>deepCopy := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), originalSlice...)<br><br><span class="hljs-comment">// 删除元素</span><br>index := <span class="hljs-number">1</span><br>mySlice = <span class="hljs-built_in">append</span>(mySlice[:index], mySlice[index+<span class="hljs-number">1</span>:]...)<br><br><span class="hljs-comment">// 查找小写字母</span><br>containsLowercase := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-keyword">if</span> unicode.IsLower(char) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历切片</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> mySlice &#123;<br>    fmt.Println(item)<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    fmt.Println(key, value)<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> _, exists := myMap[<span class="hljs-string">&quot;name&quot;</span>]; exists &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++示例</span><br><br><span class="hljs-comment">// 数组和向量</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subVector</span><span class="hljs-params">(myVector.begin() + <span class="hljs-number">1</span>, myVector.begin() + <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversedVector</span><span class="hljs-params">(myVector.rbegin(), myVector.rend())</span></span>;<br><br><span class="hljs-comment">// 字典（使用std::map）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br>myMap[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;Alice&quot;</span>;<br>myMap[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 双向链表（使用std::list）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br>std::list&lt;<span class="hljs-type">int</span>&gt; myList;<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 最大堆和最小堆（使用std::priority_queue）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>std::string myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string substring = myString.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> myInt = <span class="hljs-number">42</span>;<br>std::string myStr = std::<span class="hljs-built_in">to_string</span>(myInt);<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; originalVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; shallowCopy = originalVector;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deepCopy</span><span class="hljs-params">(originalVector)</span></span>;<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + index);<br><br><span class="hljs-comment">// 查找小写字母</span><br><span class="hljs-type">bool</span> containsLowercase = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : myString) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">islower</span>(c)) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历向量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : myVector) &#123;<br>    std::cout &lt;&lt; item &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;name&quot;</span>) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python示例&quot;&gt;&lt;a href=&quot;#Python示例&quot; class=&quot;headerlink&quot; title=&quot;Python示例&quot;&gt;&lt;/a&gt;Python示例&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 136.只出现一次的数字</title>
    <link href="https://leiqichn.github.io/2023-10-16-66afbe22520d.html"/>
    <id>https://leiqichn.github.io/2023-10-16-66afbe22520d.html</id>
    <published>2023-10-16T15:23:24.000Z</published>
    <updated>2024-01-23T17:37:54.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/single-number/description/">136. 只出现一次的数字</a><br><img src="/../../imgs/Pasted%20image%2020231016232403.png"><br>[TOC]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p></blockquote><p>答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。</p><p>任何数和 0做异或运算，结果仍然是原来的数<br>任何数和其自身做异或运算，结果是 0<br><img src="https://pic.leetcode.cn/1697469725-QtsjoA-image.png" alt="image.png"></p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ol><li><p>hash</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>numsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>numsMap[val] += <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> numsMap &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> key<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>位运算</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    single := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        single ^= num<br>    &#125;<br>    <span class="hljs-keyword">return</span> single<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/single-number/description/&quot;&gt;136. 只出现一次的数字&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/../../imgs/Pasted</summary>
      
    
    
    
    <category term="leetcode" scheme="https://leiqichn.github.io/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
