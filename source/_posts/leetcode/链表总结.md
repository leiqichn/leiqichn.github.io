# é“¾è¡¨çš„åˆå¹¶
* è™šæ‹Ÿå¤´èŠ‚ç‚¹
* æ‹‰æ‹‰é“¾ 


```go
// æ³¨æ„ï¼šgo ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç è¿˜æœªç»è¿‡åŠ›æ‰£æµ‹è¯•ï¼Œä»…ä¾›å‚è€ƒï¼Œå¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, nil}
    p := dummy
    p1 := l1
    p2 := l2
    
    for p1 != nil && p2 != nil {
        // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
        if p1.Val > p2.Val {
            p.Next = p2
            p2 = p2.Next
        } else {
            p.Next = p1
            p1 = p1.Next
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }
    
    if p1 != nil {
        p.Next = p1
    }
    
    if p2 != nil {
        p.Next = p2
    }
    
    return dummy.Next
}

```

# é“¾è¡¨çš„æ‹†åˆ†
* åˆå§‹åŒ–ä¸¤ä¸ªé“¾è¡¨ï¼Œåˆ†åˆ«æ·»åŠ 
* åˆå¹¶å‰ è®°å¾— å°†p.next ç½®ä¸ºç©ºï¼Œé˜²æ­¢åè¾¹p1.next è¿˜æŒ‚ç€p.next
* åˆå¹¶

```go

func partition(head *ListNode, x int) *ListNode {
    // å­˜æ”¾å°äº x çš„é“¾è¡¨çš„è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy1 := &ListNode{-1, nil}
    // å­˜æ”¾å¤§äºç­‰äº x çš„é“¾è¡¨çš„è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy2 := &ListNode{-1, nil}
    // p1, p2 æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
    p1, p2 := dummy1, dummy2
    // p è´Ÿè´£éå†åŸé“¾è¡¨ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    // è¿™é‡Œæ˜¯å°†ä¸€ä¸ªé“¾è¡¨åˆ†è§£æˆä¸¤ä¸ªé“¾è¡¨
    p := head
    for p != nil {
        if p.Val >= x {
            p2.Next = p
            p2 = p2.Next
        } else {
            p1.Next = p
            p1 = p1.Next
        }
        // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
        temp := p.Next
        p.Next = nil
        p = temp
    }
    // è¿æ¥ä¸¤ä¸ªé“¾è¡¨
    p1.Next = dummy2.Next

    return dummy1.Next
}


```

# k é“¾è¡¨åˆå¹¶
* æœ€å°å † goè¯­è¨€çš„å®ç°

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, nil}
    p := dummy
    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
    for _, head := range lists {
        if head != nil {
            heap.Push(&pq, head)
        }
    }

    for pq.Len() > 0 {
        // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
        node := heap.Pop(&pq).(*ListNode)
        p.Next = node
        if node.Next != nil {
            heap.Push(&pq, node.Next)
        }
        // p æŒ‡é’ˆä¸æ–­å‰è¿›
        p = p.Next
    }
    return dummy.Next
}

type PriorityQueue []*ListNode

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].Val < pq[j].Val
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    node := x.(*ListNode)
    *pq = append(*pq, node)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    node := old[n-1]
    *pq = old[0 : n-1]
    return node
}

```

# å€’æ•°Ké“¾è¡¨
* n æ˜¯åŒ…å«nil çš„
* ä¸€ä¸ªfast å»æ¢è·¯ï¼Œå…ˆèµ°kæ­¥
* slow å’Œfast ä¸€èµ·èµ°
* å½“fastä¸ºnil æ—¶ï¼Œåˆ°è¾¾k ,èµ‹å€¼ä¸ºnext.next å³å¯
![](../../imgs/Pasted%20image%2020230625002218.png)

```go
// ä¸»å‡½æ•°
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, head}
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    x := findFromEnd(dummy, n + 1)
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.Next = x.Next.Next
    return dummy.Next
}
    
// è¿”å›é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
func findFromEnd(head *ListNode, k int) *ListNode {
    p1 := head
    // p1 å…ˆèµ° k æ­¥
    for i := 0; i < k; i++ {
        p1 = p1.Next
    }
    p2 := head
    // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
    for p1 != nil {
        p1 = p1.Next
        p2 = p2.Next
    }
    // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ï¼Œå³å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
    return p2
}


```

#  å€’æ•°Ké“¾è¡¨ç§»é™¤
å¤ç”¨ä¸Šè¾¹çš„ä»£ç ï¼Œæ‰¾åˆ°å€’æ•°x=k+1, ç„¶åèµ‹å€¼x.next = x.next.next å³å¯

```go
// ä¸»å‡½æ•°
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // è™šæ‹Ÿå¤´ç»“ç‚¹
    dummy := &ListNode{-1, head}
    // åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
    x := findFromEnd(dummy, n + 1)
    // åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
    x.next = x.next.next
    return dummy.next
}
    
func findFromEnd(head *ListNode, k int) *ListNode {
    // ä»£ç è§ä¸Šæ–‡
}
```

# ç§»é™¤ä¸­é—´é“¾è¡¨
[876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/middle-of-the-linked-list/)
* slow èµ°ä¸€æ­¥ï¼Œfastèµ°ä¸¤æ­¥
* fast nilï¼Œslow ä¸ºä¸­é—´
**æ¯å½“æ…¢æŒ‡é’ˆÂ `slow`Â å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆÂ `fast`Â å°±å‰è¿›ä¸¤æ­¥ï¼Œè¿™æ ·ï¼Œå½“Â `fast`Â èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œ`slow`Â å°±æŒ‡å‘äº†é“¾è¡¨ä¸­ç‚¹**ã€‚

```go
func middleNode(head *ListNode) *ListNode {
    // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
    slow, fast := head, head
    // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
    // for fast.Next != nil && fast.Next.Next != nil {// è¿™æ ·å¥‡æ•°çš„æ—¶å€™ä¼šåœ¨ä¸­ç‚¹çš„å‰ä¸€æ­¥
    for fast!= nil && fast.Next != nil{ // åº”è¯¥ä¿®æ”¹ä¸ºè¿™ä¸ªï¼Œslow ä¼šåœåœ¨ä¸­ç‚¹å³è¾¹ç¬¬äºŒä¸ªéƒ¨åˆ†
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.Next
        fast = fast.Next.Next
    }
    // æ…¢æŒ‡é’ˆæŒ‡å‘ä¸­ç‚¹
    return slow
}

```

# åˆ¤æ–­é“¾è¡¨æ˜¯å¦æˆç¯
* slow èµ°ä¸€æ­¥ï¼Œfastèµ°ä¸¤æ­¥
* fast å’Œslow ç›¸é‡åˆ™æˆç¯ï¼Œfast é‡åˆ°nil åˆ™ä¸æˆç¯ã€‚


```go
func hasCycle(head *ListNode) bool {
    // å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head
    slow, fast := head, head
    // å¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾æ—¶åœæ­¢
    for fast != nil && fast.Next != nil {
        // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
        slow = slow.Next
        fast = fast.Next.Next
        // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
        if slow == fast {
            return true
        }
    }
    // ä¸åŒ…å«ç¯
    return false
}

```


> labuladong