
---
title: 回溯总结
date: 2025-06-03 23:53:20
modificationDate: 2025 六月 3日 星期二 23:53:20
categories: 
	- leetcode
tags: []
sticky: []
published: true
category_bar: true
---

## 子集型回溯
[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

![](../../imgs/Pasted%20image%2020250605230846.png)
![](../../imgs/Pasted%20image%2020250605230928.png)
方法一：输入的视角（选或不选）
对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2 
n
  个不同的子集。

dfs 中的 i 表示当前考虑到 nums[i] 选或不选。

```go
func subsets(nums []int) [][]int {
    n := len(nums)
    ans := make([][]int, 0, 1<<n) // 预分配空间
    path := make([]int, 0, n) // 预分配空间
    var dfs func(int)
    dfs = func(i int) {
        if i == n { // 子集构造完毕
            ans = append(ans, slices.Clone(path)) // 复制 path
            return
        }
        
        // 不选 nums[i]
        dfs(i + 1)
        
        // 选 nums[i]
        path = append(path, nums[i])
        dfs(i + 1)
        path = path[:len(path)-1] // 恢复现场
    }
    dfs(0)
    return ans
}

```

方法二：答案的视角（枚举选哪个）
枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。

dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。

如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。

注意：不需要在回溯中判断 i=n 的边界情况，因为此时不会进入循环，if i == n: return 这句话写不写都一样.


```go
func subsets(nums []int) [][]int {
    n := len(nums)
    ans := make([][]int, 0, 1<<n) // 预分配空间
    path := make([]int, 0, n) // 预分配空间
    var dfs func(int)
    dfs = func(i int) {
		if i == n {
			return
		}
        for j := i; j < n; j++ { // 从当前索引向后枚举
            path = append(path, nums[j])  // 选择数字
            dfs(j + 1)                   // 递归下一层
            path = path[:len(path)-1]     // 回溯
        }
        // 关键位置：在递归开始时记录当前路径
        ans = append(ans, slices.Clone(path))
    }
    dfs(0)
    return ans
}


func subsets(nums []int) [][]int {
    n := len(nums)
    ans := make([][]int, 0, 1<<n) // 预分配空间
    path := make([]int, 0, n) // 预分配空间
    var dfs func(int)
    dfs = func(i int) {
		if i == n {
			return
		}
        // 关键位置：在递归开始时记录当前路径
        ans = append(ans, slices.Clone(path))
        for j := i; j < n; j++ { // 从当前索引向后枚举
            path = append(path, nums[j])  // 选择数字
            dfs(j + 1)                   // 递归下一层
            path = path[:len(path)-1]     // 回溯
        }
    }
    dfs(0)
    return ans
}

```


131. 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/

从答案的角度：

```go
func isPalindrome(s string, left, right int) bool {
    for i, j := left, right;i < j; i, j = i+1, j-1 {
        if s[i] != s[j] {
            return false
        }
    }
    return true
}

func partition(s string) (ans [][]string) {
    n := len(s)
    path := []string{}

    // 考虑 s[i:] 怎么分割
    var dfs func(int)
    dfs = func(i int) {
        if i == n { // s 分割完毕
            ans = append(ans, slices.Clone(path))
            return
        }
        for j := i; j < n; j++ { // 枚举子串的结束位置
            if isPalindrome(s, i, j) {
                path = append(path, s[i:j+1]) // 分割！
                // 考虑剩余的 s[j+1:] 怎么分割
                dfs(j + 1)
                path = path[:len(path)-1] // 恢复现场
            }
        }
    }

    dfs(0)
    return
}
```



132. 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/

```go
var (
    m []string
    path []byte
    res []string
)

func letterCombinations(digits string) []string {
	// 将index 和 字符串对应起来
	m = []string{"","","abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
	path, res = make([]byte,0),make([]string,0)
    if digits == "" {
        return res
    }
	backTracking(digits,0)
	return res
}
func backTracking(digits string, start int) {
	// 终止条件 ，遍历完digits
	if start == len(digits) {
        tmp := string(path)
		res = append(res,tmp)
		return
	}
	// 找到 digit
	digitNum := int(digits[start] - '0')
	// 遍历 digit 对应的map 字符串
	str := m[digitNum]
	for i:=0;i< len(str);i++ { // i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始
		path = append(path,str[i])
		backTracking(digits,start+1)
		path =path[:len(path)-1]
	}
}
```

## 组合型回溯


## 排列型回溯