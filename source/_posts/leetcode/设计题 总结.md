---
title: 设计题 总结
date: 2023-10-10 01:21:04
modificationDate: 2023 八月 7日 星期一 22:21:04
categories: 
	- leetcode
tags: []
sticky: []
hide: false
category_bar: true
---

# 简单题

1. [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

![](../../imgs/Pasted%20image%2020240405184827.png)

 **思路：**input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；
```go
type MyQueue struct {
	inputStack  []int
	outputStack []int
}

func Constructor() MyQueue {
	return MyQueue{
		inputStack:  make([]int, 0),
		outputStack: make([]int, 0),
	}
}

func (this *MyQueue) Push(x int) {
	this.inputStack = append(this.inputStack, x)
}

func (this *MyQueue) Pop() int {
	if len(this.outputStack) != 0 {

		topTmp := this.outputStack[len(this.outputStack)-1] //
		this.outputStack = this.outputStack[:len(this.outputStack)-1]
		return topTmp
	} else {
		for len(this.inputStack) != 0 {
			this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1])
			this.inputStack = this.inputStack[:len(this.inputStack)-1]
		}
	}

	top := this.outputStack[len(this.outputStack)-1] //
	this.outputStack = this.outputStack[:len(this.outputStack)-1]
	return top
}

func (this *MyQueue) Peek() int {
	if len(this.outputStack) != 0 {

		topTmp := this.outputStack[len(this.outputStack)-1] //
		return topTmp
	} else {
		for len(this.inputStack) != 0 {
			this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1])
			this.inputStack = this.inputStack[:len(this.inputStack)-1]
		}
	}

	top := this.outputStack[len(this.outputStack)-1] //
	return top
}

func (this *MyQueue) Empty() bool {
	if len(this.inputStack) == 0 && len(this.outputStack) == 0 {
		return true
	}
	return false
}


/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */

```

2. [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/)![](../../imgs/Pasted%20image%2020240405184932.png)

**思路：**用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；

```go
type MyStack struct {
	inputQueue  []int
	outputQueue []int
}

func Constructor() MyStack {
	return MyStack{
		inputQueue:  make([]int, 0),
		outputQueue: make([]int, 0),
	}

}

func (this *MyStack) Push(x int) {
	this.inputQueue = append(this.inputQueue, x)

}

func (this *MyStack) Pop() int {
	for len(this.inputQueue) != 1 {
		this.outputQueue = append(this.outputQueue, this.inputQueue[0])
		this.inputQueue = this.inputQueue[1:]
	}
	top := this.inputQueue[0]
	this.inputQueue = this.outputQueue
    this.outputQueue = []int{}
	return top

}

func (this *MyStack) Top() int {
	for len(this.inputQueue) != 1 {
		this.outputQueue = append(this.outputQueue, this.inputQueue[0])
		this.inputQueue = this.inputQueue[1:]
	}
	top := this.inputQueue[0]
	this.inputQueue = append(this.outputQueue, this.inputQueue...)
    this.outputQueue = []int{}
	return top
}

func (this *MyStack) Empty() bool {
	if (len(this.inputQueue) == 0) && (len(this.outputQueue) == 0) {
		return true
	}
	return false
}

```


设计题 - 实现浏览器历史记录
1.初始化 homepage 和历史记录容量
2.浏览网页 
   - 和当前页相同，则直接返回
   - 和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。
3.实现前进和后退功能
```go
/*
 * Copyright (c) 2023 Lei Qi. All rights reserved.
 * Author: Lei Qi
 * Description: 浏览器实现
 * Date: 2023/10/10 上午12:33
 */

package main

import (
	"container/list"
	"fmt"
)

type Browser struct {
	history  *list.List
	current  *list.Element
	maxLen   int
	homepage string
}

func NewBrowser(maxLen int, homepage string) *Browser {
	history := list.New()
	current := history.PushBack(homepage)
	return &Browser{
		history:  history,
		current:  current,
		maxLen:   maxLen,
		homepage: homepage,
	}
}

func (b *Browser) GetCurrentPage() string {
	return b.current.Value.(string)
}

func (b *Browser) GoBack() string {
	if b.current.Prev() != nil {
		b.current = b.current.Prev()
	}
	return b.GetCurrentPage()
}

func (b *Browser) GoForward() string {
	if b.current.Next() != nil {
		b.current = b.current.Next()
	}
	return b.GetCurrentPage()
}

func (b *Browser) NavigateToNewPage(newPageURL string) string {
	if b.GetCurrentPage() == newPageURL {
		return newPageURL
	}
	
	// 清除当前页面之后的历史记录
	for e := b.current.Next(); e != nil; e = e.Next() {
		b.history.Remove(e)
	}
	// 将新页面添加到历史记录中
	b.current = b.history.InsertAfter(newPageURL, b.current)
	// 限制浏览器历史记录的最大长度
	for b.history.Len() > b.maxLen {
		front := b.history.Front()
		if front != nil {
			b.history.Remove(front)
		}
	}
	return b.GetCurrentPage()
}

func main() {
	browser := NewBrowser(5, "初始页面")

	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 浏览新页面
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面1"))
	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 浏览更多新页面
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面2"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面3"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面4"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面5"))
	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 后退和前进
	fmt.Println("后退:", browser.GoBack())
	fmt.Println("后退:", browser.GoBack())
	fmt.Println("前进:", browser.GoForward())
}
```

当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。

# 第一步：理解需求
在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：

记录当前页面。
支持前进和后退操作。
能够跳转到新页面。
考虑历史记录的容量限制。
# 第二步：建模
接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：

当前页面：表示用户当前正在浏览的页面。
历史记录：表示用户访问过的页面的顺序列表。
最大容量：限制历史记录的长度，以防止无限增长。
一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。

# 第三步：选择数据结构和函数
接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container/list包中的双向链表作为数据结构，并定义以下函数：

NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。
GetCurrentPage() string：获取当前页面的URL。
GoBack() string：执行后退操作，并返回当前页面的URL。
GoForward() string：执行前进操作，并返回当前页面的URL。
NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。

# 第四步：编写示例代码
现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。

# 第五步：测试和优化
一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。

根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。

# 总结
在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。





