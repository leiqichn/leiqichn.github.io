---
title: 设计题 总结
date: 2024-04-06 01:21:04
modificationDate: 2024 4月 6日 星期六 20:51:04
categories: 
	- leetcode
tags: []
sticky: []
hide: false
category_bar: true
---

**设计题 - 实现浏览器历史记录**
1.初始化 homepage 和历史记录容量
2.浏览网页 
   - 和当前页相同，则直接返回
   - 和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。
3.实现前进和后退功能
```go
/*
 * Copyright (c) 2023 Lei Qi. All rights reserved.
 * Author: Lei Qi
 * Description: 浏览器实现
 * Date: 2023/10/10 上午12:33
 */

package main

import (
	"container/list"
	"fmt"
)

type Browser struct {
	history  *list.List
	current  *list.Element
	maxLen   int
	homepage string
}

func NewBrowser(maxLen int, homepage string) *Browser {
	history := list.New()
	current := history.PushBack(homepage)
	return &Browser{
		history:  history,
		current:  current,
		maxLen:   maxLen,
		homepage: homepage,
	}
}

func (b *Browser) GetCurrentPage() string {
	return b.current.Value.(string)
}

func (b *Browser) GoBack() string {
	if b.current.Prev() != nil {
		b.current = b.current.Prev()
	}
	return b.GetCurrentPage()
}

func (b *Browser) GoForward() string {
	if b.current.Next() != nil {
		b.current = b.current.Next()
	}
	return b.GetCurrentPage()
}

func (b *Browser) NavigateToNewPage(newPageURL string) string {
	if b.GetCurrentPage() == newPageURL {
		return newPageURL
	}
	
	// 清除当前页面之后的历史记录
	for e := b.current.Next(); e != nil; e = e.Next() {
		b.history.Remove(e)
	}
	// 将新页面添加到历史记录中
	b.current = b.history.InsertAfter(newPageURL, b.current)
	// 限制浏览器历史记录的最大长度
	for b.history.Len() > b.maxLen {
		front := b.history.Front()
		if front != nil {
			b.history.Remove(front)
		}
	}
	return b.GetCurrentPage()
}

func main() {
	browser := NewBrowser(5, "初始页面")

	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 浏览新页面
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面1"))
	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 浏览更多新页面
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面2"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面3"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面4"))
	fmt.Println("浏览新页面:", browser.NavigateToNewPage("新页面5"))
	fmt.Println("当前页面:", browser.GetCurrentPage())

	// 后退和前进
	fmt.Println("后退:", browser.GoBack())
	fmt.Println("后退:", browser.GoBack())
	fmt.Println("前进:", browser.GoForward())
}
```

当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。

# 第一步：理解需求
在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：

记录当前页面。
支持前进和后退操作。
能够跳转到新页面。
考虑历史记录的容量限制。
# 第二步：建模
接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：

当前页面：表示用户当前正在浏览的页面。
历史记录：表示用户访问过的页面的顺序列表。
最大容量：限制历史记录的长度，以防止无限增长。
一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。

# 第三步：选择数据结构和函数
接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container/list包中的双向链表作为数据结构，并定义以下函数：

NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。
GetCurrentPage() string：获取当前页面的URL。
GoBack() string：执行后退操作，并返回当前页面的URL。
GoForward() string：执行前进操作，并返回当前页面的URL。
NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。

# 第四步：编写示例代码
现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。

# 第五步：测试和优化
一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。

根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。

# 总结
在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。

# 练习
下面，我们来按照难度多练习几道题目

# 简单题

1. [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

![](../../imgs/Pasted%20image%2020240405184827.png)

 **思路：**input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；
```go
type MyQueue struct {
	inputStack  []int
	outputStack []int
}

func Constructor() MyQueue {
	return MyQueue{
		inputStack:  make([]int, 0),
		outputStack: make([]int, 0),
	}
}

func (this *MyQueue) Push(x int) {
	this.inputStack = append(this.inputStack, x)
}

func (this *MyQueue) Pop() int {
	if len(this.outputStack) != 0 {

		topTmp := this.outputStack[len(this.outputStack)-1] //
		this.outputStack = this.outputStack[:len(this.outputStack)-1]
		return topTmp
	} else {
		for len(this.inputStack) != 0 {
			this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1])
			this.inputStack = this.inputStack[:len(this.inputStack)-1]
		}
	}

	top := this.outputStack[len(this.outputStack)-1] //
	this.outputStack = this.outputStack[:len(this.outputStack)-1]
	return top
}

func (this *MyQueue) Peek() int {
	if len(this.outputStack) != 0 {

		topTmp := this.outputStack[len(this.outputStack)-1] //
		return topTmp
	} else {
		for len(this.inputStack) != 0 {
			this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1])
			this.inputStack = this.inputStack[:len(this.inputStack)-1]
		}
	}

	top := this.outputStack[len(this.outputStack)-1] //
	return top
}

func (this *MyQueue) Empty() bool {
	if len(this.inputStack) == 0 && len(this.outputStack) == 0 {
		return true
	}
	return false
}


/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */

```

2. [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/description/)![](../../imgs/Pasted%20image%2020240405184932.png)

**思路：**用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；

```go
type MyStack struct {
	inputQueue  []int
	outputQueue []int
}

func Constructor() MyStack {
	return MyStack{
		inputQueue:  make([]int, 0),
		outputQueue: make([]int, 0),
	}

}

func (this *MyStack) Push(x int) {
	this.inputQueue = append(this.inputQueue, x)

}

func (this *MyStack) Pop() int {
	for len(this.inputQueue) != 1 {
		this.outputQueue = append(this.outputQueue, this.inputQueue[0])
		this.inputQueue = this.inputQueue[1:]
	}
	top := this.inputQueue[0]
	this.inputQueue = this.outputQueue
    this.outputQueue = []int{}
	return top

}

func (this *MyStack) Top() int {
	for len(this.inputQueue) != 1 {
		this.outputQueue = append(this.outputQueue, this.inputQueue[0])
		this.inputQueue = this.inputQueue[1:]
	}
	top := this.inputQueue[0]
	this.inputQueue = append(this.outputQueue, this.inputQueue...)
    this.outputQueue = []int{}
	return top
}

func (this *MyStack) Empty() bool {
	if (len(this.inputQueue) == 0) && (len(this.outputQueue) == 0) {
		return true
	}
	return false
}

```




# [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

![](../../imgs/Pasted%20image%2020240406201421.png)
思路：简单题，


```go
type NumArray struct {
    nums  []int
}


func Constructor(nums []int) NumArray {
    return NumArray{nums: nums}
}


func (this *NumArray) SumRange(left int, right int) int {
    sum := 0 
    for i:= left; i<= right; i++ {
        sum += this.nums[i]
    }
    return sum
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */

```

使用前缀和
![](../../imgs/Pasted%20image%2020240406201959.png)
怎么求 preSum 数组
利用前面提到的递推式:
![](../../imgs/Pasted%20image%2020240406201929.png)

遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，**即preSum[0]为nums[0]（前提是nums有元素）**。

预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。

需要针对len(nums) == 0的情况进行特判，i = 0 的情况，也需单独讨论。

后面会给出简化的写法。
```go
type NumArray struct {
    preSum []int
}


func Constructor(nums []int) NumArray {
    preSum := make([]int, len(nums))
    preSum[0] = nums[0]
    for i:=1; i<len(nums);i++ {
        preSum[ i] = preSum[ i-1] + nums[i]
    }
    
    return NumArray{preSum}
}


func (this *NumArray) SumRange(left int, right int) int {
    	if left == 0 { // 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]
		if len(this.preSum) == 0 { // 但如果nums根本没有长度，直接返回0
			return 0
		}
		return this.preSum[right]
	}
    return this.preSum[right] - this.preSum[left-1]
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */

```

使用多一位长度的前缀和
之所以上面处理东西多，是因为`preSum[i]`的定义导致的。例如如果上边left == 0 ; 则不再适用于通用公式；那是因为left -1 = -1了，而数组中没有-1 index

要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1] 
即：

![](../../imgs/Pasted%20image%2020240406202142.png)
```go
type NumArray struct {
    preSum []int
}


func Constructor(nums []int) NumArray {
    preSum := make([]int, len(nums) + 1)
    for index, value := range nums {
        preSum[index + 1] = preSum[index] + value
    }
    
    return NumArray{preSum}
}


func (this *NumArray) SumRange(left int, right int) int {
    return this.preSum[right + 1] - this.preSum[left]
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */

```

# [703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)
![](../../imgs/Pasted%20image%2020240406204841.png)
**暴力解法**
```go

type KthLargest struct {
	// 排序后的nums
	index      int
	sortedNums []int
}

func Constructor(k int, nums []int) KthLargest {
	return KthLargest{k, nums}
}

func (this *KthLargest) Add(val int) int {
	this.sortedNums = append(this.sortedNums, val)
	sort.Ints(this.sortedNums)
	revert(this.sortedNums)
	return this.sortedNums[this.index-1]
}

func revert(nums []int) {
	for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
		nums[i], nums[j] = nums[j], nums[i]
	}
}



/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */

```
**优先队列**
我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。

在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。


```go
type KthLargest struct {
    sort.IntSlice
    k int
}

func Constructor(k int, nums []int) KthLargest {
    kl := KthLargest{k: k}
    for _, val := range nums {
        kl.Add(val)
    }
    return kl
}

func (kl *KthLargest) Push(v interface{}) {
    kl.IntSlice = append(kl.IntSlice, v.(int))
}

func (kl *KthLargest) Pop() interface{} {
    a := kl.IntSlice
    v := a[len(a)-1]
    kl.IntSlice = a[:len(a)-1]
    return v
}

func (kl *KthLargest) Add(val int) int {
    heap.Push(kl, val)
    if kl.Len() > kl.k {
        heap.Pop(kl)
    }
    return kl.IntSlice[0]
}


```
