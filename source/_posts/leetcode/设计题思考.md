--
title: 设计题思考
date: 2024-05-09 01:20:58
modificationDate: 2024 五月 9日 星期四 01:20:58
categories: 
	- leetcode
tags: []
sticky: []
hide: false
category_bar: true
---

设计数据结构和算法时，通常需要遵循以下步骤来解决问题：

1. **理解问题**：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。

2. **确定需求**：明确需要哪些**数据结构**来存储信息，以及如何使用这些数据结构来满足题目的需求。

3. **设计数据结构**：
   - 确定实体类型：例如，用户（User）、推文（Tweet）等。
   - 确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。

4. **定义方法**：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。

5. **实现逻辑**：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。

6. **考虑边界条件和错误处理**：确保你的代码可以处理各种边界情况和潜在的错误。

7. **优化**：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。

对于LeetCode题目 **设计推特**，思考过程如下：

1. **理解题目**：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。

2. **确定需求**：
   - 需要存储用户信息，包括用户ID、关注列表和推文列表。
   - 需要存储推文信息，包括推文ID和时间戳。

3. **设计数据结构**：
   - `Twitter`：包含用户映射，用于快速访问用户信息。
   - `User`：包含用户ID、关注列表和推文列表。
   - `Tweet`：包含推文ID和时间戳。

4. **定义方法**：
   - `Constructor`：初始化`Twitter`实例。
   - `PostTweet`：实现用户发布推文的逻辑。
   - `Follow`：实现用户关注其他用户的逻辑。
   - `Unfollow`：实现用户取消关注的逻辑。
   - `GetNewsFeed`：实现获取用户信息流的逻辑。

5. **实现逻辑**：
   - 对于`PostTweet`，检查用户是否存在，如果不存在则创建用户，然后添加推文。
   - 对于`Follow`和`Unfollow`，更新用户的`followees`映射。
   - 对于`GetNewsFeed`，收集并排序推文，然后返回结果。

6. **考虑边界条件**：
   - 确保在添加推文或关注用户时，处理用户不存在的情况。
   - 在获取信息流时，处理用户没有推文或关注任何人的情况。

7. **优化**：
   - 考虑是否可以使用更高效的数据结构或算法来提高性能。

当在类似 LeetCode 的设计题考试中遇到思路瓶颈时，可以按以下结构化方法应对（以 Go 为例）：

### 1. **冷静分析问题**
- **拆解需求**：将题目分解为独立功能模块（如数据存储、查询、更新）
  *例：设计停车场系统 → 分解为：车位分配、释放、状态查询*
- **确认约束**：明确数据规模、时间复杂度要求（如 `O(1)` 操作）

### 2. **暴力解法先行**
- 先实现基础功能（即使性能差）
- *例：设计日志系统 → 直接用数组存储日志，查询时遍历*

### 3. **联想经典模型**
回忆常见设计模式与数据结构：

| 问题特征                                 | 可能方案              | LeetCode 例题  |
| ------------------------------------ | ----------------- | ------------ |
| <font color="#ff0000">键值快速访问</font>  | 哈希表(map)          | LRU缓存(146)   |
| <font color="#ff0000">时间/频率排序</font> | 堆(container/heap) | 股票价格波动(2034) |
| <font color="#ff0000">顺序关系维护</font>  | 链表(list)          | LFU缓存(460)   |
| <font color="#ff0000">区间查询</font>    | 树状数组/线段树          | 日历系统(729)    |
| <font color="#ff0000">前缀匹配</font>    | Trie树             | 添加搜索词(211)   |

### 4. **空间换时间**
- 使用冗余存储优化查询：
  ```go
  // 优化前：O(n)遍历查询
  type LogSystem { logs []Log }
  
  // 优化后：O(1)查询
  type LogSystem {
      logs []Log
      idMap map[int]Log // 额外存储ID->日志映射
  }
  ```

### 5. **分步验证法**
用 Go 逐步实现核心接口：
```go
type ParkingSystem struct {
    slots [3]int // 1. 定义基础数据结构
}

func Constructor(big, medium, small int) ParkingSystem {
    return ParkingSystem{[3]int{big, medium, small}} // 2. 初始化
}

func (p *ParkingSystem) AddCar(carType int) bool {
    if p.slots[carType-1] > 0 {
        p.slots[carType-1]-- // 3. 实现核心逻辑
        return true
    }
    return false
}
```

### 6. **边界处理技巧**
- 预分配内存避免扩容开销
- 使用接口隔离功能：
  ```go
  type Cache interface {
      Get(key int) int
      Put(key, value int)
  }
  
  // 实现时可先完成基础版本再优化
  ```

### 7. **时间管理策略**
- 20%时间：分析问题+画草图
- 60%时间：编写核心逻辑
- 20%时间：边界测试与优化
- *若卡壳超过10分钟：先写暴力解并添加TODO注释*

### 实战示例：设计HashSet(705)
```go
type MyHashSet struct {
    data []bool // 暴力解法
}

func Constructor() MyHashSet {
    return MyHashSet{make([]bool, 1000001)}
}

func (s *MyHashSet) Add(key int) {
    s.data[key] = true // O(1)但空间消耗大
}

// 优化方向：改用分桶+链表实现
type OptimizedSet struct {
    buckets [1000]*list.List
}
```

> **关键提示**：考试中优先保证**基础功能正确性**，再考虑优化。Go 特有的 `map`+`struct{}` 组合、`sync.Mutex` 并发控制等特性常在设计题中成为加分项。若完全无思路，尝试将问题类比现实场景（如设计电梯系统 ≈ 优先队列+状态机）往往能打开突破口。

在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。