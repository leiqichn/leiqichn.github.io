{"meta":{"title":"Lei Qi's Blog","subtitle":"","description":"Lei Qi Blog又名LeiQi论坛/中文网/社区/学习/是基于技术方面：Golang, 云原生，大数据，Linux学习，生活方面：摄影技术学习与分享 为一体的综合性网络博客网站。本博客是非营利性博客，目的在于让各位计算机爱好者通过本博客可以学到自己感兴趣的知识，也是记录自己学习成长的一个平台。","author":"Lei Qi","url":"https://leiqi.top","root":"/"},"pages":[{"title":"","date":"2025-04-11T05:09:02.146Z","updated":"2025-04-11T05:09:02.146Z","comments":false,"path":"manifest.json","permalink":"https://leiqi.top/manifest.json","excerpt":"","text":"{\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"name\":\"Lei Qi's blog\",\"short_name\":\"Lei Qi's blog\",\"icons\":[{\"src\":\"imgs/icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/apple-touch-icon.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"about","date":"2023-03-13T17:15:57.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"about/index.html","permalink":"https://leiqi.top/about/index.html","excerpt":"","text":"博客链接链接 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~ 爱生活，爱学习，爱分享希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！ 欢迎关注微信公众号~"},{"title":"","date":"2025-04-11T05:09:02.146Z","updated":"2025-04-11T05:09:02.146Z","comments":false,"path":"sw.js","permalink":"https://leiqi.top/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://leiqichn.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"guestbook","date":"2023-03-25T15:43:27.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"guestbook/index.html","permalink":"https://leiqi.top/guestbook/index.html","excerpt":"","text":"这里是留言板！欢迎留言哦~"},{"title":"categories","date":"2023-05-20T15:57:35.000Z","updated":"2025-04-11T05:09:01.869Z","comments":false,"path":"categories/index.html","permalink":"https://leiqi.top/categories/index.html","excerpt":"","text":""},{"title":"<% tp.file.title %>","date":"2025-04-11T05:09:02.146Z","updated":"2025-04-11T05:09:02.146Z","comments":false,"path":"obsidian_tamplate/TemPlater.html","permalink":"https://leiqi.top/obsidian_tamplate/TemPlater.html","excerpt":"","text":""},{"title":"","date":"2025-04-11T05:09:01.869Z","updated":"2025-04-11T05:09:01.869Z","comments":false,"path":"assets/img/微信图片_20230319125819.png.html","permalink":"https://leiqi.top/assets/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png.html","excerpt":"","text":""},{"title":"","date":"2025-04-11T05:09:01.869Z","updated":"2025-04-11T05:09:01.869Z","comments":false,"path":"assets/img/Snipaste_2023-03-19_12-43-32.png.html","permalink":"https://leiqi.top/assets/img/Snipaste_2023-03-19_12-43-32.png.html","excerpt":"","text":""}],"posts":[{"title":"数据结构设计专题","slug":"刷记录/数据结构设计专题","date":"2025-03-06T14:56:44.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2025-03-06-dab119f1439d.html","link":"","permalink":"https://leiqi.top/2025-03-06-dab119f1439d.html","excerpt":"","text":"数据结构设计 LeetCode 力扣 难度 是否完成 146. LRU Cache 146. LRU 缓存 🟠 202050306🟢 460. LFU Cache 460. LFU 缓存 🔴 🔴 729. My Calendar I 729. 我的日程安排表 I 🟠 🔴 950. Reveal Cards In Increasing Order 950. 按递增顺序显示卡牌 🟠 🔴 1700. Number of Students Unable to Eat Lunch 1700. 无法吃午餐的学生数量 🟢 202050307🟢 155. Min Stack 155. 最小栈 🟠 🔴 1670. Design Front Middle Back Queue 1670. 设计前中后队列 🟠 🔴 895. Maximum Frequency Stack 895. 最大频率栈 🔴 🔴 224. Basic Calculator 224. 基本计算器 🔴 🔴 227. Basic Calculator II 227. 基本计算器 II 🟠 🔴 146. LRU 缓存请设计 最近 最少使用 约束的数据结构 20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type LRUCache struct &#123; orderList []int cacheMaps map[int]int capacity int&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; orderList: make([]int, 0, capacity), // 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0 cacheMaps: make(map[int]int, capacity), capacity: capacity, &#125;&#125;func (this *LRUCache) Get(key int) int &#123; // key 存在与单独的环境中 if _, ok := this.cacheMaps[key]; ok &#123; this.Update(key) return this.cacheMaps[key] &#125; return -1&#125;func (this *LRUCache) Update(key int) &#123; // 更新key 到最新位置 for i := 0; i &lt; len(this.orderList); i++ &#123; if this.orderList[i] == key &#123; this.orderList = append(this.orderList[:i], append(this.orderList[i+1:], this.orderList[i])...) &#125; &#125;&#125;func (this *LRUCache) Put(key int, value int) &#123; if _, ok := this.cacheMaps[key]; ok &#123; // 更新key this.cacheMaps[key] = value this.Update(key) &#125; else if len(this.cacheMaps) &gt;= this.capacity &#123; fmt.Println(&quot;=&quot;,len(this.orderList), len(this.cacheMaps), this.capacity) // 删除key oldKey := this.orderList[0] this.orderList = this.orderList[1:] delete(this.cacheMaps, oldKey) // 新建key this.cacheMaps[key] = value this.orderList = append(this.orderList, key) &#125;else if len(this.cacheMaps) &lt; this.capacity &#123; fmt.Println(&quot;&lt;&quot;, len(this.orderList), len(this.cacheMaps), this.capacity) // 新建key this.cacheMaps[key] = value this.orderList = append(this.orderList, key) &#125;&#125; O(1) 方法双向列表，map 中直接保存列表元素指针，123456789101112131415161718192021222324252627282930313233343536373839404142434445type LRUCache struct &#123; cacheMaps map[int]*list.Element orderList *list.List capacity int&#125;type entry struct &#123; key int value int&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cacheMaps: make(map[int]*list.Element, capacity), orderList: list.New(), capacity: capacity, &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cacheMaps[key]; ok &#123; this.orderList.MoveToBack(elem) return elem.Value.(entry).value &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cacheMaps[key]; ok &#123; // 更新已存在的键 elem.Value = entry&#123;key: key, value: value&#125; this.orderList.MoveToBack(elem) &#125; else &#123; // 插入新键 if len(this.cacheMaps) == this.capacity &#123; // 删除最久未使用的键 frontElem := this.orderList.Front() delete(this.cacheMaps, frontElem.Value.(entry).key) this.orderList.Remove(frontElem) &#125; // 插入新键到链表末尾 newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;) this.cacheMaps[key] = newElem &#125;&#125; 1700. 无法吃午餐的学生数量 12345678910111213141516171819202122232425262728package leetcode1700 // 9分钟完成 func countStudents(students []int, sandwiches []int) int &#123; // 栈模拟 // 结束条件 // 同学中数字都相同，且不等于栈顶元素 [0] for !isEnd(students, sandwiches) &#123; if sandwiches[0] == students[0] &#123; sandwiches = sandwiches[1:] students = students[1:] &#125; else &#123; students = append(students[1:], students[0]) &#125; &#125; return len(students) &#125; func isEnd(students []int, sandwiches []int) bool &#123; for _, val := range students &#123; if val == sandwiches[0] &#123; return false &#125; &#125; return true &#125;","categories":[{"name":"速刷记录","slug":"速刷记录","permalink":"https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"系统序列图 - 时序图","slug":"客时间/架构/系统序列图 - 时序图","date":"2025-02-19T12:07:47.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2025-02-19-05250c3f88f5.html","link":"","permalink":"https://leiqi.top/2025-02-19-05250c3f88f5.html","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"如何画好一个架构图","slug":"客时间/架构/如何画好一个架构图","date":"2025-02-19T11:39:54.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2025-02-19-d829d1f5a9ea.html","link":"","permalink":"https://leiqi.top/2025-02-19-d829d1f5a9ea.html","excerpt":"","text":"业务架构 客户端架构、前端架构类似于逻辑视图 通过不同的颜色白标识不同颜色 系统架构技术架构或者是后端架构，后端的逻辑架构后端架构是核心架构两张图 左边说明功能，右边说明交互。和业务架构有区别。 应用架构描述后端系统有哪些应用组成 使用场景： 项目开发和测试 部署发布 子领域项目架构，下方就是个会员中心* 部署架构 - 物理视图描述后端系统具体是如何部署的，对应4+1 视图中的物理视图 使用场景 总体架构设计 运维规划和优化 画图技巧 使用图标代替区块*上边的球是网络加速点 前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili","categories":[{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"【sed】快速替换当前文件夹下文件中指定内容","slug":"inux/【sed】快速替换当前文件夹下文件中指定内容","date":"2025-01-13T15:40:59.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2025-01-13-1b5c01477594.html","link":"","permalink":"https://leiqi.top/2025-01-13-1b5c01477594.html","excerpt":"","text":"在 Linux 中，可以使用以下命令来实现这个需求： 1sed -i &#x27;s/hide: true/hide: false/g&#x27; * 解释一下这个命令： sed 是流编辑器，用于对文本进行过滤和转换。 -i 选项表示直接修改文件，而不是输出到终端。 &#39;s/hide: true/hide: false/g&#39; 是 sed 的替换命令，其中： s 表示替换操作。 hide: true 是要被替换的字符串。 hide: false 是替换后的字符串。 g 表示全局替换，即在每一行中将所有匹配的 hide: true 都替换为 hide: false。 * 表示当前文件夹下的所有文件。 需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 .txt 文件中的内容： 1sed -i &#x27;s/hide: true/hide: false/g&#x27; *.txt 另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 find 命令结合 sed 来实现，例如： 1find . -type f -exec sed -i &#x27;s/hide: true/hide: false/g&#x27; &#123;&#125; + 这个命令会递归查找当前文件夹及其子文件夹下的所有文件（-type f），然后对每个文件执行 sed 命令进行替换。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[]},{"title":"【最强春节抢票攻略】火车票抢票攻略","slug":"具/【最强春节抢票攻略】火车票抢票攻略","date":"2025-01-13T15:06:26.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2025-01-13-facf42a009b6.html","link":"","permalink":"https://leiqi.top/2025-01-13-facf42a009b6.html","excerpt":"","text":"1. 下载分流抢票（windows) ，并安装https://www.bypass.cn/ 2. 登录，查询目标车票放票时间需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。 3 先同步服务器时间其他设置小黑屋设置为100秒&#x2F;次。 4.设置微信通知扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。 5.设置自动支付绑定支付宝，抢到票自动支付。 6. 设置定时抢票提前两秒时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击开始抢票！等待抢票成功吧！ 抢到啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【Golang】for range 数组指针遍历","slug":"eetcode/【Golang】for range 数组指针遍历","date":"2024-12-03T16:55:24.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-12-03-90d19c862e9c.html","link":"","permalink":"https://leiqi.top/2024-12-03-90d19c862e9c.html","excerpt":"","text":"在Go语言中，使用for range遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如[]*Student）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。 这意味着，即使for range对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点： 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type Student struct &#123; Name string Age int&#125;func main() &#123; students := []*Student&#123; &#123;Name: &quot;Alice&quot;, Age: 20&#125;, &#123;Name: &quot;Bob&quot;, Age: 22&#125;, &#125; // 使用for range遍历指针数组 for _, student := range students &#123; // 修改指向的结构体的内容 student.Age += 1 // 给每个学生的年龄加1 &#125; // 打印修改后的students数组 for _, student := range students &#123; fmt.Printf(&quot;Name: %s, Age: %d\\n&quot;, student.Name, student.Age) &#125;&#125; 在这个例子中，尽管for range对每个*Student指针进行了拷贝，但通过这个拷贝的指针修改Age字段时，修改的是原始Student结构体的内容。因此，当再次遍历students数组时，你会看到每个学生的年龄都已经增加了。 总结来说，当你使用for range遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 浮点数次方","slug":"olang/Go 浮点数次方","date":"2024-12-03T15:46:08.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2024-12-03-3d026e7b5bec.html","link":"","permalink":"https://leiqi.top/2024-12-03-3d026e7b5bec.html","excerpt":"","text":"在Go语言中，计算一个数的几次方可以通过标准库中的math包来实现。math包提供了一个Pow函数，用于计算x的y次方。 使用math.Pow函数math.Pow函数的签名如下： 1func Pow(x, y float64) float64 这个函数接受两个float64类型的参数：x是底数，y是指数，返回x的y次方的结果。 示例代码下面是一个使用math.Pow函数的示例： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; // 计算2的3次方 result := math.Pow(2, 3) fmt.Printf(&quot;2的3次方是: %v\\n&quot;, result) // 计算3的2次方 result = math.Pow(3, 2) fmt.Printf(&quot;3的2次方是: %v\\n&quot;, result) // 计算10的-2次方 result = math.Pow(10, -2) fmt.Printf(&quot;10的-2次方是: %v\\n&quot;, result)&#125; 输出1232的3次方是: 83的2次方是: 910的-2次方是: 0.01 注意事项 math.Pow函数的参数和返回值都是float64类型，因此如果你需要计算整数的次方，可能需要先将整数转换为float64，然后再进行计算。 如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"【基础知识】Golang  sort.Slice 复杂排序","slug":"eetcode/【基础知识】Golang  sort.Slice 复杂排序","date":"2024-11-24T04:47:52.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-11-24-24291296f81a.html","link":"","permalink":"https://leiqi.top/2024-11-24-24291296f81a.html","excerpt":"","text":"在 Go 语言中，你可以使用 sort.Slice 对 slice 按照复杂条件进行排序。 sort.Slice 函数接受一个 slice 和一个比较函数，该比较函数定义了两个元素之间的排序关系。 以下是实现复杂条件排序的步骤和示例： 1. 基本语法1234sort.Slice(slice, func(i, j int) bool &#123; // 比较 slice[i] 和 slice[j] return 条件&#125;) 2. 示例：对结构体切片进行多条件排序假设有一个包含多个 Person 的切片，我们希望按以下规则排序： 年龄从小到大排序。 如果年龄相同，则按名字的字母顺序排序。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Person struct &#123; Name string Age int&#125;func main() &#123; people := []Person&#123; &#123;&quot;Alice&quot;, 30&#125;, &#123;&quot;Bob&quot;, 25&#125;, &#123;&quot;Charlie&quot;, 30&#125;, &#123;&quot;Dave&quot;, 25&#125;, &#125; // 使用 sort.Slice 按多个条件排序 sort.Slice(people, func(i, j int) bool &#123; // 优先按年龄排序 if people[i].Age != people[j].Age &#123; return people[i].Age &lt; people[j].Age &#125; // 如果年龄相同，则按名字排序 return people[i].Name &lt; people[j].Name &#125;) fmt.Println(people)&#125; 3. 更复杂条件：按多个字段权重排序如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Product struct &#123; Name string Price float64 Rating int&#125;func main() &#123; products := []Product&#123; &#123;&quot;Laptop&quot;, 1000, 5&#125;, &#123;&quot;Phone&quot;, 800, 4&#125;, &#123;&quot;Tablet&quot;, 800, 5&#125;, &#123;&quot;Watch&quot;, 400, 4&#125;, &#125; // 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序 sort.Slice(products, func(i, j int) bool &#123; // 按价格降序 if products[i].Price != products[j].Price &#123; return products[i].Price &gt; products[j].Price &#125; // 如果价格相同，按评分降序 if products[i].Rating != products[j].Rating &#123; return products[i].Rating &gt; products[j].Rating &#125; // 如果评分也相同，按名称升序 return products[i].Name &lt; products[j].Name &#125;) fmt.Println(products)&#125; 4. 注意事项 如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。 sort.Slice 是不稳定的。如果需要稳定排序，可以使用 sort.SliceStable。 对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。 通过 sort.Slice 的灵活性，可以轻松实现各种复杂条件的排序逻辑。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【刨根问底】创建slice是否填第二个参数0的区别","slug":"eetcode/【刨根问底】创建slice是否填第二个参数0的区别","date":"2024-11-23T05:10:49.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-11-23-b80d94088ccd.html","link":"","permalink":"https://leiqi.top/2024-11-23-b80d94088ccd.html","excerpt":"","text":"在Go语言中，创建切片（slice）时使用make函数有两种常见的方式，它们之间有细微的差别： slice := make([]string, 0) 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是[]string），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。 slice := make([]string) 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，make函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。 两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用make([]string)（或者等价的make([]string, 0)）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。 总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","slug":"eetcode/【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","date":"2024-11-23T05:05:23.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-11-23-cf0eba4d8369.html","link":"","permalink":"https://leiqi.top/2024-11-23-cf0eba4d8369.html","excerpt":"","text":"确实，如果我们按照缩写的逻辑来看，Itos（Integer to String）可能更直观地表达了Itoa函数的功能，即把整数转换为字符串。 然而，Itoa这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，Itoa这个术语已经被广泛接受和使用。以下是一些可能的原因： 历史原因：Itoa这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，Itoa（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。 约定俗成：在编程社区中，Itoa已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。 ASCII与字符串的关系：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字123的ASCII表示和字符串表示都是&quot;123&quot;。因此，Itoa这个名字仍然适用。 简洁性：Itoa这个名称比较简洁，易于记忆。如果使用Itos，虽然直观，但可能不如Itoa简洁。 Itoa这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管Itos可能更直观地表示整数到字符串的转换，但Itoa已经成为一个广泛接受和使用的术语。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}]},{"title":"【基础知识】符号整数和非符号整数","slug":"eetcode/【基础知识】符号整数和非符号整数","date":"2024-11-23T04:47:02.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-11-23-dce4118b03a7.html","link":"","permalink":"https://leiqi.top/2024-11-23-dce4118b03a7.html","excerpt":"","text":"uint8 uint16和uint32是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。 unit8 : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255 **uint16**： uint16是一个16位的无符号整数。 它可以存储的数字数量是 2^16。 计算得出：216&#x3D;65536216&#x3D;65536。 因此，uint16能存储的数字范围是从0到65535。 **uint32**： uint32是一个32位的无符号整数。 它可以存储的数字数量是 2^32。 计算得出：232&#x3D;4294967296232&#x3D;4294967296。 因此，uint32能存储的数字范围是从0到4294967295。 总结： uint16能存储的数字数量是 216216，即65536个数字。 uint32能存储的数字数量是 232232，即4294967296个数字。 int32是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。 具体来说： 对于正数，最高位是0，剩下的31位可以表示 231231 个不同的正数值。 对于负数，最高位是1，剩下的31位可以表示 231231 个不同的负数值。 由于0既不是正数也不是负数，它单独占用了一个数值。 因此，int32的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说int32的范围是31次方而不是32次方的原因。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Golang】 byte和rune 有什么区别","slug":"eetcode/【Golang】 byte和rune 有什么区别","date":"2024-11-23T04:38:13.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-11-23-ff51ba651704.html","link":"","permalink":"https://leiqi.top/2024-11-23-ff51ba651704.html","excerpt":"","text":"byte 和rune 有什么区别？ 在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义： byte： byte是uint8的别名，即一个无符号的8位整数。在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。rune： rune是int32的别名，即一个有符号的32位整数。rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。区别： 大小：byte是8位的，而rune是32位的。用途：byte用于处理字节数据，rune用于处理Unicode字符。范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"申请域名绑定github pages","slug":"端/申请域名绑定github pages","date":"2024-09-01T02:17:17.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2024-09-01-ed1bf9078b39.html","link":"","permalink":"https://leiqi.top/2024-09-01-ed1bf9078b39.html","excerpt":"","text":"你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！ 前置需求 在Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo完成了域名的购买 完成了GitHub Pages的设置，有了可用的http://username.github.io库之后，可以访问 Github Pages 正文0. 进入我的账户 1. 无论是什么域名服务商，找到DNS Management页面如果是namesilo购买的域名，可以通过以下步骤：点击“domain manager”点击这个蓝色的小球（Manage DNS for this domain） 2. 写入 type A 的DNS记录 如果厂商提供了写入模板，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 DNS Templates。 找到GitHub的template，点击“Apply Template”，然后在弹出的窗口里直接点击“Accept”，你就会发现4条A记录已经自动写入了。 如果厂商不能自动添加，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图 [Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain! 上面圈起来的四个地址就是需要等会儿手动输入的。 不同厂商之间的手动添加方法不一样，但只要记住 type 后填“A”，address&#x2F;points to或其他同义表达后填这四个地址中的一个，其他默认就好了，一共需要添加四条，可以复制粘贴。 添加之后会多出四个### 3. 创建CNAME文件 这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成http://username.github.io， 上面的方法 save 之后看到报错不要慌，让子弹飞一会儿就好了 最终有这些配置即可： github 填写域名地址在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。 即刻访问你自己的域名网站吧！ 参考：将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)","categories":[{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"git stash","slug":"it/git stash","date":"2024-08-21T16:26:46.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-08-21-f4ccab39149e.html","link":"","permalink":"https://leiqi.top/2024-08-21-f4ccab39149e.html","excerpt":"","text":"当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作： 放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。 bashgit checkout – .obsidian&#x2F;workspace.json再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。 bashgit pull如果不想放弃这些更改，而是想将它们保存起来，可以使用 git stash 命令： 保存更改：使用 git stash 将更改保存到一个临时区域。 git stash拉取远程更新： 1git pull 恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。 1git stash apply 请注意，使用 git stash apply 可能不会总是成功，在这种情况下，可能需要手动解决冲突。","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"leetcode  1.两数之和","slug":"eetcode/leetcode  1.两数之和","date":"2024-08-21T15:53:21.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-08-21-64c0a1f316e6.html","link":"","permalink":"https://leiqi.top/2024-08-21-64c0a1f316e6.html","excerpt":"","text":"有两种思路： 使用暴力遍历， 复杂度的是 O(n ^2) 123456789101112func twoSum(nums []int, target int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; for j:= i+1; j &lt; len(nums); j++ &#123; if nums[i] + nums[j] == target &#123; return []int&#123;i, j&#125; &#125; &#125; &#125; return []int&#123;&#125;&#125; 使用哈希表，是O(n) 使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置1234567891011121314151617func twoSum(nums []int, target int) []int &#123; maps := make(map[int]int, len(nums)) for idx, num := range nums &#123; maps[num] = idx &#125; for idx, num := range nums &#123; if idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; // 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意 return []int&#123;idx, idx2&#125; &#125; &#125; return []int&#123;&#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"docker容器打包成本地压缩镜像并load","slug":"ocker/docker容器打包成本地压缩镜像并load","date":"2024-08-11T03:59:34.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2024-08-11-a8e2c27fed87.html","link":"","permalink":"https://leiqi.top/2024-08-11-a8e2c27fed87.html","excerpt":"","text":"docker容器打包成镜像和压缩（1）将容器保存成新的镜像相当于加了一层，使用docker commit 1sudo docker commit -a &#x27;run_code&#x27; b4293c3b9202 myimage:v2 （2）将镜像打包 1docker save -o mask_detection_v5.tar myimage:v5 (3) 将镜像包压缩 1sudo tar -zcvf myimage.tar.gz myimage.tar 还有一种容器的打包和压缩一步到位的方法： 1docker save myimage:v5 | gzip &gt; myimage.tar.gz docker镜像压缩包解压及镜像载入 一步加载压缩的镜像命令 12docker load &lt; myimage.tar.gz （1）压缩包解压 1tar -zxvf myimage.tar.gz 得到.tar格式的镜像包 （2）镜像载入 1sudo docker load -i myimage.tar 载入后查看已经加载的镜像 1sudo docker images 运行镜像123# 交互式运行docker run -it myimage:v1 bash 进入已经运行的容器12docker exec -it [imagesID] bash","categories":[{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"}],"tags":[]},{"title":"查询深度学习环境python torch cuda版本","slug":"具/查询深度学习环境python torch cuda版本","date":"2024-08-08T14:55:03.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2024-08-08-efa703ec12d7.html","link":"","permalink":"https://leiqi.top/2024-08-08-efa703ec12d7.html","excerpt":"","text":"1234567import sysimport torch#sys模块提供了一系列有关Python运行环境的变量和函数。print(sys.version)print(torch.__version__)print(torch.cuda.is_available())","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"开机自启WSL","slug":"具/开机自启WSL","date":"2024-08-07T14:09:47.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2024-08-07-117ef9b8f4c6.html","link":"","permalink":"https://leiqi.top/2024-08-07-117ef9b8f4c6.html","excerpt":"","text":"在C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 目录下，新建vbs文件 文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址 123456Set ws = WScript.CreateObject(&quot;WScript.Shell&quot;)cmd = &quot;C:\\Windows\\System32\\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;&#x27;运行命令不显示cmd窗口ws.Run cmd, 0, falseSet ws = NothingWScript.quit","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git更新仓库地址","slug":"it/git更新仓库地址","date":"2024-07-23T15:34:45.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-07-23-764a3cd05cde.html","link":"","permalink":"https://leiqi.top/2024-07-23-764a3cd05cde.html","excerpt":"","text":"使用如下命令 1git remote set-url origin https://gitee.com/xxxxx","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"设置github 同步到gitee","slug":"it/设置github 同步到gitee","date":"2024-07-21T14:15:47.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-07-21-3ee37da7ed1c.html","link":"","permalink":"https://leiqi.top/2024-07-21-3ee37da7ed1c.html","excerpt":"","text":"复制自己电脑的私钥到github 复制自己电脑的公钥到gitee 获取gitee 的私人令牌 创建.github&#x2F;workflows&#x2F;xxx.ymal 12345678910111213141516171819202122232425name: Pageson: push: branches: - master # default branchjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v2 - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125; with: # 注意替换为你的 GitHub 源仓库地址 source-repo: git@github.com:leiqichn/novelBigModel.git # 注意替换为你的 Gitee 目标仓库地址 destination-repo: git@gitee.com:leiqichn/novelBigModel.git","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Golang 使用new创建slice","slug":"olang/Golang 使用new创建slice","date":"2024-07-21T06:14:35.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2024-07-21-01f71b57e534.html","link":"","permalink":"https://leiqi.top/2024-07-21-01f71b57e534.html","excerpt":"","text":"在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。 然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做： 12var s *[]int // 声明一个指向int类型slice的指针s = new([]int) // 分配一个int类型的slice，并将其地址赋给s 但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数： 1s := make([]int, length, capacity) // 创建一个长度为 length，容量为 capacity 的int类型slice 如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做： 12s := new([]int)*s = make([]int, length, capacity) // 通过解引用指针并使用make来初始化slice 在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"依赖注入","slug":"olang/依赖注入","date":"2024-07-21T05:03:46.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-07-21-618c8c29b962.html","link":"","permalink":"https://leiqi.top/2024-07-21-618c8c29b962.html","excerpt":"","text":"依赖注入使用接口来实现依赖注入，降低模块间的耦合。概念： 依赖注入是一种设计模式，它允许你将组件的依赖关系（即其他组件或服务）从组件本身中分离出来，并在组件外部进行配置。这样做可以减少组件之间的耦合，使得代码更加模块化，易于测试和维护。 Go 语言实现： 在 Go 语言中，可以通过接口来实现依赖注入。接口定义了组件所需的行为，然后你可以在运行时注入任何实现了这些行为的具体类型。 优点： 降低耦合：组件不直接依赖于具体的实现类，而是依赖于接口，这降低了组件之间的耦合度。 提高灵活性：可以轻易地替换依赖的具体实现，而不需要修改组件的代码。 易于测试：可以为测试注入模拟对象（mocks），从而可以隔离测试组件，不依赖于外部服务或组件。 1234567891011121314151617181920212223242526272829303132333435package maintype Logger interface &#123; Log(message string)&#125;type ConsoleLogger struct&#123;&#125;func (l ConsoleLogger) Log(message string) &#123; println(&quot;Log-DEBUG:&quot;, message)&#125;type ConsoleLoggerINFO struct&#123;&#125;func (l ConsoleLoggerINFO) Log(message string) &#123; println(&quot;Log-INFO:&quot;, message)&#125;type Application struct &#123; logger Logger&#125;func (a *Application) SetLogger(logger Logger) &#123; a.logger = logger&#125;func main() &#123; app := Application&#123;&#125; consoleLogger := ConsoleLogger&#123;&#125; app.SetLogger(consoleLogger) app.logger.Log(&quot;Application started&quot;) consoleLoggerInfo := ConsoleLoggerINFO&#123;&#125; app.SetLogger(consoleLoggerInfo)&#125; 上边通过Go语言的Logger接口包含了Log方法, Application包含了Logger接口。 Application可以通过SetLogger来设置任何实现接口中Log 方法的就，可以方便切换日志类型。这就是依赖注入，每个部分都是个组件，可以随意方便的更换","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"回调函数和直接调用的区别","slug":"olang/回调函数和直接调用的区别","date":"2024-07-21T04:51:05.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-07-21-023e6a227482.html","link":"","permalink":"https://leiqi.top/2024-07-21-023e6a227482.html","excerpt":"","text":"回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异： 调用时机： 直接调用：函数A直接调用函数B，函数B的执行是立即的，并且是在函数A的控制下进行的。 回调函数：函数A接收函数B作为参数，但函数B的执行时机可能由外部事件或条件触发，不一定立即执行。 控制流： 直接调用：控制流是线性的，函数B执行完毕后，控制权返回给函数A。 回调函数：控制流可能会中断，函数A执行到某个点后，将控制权交给函数B，函数B执行完毕后，控制权可能不会直接返回给函数A，而是等待某个条件满足后才继续执行。 执行环境： 直接调用：函数B在函数A的上下文中执行，可以访问函数A的局部变量。 回调函数：函数B可能在不同的上下文中执行，例如在异步操作完成后，此时它可能无法访问函数A的局部变量。 目的和用途： 直接调用：通常用于直接执行某个操作或计算。 回调函数：通常用于响应事件、处理异步操作的结果或在特定条件下触发后续操作。 编程模式： 直接调用：更符合同步编程模式，代码执行顺序明确。 回调函数：常用于异步编程模式，代码的执行顺序可能不那么明确，需要更多的控制结构来管理。 函数定义： 直接调用：函数B在被调用时不需要特定的定义或约束。 回调函数：函数B可能需要符合特定的接口或签名，以便作为回调被其他函数使用。 错误处理： 直接调用：错误处理通常在调用者（函数A）中进行。 回调函数：错误处理可能需要在回调函数本身中进行，调用者可能不知道回调函数何时被调用。 代码组织： 直接调用：代码组织可能更直观，因为函数调用关系清晰。 回调函数：代码组织可能需要更多的设计考虑，以确保回调函数在适当的时机被调用，并且逻辑清晰。 使用回调函数而不是直接调用的原因通常与程序设计的复杂性、灵活性和可扩展性有关。例如，在处理异步事件、网络请求或用户界面操作时，回调函数提供了一种有效的方式来处理这些操作的结果，而不需要阻塞主程序流程。此外，回调函数还可以帮助实现更高层次的抽象，如事件监听器、中间件等","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"github同步gitee","slug":"it/github同步gitee","date":"2024-07-18T16:38:12.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-07-18-e17dac938cf8.html","link":"","permalink":"https://leiqi.top/2024-07-18-e17dac938cf8.html","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"vue3快速实践","slug":"端/vue3/vue3 入门/vue3快速实践","date":"2024-06-24T14:32:19.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2024-06-24-1130f46a1ad4.html","link":"","permalink":"https://leiqi.top/2024-06-24-1130f46a1ad4.html","excerpt":"","text":"教程 | Vue.js (vuejs.org) 声明式渲染你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。SFC 是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 .vue 后缀的文件中。 Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。能在改变时触发更新的状态被称作是响应式的。我们可以使用 Vue 的 reactive() API 来声明响应式状态。由 reactive() 创建的对象都是 JavaScript Proxy 123456789import &#123; reactive &#125; from &#x27;vue&#x27;const counter = reactive(&#123; count: 0&#125;)console.log(counter.count) // 0counter.count++ reactive() 只适用于对象 (包括数组和内置类型，如 Map 和 Set)。而另一个 API ref() 则可以接受任何值类型。ref 会返回一个包裹对象，并在 .value 属性下暴露内部值。 在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。 template 1&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt; 现在，试着自己创建一些响应式状态， Attribute 绑定 v-bind1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const titleClass = ref(&#x27;title&#x27;)&lt;/script&gt;&lt;template&gt; &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;&lt;/template&gt;&lt;style&gt;.title &#123; color: red;&#125;&lt;/style&gt; 时间监听 v-on : clickv-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa” 123456789101112131415161718&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)function increment() &#123; // 更新组件状态 count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 使此按钮生效 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 表单绑定 v-modelv-model 会将被绑定的值与 &lt;input&gt; 的值自动同步，这样我们就不必再使用事件处理函数了。 v-model 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在指南 - 表单绑定中讨论了更多的细节。 1234567891011121314151617181920212223242526272829303132&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)function onInput(e) &#123; text.value = e.target.value&#125;&lt;/script&gt;&lt;template&gt; &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt;# 使用v-model 简化&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)&lt;/script&gt;&lt;template&gt; &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt; 条件渲染 12345678910111213141516&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const awesome = ref(true)function toggle() &#123; awesome.value = !awesome.value # 做取反&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;&lt;/template&gt;","categories":[{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"jupyter","slug":"ython/Linux环境上jupyter 安装","date":"2024-06-21T14:26:04.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-06-21-02cd02e81f22.html","link":"","permalink":"https://leiqi.top/2024-06-21-02cd02e81f22.html","excerpt":"","text":"安装pip install notebook 用于启动 Jupyter Notebook 服务的一系列命令 12345jupyter-notebook stop 8888JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)echo $JUPYTER_TOKENnohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;jupyter-notebook list 这里是每条命令的简要说明： 12345jupyter-notebook stop 8888：停止端口为 8888 的 Jupyter Notebook 服务。JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)：生成一个随机的 16 位的 token，用于 Jupyter Notebook 的安全认证。nohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。jupyter-notebook list：列出当前运行的 Jupyter Notebook 服务。 conda 对应版本12345# 创建glm4-demo python 3.10的虚拟环境conda create --name glm4-demo python=3.10conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch PyTorch 12conda install python=3.10 pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia 指定python版本：conda install python&#x3D;3.10 pytorch&#x3D;2.3.0 torchvision torchaudio pytorch-cuda&#x3D;12.1 -c pytorch -c nvidia","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"leetcode 每日温度 单调栈","slug":"eetcode/leetcode 每日温度 单调栈","date":"2024-05-20T16:16:04.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-05-20-1fbf9ee2486f.html","link":"","permalink":"https://leiqi.top/2024-05-20-1fbf9ee2486f.html","excerpt":"","text":"739. 每日温度 - 力扣（LeetCode） 栈里边存放的是还没有找到后边更大值的元素 123456789101112131415func dailyTemperatures(temperatures []int) []int &#123; n := len(temperatures) ans := make([]int, n) st := []int&#123;&#125; for i, t := range temperatures &#123; for len(st) &gt; 0 &amp;&amp; t &gt; temperatures[st[len(st)-1]] &#123; j := st[len(st)-1] st = st[:len(st)-1] ans[j] = i - j &#125; st = append(st, i) &#125; return ans&#125; 这段代码是一个Go语言编写的函数，名为dailyTemperatures，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表temperatures，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。 代码思想解释： 问题定义：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。 单调栈的应用：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个索引栈，栈内元素代表尚未找到更大温度的天的索引。 初始化： n：记录输入温度数组的长度。 ans：初始化一个长度为n的数组，用于存储结果，初始值设为0。 st：初始化一个空的切片，用作单调栈。 遍历温度数组： 通过range关键字遍历temperatures数组，同时获取索引i和对应的温度值t。 维护单调栈： 当前温度t大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作： 弹出栈顶元素j，即st[len(st)-1]。 计算索引差i - j，并将这个差值赋给ans[j]。 更新栈st，移除栈顶元素。 压栈操作： 将当前索引i压入栈st中。这表示当前索引的天还没有找到之后的第一个更高温度。 返回结果： 遍历结束后，返回ans数组，其中每个元素表示对应天之后第一个更高温度的天数。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"go语言实现优先队列","slug":"eetcode/go语言实现优先队列","date":"2024-05-18T16:39:54.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-05-18-dfe0612e31db.html","link":"","permalink":"https://leiqi.top/2024-05-18-dfe0612e31db.html","excerpt":"","text":"Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。 1. 优先队列优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。 2. 最大堆最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。 3. 最小堆最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。 实现步骤定义堆的元素类型首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。 1type IntHeap []int 实现heap.Interface接口要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。 123456789101112131415func (h IntHeap) Len() int &#123; return len(h) &#125;func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125; // 对于最小堆func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125; 使用heap.Init初始化堆在使用堆之前，你需要调用heap.Init来初始化它。 123var h IntHeap // 先声明hheap.Init(&amp;h) // 再使用heap.Init(&amp;h) 初始化h指针 添加元素使用heap.Push来添加元素。 12heap.Push(&amp;h, 10)heap.Push(&amp;&amp;h, 20) 移除元素使用heap.Pop来移除并获取堆顶元素。 12top := heap.Pop(&amp;h)fmt.Printf(&quot;top element: %v\\n&quot;, top) 修改元素如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。 转换为最大堆如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。 1func (h IntHeap) Less(i, j int) bool &#123; return h[i] &gt; h[j] &#125; // 对于最大堆 以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。 例题215. 数组中的第K个最大元素 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * Copyright (c) 2024 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2024/5/20 上午12:00 */package leetcode215import &quot;container/heap&quot;func findKthLargest(nums []int, k int) int &#123; h := heapify(nums) // 转化为heap 类型 var res any for i := 0; i &lt; k; i++ &#123; res = heap.Pop(&amp;h) &#125; return res.(int)&#125;type BigHeap []intfunc (h BigHeap) Len() int &#123; return len(h) &#125;func (h BigHeap) Less(i, j int) bool &#123; // 大根堆 return h[i] &gt; h[j]&#125;func (h BigHeap) Swap(i, j int) &#123; tmp := h[i] h[i] = h[j] h[j] = tmp&#125;func (h *BigHeap) Push(x any) &#123; // 使用any 或者interface *h = append(*h, x.(int))&#125;// 删除元素待定func (h *BigHeap) Pop() any &#123; x := (*h)[h.Len()-1] *h = (*h)[:h.Len()-1] return x&#125;// 将 nums 转换成 BigHeapfunc heapify(nums []int) BigHeap &#123; h := BigHeap(nums) // bigHeap 本身就是slice 的别名，所以可以转换 // 或者使用下边两行 h := make(BigHeap, len(nums)) // 新建BigHeap，长度为lenNums copy(h, nums) // 将num copy 到 BigHeap 中去 heap.Init(&amp;h) // 需要输入指针 return h&#125; 347. 前 K 个高频元素 涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//方法一：小顶堆func topKFrequent(nums []int, k int) []int &#123; map_num:=map[int]int&#123;&#125; //记录每个元素出现的次数 for _,item:=range nums&#123; map_num[item]++ &#125; h:=&amp;IHeap&#123;&#125; heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num&#123; heap.Push(h,[2]int&#123;key,value&#125;) if h.Len()&gt;k&#123; heap.Pop(h) &#125; &#125; res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i&lt;k;i++&#123; res[k-i-1]=heap.Pop(h).([2]int)[0] &#125; return res&#125;//构建小顶堆type IHeap [][2]intfunc (h IHeap) Len()int &#123; return len(h)&#125;func (h IHeap) Less (i,j int) bool &#123; return h[i][1]&lt;h[j][1]&#125;func (h IHeap) Swap(i,j int) &#123; h[i],h[j]=h[j],h[i]&#125;func (h *IHeap) Push(x interface&#123;&#125;)&#123; *h=append(*h,x.([2]int))&#125;func (h *IHeap) Pop() interface&#123;&#125;&#123; old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 355设计推特","slug":"eetcode/leetcode 355设计推特","date":"2024-05-10T15:26:56.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2024-05-10-b1491b9671d6.html","link":"","permalink":"https://leiqi.top/2024-05-10-b1491b9671d6.html","excerpt":"","text":"Problem: 355. 设计推特 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"设计题思考","slug":"eetcode/设计题思考","date":"2024-05-08T17:20:58.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2024-05-08-9a58f8b87168.html","link":"","permalink":"https://leiqi.top/2024-05-08-9a58f8b87168.html","excerpt":"","text":"设计数据结构和算法时，通常需要遵循以下步骤来解决问题： 理解问题：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。 确定需求：明确需要哪些数据结构来存储信息，以及如何使用这些数据结构来满足题目的需求。 设计数据结构： 确定实体类型：例如，用户（User）、推文（Tweet）等。 确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。 定义方法：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。 实现逻辑：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。 考虑边界条件和错误处理：确保你的代码可以处理各种边界情况和潜在的错误。 优化：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。 对于LeetCode题目 设计推特，思考过程如下： 理解题目：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。 确定需求： 需要存储用户信息，包括用户ID、关注列表和推文列表。 需要存储推文信息，包括推文ID和时间戳。 设计数据结构： Twitter：包含用户映射，用于快速访问用户信息。 User：包含用户ID、关注列表和推文列表。 Tweet：包含推文ID和时间戳。 定义方法： Constructor：初始化Twitter实例。 PostTweet：实现用户发布推文的逻辑。 Follow：实现用户关注其他用户的逻辑。 Unfollow：实现用户取消关注的逻辑。 GetNewsFeed：实现获取用户信息流的逻辑。 实现逻辑： 对于PostTweet，检查用户是否存在，如果不存在则创建用户，然后添加推文。 对于Follow和Unfollow，更新用户的followees映射。 对于GetNewsFeed，收集并排序推文，然后返回结果。 考虑边界条件： 确保在添加推文或关注用户时，处理用户不存在的情况。 在获取信息流时，处理用户没有推文或关注任何人的情况。 优化： 考虑是否可以使用更高效的数据结构或算法来提高性能。 在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"如何使用递归","slug":"olang/如何使用递归","date":"2024-05-08T15:15:21.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-05-08-23291165e2d9.html","link":"","permalink":"https://leiqi.top/2024-05-08-23291165e2d9.html","excerpt":"","text":"123456789101112131415func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125; 解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤： 识别重复模式： 确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。 定义递归函数： 根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。 确定基本情况： 找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。 分解问题： 将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。 递归工作： 描述递归如何工作，包括如何从子问题的解中构建出原问题的解。 合并结果： 确定如何将子问题的解合并为原问题的解。 编写伪代码： 在编写实际代码之前，先用伪代码描述递归逻辑。 考虑边界条件： 考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。 优化性能： 如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。 测试和调试： 编写测试用例来验证递归逻辑，并调试任何出现的问题。 以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成： 重复模式：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。 定义递归函数：traversal 函数接收一个数组和两个索引，表示当前考虑的子数组。 确定基本情况：如果左索引大于右索引，说明子数组为空，返回 nil。 分解问题：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 traversal 函数。 递归工作：递归地构建左子树和右子树，然后将它们连接到当前根节点。 合并结果：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。 编写伪代码：在脑中或纸上概述递归调用的流程。 考虑边界条件：确保数组索引不会超出数组边界。 优化性能：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。 测试和调试：通过在不同的数组输入上测试函数来确保其正确性。 通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"goland中debug 无法显示全局变量解决","slug":"olang/goland中debug 无法显示全局变量解决","date":"2024-05-07T16:22:44.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-05-07-c105be0dd846.html","link":"","permalink":"https://leiqi.top/2024-05-07-c105be0dd846.html","excerpt":"","text":"实际只会有局部变量，没有全局变量test 解决方法： 右键 选择+ New Watch ； 或者 按按键 Insert 添加变量 test 即可 添加成功之后每次单步执行都会显示变量结果：","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang 中格式化打印单个字符","slug":"olang/golang 中格式化打印单个字符Byte","date":"2024-05-03T08:58:56.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-05-03-ec16a5fd018e.html","link":"","permalink":"https://leiqi.top/2024-05-03-ec16a5fd018e.html","excerpt":"","text":"在Go语言中，fmt.Printf 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。 %c 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 fmt.Printf 中使用 %c，并且传入一个整数（int 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。 例如： 12345678package mainimport &quot;fmt&quot;func main() &#123; var codePoint int = 65 // ASCII码中A的码点 fmt.Printf(&quot;%c\\n&quot;, codePoint) // 输出: A&#125; 在这个例子中，变量 codePoint 的值为 65，它是大写字母 “A” 在ASCII编码中的码点。fmt.Printf(&quot;%c\\n&quot;, codePoint) 将这个整数值格式化为字符 “A” 并输出。 在处理字节数组 []byte 并想要将每个字节转换为对应的字符时，%c 非常有用，因为Go的 string 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; s := &quot;hello&quot; bytes := []byte(s) for i, b := range bytes &#123; fmt.Printf(&quot;Byte %d: %c\\n&quot;, i, b) &#125; // 输出: // Byte 0: h // Byte 1: e // Byte 2: l // Byte 3: l // Byte 4: o&#125; 在这个例子中，我们遍历字符串 &quot;hello&quot; 的字节表示，并使用 %c 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang slice无法添加指针","slug":"olang/golang slice无法添加指针","date":"2024-05-02T13:37:36.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-05-02-247b79126fb5.html","link":"","permalink":"https://leiqi.top/2024-05-02-247b79126fb5.html","excerpt":"","text":"在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向int的指针，比如timePtr *int，你可以通过*timePtr来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。 在你提供的add函数中： 1func add(timePtr *int) &#123; *timePtr += 1 &#125; // 增加一秒 timePtr是一个指向int的指针。虽然你可以通过*timePtr来间接修改它所指向的int值，但是你不能使用这个指针来创建一个关于*int的切片。原因如下： 指针的值是地址：timePtr变量存储的是currentTime变量的内存地址，而不是currentTime的值。切片是基于数组的，它们需要一个具体的数据集合来创建。 切片的元素类型：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于*int的切片，因为切片的元素类型是int，而不是*int（指向int的指针）。 切片创建语法：创建切片通常需要一个数组或另一个切片作为基础，或者使用make函数指定长度和容量。例如： 123var arr [5]intslice1 := arr[:] // 基于数组的切片slice2 := make([]int, 5, 10) // 使用make创建切片 如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在main函数中声明这样一个切片，并在CRUD操作中更新它： 1234567891011121314151617var currentTime intvar history []int // 用于记录历史时间func add(timePtr *int, historyPtr *[]int) &#123; *timePtr++ historyPtr = append(*historyPtr, *timePtr)&#125;func main() &#123; currentTime = 0 history = make([]int, 0) // 初始化历史切片 add(&amp;currentTime, &amp;history) // 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点 fmt.Println(&quot;History of times:&quot;, history)&#125; 在这个例子中，history是一个切片，用于存储时间点的历史记录。每次调用add函数时，我们不仅更新currentTime，还将新的时间点添加到history切片中。注意，由于切片是引用类型，我们传递&amp;history来允许函数修改原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"计算机网络概览","slug":"络/计算机网络概览","date":"2024-05-02T07:27:45.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2024-05-02-82705503428a.html","link":"","permalink":"https://leiqi.top/2024-05-02-82705503428a.html","excerpt":"","text":"【计算机网络】常识 知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；数据链路层；【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；【物理地址MAC】交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）【点对点连接】【全双工通讯】提高了带宽利用率；【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；【IP地址】用于标识不同的网络和网络设备；【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）【默认网关IP】不同网段连接到路由器的IP；【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；【海底光缆】","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"ssh 隧道 端口转发","slug":"具/ssh 隧道 端口转发","date":"2024-04-21T14:30:08.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2024-04-21-29ab33001840.html","link":"","permalink":"https://leiqi.top/2024-04-21-29ab33001840.html","excerpt":"","text":"使用SSH端口转发 如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用-L参数实现，如下所示： 1ssh -L 本地端口:localhost:13579 用户名@物理机IP 其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。 例如：我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC； 123ssh -L 13579:localhost:13579 root@110.43.203.19 -p 30005 // ssh -p 13579 root@localhost","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 208. 实现 Trie (前缀树)","slug":"eetcode/leetcode 208. 实现 Trie (前缀树)","date":"2024-04-16T16:34:47.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2024-04-16-1150f59f3df6.html","link":"","permalink":"https://leiqi.top/2024-04-16-1150f59f3df6.html","excerpt":"","text":"Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。 208. 实现 Trie (前缀树) - 力扣（LeetCode） Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。 为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的： 12345678type TrieNode struct &#123; Value int Next *TrieNode&#125; 而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)： 12345678type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package main import &quot;fmt&quot; // TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; // Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125; // Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125; // Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125; // Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125; // StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125; /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Golang slice作为参数传递给函数需要使用指针","slug":"olang/Golang slice作为参数传递给函数需要使用指针","date":"2024-04-11T16:35:04.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2024-04-11-22166b2f52d0.html","link":"","permalink":"https://leiqi.top/2024-04-11-22166b2f52d0.html","excerpt":"","text":"123456789101112131415161718func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; dfs(1,n,k,&amp;res,&amp;[]int&#123;&#125;) return res&#125;func dfs(s, n, k int, res *[][]int, item *[]int) &#123; if len(*item) == k &#123; *res = append(*res, append([]int&#123;&#125;, *item...)) return &#125; for i := s; i &lt;= n-(k-len(*item))+1; i++&#123; *item = append(*item, i) dfs(i+1, n, k, res, item) *item = (*item)[:len(*item)-1] &#125;&#125; 在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 append 函数或者直接索引赋值的方式，那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。 这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。 例如，在 combine 函数中，如果想要 dfs 函数能够修改 res slice 的长度（即添加新的组合到 res 中），那么需要传递 res 的指针的指针。这样，当 dfs 函数执行 *res = append(*res, newCombination...) 时，它会修改原始的 res slice 而不是它的副本。 传递指针的原因是为了： 避免不必要的副本创建：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。 确保函数内部的修改能够反映到原始数据上：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。 提高代码的效率和性能：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。 还可以转化为全局变量；需要注意的是go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化 123456789101112131415161718192021222324252627var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) // 需要进行初始化 path = make([]int, 0) // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return &#125; for i := startIdx;i&lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; tempPath :&#x3D; []int{},copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。copy(tempPath, path) 123456789101112131415161718192021222324252627282930var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) path = make([]int, 0) // 结束条件 var backtracking func(n int, k int, startIndex int) backtracking = func(n int, k int, startIndex int) &#123; if len(path) == k &#123; tempPath := make([]int, k) // tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。 copy(tempPath, path) res = append(res, tempPath) &#125; for i:= startIndex; i &lt;= n; i++ &#123; if (n -i +1 ) &lt; (k -len(path)) &#123; return &#125; path = append(path, i) backtracking(n, k, i+1) path = path[:len(path)-1] &#125; &#125; backtracking(n,k,1) return res&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"设计题 总结","slug":"eetcode/设计题 总结","date":"2024-04-05T17:21:04.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2024-04-05-d9f9294c39ef.html","link":"","permalink":"https://leiqi.top/2024-04-05-d9f9294c39ef.html","excerpt":"","text":"举个简单的例子：设计题 - 实现浏览器历史记录1.初始化 homepage 和历史记录容量2.浏览网页 和当前页相同，则直接返回 和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。3.实现前进和后退功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: 浏览器实现 * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; if b.GetCurrentPage() == newPageURL &#123; return newPageURL &#125; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。 第一步：理解需求在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能： 记录当前页面。支持前进和后退操作。能够跳转到新页面。考虑历史记录的容量限制。 第二步：建模接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素： 当前页面：表示用户当前正在浏览的页面。历史记录：表示用户访问过的页面的顺序列表。最大容量：限制历史记录的长度，以防止无限增长。一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。 第三步：选择数据结构和函数接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数： NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。GetCurrentPage() string：获取当前页面的URL。GoBack() string：执行后退操作，并返回当前页面的URL。GoForward() string：执行前进操作，并返回当前页面的URL。NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。 第四步：编写示例代码现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。 第五步：测试和优化一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。 根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。 总结在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。 练习下面，我们来按照难度多练习几道题目 简单题 232. 用栈实现队列 - 力扣（LeetCode） 思路：input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667type MyQueue struct &#123; inputStack []int outputStack []int&#125;func Constructor() MyQueue &#123; return MyQueue&#123; inputStack: make([]int, 0), outputStack: make([]int, 0), &#125;&#125;func (this *MyQueue) Push(x int) &#123; this.inputStack = append(this.inputStack, x)&#125;func (this *MyQueue) Pop() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return top&#125;func (this *MyQueue) Peek() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // return top&#125;func (this *MyQueue) Empty() bool &#123; if len(this.inputStack) == 0 &amp;&amp; len(this.outputStack) == 0 &#123; return true &#125; return false&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 - 力扣（LeetCode） 思路：用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type MyStack struct &#123; inputQueue []int outputQueue []int&#125;func Constructor() MyStack &#123; return MyStack&#123; inputQueue: make([]int, 0), outputQueue: make([]int, 0), &#125;&#125;func (this *MyStack) Push(x int) &#123; this.inputQueue = append(this.inputQueue, x)&#125;func (this *MyStack) Pop() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = this.outputQueue this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Top() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = append(this.outputQueue, this.inputQueue...) this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Empty() bool &#123; if (len(this.inputQueue) == 0) &amp;&amp; (len(this.outputQueue) == 0) &#123; return true &#125; return false&#125; 303. 区域和检索 - 数组不可变思路：简单题， 12345678910111213141516171819202122232425type NumArray struct &#123; nums []int&#125;func Constructor(nums []int) NumArray &#123; return NumArray&#123;nums: nums&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; sum := 0 for i:= left; i&lt;= right; i++ &#123; sum += this.nums[i] &#125; return sum&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用前缀和怎么求 preSum 数组利用前面提到的递推式: 遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，即preSum[0]为nums[0]（前提是nums有元素）。 预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。 需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。 后面会给出简化的写法。 123456789101112131415161718192021222324252627282930313233type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums)) preSum[0] = nums[0] for i:=1; i&lt;len(nums);i++ &#123; preSum[ i] = preSum[ i-1] + nums[i] &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; if left == 0 &#123; // 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j] if len(this.preSum) == 0 &#123; // 但如果nums根本没有长度，直接返回0 return 0 &#125; return this.preSum[right] &#125; return this.preSum[right] - this.preSum[left-1]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用多一位长度的前缀和之所以上面处理东西多，是因为preSum[i]的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index 要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]即： 1234567891011121314151617181920212223242526type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums) + 1) for index, value := range nums &#123; preSum[index + 1] = preSum[index] + value &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; return this.preSum[right + 1] - this.preSum[left]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 703. 数据流中的第 K 大元素暴力解法 1234567891011121314151617181920212223242526272829303132type KthLargest struct &#123; // 排序后的nums index int sortedNums []int&#125;func Constructor(k int, nums []int) KthLargest &#123; return KthLargest&#123;k, nums&#125;&#125;func (this *KthLargest) Add(val int) int &#123; this.sortedNums = append(this.sortedNums, val) sort.Ints(this.sortedNums) revert(this.sortedNums) return this.sortedNums[this.index-1]&#125;func revert(nums []int) &#123; for i, j := 0, len(nums)-1; i &lt; j; i, j = i+1, j-1 &#123; nums[i], nums[j] = nums[j], nums[i] &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * obj := Constructor(k, nums); * param_1 := obj.Add(val); */ 优先队列我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。 在单次插入的操作中，我们首先将元素 val\\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。 123456789101112131415161718192021222324252627282930313233type KthLargest struct &#123; sort.IntSlice k int&#125;func Constructor(k int, nums []int) KthLargest &#123; kl := KthLargest&#123;k: k&#125; for _, val := range nums &#123; kl.Add(val) &#125; return kl&#125;func (kl *KthLargest) Push(v interface&#123;&#125;) &#123; kl.IntSlice = append(kl.IntSlice, v.(int))&#125;func (kl *KthLargest) Pop() interface&#123;&#125; &#123; a := kl.IntSlice v := a[len(a)-1] kl.IntSlice = a[:len(a)-1] return v&#125;func (kl *KthLargest) Add(val int) int &#123; heap.Push(kl, val) if kl.Len() &gt; kl.k &#123; heap.Pop(kl) &#125; return kl.IntSlice[0]&#125; 146 LRU缓存146. LRU 缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type LRUCache struct &#123; capacity int // 容量 keysList []int // 实现最新时间 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间 keysMap map[int]int // 存放key value&#125;func Constructor(capacity int) LRUCache &#123; //return return LRUCache&#123;capacity, make([]int, 0), make(map[int]int, 0)&#125;&#125;// 如果key存在于缓存中，则返回关键字的值，否则返回-1func (this *LRUCache) Get(key int) int &#123; if ele, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) return ele &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; // 关键字存在 则更新值为value // 不存在，则插入value // 如果插入超过数量capacity 则删除最久没有使用的关键字【list] if _, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) this.keysMap[key] = value &#125; else &#123; this.updateListKey(key) this.keysMap[key] = value if len(this.keysList) &gt; this.capacity &#123; delete(this.keysMap, this.keysList[0]) // 这里删除key 从list队列中获取 this.keysList = this.keysList[1:] &#125; &#125;&#125;func (this *LRUCache) updateListKey(key int) &#123; for i := 0; i &lt; len(this.keysList); i++ &#123; if key == this.keysList[i] &#123; this.keysList = append(this.keysList[:i], this.keysList[i+1:]...) // 删除该key, 然后放在末尾 break &#125; &#125; this.keysList = append(this.keysList, key)&#125; 355 设计推特355. 设计推特 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特数目，用于时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 和时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125; 208. 实现 Trie (前缀树) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport &quot;fmt&quot;// TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125;// Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125;// Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125;// Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125;// Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125;// StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125;/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 211. 添加与搜索单词 - 数据结构设计 一次AC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &quot;strings&quot;type WordDictionary struct &#123; wordMap map[string]bool&#125;func Constructor() WordDictionary &#123; return WordDictionary&#123;make(map[string]bool, 0)&#125;&#125;func (this *WordDictionary) AddWord(word string) &#123; this.wordMap[word] = true&#125;func (this *WordDictionary) Search(word string) bool &#123; if _, ok := this.wordMap[word]; ok &#123; return true &#125; else if strings.Contains(word, &quot;.&quot;) &#123; for key, _ := range this.wordMap &#123; if len(key) == len(word) &#123; flag := true for i := 0; i &lt; len(word); i++ &#123; if key[i] == word[i] || word[i] == &#x27;.&#x27; &#123; &#125; else &#123; flag = false &#125; &#125; if flag == true &#123; return true &#125; &#125; &#125; return false &#125; return false&#125;/** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */ 284. 窥视迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142/* Below is the interface for Iterator, which is already defined for you. * * type Iterator struct &#123; * * &#125; * * func (this *Iterator) hasNext() bool &#123; * // Returns true if the iteration has more elements. * &#125; * * func (this *Iterator) next() int &#123; * // Returns the next element in the iteration. * &#125; */type PeekingIterator struct &#123; iter *Iterator _hasNext bool _next int&#125;func Constructor(iter *Iterator) *PeekingIterator &#123; return &amp;PeekingIterator&#123;iter, iter.hasNext(), iter.next()&#125;&#125;func (it *PeekingIterator) hasNext() bool &#123; return it._hasNext&#125;func (it *PeekingIterator) next() int &#123; ret := it._next it._hasNext = it.iter.hasNext() if it._hasNext &#123; it._next = it.iter.next() &#125; return ret&#125;func (it *PeekingIterator) peek() int &#123; return it._next&#125; 535. TinyURL 的加密与解密 12345678910111213141516171819202122232425262728293031323334// 通过自增id 的方式来实现encodetype Codec struct &#123; dataId map[int]string nums int&#125;func Constructor() Codec &#123; return Codec&#123;map[int]string&#123;&#125;, 0&#125;&#125;// Encodes a URL to a shortened URL.func (this *Codec) encode(longUrl string) string &#123; this.nums++ this.dataId[this.nums] = longUrl res := &quot;http://tinyurl.com/&quot; + strconv.Itoa(this.nums) return res&#125;// Decodes a shortened URL to its original URL.func (this *Codec) decode(shortUrl string) string &#123; index := strings.Split(shortUrl, &quot;/&quot;) tmp := index[len(index)-1] idx, _ := strconv.Atoi(tmp) long := this.dataId[idx] return long&#125;/** * Your Codec object will be instantiated and called as such: * obj := Constructor(); * url := obj.encode(longUrl); * ans := obj.decode(url); */ 707. 设计链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374type MyLinkedList struct &#123; // 如何确定结构体里应设置什么变量？ // 总的List 包含 有多少个节点，以及头节点是什么 Size int dummyHead *ListNode &#125;func Constructor() MyLinkedList &#123; // Constructor 该如何写？如何才能符合题目要求？ return MyLinkedList&#123;0, &amp;ListNode&#123;0,nil&#125;&#125; // 这个虚拟头节点不应该删掉吗？&#125;func (this *MyLinkedList) Get(index int) int &#123; if index &lt; 0 || index &gt;= this.Size &#123; return -1 &#125; //dummyHead := &amp;ListNode&#123;0, this.head&#125; cur := this.dummyHead.Next for index != 0 &amp;&amp; cur != nil &#123; cur = cur.Next index-- &#125; return cur.Val&#125;func (this *MyLinkedList) AddAtHead(val int) &#123; this.AddAtIndex(0, val)&#125;func (this *MyLinkedList) AddAtTail(val int) &#123; this.AddAtIndex(this.Size, val)&#125;func (this *MyLinkedList) AddAtIndex(index int, val int) &#123; if index &gt;= 0 &amp;&amp; index &lt;= this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; newNode := &amp;ListNode&#123;val, cur.Next&#125; cur.Next = newNode this.Size++ &#125; if index &lt; 0 &#123; this.AddAtIndex(0, val) this.Size++ &#125; if index &gt; this.Size &#123; return // 这个return 到哪里了？ 代表结束这个程序吗？ &#125;&#125;func (this *MyLinkedList) DeleteAtIndex(index int) &#123; if index &gt;= 0 &amp;&amp; index &lt; this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; cur.Next = cur.Next.Next this.Size-- &#125; return&#125;/** * Your MyLinkedList object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Get(index); * obj.AddAtHead(val); * obj.AddAtTail(val); * obj.AddAtIndex(index,val); * obj.DeleteAtIndex(index); */ 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 901. 股票价格跨度 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 1396. 设计地铁系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */ 1476. 子矩形查询 1234567891011121314151617181920212223242526272829303132type SubrectangleQueries struct &#123; // 需要什么数据结构呢？ 1. 一个二维数组 rectangle [][]int&#125;func Constructor(rectangle [][]int) SubrectangleQueries &#123; return SubrectangleQueries&#123;rectangle: rectangle&#125;&#125;func (this *SubrectangleQueries) UpdateSubrectangle(row1 int, col1 int, row2 int, col2 int, newValue int) &#123; for i:=row1;i &lt;= row2;i++ &#123; for j:= col1; j &lt;= col2; j++ &#123; this.rectangle[i][j] = newValue &#125; &#125;&#125;func (this *SubrectangleQueries) GetValue(row int, col int) int &#123; return this.rectangle[row][col]&#125;/** * Your SubrectangleQueries object will be instantiated and called as such: * obj := Constructor(rectangle); * obj.UpdateSubrectangle(row1,col1,row2,col2,newValue); * param_2 := obj.GetValue(row,col); */ 1845. 座位预约管理系统 1234567891011121314151617181920212223242526272829303132333435type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125; 1993. 树上的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869type LockingTree struct &#123; parent []int lockNodeUser []int children [][]int&#125;func Constructor(parent []int) LockingTree &#123; n := len(parent) lockNodeUser := make([]int, n) children := make([][]int, n) for i := 0; i &lt; n; i++ &#123; lockNodeUser[i] = -1 p := parent[i] if p != -1 &#123; children[p] = append(children[p], i) &#125; &#125; return LockingTree&#123;parent, lockNodeUser, children&#125;&#125;func (this *LockingTree) Lock(num int, user int) bool &#123; if this.lockNodeUser[num] == -1 &#123; this.lockNodeUser[num] = user return true &#125; return false&#125;func (this *LockingTree) Unlock(num int, user int) bool &#123; if this.lockNodeUser[num] == user &#123; this.lockNodeUser[num] = -1 return true &#125; return false&#125;func (this *LockingTree) Upgrade(num int, user int) bool &#123; res := this.lockNodeUser[num] == -1 &amp;&amp; !this.hasLockedAncestor(num) &amp;&amp; this.checkAndUnlockDescendant(num) if res &#123; this.lockNodeUser[num] = user &#125; return res&#125;func (this *LockingTree) hasLockedAncestor(num int) bool &#123; num = this.parent[num] for num != -1 &#123; if this.lockNodeUser[num] != -1 &#123; return true &#125; num = this.parent[num] &#125; return false&#125;func (this *LockingTree) checkAndUnlockDescendant(num int) bool &#123; res := false if this.lockNodeUser[num] != -1 &#123; res = true &#125; this.lockNodeUser[num] = -1 for _, child := range this.children[num] &#123; if this.checkAndUnlockDescendant(child) &#123; res = true &#125; &#125; return res&#125; 2241. 设计一个 ATM 机器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type ATM struct &#123; orderList []int amountMap map[int]int // map 是多余的&#125;func Constructor() ATM &#123; return ATM&#123; make([]int, 5), make(map[int]int),// 初始化 使用make 多练习多学习，保持手感。 &#125;&#125;var price [5]int = [5]int&#123;20, 50, 100, 200, 500&#125;func (this *ATM) Deposit(banknotesCount []int) &#123; for i , count := range banknotesCount&#123; this.orderList[i] += count &#125;&#125;func (this *ATM) Withdraw(amount int) []int &#123; //使用整除法 ans := make([]int, 5) for i := 4; i &gt;= 0; i-- &#123; ans[i] = min(amount/price[i],this.orderList[i]) amount -= ans[i]*price[i] &#125; if amount &gt; 0 &#123; return []int&#123;-1&#125; &#125; for idx,v := range ans &#123; this.orderList[idx] -= v &#125; return ans // 注意试着返回是需要钞票的数量，不是钞票的剩余数量&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 2353. 设计食物评分系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394type FoodRatings struct &#123; Map map[string]*FoodHeap NameMap map[string]*Food&#125;type Food struct &#123; Name, C string Rating, Idx int&#125;// 实现堆type FoodHeap []*Foodfunc (h FoodHeap) String() string &#123; res := &quot;&quot; for _, f := range h &#123; res = fmt.Sprintf(&quot;%s -&gt; (%v, %v)&quot;, res, f.Name, f.Rating) &#125; return res&#125;func (h FoodHeap) Len() int &#123; return len(h) &#125;func (h FoodHeap) Swap(i, j int) &#123; h[i], h[i].Idx, h[j], h[j].Idx = h[j], h[j].Idx, h[i], h[i].Idx&#125;// 大顶堆 如果分数相同，Name 字典序小的更大func (h FoodHeap) Less(i, j int) bool &#123; if h[j].Rating == h[i].Rating &#123; return h[i].Name &lt; h[j].Name &#125; return h[j].Rating &lt; h[i].Rating&#125;func (h *FoodHeap) Push(f interface&#123;&#125;) &#123; // Push and Pop use pointer receivers because they modify the slice&#x27;s length, // not just its contents. food := f.(*Food) food.Idx = h.Len() *h = append(*h, food)&#125;func (h *FoodHeap) Pop() interface&#123;&#125; &#123; a := *h; v := a[len(a) - 1]; *h = a[:len(a) - 1]; return v &#125;// 以烹饪方式对评分归类func Constructor(foods []string, cuisines []string, ratings []int) FoodRatings &#123; f := FoodRatings&#123; Map: make(map[string]*FoodHeap), NameMap: make(map[string]*Food, len(foods)), &#125; var ( food *Food h *FoodHeap has bool ) for idx := range foods &#123; food = &amp;Food &#123; foods[idx], cuisines[idx], ratings[idx], 0, &#125; f.NameMap[foods[idx]] = food if h, has = f.Map[cuisines[idx]]; !has &#123; h = &amp;FoodHeap&#123;&#125; f.Map[cuisines[idx]] = h &#125; heap.Push(h, food) &#125; return f&#125;func (this *FoodRatings) ChangeRating(food string, newRating int) &#123; f := this.NameMap[food] h := this.Map[f.C] f.Rating = newRating heap.Fix(h, f.Idx) &#125;func (this *FoodRatings) HighestRated(cuisine string) string &#123; h := this.Map[cuisine] if h.Len() == 0 &#123; return cuisine + &quot;No exist&quot; &#125; return (*h)[0].Name&#125; LCR 184. 设计自助结算系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type MaxQueue struct &#123; q1 []int max []int&#125;func Constructor() MaxQueue &#123; return MaxQueue&#123; make([]int,0), make([]int,0), &#125;&#125;func (this *MaxQueue) Max_value() int &#123; if len(this.max) == 0&#123; return -1 &#125; return this.max[0]&#125;func (this *MaxQueue) Push_back(value int) &#123; this.q1 = append(this.q1,value) for len(this.max) != 0 &amp;&amp; value &gt; this.max[len(this.max)-1]&#123; this.max = this.max[:len(this.max)-1] &#125; this.max = append(this.max,value)&#125;func (this *MaxQueue) Pop_front() int &#123; n := -1 if len(this.q1) != 0&#123; n = this.q1[0] this.q1 = this.q1[1:] if this.max[0] == n&#123; this.max = this.max[1:] &#125; &#125; return n&#125;/** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Max_value(); * obj.Push_back(value); * param_3 := obj.Pop_front(); */作者：Sakura链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solutions/135149/golang-shuang-dui-lie-by-sakura-151/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows IE代理问题解决","slug":"络/windows IE代理问题解决","date":"2024-04-05T05:11:29.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2024-04-05-e1116cf34b00.html","link":"","permalink":"https://leiqi.top/2024-04-05-e1116cf34b00.html","excerpt":"","text":"CMD 检查系统代理配置： - 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。 - 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 双指针","slug":"eetcode/leetcode 双指针","date":"2024-03-23T14:51:46.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-03-23-84678021105b.html","link":"","permalink":"https://leiqi.top/2024-03-23-84678021105b.html","excerpt":"","text":"1234567891011121314// 删除有序数组中的重复元素func removeDuplicates(nums []int) int &#123; slow:=0 for fast:=1;fast &lt;len(nums);fast++ &#123; if nums[fast] != nums[slow] &#123; slow++// 跳到下个位置，保存slow nums[slow] = nums[fast] &#125; &#125; return slow +1&#125; slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。 12345678910func moveZeroes(nums []int) &#123; slow, n := 0, len(nums) for fast := 0; fast &lt; n; fast++ &#123; // 注意第一个是0的时候需要比较 if nums[fast] != 0 &#123; // 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 nums[slow], nums[fast] = nums[fast], nums[slow] slow++ &#125; &#125;&#125; 思路： 1234567891011121314func maxArea(height []int) int &#123; ans := 0 for i := 0; i &lt; len(height); i++ &#123; for j := i + 1; j &lt; len(height); j++ &#123; area := (j - i) * min(height[i], height[j]) ans = max(area,ans) &#125; &#125; return ans&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 123456789101112131415161718func maxArea(height []int) (ans int) &#123; left, right := 0, len(height)-1 // 初始化两边指针 for left &lt; right &#123; area := (right - left) * min(height[left], height[right]) // 计算面积 ans = max(ans, area) // 计算最大值 if height[left] &lt; height[right] &#123; left++ // 移动短的那个 &#125; else &#123; right-- &#125; &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 前缀和，后缀和木桶效应，当前能装的水，取决于两边最大值 的最小值。 1234567891011121314151617181920212223242526func trap(height []int) (ans int) &#123; n := len(height) preMax := make([]int, n) // preMax[i] 表示从 height[0] 到 height[i] 的最大值 preMax[0] = height[0] for i := 1; i &lt; n; i++ &#123; preMax[i] = max(preMax[i-1], height[i]) &#125; sufMax := make([]int, n) // sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值 sufMax[n-1] = height[n-1] for i := n - 2; i &gt;= 0; i-- &#123; sufMax[i] = max(sufMax[i+1], height[i]) &#125; for i, h := range height &#123; ans += min(preMax[i], sufMax[i]) - h // 累加每个水桶能接多少水 &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 双指针 123456789101112131415161718func trap(height []int) (ans int) &#123; left, right, preMax, sufMax := 0, len(height)-1, 0, 0 for left &lt; right &#123; preMax = max(preMax, height[left]) sufMax = max(sufMax, height[right]) if preMax &lt; sufMax &#123; ans += preMax - height[left] left++ &#125; else &#123; ans += sufMax - height[right] right-- &#125; &#125; return&#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 单调栈","slug":"eetcode/leetcode 单调栈","date":"2024-02-24T15:57:54.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-02-24-dd95d981cb94.html","link":"","permalink":"https://leiqi.top/2024-02-24-dd95d981cb94.html","excerpt":"","text":"单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」 输入一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 1234567891011121314151617181920212223func nextGreaterElement(nums []int) []int &#123; n := len(nums) // 存放答案的数组 res := make([]int, n) // 倒着往栈里放 s := make([]int, 0) for i := n - 1; i &gt;= 0; i-- &#123; // 倒着入栈是为了后边正着出栈 // 判定个子高矮 for len(s) &gt; 0 &amp;&amp; s[len(s)-1] &lt;= nums[i] &#123; // 矮个起开，反正也被挡着了。。。 s = s[:len(s)-1] &#125; // nums[i] 身后的更大元素 if len(s) == 0 &#123; // 没有更大的元素 res[i] = -1 &#125; else &#123; res[i] = s[len(s)-1] // 正着出栈 &#125; s = append(s, nums[i]) // 当前元素 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"golang 修改函数传入参数切片需要指针","slug":"olang/golang 修改函数传入参数切片需要指针","date":"2024-02-24T14:50:06.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2024-02-24-4fbd7a88bf6f.html","link":"","permalink":"https://leiqi.top/2024-02-24-4fbd7a88bf6f.html","excerpt":"","text":"func dfs(root *TreeNode, res *[]int) { if root &#x3D;&#x3D; nil { return } *res = append(*res, root.Val) dfs(root.Left, res) dfs(root.Right, res) }在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。 在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。 但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。 这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"路由器设置桥接","slug":"络/路由器设置桥接","date":"2024-02-15T13:34:12.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2024-02-15-1f66da892e14.html","link":"","permalink":"https://leiqi.top/2024-02-15-1f66da892e14.html","excerpt":"","text":"设置密码类型和主路由一样 记得关闭DHCP服务器","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 406. 根据身高重建队列【贪心】","slug":"eetcode/leetcode 406. 根据身高重建队列【贪心】","date":"2024-01-23T16:13:30.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2024-01-23-1cb0809a7893.html","link":"","permalink":"https://leiqi.top/2024-01-23-1cb0809a7893.html","excerpt":"","text":"406. 根据身高重建队列 - 力扣（LeetCode） 12345678910111213141516func reconstructQueue(people [][]int) [][]int &#123; sort.Slice(people, func(i, j int) bool &#123; if people[i][0] == people[j][0]&#123; return people[i][1] &lt; people[j][1] &#125; return people[i][0] &gt; people[j][0] // 身高由大到小排列 &#125;)i // 再按照K进行插入排序，优先插入K小的 for i, p := range people &#123; copy(people[p[1]+1 :i+1], people[p[1] :i=1]) // 腾空出一个位置 people[p[1]] = pi &#125; return people&#125; sort.Slice(people, func(i, j int) bool &#123; ... &#125;): 使用 sort.Slice 对 people 进行排序，按照身高从大到小排列，如果身高相同则按照 k 从小到大排列。 for i, p := range people &#123; ... &#125;: 遍历排序后的数组，按照每个人的 k 值进行插入排序。 copy(people[p[1]+1:i+1], people[p[1]:i+1]): 在插入位置 p[1] 之后的位置腾出一个空位，为新的元素插入做准备。 people[p[1]] = p: 将当前人物 p 插入到正确的位置。 最终，返回重新排列后的队列 people。 在 copy(people[p[1]+1:i+1], people[p[1]:i+1]) 中，使用 i+1 而不是 len(people) 的原因是为了确保只复制有效的元素范围。这里的目标是将 people[p[1]:i+1] 复制到 people[p[1]+1:i+1]，而不是复制整个切片。 让我们考虑一下为什么使用 i+1： i 表示当前元素的索引，而我们想要复制的范围是从 p[1] 到 i。 使用 i+1 作为结束索引可以确保包含 i 在内的元素，而不会超出有效的范围。 如果使用 len(people) 作为结束索引，那么将会复制从 p[1] 到 len(people)-1 的所有元素，这超出了实际有效的范围。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 77.组合【回溯】","slug":"eetcode/leetcode 77.组合【回溯】","date":"2024-01-23T15:17:11.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-23-183e0ff5f5ef.html","link":"","permalink":"https://leiqi.top/2024-01-23-183e0ff5f5ef.html","excerpt":"","text":"77. 组合 - 力扣（LeetCode） 使用回溯的模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 12345678910111213141516171819202122232425func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; path := []int&#123;&#125; // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return // return &#125; for i := startIdx;i &lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) // i+1 进行下一轮 path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; 创建一个二维切片 res 用于存储最终结果，以及一个一维切片 path 用于存储当前路径。 定义回溯函数 backtracking，它接收三个参数：n 表示数字范围，k 表示组合长度，startIdx 表示当前起始数字的索引。 在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。 使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。 在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。 在主函数中初始调用回溯函数，然后返回最终结果。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【BFS DFS通用模板】","slug":"eetcode/【BFS DFS通用模板】","date":"2024-01-22T16:05:29.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-22-759654485d5d.html","link":"","permalink":"https://leiqi.top/2024-01-22-759654485d5d.html","excerpt":"","text":"深度优先搜索（DFS）通用模板123456789101112131415161718192021222324252627282930313233343536// 通用的深度优先搜索函数func dfs(node int, visited []bool, graph [][]int) &#123; // 边界终止条件 if m n &#123; &#125; // 终止条件 if visited[node] &#123; return &#125; // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 递归处理相邻节点 for _, neighbor := range graph[node] &#123; dfs(neighbor, visited, graph) &#125;&#125;// 在主函数中调用func main() &#123; // 初始化节点、访问数组等 // ... // 遍历所有节点 for node := 0; node &lt; len(graph); node++ &#123; if !visited[node] &#123; dfs(node, visited, graph) &#125; &#125;&#125; 广度优先搜索（BFS）通用模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 通用的广度优先搜索函数func bfs(start int, graph [][]int) &#123; queue := []int&#123;start&#125; visited := make([]bool, len(graph)) for len(queue) &gt; 0 &#123; // 出队列 node := queue[0] queue = queue[1:] // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 将相邻节点入队列 for _, neighbor := range graph[node] &#123; if !visited[neighbor] &#123; queue = append(queue, neighbor) &#125; &#125; &#125;&#125;// 在主函数中调用func main() &#123; // 初始化起始节点、图等 // ... // 调用BFS函数 bfs(start, graph)&#125;// 计算从起点 start 到终点 target 的最近距离func BFS(start Node, target Node) int &#123; // 核心数据结构 q := make([]Node, 0) // 避免走回头路 visited := make(map[Node]bool) // 将起点加入队列 q = append(q, start) visited[start] = true for len(q) &gt; 0 &#123; sz := len(q) // 将当前队列中的所有节点向四周扩散 for i := 0; i &lt; sz; i++ &#123; cur := q[0] q = q[1:] // 划重点：这里判断是否到达终点 if cur == target &#123; return step &#125; // 将 cur 的相邻节点加入队列 for _, x := range cur.adj() &#123; if _, ok := visited[x]; !ok &#123; q = append(q, x) visited[x] = true &#125; &#125; &#125; &#125; // 如果走到这里，说明在图中没有找到目标节点&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 94.二叉树的中序遍历","slug":"eetcode/leetcode 94.二叉树的中序遍历","date":"2024-01-22T15:01:59.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-22-f8790b7ced8e.html","link":"","permalink":"https://leiqi.top/2024-01-22-f8790b7ced8e.html","excerpt":"","text":"递归方法123456789101112131415func inorderTraversal(root *TreeNode) (res []int) &#123; var traversal func(node *TreeNode) traversal = func(node *TreeNode) &#123; if node == nil &#123; return &#125; traversal(node.Left) res = append(res,node.Val) traversal(node.Right) &#125; traversal(root) return res&#125; 非递归方法1234567891011121314151617181920212223func inorderTraversal(root *TreeNode) []int &#123; ans := []int&#123;&#125; if root == nil &#123; return ans &#125; st := list.New() cur := root for cur != nil || st.Len() &gt; 0 &#123; if cur != nil &#123; st.PushBack(cur) cur = cur.Left &#125; else &#123; cur = st.Remove(st.Back()).(*TreeNode) ans = append(ans, cur.Val) cur = cur.Right &#125; &#125; return ans&#125; 下面是对代码的解释： ans := []int&#123;&#125;: 创建一个空的整数切片，用于存储最终的中序遍历结果。 if root == nil &#123; return ans &#125;: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。 st := list.New(): 创建一个新的链表（list），用作栈。这里使用标准库中的list包，实现了一个双向链表作为栈。 cur := root: 初始化当前节点为根节点。 for cur != nil || st.Len() &gt; 0 &#123;: 进入循环，只要当前节点不为空或栈不为空就继续遍历。 if cur != nil &#123;: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。 st.PushBack(cur): 将当前节点入栈。 cur = cur.Left: 移动到左子树。 &#125; else &#123;: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。 cur = st.Remove(st.Back()).(*TreeNode): 弹出栈顶节点，即当前待处理的节点。 ans = append(ans, cur.Val): 将当前节点的值加入结果切片。 cur = cur.Right: 移动到右子树。 循环回到第5步，直到栈为空。 这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。 其中 进入循环的条件 for cur != nil || st.Len() &gt; 0 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件： cur != nil: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。 st.Len() &gt; 0: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。 这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。 在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【go】初始化双向列表List","slug":"eetcode/【go】初始化双向列表List","date":"2024-01-22T14:39:01.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-22-93119ce81a1c.html","link":"","permalink":"https://leiqi.top/2024-01-22-93119ce81a1c.html","excerpt":"","text":"在Go语言中，两种方法都可以用于初始化一个list.List。 queue := &amp;list.List&#123;&#125;: 这是使用结构体字面量的方式，创建一个 list.List 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。 queue := list.New(): 这是使用 list 包中的 New 函数来创建一个新的 list.List。New 函数返回一个指向新创建的 list.List 实例的指针。同样，这种方式也创建了一个空的链表。 两种方式都是有效的","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【20240114】LeetCode 83. 删除排序链表中的重复元素","slug":"eetcode/【20240114】LeetCode 83. 删除排序链表中的重复元素","date":"2024-01-14T10:10:30.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-14-e61755fec3db.html","link":"","permalink":"https://leiqi.top/2024-01-14-e61755fec3db.html","excerpt":"","text":"Problem: 83. 删除排序链表中的重复元素 [TOC] 思路 遍历 解题方法 描述你的解题方法 复杂度时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123; for i := head; i != nil &amp;&amp; i.Next != nil ; &#123; if i.Next.Val == i.Val &#123; i.Next = i.Next.Next // 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123; i = i.Next不需要 &#125; else &#123; i = i.Next &#125; &#125; return head&#125;2func deleteDuplicates(head *ListNode) *ListNode &#123; current := head for current != nil &amp;&amp; current.Next != nil &#123; if current.Next.Val == current.Val &#123; // 保存下一个节点的引用 nextNode := current.Next // 删除当前节点 current.Next = nextNode.Next // 释放内存 nextNode = nil &#125; else &#123; // 非重复元素，继续遍历 current = current.Next &#125; &#125; return head&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Win】键盘下键坏了，使用组合键模拟下方向键","slug":"具/【Win】键盘下键坏了，使用组合键模拟下方向键","date":"2024-01-14T09:05:02.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2024-01-14-2aaa71f8e7be.html","link":"","permalink":"https://leiqi.top/2024-01-14-2aaa71f8e7be.html","excerpt":"","text":"使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤： 下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中： 1!s::Send &#123;Down&#125; 这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。 运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。 现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【20240106】leetcode 2807. 在链表中插入最大公约数","slug":"eetcode/【20240106】leetcode 2807. 在链表中插入最大公约数","date":"2024-01-06T15:27:26.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2024-01-06-2b3ad028343c.html","link":"","permalink":"https://leiqi.top/2024-01-06-2b3ad028343c.html","excerpt":"","text":"2807. 在链表中插入最大公约数 - 力扣（LeetCode） 最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。 计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下： 用较大的数除以较小的数，得到余数。 将较小的数作为新的被除数，余数作为新的除数。 重复步骤 1 和 2，直到余数为零。 最后的非零余数即为最大公约数。 这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。 以下是一个用 Go 语言实现的最大公约数的辗转相除法示例： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;// 辗转相除法求最大公约数func gcd(a, b int) int &#123; for b != 0 &#123; temp := b b = a % b a = temp &#125; return a&#125;func main() &#123; num1 := 48 num2 := 18 result := gcd(num1, num2) fmt.Println(&quot;最大公约数为:&quot;, result)&#125; 在这个例子中，gcd 函数使用了辗转相除法来计算两个整数的最大公约数。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LeetCode 1071. 字符串的最大公因子","slug":"eetcode/LeetCode 1071. 字符串的最大公因子","date":"2024-01-03T15:12:16.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-01-03-58e186a9065e.html","link":"","permalink":"https://leiqi.top/2024-01-03-58e186a9065e.html","excerpt":"","text":"1071. 字符串的最大公因子 解题思路： 暴力解法123456789101112131415161718192021222324252627282930313233343536373839404142func gcdOfStrings(str1 string, str2 string) string &#123; n1, n2 := len(str1), len(str2) // 从最长的可能的子串长度开始尝试 for i := min(n1, n2); i &gt; 0; i-- &#123; if n1%i == 0 &amp;&amp; n2%i == 0 &#123; commonSubstring := str1[:i] // 检查是否满足条件 if checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123; return commonSubstring &#125; &#125; &#125; return &quot;&quot;&#125;// 检查字符串是否能够整除func checkDivisible(s string, sub string) bool &#123; repeats := len(s) / len(sub) concatenated := repeatString(sub, repeats) return s == concatenated&#125;// 重复字符串func repeatString(s string, count int) string &#123; result := &quot;&quot; for i := 0; i &lt; count; i++ &#123; result += s &#125; return result&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 数学方法辗转相除法 1234567891011121314151617func gcdOfStrings(str1 string, str2 string) string &#123; if str1 + str2 != str2 + str1 &#123; return &quot;&quot; &#125; gcd := gcd(len(str1), len(str2)) return str1[0:gcd]&#125; func gcd(a, b int) int &#123; for b != 0 &#123; a, b = b, a % b &#125; return a&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows新增wsl bash here键快捷方式","slug":"具/windows新增wsl bash here键快捷方式","date":"2024-01-01T10:23:10.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2024-01-01-38178c63ba17.html","link":"","permalink":"https://leiqi.top/2024-01-01-38178c63ba17.html","excerpt":"","text":"win + R 输入regedit输入到 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 新建wsl_bash_here目录, 设置如下默认值 新建command新建项，输入wsl.exe 的地址 成功可以看到右侧是有wsl bash here的选项的在当面目录打开wsl 成功原理和添加git bash here 类似, 参考:手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git 设置免密配置-全局免密-单仓库免密-SSH免密","slug":"it/git 设置免密配置-全局免密-单仓库免密-SSH免密","date":"2024-01-01T06:56:28.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2024-01-01-91517aa963bc.html","link":"","permalink":"https://leiqi.top/2024-01-01-91517aa963bc.html","excerpt":"","text":"介绍之前我们要首先知道一个简单的概念:https通过记住账号密码免登，ssh通过校验生成的密钥免登。 通常都用ssh校验。 查看通信方式 在项目目录中运行命令： 1git remote -v 如果出现提示是： 12origin https://gitee.com/xxx/xxx.git (fetch)origin https://gitee.com/xxx/xxx.git (push) 则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址 一、https 方式及免密码配置0. 项目中 git 基本配置全局用户名密码配置 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@qq.com&quot; 项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。 1234567# 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令git init# 关联远程仓库git remote add origin https://gitee.com/xxx/xxx.gitgit add -Agit commit -m &quot;初始化&quot;git push -u origin master 需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。 这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。 1.全局免密码配置配置存储模式 1git config --global credential.helper store 执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store Linux 下查看： 1vim ~/.gitconfig windows10 下当前用户路径：%USERPROFILE%内容如下： 12345[user] name = lenovo email = xxxx@outlook.com[credential] helper = store 然后在项目目录，执行git pull&#x2F;git push命令，会提示输入账号密码。这次输入账号密码之后，就会记住账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。 2、单项目免密码配置编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项： 12[remote &quot;origin&quot;]url = https://gitee.com/xxx/xxx.git 修改为： 12[remote &quot;origin&quot;] url = https://yourusername:password@gitee.com/xxx/xxxx.git 也就是在 https:// 之后，增加 用户名:密码@ 二. SSH免密登录如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式, 1git remote rm origin 前提github 网页增加本机SSH key git ssh 方式免密提交方式需要将 ssh-keygen 生成的公钥放到服务器上 全局用户名密码配置 12git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx@qq.com&quot; 项目初始化，生成 .git 目录，配置 ssh 远程项目地址。 123# 如果是新仓库需要git init ;否则不需要git init; git init# git 关联远程仓库git remote add origin git@gitee.com:xxx/xxx.git 生成公钥和私钥1、首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，检查本机的ssh密钥。 12$ cd ~/.ssh $ ls 如果提示：No such file or directory ，说明是第一次使用 git。 如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。 123$ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 2、执行生成公钥和私钥的命令，生成新的密钥： 1ssh-keygen -t rsa -C &quot;xxx&quot; 代码参数： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。 按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 执行查看公钥信息： 1cat ~/.ssh/id_rsa.pub Windows 系统，位置在用户目录下 .ssh文件夹中。%USERPROFILE% 复制公钥信息到远端仓库gitee打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。 githubSettings -SSH and GPG keys - New SSH key然后，提交时就不再需要用户名和密码了 123git add -Agit commit -m &quot;ssh免密提交&quot;git push -u origin master 参考:https://zhuanlan.zhihu.com/p/358721423","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Windows设置Clion 下方Terminal为WSL linux 子系统","slug":"具/Windows设置Clion 下方Terminal为WSL linux 子系统","date":"2023-12-30T15:49:39.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-12-30-397a0b919639.html","link":"","permalink":"https://leiqi.top/2023-12-30-397a0b919639.html","excerpt":"","text":"终端上的小箭头下的设置 找到WSL的地址 粘贴到对应地址中 设置成功这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"免费使用Jetbrain 全家桶-服务器激活码激活软件","slug":"具/免费使用Jetbrain 全家桶-服务器激活码激活软件","date":"2023-12-30T15:08:29.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-12-30-6a1e804ab992.html","link":"","permalink":"https://leiqi.top/2023-12-30-6a1e804ab992.html","excerpt":"","text":"众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品. Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。 https://search.censys.io/ 搜索：services.http.response.headers.location: account.jetbrains.com/fls-auth https://www.shodan.io 搜索：Location: https://account.jetbrains.com/fls-auth https://fofa.info/ 搜索：fls-auth 随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是https://search.censys.io/ 网站, 搜索 1services.http.response.headers.location: account.jetbrains.com/fls-auth 例如上边就是 http://111.231.22.61:1024 激活成功激活成功，请开始愉快的编码吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"WPS设置打开文件自动同步云文档","slug":"具/WPS设置打开文件自动同步云文档","date":"2023-12-30T14:08:47.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-12-30-3a73bdfdd568.html","link":"","permalink":"https://leiqi.top/2023-12-30-3a73bdfdd568.html","excerpt":"","text":"不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作： 打开首页，设置中心 打开新文件会自动上传更新","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git强制拉取远端","slug":"it/git强制拉取远端","date":"2023-10-22T09:53:57.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-10-22-9bf76366f18c.html","link":"","permalink":"https://leiqi.top/2023-10-22-9bf76366f18c.html","excerpt":"","text":"12git fetch origingit reset --hard origin/&lt;branch_name&gt; 这里的 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下： git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。 git reset –hard origin&#x2F;：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。 这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"leetcode 1726.同积元组","slug":"eetcode/leetcode 1726.同积元组","date":"2023-10-20T15:21:57.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-10-20-9599b5db4d91.html","link":"","permalink":"https://leiqi.top/2023-10-20-9599b5db4d91.html","excerpt":"","text":"Problem: 1726. 同积元组 思路 使用排列组合的方法，开始使用三种语言同时写leetcode. 解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213func tupleSameProduct(nums []int) int &#123; n := len(nums) cnt := make(map[int]int) for i := 0; i &lt; n; i++ &#123; for j := i + 1; j &lt; n; j++ &#123;// j +1 不要重复 cnt[nums[i] * nums[j]]++ // 使用map 遍历每次乘积对应次数 &#125; &#125; ans := 0 for _, v := range cnt &#123; ans += v * (v - 1) * 4 &#125; []1234567891011121314151617class Solution &#123;public: int tupleSameProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = 0; unordered_map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; cnt[nums[i] * nums[j]]++; &#125; &#125; for (auto &amp;[k, v] : cnt) &#123; ans += v * (v - 1) * 4; &#125; return ans; &#125;&#125;; []12345678910111213141516class Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = dict() for i in range(n): for j in range(i+1,n): if nums[i]*nums[j] in maps: maps[nums[i] * nums[j]] += 1 else: maps[nums[i] * nums[j]] = 1 ans = 0 for _, v in maps.items(): ans += v*(v-1) *4 return ans","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"本地运行LeetCode的Python代码 调试","slug":"ython/本地运行LeetCode的Python代码 调试","date":"2023-10-19T16:57:22.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-10-19-6057db0e071e.html","link":"","permalink":"https://leiqi.top/2023-10-19-6057db0e071e.html","excerpt":"","text":"最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦 要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类： 创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。 导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。 1from typing import List 创建Solution类并在其中定义问题的解决方案。例如： 1234567891011class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: # 实现你的解决方案 # 例如，找到两个数的和等于目标，并返回它们的索引 num_to_index = &#123;&#125; for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] 创建一个main函数来测试你的解决方案。 12345def main(): solution = Solution() # 调用Solution类的方法进行测试 result = solution.twoSum([2, 7, 11, 15], 9) print(result) 12if __name__ == &quot;__main__&quot;: main() 执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行： 1python leetcode_solution.py 这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"三种Python3 判断字典中是否存在对应key的方法","slug":"ython/三种Python3 判断字典中是否存在对应key的方法","date":"2023-10-19T16:41:07.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-10-19-8f51ae9ef5a1.html","link":"","permalink":"https://leiqi.top/2023-10-19-8f51ae9ef5a1.html","excerpt":"","text":"第一种：使用get()方法 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; 打印返回值 12print(dict.get(&#x27;name&#x27;)) # 结果返回对应valprint(dict.get(&#x27;id&#x27;)) # 结果返回None 第二种：使用keys()方法 生成一个字典dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’} 判断是否存在，其中dict.keys()是列出字典所有的key 12print(&#x27;name&#x27; in dict.keys()) # 结果返回Trueprint(&#x27;id&#x27; in dict.keys()) # 结果返回False 除了使用in也可以使用not in，用于判定这个key不存在 第三种：使用 in 关键字 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; # 判断key是否存在于dict中 12print(&#x27;name&#x27; in dict) # 结果返回Trueprint(&#x27;id&#x27; in dict) # 结果返回False 补充：生成默认字典（collections.defaultdict）使用defaultdict(int)来创建maps，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。 123456789101112131415from collections import defaultdictclass Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = defaultdict(int) ans = 0 for i in range(n): for j in range(i+1, n): product = nums[i] * nums[j] ans += maps[product] * 4 maps[product] += 1 return ans","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"数据结构和操作的对比：Python vs. Go vs. C++","slug":"eetcode/数据结构和操作的对比：Python vs. Go vs. C++","date":"2023-10-19T16:25:56.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-10-19-86483682723b.html","link":"","permalink":"https://leiqi.top/2023-10-19-86483682723b.html","excerpt":"","text":"Python示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 数组my_list = [1, 2, 3, 4]# 切片sub_list = my_list[1:3]reversed_list = my_list[::-1python]# 字典my_dict = &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;# 双向链表（使用collections.deque）from collections import dequemy_linked_list = deque()my_linked_list.append(1)my_linked_list.append(2)my_linked_list.append(3)# 最大堆和最小堆（需要使用第三方库heapq）import heapqmax_heap = []min_heap = []# 二叉树（使用类或结构体）# 字符串操作my_string = &quot;Hello, World!&quot;substring = my_string[7:12]my_int = 42my_str = str(my_int)# 深度拷贝和浅拷贝（使用copy模块）import copyoriginal_list = [1, [2, 3], 4]shallow_copy = copy.copy(original_list)deep_copy = copy.deepcopy(original_list)# 删除元素my_list.pop(1) # 删除第二个元素# 查找小写字母if my_string.islower(): print(&quot;String contains only lowercase letters&quot;)# 遍历数组for item in my_list: print(item)# 使用循环遍历字典for key, value in my_dict.items(): print(key, value)# 判断字典是否包含键if &#x27;name&#x27; in my_dict: print(&quot;Dictionary contains &#x27;name&#x27;&quot;) Go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Go示例// 数组和切片mySlice := []int&#123;1, 2, 3, 4&#125;subSlice := mySlice[1:3]reversedSlice := reverseSlice(mySlice)// 字典myMap := map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30,&#125;// 双向链表（使用container/list）import &quot;container/list&quot;myList := list.New()myList.PushBack(1)myList.PushBack(2)myList.PushBack(3)// 最大堆和最小堆（需要使用heap包）import &quot;container/heap&quot;maxHeap := &amp;MaxHeap&#123;&#125;minHeap := &amp;MinHeap&#123;&#125;// 二叉树（使用结构体或指针）// 字符串操作myString := &quot;Hello, World!&quot;substring := myString[7:12]myInt := 42myStr := fmt.Sprintf(&quot;%d&quot;, myInt)// 深度拷贝和浅拷贝（使用复制切片或递归）originalSlice := []int&#123;1, 2, 3, 4&#125;shallowCopy := make([]int, len(originalSlice))copy(shallowCopy, originalSlice)deepCopy := append([]int(nil), originalSlice...)// 删除元素index := 1mySlice = append(mySlice[:index], mySlice[index+1:]...)// 查找小写字母containsLowercase := falsefor _, char := range myString &#123; if unicode.IsLower(char) &#123; containsLowercase = true break &#125;&#125;// 遍历切片for _, item := range mySlice &#123; fmt.Println(item)&#125;// 使用循环遍历字典for key, value := range myMap &#123; fmt.Println(key, value)&#125;// 判断字典是否包含键if _, exists := myMap[&quot;name&quot;]; exists &#123; fmt.Println(&quot;Map contains &#x27;name&#x27;&quot;)&#125; C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// C++示例// 数组和向量#include &lt;vector&gt;std::vector&lt;int&gt; myVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; subVector(myVector.begin() + 1, myVector.begin() + 3);std::vector&lt;int&gt; reversedVector(myVector.rbegin(), myVector.rend());// 字典（使用std::map）#include &lt;map&gt;std::map&lt;std::string, int&gt; myMap;myMap[&quot;name&quot;] = &quot;Alice&quot;;myMap[&quot;age&quot;] = 30;// 双向链表（使用std::list）#include &lt;list&gt;std::list&lt;int&gt; myList;myList.push_back(1);myList.push_back(2);myList.push_back(3);// 最大堆和最小堆（使用std::priority_queue）#include &lt;queue&gt;std::priority_queue&lt;int&gt; maxHeap;std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;// 二叉树（使用结构体或指针）// 字符串操作std::string myString = &quot;Hello, World!&quot;;std::string substring = myString.substr(7, 5);int myInt = 42;std::string myStr = std::to_string(myInt);// 深度拷贝和浅拷贝std::vector&lt;int&gt; originalVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; shallowCopy = originalVector;std::vector&lt;int&gt; deepCopy(originalVector);// 删除元素int index = 1;myVector.erase(myVector.begin() + index);// 查找小写字母bool containsLowercase = false;for (char c : myString) &#123; if (std::islower(c)) &#123; containsLowercase = true; break; &#125;&#125;// 遍历向量for (int item : myVector) &#123; std::cout &lt;&lt; item &lt;&lt; std::endl;&#125;// 使用循环遍历字典for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;// 判断字典是否包含键if (myMap.find(&quot;name&quot;) != myMap.end()) &#123; std::cout &lt;&lt; &quot;Map contains &#x27;name&#x27;&quot; &lt;&lt; std::endl;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 136.只出现一次的数字","slug":"eetcode/Leetcode 136.只出现一次的数字","date":"2023-10-16T15:23:24.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-10-16-66afbe22520d.html","link":"","permalink":"https://leiqi.top/2023-10-16-66afbe22520d.html","excerpt":"","text":"Problem: 136. 只出现一次的数字[TOC] 思路 如何才能做到线性时间复杂度和常数空间复杂度呢？ 答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。 任何数和 0做异或运算，结果仍然是原来的数任何数和其自身做异或运算，结果是 0 解题方法 描述你的解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code hash []1234567891011121314func singleNumber(nums []int) int &#123; numsMap := make(map[int]int) for _, val := range nums &#123; numsMap[val] += 1 &#125; for key, val := range numsMap &#123; if val == 1 &#123; return key &#125; &#125; return 0&#125; 位运算 []123456789func singleNumber(nums []int) int &#123; single := 0 for _, num := range nums &#123; single ^= num &#125; return single&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 155.最小栈","slug":"eetcode/leetcode 155.最小栈","date":"2023-10-12T16:07:58.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-10-12-cfa4d16bfad5.html","link":"","permalink":"https://leiqi.top/2023-10-12-cfa4d16bfad5.html","excerpt":"","text":"Problem: 155. 最小栈 思路 栈 解题方法 描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213141516171819202122232425262728293031323334353637383940// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好type MinStack struct &#123; stack []int // 主栈 minStack []int // 辅助栈&#125;func Constructor() MinStack &#123; minStacks := MinStack&#123;[]int&#123;&#125;, []int&#123;math.MaxInt&#125;&#125; return minStacks&#125;func (this *MinStack) Push(x int) &#123; // 同时比较辅助站的的top元素，如果更小 则添加到辅助站 this.stack = append(this.stack, x) minTmp := min(x, this.minStack[len(this.minStack)-1]) this.minStack = append(this.minStack, minTmp)&#125;func (this *MinStack) Pop() &#123; this.stack = this.stack[:len(this.stack)-1] this.minStack = this.minStack[:len(this.minStack)-1]&#125;func (this *MinStack) Top() int &#123; return (this.stack[len(this.stack)-1])&#125;func (this *MinStack) GetMin() int &#123; return (this.minStack[len(this.minStack)-1])&#125;func min(x, y int) int &#123; if x &lt; y &#123; return x &#125; return y&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"使用 Go 的 container list 包：双向链表的便捷工具","slug":"eetcode/使用 Go 的 container list 包：双向链表的便捷工具","date":"2023-10-09T16:44:33.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-10-09-5ecfb18fa495.html","link":"","permalink":"https://leiqi.top/2023-10-09-5ecfb18fa495.html","excerpt":"","text":"Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。 基本概念在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。 导入 container&#x2F;list 包要使用 container&#x2F;list 包，首先需要导入它： 1import &quot;container/list&quot; 创建链表创建一个新的链表非常简单： 1myList := list.New() 这将创建一个名为 myList 的新链表。 插入元素你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头： 12myList.PushBack(42)myList.PushFront(23) 访问元素要访问链表中的元素，你可以使用 Front 和 Back 方法： 12firstElement := myList.Front().ValuelastElement := myList.Back().Value 遍历链表遍历链表可以使用 for 循环来实现： 123for element := myList.Front(); element != nil; element = element.Next() &#123; // 处理 element.Value&#125; 删除元素要删除链表中的元素，可以使用 Remove 方法： 12elementToRemove := myList.Front()myList.Remove(elementToRemove) 容易混淆的地方1. 类型断言链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如： 1value := element.Value.(int) 如果断言失败，会导致运行时错误。 2. InsertAfter 和 InsertBefore这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。 示例：浏览器历史记录下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。 结论container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845. 座位预约管理系统","slug":"eetcode/leetcode 1845. 座位预约管理系统","date":"2023-10-06T04:09:42.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-10-06-c2afb6383992.html","link":"","permalink":"https://leiqi.top/2023-10-06-c2afb6383992.html","excerpt":"","text":"Problem: 1845. 座位预约管理系统 个人博客,记录学习: https://leiqicn.gitee.io/ [TOC] 思路 座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存. 解题方法 使用slice 的index来表示座位号,1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n; 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code使用slice []12345678910111213141516171819202122232425262728293031323334 type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125;使用mapmap 有个用例会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type SeatManager struct &#123; seatMap map[int]int minSeat int&#125;func Constructor(n int) SeatManager &#123; seatMap := make(map[int]int, n+1) for i := 0; i &lt;= n; i++ &#123; // 注意从0 开始初始化 seatMap[i] = 0 &#125; seatMan := SeatManager&#123; seatMap, 1, &#125; return seatMan&#125;func (this *SeatManager) Reserve() int &#123; value := this.minSeat this.seatMap[value] = 1 for i:= value; i &lt;= len(this.seatMap);i++ &#123; if this.seatMap[i] == 1 &#123; continue &#125; this.minSeat = i break &#125; return value&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seatMap[seatNumber] = 0 if seatNumber &lt; this.minSeat &#123; this.minSeat = seatNumber &#125;&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 中是否使用make创建slice的区别","slug":"olang/Go 中是否使用make创建slice的区别","date":"2023-10-05T09:01:37.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-10-05-9d3185fd2258.html","link":"","permalink":"https://leiqi.top/2023-10-05-9d3185fd2258.html","excerpt":"","text":"go slice 的make 会创建默认长度 且值为0 的slice 在 Go 语言中，可以使用 make 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 make 和不使用 make 创建切片的主要区别： 使用 make 创建切片： 12// 使用 make 创建切片，指定长度和容量 slice := make([]int, 5, 10) 指定长度和容量： 使用 make 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。 底层数组初始化： 使用 make 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，slice 是一个包含5个零值整数的切片。 不使用 make 创建切片： 12// 不使用 make 创建切片，长度为 5 slice := []int&#123;1, 2, 3, 4, 5&#125; &#96; 自动确定长度： 不使用 make 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，slice 的长度是5，因为提供了5个整数。 容量与长度相同： 如果不使用 make 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。 总结： 使用 make 创建切片时，您可以明确控制切片的容量，并按长度初始化为0值，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。 不使用 make 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。 无论使用哪种方式创建切片，都可以使用 append 函数来动态增长切片的长度。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"JetBrians 全家桶设置文件header","slug":"具/JetBrians 全家桶设置文件header","date":"2023-10-05T08:41:46.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-10-05-7527c8e47a8b.html","link":"","permalink":"https://leiqi.top/2023-10-05-7527c8e47a8b.html","excerpt":"","text":"前言我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。 先看下效果图 操作步骤1. file- settings 找到Copyright - CopyrightProfiles点击+ 号，新建一个name 为“copyRight” 的profile profile 的内容粘贴下面的问文本, 替换自己的名字 1234Copyright (c) $originalComment.match(&quot;Copyright \\(c\\) (\\d+)&quot;, 1, &quot;-&quot;, &quot;$today.year&quot;)$today.year YOUR NAME. All rights reserved. Author: YOUR NAME Description: Date: $today 点击Copyright 添加刚才的profile 点击应用即可 右键-generate-Copyright 插入","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Leetcode1603. 设计停车系统","slug":"eetcode/Leetcode 1603. 设计停车系统","date":"2023-09-26T17:09:22.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-09-26-aeddfdb3bdac.html","link":"","permalink":"https://leiqi.top/2023-09-26-aeddfdb3bdac.html","excerpt":"","text":"Problem: 1603. 设计停车系统 [TOC] 思路 首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。 虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。 解题方法 lastCar [3]int 添加上边的数组 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code []12345678910111213141516171819202122232425262728293031 type ParkingSystem struct &#123; lastCar [3]int&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; var parkingSystem ParkingSystem parkingSystem.lastCar[0] = big parkingSystem.lastCar[1] = medium parkingSystem.lastCar[2] = small return parkingSystem&#125;func (this *ParkingSystem) AddCar(carType int) bool &#123; carIdx := carType - 1 if this.lastCar[carIdx] &gt; 0 &#123; this.lastCar[carIdx]-- return true &#125; return false&#125;/** * Your ParkingSystem object will be instantiated and called as such: * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver） * param_1 := obj.AddCar(carType); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Linux非root用户通过X11运行图形界面程序-以Rstudio为例","slug":"具/Linux非root用户通过X11运行图形界面程序-以Rstudio为例","date":"2023-09-24T12:36:53.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-09-24-4fe5badbd053.html","link":"","permalink":"https://leiqi.top/2023-09-24-4fe5badbd053.html","excerpt":"","text":"问题由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！ X11是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。 操作步骤 使用mobaxTerm 登录对应服务器，需要显示X11 打开 创建虚拟环境1234567# 创建虚拟环境 conda create -n rstudio# 安装Ｒconda activate rstudio # 进入创建好的环境变量conda install r-base# 安装Rstudioconda install rstudio-desktop 成功 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面 画个图试试，顺利出图！开始愉快的coding吧！ 已知问题： 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。 总结我们可以通过X11来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 将用户追加到对应用户组","slug":"inux/Linux 将用户追加到对应用户组,新建文件默认同组读写权限","date":"2023-09-17T06:02:54.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-09-17-5141f57450ab.html","link":"","permalink":"https://leiqi.top/2023-09-17-5141f57450ab.html","excerpt":"","text":"前言本文目的是为了将多个用户设置同组用户，并且同组内用户新建文件的默认权限是同组内用户可读写。 解决方案 将test 添加到GroupA 1234usermod -a -G GroupName UserName# 例如将test 追加到GroupAusermod -a -G GroupA test 修改新建文件的默认权限 在.bashrc 里添加 1umask 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--) 1source ~/.bashrc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[]},{"title":"C++ 结构化设计","slug":"++/C++ 结构化设计","date":"2023-09-13T15:21:57.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-09-13-476441b87811.html","link":"","permalink":"https://leiqi.top/2023-09-13-476441b87811.html","excerpt":"","text":"结构化程序设计自顶向下的设计 是自顶向下的分解 -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题 实现阶段自顶向上的实现，实现一个一个子问题 程序由三种基本结构组成，顺序-分支-循环 例子","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"clash在终端设置代理","slug":"具/clash在终端设置代理","date":"2023-09-12T15:38:32.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-09-12-b926f621cf15.html","link":"","permalink":"https://leiqi.top/2023-09-12-b926f621cf15.html","excerpt":"","text":"前言github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！ 开启代理前置条件：手动开打 clash 等VPN软件 12export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890 对应的网址是在settings- static-Host; 对应port 为General-Prot 取消代理12unset http_proxyunset http_proxy git 里设置开启代理 alias 命令别名新建 .bashrc123456789101112131415161718cd ~vi .bashrc# 将以下内容复制进去# .bashrc# Source global definitionsif [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrcfi# Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:# export SYSTEMD_PAGER=# User specific aliases and functions// 别名设置，其他别名设置也是类似alias proxyon=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;alias proxyoff=&quot;unset http_proxy;unset https_proxy&quot; 测试是否成功可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 2594修车的最少时间","slug":"eetcode/leetcode 2594修车的最少时间","date":"2023-09-07T15:59:00.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-09-07-b8c038c07b41.html","link":"","permalink":"https://leiqi.top/2023-09-07-b8c038c07b41.html","excerpt":"","text":"2594. 修车的最少时间 - 力扣（LeetCode） 思路能力值为 r 的机械工可以在 t&#x3D; r * n2 分钟内修好 n 辆车。可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。 12345678910111213141516171819202122func repairCars(ranks []int, cars int) int64 &#123; l , r := 1, ranks[0] * cars * cars var check = func(m int) bool &#123; cnt := 0 for _, x := range ranks &#123; cnt += int(math.Sqrt(float64(m / x))) &#125; return cnt &gt;= cars &#125; for l &lt; r &#123; m := (l + r) &gt;&gt; 1 if check(m) &#123; r = m &#125; else &#123; l = m + 1 &#125; &#125; return int64(l)&#125; l 和 r 的初始化： l 初始化为1，表示最小可能的修理时间。 r 初始化为 ranks[0] * cars * cars，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。 check 函数定义： 这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 m 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 m 时间内能修理多少辆车，然后累加到 cnt 变量中。 如果 cnt 大于或等于需要修理的汽车数量 cars，则返回 true，否则返回 false。 二分查找循环： 使用一个二分查找循环来查找最小的修理时间。循环条件是 l &lt; r，即当最小时间小于最大时间时，继续循环。 在每次循环中，计算中间值 m，并调用 check(m) 检查是否满足修理所有汽车的条件。 如果满足条件，则将 r 更新为 m，因为我们希望找到更小的修理时间。 如果不满足条件，则将 l 更新为 m + 1，因为我们需要增加修理时间。 这样，不断地缩小时间范围，直到找到最小的修理时间。 最终返回结果： 一旦 l 不再小于 r，循环结束，说明已经找到了最小的修理时间，将其转换为 int64 类型并返回。 我们总结一下二分查找适用的场景 二分查找算法适用场景递增或递减规律：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。 有序数据集合：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。 快速查找：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。 确定性问题：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。 时间复杂度要求较高：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。 可比较性数据：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。 搜索范围可确定：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。 内存连续性：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。 一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"设计模式-抽象工厂","slug":"计模式/设计模式-抽象工厂","date":"2023-09-03T12:39:19.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2023-09-03-c6ab66461699.html","link":"","permalink":"https://leiqi.top/2023-09-03-c6ab66461699.html","excerpt":"","text":"抽象工厂模式结构多个工厂模式; 有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式-工厂方法模式","slug":"计模式/设计模式-工厂方法模式","date":"2023-09-03T05:09:25.000Z","updated":"2025-04-11T05:09:01.869Z","comments":true,"path":"2023-09-03-c58ee0dac51b.html","link":"","permalink":"https://leiqi.top/2023-09-03-c58ee0dac51b.html","excerpt":"","text":"网站链接：工厂方法设计模式 (refactoringguru.cn) 简介工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。 简单工厂‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间. 工厂方法模式结构不同的类实现相同的动作,例如运输等 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 具体产品 （Concrete Products） 是产品接口的不同实现。 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。 注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 伪代码基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。 如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。 如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。 你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 简单工厂和工厂模式的区别1. 简单工厂设计模式（Simple Factory Design Pattern）： 定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。2. 工厂方法设计模式（Factory Method Design Pattern）： 定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。结构： 工厂方法模式包括抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。主要区别： 复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。 责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。 扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。 灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。 选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。 UML类图如何看看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。” 接口: ‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口. 类和类之间的关系: 继承的关系，继承关系用空心三角形+实线来表示 聚合: 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。 合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。 依赖","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"leetcode 2511 最多可以摧毁的敌人城堡数目","slug":"eetcode/leetcode 2511 最多可以摧毁的敌人城堡数目","date":"2023-09-02T12:51:41.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-09-02-72954cc13c19.html","link":"","permalink":"https://leiqi.top/2023-09-02-72954cc13c19.html","excerpt":"","text":"2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode） 思路抽象出来就是求1和-1间最大连续0 的数量。 有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？ 1.当然可以分类讨论，代码会很复杂，判断很多，容易出错 使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res 12345678910111213141516171819202122232425262728293031323334353637383940func captureForts(forts []int) int &#123; ans, pre := 0, -1 //pre 记录的是 1 或 -1 的位置 for i, fort := range forts &#123; if fort == -1 || fort == 1 &#123; if pre &gt;= 0 &amp;&amp; forts[pre] != fort &#123; ans = max(ans, i - pre - 1) &#125; pre = i &#125; &#125; return ans&#125; func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LRU","slug":"eetcode/LRU","date":"2023-08-07T15:29:00.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-08-07-e74632bdccbf.html","link":"","permalink":"https://leiqi.top/2023-08-07-e74632bdccbf.html","excerpt":"","text":"146. LRU 缓存 - 力扣（LeetCode） list Elemet 双向列表； 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &quot;container/list&quot;type LRUCache struct &#123; cap int // 缓存容量 cache map[int]*list.Element//!!! 双向链表 使用Element // 双向链表节点 指向的map list *list.List // 双向链表&#125;type keyVal struct &#123; key, val int // 节点的Key和Value&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cap: capacity, // 初始化缓存容量 cache: make(map[int]*list.Element), // 初始化map映射 list: list.New(), // 初始化双向链表 &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 return elem.Value.(*keyVal).val // 返回节点的value值 &#125; return -1 // 没有找到的情况下，返回-1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 //!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值； elem.Value.(*keyVal).val = value // 更新节点的value值 return &#125; if this.list.Len() &gt;= this.cap &#123; // 如果超过了缓存容量 tail := this.list.Back() // 获取链表的尾节点 k := tail.Value.(*keyVal).key // 获取节点的key this.list.Remove(tail) // 从链表中删除尾节点 delete(this.cache, k) // 从map中删除尾节点 &#125; elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) // 将节点添加到链表头 this.cache[key] = elem // 将节点映射到map中&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 最大深度和最小深度","slug":"eetcode/leetcode 最大深度和最小深度","date":"2023-07-29T15:46:22.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-07-29-4df215f63090.html","link":"","permalink":"https://leiqi.top/2023-07-29-4df215f63090.html","excerpt":"","text":"题目104. 二叉树的最大深度 - 力扣（LeetCode） 111. 二叉树的最小深度 - 力扣（LeetCode） 思路深度 是指从根节点到该节点的距离（节点数量）高度 是指从该节点到叶子节点的角力（节点数量） 最大深度 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)最小子树 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现： 最大深度递归分治后序遍历 需要调用自生函数，需要严格按照定义调用递归。 1234567891011121314151617// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := maxDepth(root.Right) leftMaxDepth := maxDepth(root.Left) return 1 + max(rightMaxDepth,leftMaxDepth)&#125;func max(a,b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 迭代 层序遍历1234567891011121314151617181920212223242526// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 最小深度递归后序遍历 12345678910111213141516171819202122232425262728293031// 定义：输入根节点，返回这棵二叉树的最小深度func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := minDepth(root.Right) leftMaxDepth := minDepth(root.Left) // 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论 if root.Right == nil &amp;&amp; root.Left !=nil &#123; return 1 + leftMaxDepth // 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。 &#125; if root.Left == nil &amp;&amp; root.Right !=nil &#123; return 1 + rightMaxDepth &#125; return 1 + min(rightMaxDepth,leftMaxDepth)&#125; func min(a,b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 迭代 层序遍历123456789101112131415161718192021222324252627282930func minDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; if top.Right == nil &amp;&amp; top.Left == nil &#123; return depth + 1 // 当前节点也算哦 &#125; &#125; depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go语言中的byte类型与Unicode码点与整数的转换","slug":"eetcode/Go语言中的byte类型与Unicode码点与整数的转换","date":"2023-07-09T14:22:16.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-07-09-dda1c4b9508f.html","link":"","permalink":"https://leiqi.top/2023-07-09-dda1c4b9508f.html","excerpt":"","text":"byte类型与Unicode码点的转换在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。 当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; b := byte(&#x27;A&#x27;) i := int(b) fmt.Printf(&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\\n&quot;, b, b, i)&#125; 在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下： 1Byte: A, Unicode码点: 65, 转换后的整数: 65 可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。 byte类型与整数的转换之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。 123456789101112package main import ( &quot;fmt&quot; ) func main() &#123; ch := &#x27;0&#x27; num := int(ch - &#x27;0&#x27;) fmt.Printf(&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\\n&quot;, ch, ch, num) &#125; 在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下： 1字符: 0, unicode码点或者byte对应的数值: 48, 转换后的整数: 0 可以看到，字符 ‘0’ 成功转换为整数 0。其中需要注意的是：在Go语言中，格式化输出时 %c 是一个占位符，用于表示要输出的值是一个Unicode字符。具体来说，%c 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48 这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。 总结byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Mesh组网：家庭路由和无线连接新方式","slug":"络/Mesh组网：家庭路由和无线连接新方式","date":"2023-06-25T14:24:32.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-06-25-a45e5f4edabc.html","link":"","permalink":"https://leiqi.top/2023-06-25-a45e5f4edabc.html","excerpt":"","text":"在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。 what Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。 how Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释： 设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。 路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。 中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。 自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。 why 为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择： 扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。 提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。 可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。 鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。 应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。 与桥接路由对比 Mesh组网： 概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。 特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。 优点： 扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。 鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。 简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。 缺点： 延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。 多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。 网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。 桥接路由： 概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。 特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。 优点： 低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。 单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。 集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。 缺点： 单点故障：中央路由器的故障可能导致整个网络失去连接。 限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。 扩展性：增加节点时，可能需要重新配置和调整网络结构。 结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"链表总结","slug":"eetcode/链表总结","date":"2023-06-24T16:15:32.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-06-24-42b41b131ba0.html","link":"","permalink":"https://leiqi.top/2023-06-24-42b41b131ba0.html","excerpt":"","text":"链表的合并 虚拟头节点 拉拉链 1234567891011121314151617181920212223242526272829303132func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy p1 := l1 p2 := l2 for p1 != nil &amp;&amp; p2 != nil &#123; // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if p1.Val &gt; p2.Val &#123; p.Next = p2 p2 = p2.Next &#125; else &#123; p.Next = p1 p1 = p1.Next &#125; // p 指针不断前进 p = p.Next &#125; if p1 != nil &#123; p.Next = p1 &#125; if p2 != nil &#123; p.Next = p2 &#125; return dummy.Next&#125; 链表的拆分 初始化两个链表，分别添加 合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next 合并 12345678910111213141516171819202122232425262728293031func partition(head *ListNode, x int) *ListNode &#123; // 存放小于 x 的链表的虚拟头结点 dummy1 := &amp;ListNode&#123;-1, nil&#125; // 存放大于等于 x 的链表的虚拟头结点 dummy2 := &amp;ListNode&#123;-1, nil&#125; // p1, p2 指针负责生成结果链表 p1, p2 := dummy1, dummy2 // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 p := head for p != nil &#123; if p.Val &gt;= x &#123; p2.Next = p p2 = p2.Next &#125; else &#123; p1.Next = p p1 = p1.Next &#125; // 断开原链表中的每个节点的 next 指针 temp := p.Next p.Next = nil p = temp &#125; // 连接两个链表 p1.Next = dummy2.Next return dummy1.Next&#125; k 链表合并 最小堆 go语言的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162type ListNode struct &#123; Val int Next *ListNode&#125;func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy // 优先级队列，最小堆 pq := make(PriorityQueue, 0) heap.Init(&amp;pq) // 将 k 个链表的头结点加入最小堆 for _, head := range lists &#123; if head != nil &#123; heap.Push(&amp;pq, head) &#125; &#125; for pq.Len() &gt; 0 &#123; // 获取最小节点，接到结果链表中 node := heap.Pop(&amp;pq).(*ListNode) p.Next = node if node.Next != nil &#123; heap.Push(&amp;pq, node.Next) &#125; // p 指针不断前进 p = p.Next &#125; return dummy.Next&#125;type PriorityQueue []*ListNodefunc (pq PriorityQueue) Len() int &#123; return len(pq)&#125;func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].Val &lt; pq[j].Val&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i]&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; node := x.(*ListNode) *pq = append(*pq, node)&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) node := old[n-1] *pq = old[0 : n-1] return node&#125; 倒数K链表 n 是包含nil 的 一个fast 去探路，先走k步 slow 和fast 一起走 当fast为nil 时，到达k ,赋值为next.next 即可 1234567891011121314151617181920212223242526272829// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.Next = x.Next.Next return dummy.Next&#125; // 返回链表的倒数第 k 个节点func findFromEnd(head *ListNode, k int) *ListNode &#123; p1 := head // p1 先走 k 步 for i := 0; i &lt; k; i++ &#123; p1 = p1.Next &#125; p2 := head // p1 和 p2 同时走 n - k 步 for p1 != nil &#123; p1 = p1.Next p2 = p2.Next &#125; // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2&#125; 倒数K链表移除复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可 1234567891011121314// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.next = x.next.next return dummy.next&#125; func findFromEnd(head *ListNode, k int) *ListNode &#123; // 代码见上文&#125; 移除中间链表876. 链表的中间结点 - 力扣（LeetCode） slow 走一步，fast走两步 fast nil，slow 为中间每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 1234567891011121314func middleNode(head *ListNode) *ListNode &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 // for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步 for fast!= nil &amp;&amp; fast.Next != nil&#123; // 应该修改为这个，slow 会停在中点右边第二个部分 // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next &#125; // 慢指针指向中点 return slow&#125; 判断链表是否成环 slow 走一步，fast走两步 fast 和slow 相遇则成环，fast 遇到nil 则不成环。 1234567891011121314151617func hasCycle(head *ListNode) bool &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 for fast != nil &amp;&amp; fast.Next != nil &#123; // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，说明含有环 if slow == fast &#123; return true &#125; &#125; // 不包含环 return false&#125; labuladong","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"数组双指针刷题总结","slug":"eetcode/数组双指针刷题总结","date":"2023-06-22T14:01:13.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-06-22-079d0af75447.html","link":"","permalink":"https://leiqi.top/2023-06-22-079d0af75447.html","excerpt":"","text":"双指针技巧分为快慢指针和左右指针 快慢指针 原地修改数组 遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++ 去除有序数组&#x2F;链表中去重 和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast] 左右指针1.二分查找 * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界2.N sum 之和 * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大3.反转字符串 * 终止条件是i&gt;j4.回文串判断 * 判断条件s[i] &#x3D;&#x3D; s[j]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1170. 比较字符串最小字母出现频次","slug":"eetcode/leetcode 1170. 比较字符串最小字母出现频次","date":"2023-06-14T15:28:09.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-06-14-88f65f0a1bb7.html","link":"","permalink":"https://leiqi.top/2023-06-14-88f65f0a1bb7.html","excerpt":"","text":"1170. 比较字符串最小字母出现频次 - 力扣（Leetcode） 后缀和（Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。 具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。 在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。 不使用后缀和1234567891011121314151617181920212223242526272829303132func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量 for _, s := range words &#123; count[f(s)] += 1 &#125; res := make([]int, len(queries)) for i, s := range queries &#123; for idx, c := range count &#123; // 遍历count if c&gt;0 &amp;&amp; f(s) &lt; idx &#123;// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c res[i]+=c &#125; &#125; &#125; return res&#125; 使用后缀和12345678910111213141516171819202122232425262728293031func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 for _, s := range words &#123; count[f(s)] += 1 &#125; // 计算后缀和,i+1 就是大于i位置的所有个数 for i := 9; i &gt;= 1; i-- &#123; count[i] += count[i + 1] &#125; res := make([]int, len(queries)) for i, s := range queries &#123; res[i] = count[f(s) + 1] &#125; return res&#125; 为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？ 在numSmallerByFrequency函数中， count数组记录的是各个不同频次出现的次数，因此 count[i]代表所有最小字母出现频次不于 i 的字符串的数量。 如果对于 queries 中的某个字符串 s ，它的最小字母出现频次为 f(s)，那么可以依据 count 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 f(s)+1 开始的所有频次出现次数即可： res[i] = count[f(s) + 1] 这里使用的是 f(s)+1 而不是 f(s) 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"什么是二进制的按位或和按位异或","slug":"olang/什么是二进制的按位或和按位异或","date":"2023-06-08T15:59:19.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-06-08-3d1c210a715f.html","link":"","permalink":"https://leiqi.top/2023-06-08-3d1c210a715f.html","excerpt":"","text":"按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！ 按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下 123456input bit a | input bit b | output ------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 1 例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111): 12345 110| 011----- 111 按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下： 1234567input bit a | input bit b | output------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 0 12345 110^ 011----- 101 总结按位或，就是只要有1 就为1 (包含了1 1 ；0 1；1 0；三种)按位异或，必须一个0一个1，才为1 （包含0 1；1 0；两种）大家记住了吗？","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 2460.对数组执行操作 2023.05.06每日一题","slug":"eetcode/leetcode 2460.对数组执行操作 2023.05.06每日一题","date":"2023-06-05T14:46:05.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-06-05-869070f8049d.html","link":"","permalink":"https://leiqi.top/2023-06-05-869070f8049d.html","excerpt":"","text":"2460. 对数组执行操作 - 力扣（Leetcode） 思路直接模拟 Code第一版时间复杂度：O(n)空间复杂度：O(n) 123456789101112131415161718192021func applyOperations(nums []int) []int &#123; var res []int res = make([]int, len(nums)) index := 0 // 第一次遍历 进行赋值操作 for i := 0; i &lt; len(nums)-1; i++ &#123; if nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i+1] = 0 &#125; &#125; // 第二次遍历 将非0移动到前边 for i := 0; i &lt; len(nums); i++ &#123; if nums[i] != 0 &#123; res[index] = nums[i] index++ &#125; &#125; return res&#125; 第二版时间复杂度：O(n)空间复杂度：O(1) 12345678910111213141516func applyOperations(nums []int) []int &#123; n := len(nums) j := 0 for i := 0; i &lt; n; i++ &#123; if i+1 &lt; n &amp;&amp; nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i + 1] = 0 &#125; if nums[i] != 0 &#123; nums[i], nums[j] = nums[j], nums[i] j++ &#125; &#125; return nums&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 28.找出字符串中第一个匹配项的下标","slug":"eetcode/leetcode 28.找出字符串中第一个匹配项的下标","date":"2023-05-31T14:27:00.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-31-396a1cd3c61e.html","link":"","permalink":"https://leiqi.top/2023-05-31-396a1cd3c61e.html","excerpt":"","text":"28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode） 简单解法利用split 函数，判断是否能够拆分，如果 12345678910111213func strStr(haystack string, needle string) int &#123; // 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片 splitList := strings.Split(haystack, needle) // 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1 if len(splitList)== 1 &amp;&amp; needle!=haystack &#123; return -1 &#125; if len(splitList) &gt; 1 &#123; return len(splitList[0]) &#125; // needle 在haystack的最开头，返回0 return 0&#125; 123456789101112 func main() &#123; haystack := &quot;good&quot; needle := &quot;go&quot; splitList := strings.Split(haystack, needle) // 如果在首位相同，前边会有个空字符串。 fmt.Println(splitList, len(splitList)) fmt.Println(&quot;tmp:&quot;, splitList[0]) &#125;// [&quot;&quot; &quot;od&quot;] 2 双指针解法朴素解法直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配： 匹配成功：返回本次匹配的原串「发起点」。匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。 12345678910111213141516171819202122func strStr(haystack string, needle string) int &#123; cur := 0 for cur &lt; len(haystack) &#123; p1 := cur p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return cur &#125; cur++ &#125; return -1&#125; 可以修改为for 循环 1234567891011121314151617181920212223func strStr(haystack string, needle string) int &#123; if len(haystack) &lt; len(needle) &#123; return -1 &#125; for i:= 0; i &lt; len(haystack); i++ &#123; p1 := i p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return i &#125; &#125; return -1&#125; TODO KMP 算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 104.二叉树的深度","slug":"eetcode/leetcode 104.二叉树的深度","date":"2023-05-30T15:33:48.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-30-b1879d2b65d1.html","link":"","permalink":"https://leiqi.top/2023-05-30-b1879d2b65d1.html","excerpt":"","text":"个人网站：https://leiqicn.gitee.io/categories/leetcode/104. 二叉树的最大深度 - 力扣（Leetcode） 二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。 所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。 递归123456789101112131415func max (a, b int) int &#123; if a &gt; b &#123; return a; &#125; return b;&#125;// 递归func maxdepth(root *treenode) int &#123; if root == nil &#123; return 0; &#125; return max(maxdepth(root.left), maxdepth(root.right)) + 1;&#125; 迭代法可以使用模板层序遍历 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */import &quot;container/list&quot;func maxDepth(root *TreeNode) int &#123; depth := 0 if root == nil &#123; return 0 &#125; queue := list.New() queue.PushBack(root) for queue.Len() &gt; 0 &#123; size := queue.Len() for i := 0; i &lt; size; i++ &#123; // 切掉第一个元素 first := queue.Remove(queue.Front()).(*TreeNode) //注意层序遍历是切掉前边一个 if first.Left != nil &#123; queue.PushBack(first.Left) &#125; if first.Right != nil &#123; queue.PushBack(first.Right) &#125; &#125; depth++ &#125; return depth&#125; 切片实现12345678910111213141516171819202122232425262728// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 使用一个临时切片来存储当前层所有节点的子节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; // 使用切片实现队列 var queue []*TreeNode queue = append(queue, root) depth := 0 for len(queue) &gt; 0 &#123; // 当前层的节点数量 size := len(queue) // 使用一个临时切片来存储当前层所有节点的子节点 var nextLevel []*TreeNode for i := 0; i &lt; size; i++ &#123; // 从队列头部移除节点 node := queue[0] queue = queue[1:] // 移除队列的第一个元素 // 将左子树和右子树添加到下一层的队列 if node.Left != nil &#123; nextLevel = append(nextLevel, node.Left) &#125; if node.Right != nil &#123; nextLevel = append(nextLevel, node.Right) &#125; &#125; // 将下一层的节点赋值给当前层的队列 queue = nextLevel // 每次循环处理一层的节点 depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"leetcode 122买动态股票的最佳时机II","slug":"eetcode/leetcode 122买动态股票的最佳时机II","date":"2023-05-27T15:51:57.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-27-5cebfed1675b.html","link":"","permalink":"https://leiqi.top/2023-05-27-5cebfed1675b.html","excerpt":"","text":"122. 买卖股票的最佳时机 II - 力扣（Leetcode） 每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。 相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。 下面是代码解释： 首先定义变量 sum 记录当前总利润。然后从第二个价格开始遍历，计算当日价格与前一天价格之差。如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。最后返回累计的总利润。这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1091.二进制矩阵中的最短路径","slug":"eetcode/leetcode 1091.二进制矩阵中的最短路径","date":"2023-05-26T15:35:54.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-26-5abcbf266873.html","link":"","permalink":"https://leiqi.top/2023-05-26-5abcbf266873.html","excerpt":"","text":"1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）DFS 超时版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type point struct &#123; x int y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; n := len(grid) if grid[0][0] == 1 || grid[n-1][n-1] == 1 &#123; return -1 &#125; res := 0 dirs := [][]int&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125; var help func(i, j, tmp int) help = func(i, j, tmp int) &#123; // 判断是否越界或已经访问过当前节点 if i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n || grid[i][j] == 1 &#123; return &#125; if i == n-1 &amp;&amp; j == n-1 &#123; // 当到达终点时，更新res if tmp+1 &lt; res || res == 0 &#123; res = tmp + 1 &#125; return &#125; // 将当前点标记为已访问 grid[i][j] = 1 tmp++ for _, item := range dirs &#123; x := i + item[0] y := j + item[1] help(x, y, tmp) &#125; // 回溯操作，将当前点复原为未访问状态 grid[i][j] = 0 &#125; help(0, 0, 0) if res == 0 &#123; return -1 &#125; return res&#125; BFS，最短路径使用BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type point struct &#123; x,y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; // queue 维护 m,n := len(grid),len(grid[0]) visited := make(map[point]int) queue := make([]point,0) step := 1 start := point&#123;0,0&#125; end := point&#123;m-1,n-1&#125; dirs := []point&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125; // 起点为1 则直接返回 if grid[0][0] == 1 &#123; return -1 &#125; queue = append(queue,start) visited[start] = 1 for len(queue) &gt; 0 &#123; size := len(queue) // 将当前队列中的所有节点向四周扩散 for i:=0; i &lt; size; i++&#123; cur := queue[0] // 当前cur queue = queue[1:] // 切掉当前点 // 判断是否是终点 if cur == end &#123; return step &#125; // 遍历八个方向 判断是否符合边界条件 for _, dir :=range dirs&#123; newX := cur.x + dir.x newY := cur.y + dir.y newPoint := point&#123;newX,newY&#125; if newX &gt;=0 &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=0 &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==0 &amp;&amp; grid[newX][newY]==0 &#123; visited[point&#123;newX,newY&#125;] = 1 queue =append(queue,newPoint) &#125; &#125; &#125; step++ &#125; // 只能为0 的路径才可以更新到queue 边界控制 return -1&#125; &gt; 1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）### 解题思路 典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。 &gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？ 1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。 &gt; ### BFS解法中的visited为什么可以全局使用？ BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"leetcode 53.最大子数和","slug":"eetcode/leetcode 53.最大子数和","date":"2023-05-25T15:08:24.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-25-8fc7b96cd054.html","link":"","permalink":"https://leiqi.top/2023-05-25-8fc7b96cd054.html","excerpt":"","text":"Problem: 53. 最大子数组和 个人网站： https://leiqicn.gitee.io/categories/leetcode/[TOC] 思路 这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。 解题方法 方法1 算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。 方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums0; 遍历顺序，从idx &#x3D; 1 开始遍历。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code[]123456789101112131415161718192021222324252627282930313233// 方法1 func maxSubArray(nums []int) int &#123; count := 0 res := math.MinInt32 for i := 0; i &lt; len(nums); i++ &#123; count += nums[i] if count &gt; res &#123; res = count &#125; if count &lt; 0 &#123; count = 0 &#125; &#125; return res&#125;// 方法2 使用了类似动态规划的思想// 定义 nums[i] 当前元素，nums[i-1] 前序列之和func maxSubArray(nums []int) int &#123; max := nums[0] //初始化最大值为前边一个元素 // 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。 for i:= 0 ;i &lt;len(nums)-1; i++ &#123; if nums[i+1] + nums[i] &gt; nums[i+1] &#123; nums[i+1] = nums[i+1] + nums[i] &#125; // 超过最大值，则更新 if nums[i+1] &gt; max &#123; max = nums[i+1] &#125; &#125; return max&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"go语言-回调函数（钩子）","slug":"olang/go语言-回调函数（钩子）","date":"2023-05-25T13:56:41.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-05-25-2cbe3a05ec00.html","link":"","permalink":"https://leiqi.top/2023-05-25-2cbe3a05ec00.html","excerpt":"","text":"在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。 以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func printWithCallback(callback func(string)) &#123; text := &quot;Hello, world!&quot; fmt.Println(text) callback(text)&#125;func main() &#123; callback := func(text string) &#123; fmt.Printf(&quot;Printed: %s\\n&quot;, text) &#125; printWithCallback(callback)&#125; 以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。 当程序运行起来后，会输出如下内容： 12Hello, world!Printed: Hello, world! 这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。 对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;time&quot;)func TimeElapsedCallback(start time.Time) &#123; elapsed := time.Now().Sub(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func heavyCalculation(callback func(time.Time)) &#123; start := time.Now() // 这里进行任何需要测量时间的操作 callback(start)&#125;func main() &#123; heavyCalculation(TimeElapsedCallback)&#125; 在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。 在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容： Time elapsed: 1.001201ms以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。 回调函数的不同以下是不使用回调函数的方式实现计算程序执行时间的示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func heavyCalculation() &#123; start := time.Now() // 这里进行任何需要测量时间的操作 elapsed := time.Since(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func main() &#123; heavyCalculation()&#125; 和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。 在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。 当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。 使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。 而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。 钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。 以下是使用回调函数的优点：灵活性：可以轻松地将自定义代码插入到已有的代码流程中。可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 376.摆动序列","slug":"eetcode/leetcode 376.摆动序列","date":"2023-05-23T17:05:07.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-23-7b5e53100757.html","link":"","permalink":"https://leiqi.top/2023-05-23-7b5e53100757.html","excerpt":"","text":"376. 摆动序列 - 力扣（Leetcode） 12345678910111213141516171819func wiggleMaxLength(nums []int) int &#123; var count, preDiff, curDiff int count = 1 // 初始化计数为1，至少有一个数字是有效的 if len(nums) &lt; 2 &#123; return count // 如果数组长度小于2，直接返回计数值 &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; curDiff = nums[i+1] - nums[i] // 计算当前数字之间的差值 // 根据差值的正负和前一个差值的正负进行判断 // 如果满足摆动序列的条件，更新前一个差值和计数值 if (curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) &#123; preDiff = curDiff count++ &#125; &#125; return count // 返回最终的计数值&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 226. 翻转二叉树","slug":"eetcode/leetcode 226. 翻转二叉树","date":"2023-05-23T15:06:25.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-23-d59f64e0619b.html","link":"","permalink":"https://leiqi.top/2023-05-23-d59f64e0619b.html","excerpt":"","text":"226. 翻转二叉树 - 力扣（Leetcode） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ // 定义将二叉树翻转func invertTree(root *TreeNode) *TreeNode &#123; // 递归终止条件 if root == nil &#123; return nil &#125; // 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点 root.Right,root.Left = root.Left,root.Right // 将右子树翻转 invertTree(root.Right) // 将左子树翻转 invertTree(root.Left) return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 144. 二叉树的前序遍历","slug":"eetcode/leetcode 144. 二叉树的前序遍历","date":"2023-05-23T14:49:08.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-23-62bd8ef029a5.html","link":"","permalink":"https://leiqi.top/2023-05-23-62bd8ef029a5.html","excerpt":"","text":"144. 二叉树的前序遍历 - 力扣（Leetcode） 记得提前判断是否为空，否则会报找不到内存指针的错误 注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。leetcode 102. 二叉树的层序遍历 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; stack := list.New() res := []int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; stack.PushBack(root) for stack.Len() &gt; 0 &#123; top := stack.Remove(stack.Back()).(*TreeNode) res = append(res,top.Val) if top.Right !=nil &#123; stack.PushBack(top.Right) &#125; if top.Left !=nil &#123; stack.PushBack(top.Left) &#125; &#125; return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 102. 二叉树的层序遍历","slug":"eetcode/leetcode 102. 二叉树的层序遍历","date":"2023-05-23T14:46:19.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-05-23-a419f5d1c6af.html","link":"","permalink":"https://leiqi.top/2023-05-23-a419f5d1c6af.html","excerpt":"","text":"102. 二叉树的层序遍历 - 力扣（Leetcode） 使用slice123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; // 层序遍历 使用size 记录每层数组 queue node 队列 res := make([][]int, 0) queue := make([]*TreeNode, 0) if root != nil &#123; queue = append(queue, root) &#125; else &#123; return res &#125; for len(queue) != 0 &#123; size := len(queue) levels := make([]int, 0) for i:= 0; i &lt; size; i++ &#123; node := queue[0] queue = queue[1:len(queue)] //切掉元素0 levels = append(levels, node.Val) // 添加元素 if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; res = append(res, levels) &#125; return res&#125; 使用list123456789101112131415161718192021222324252627func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; queue := &amp;list.List&#123;&#125; queue.PushBack(root) for queue.Len() &gt; 0 &#123; length := queue.Len() //保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） var levelQueue []int fmt.Println(length) for i := 0; i &lt; length; i++ &#123; node := queue.Remove(queue.Front()).(*TreeNode) //出队列 if node.Left != nil &#123; queue.PushBack(node.Left) &#125; if node.Right != nil &#123; queue.PushBack(node.Right) &#125; levelQueue = append(levelQueue, node.Val) //将值加入本层切片中 &#125; res = append(res, levelQueue) //放入结果集 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845.座位预约管理系统","slug":"eetcode/leetcode 1845.座位预约管理系统","date":"2023-05-22T16:06:33.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-22-97adde03f66a.html","link":"","permalink":"https://leiqi.top/2023-05-22-97adde03f66a.html","excerpt":"","text":"1845. 座位预约管理系统 - 力扣（Leetcode） 超时版本123456789101112131415161718192021222324252627282930313233type seat struct &#123; seatId int isFree int // 空&#125;type SeatManager struct &#123; seats map[int]*seat isFrees []int // 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加&#125;func Constructor(n int) SeatManager &#123; var a = SeatManager&#123;make(map[int]*seat, n), make([]int, n)&#125; for i := 0; i &lt; n; i++ &#123; id := i + 1 a.seats[id] = &amp;seat&#123;id, 1&#125; a.isFrees[i] = id // 初始化 &#125; return a&#125;func (this *SeatManager) Reserve() int &#123; sort.Ints(this.isFrees) top := this.isFrees[0] this.seats[top].isFree = 0 this.isFrees = this.isFrees[1:] return top&#125;// 遍历 或者使用mapfunc (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber].isFree = 1 this.isFrees = append(this.isFrees,seatNumber)&#125; 通过版本123456789101112131415161718192021222324252627282930313233343536type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber]=0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125; return&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 455.分发饼干","slug":"eetcode/leetcode 455.分发饼干","date":"2023-05-21T15:10:15.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-21-c1aa51f444e0.html","link":"","permalink":"https://leiqi.top/2023-05-21-c1aa51f444e0.html","excerpt":"","text":"455. 分发饼干 - 力扣（Leetcode） https://leiqicn.gitee.io/ 欢迎关注我的博客，定时更新golang 刷题笔记 贪心的策略： 贪心算法一般分为如下四步： 将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;如果没有越界并且饼干大于等于胃口，则childIdx ++；res++ 12345678910111213141516171819func findContentChildren(g []int, s []int) int &#123; // g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值 sort.Ints(g) sort.Ints(s) j := 0 res := 0 // 用小饼干 来满足最小的胃口 for i := 0; i &lt; len(s); i++ &#123; // 判断越界 饼干大于胃口 if j &lt; len(g) &amp;&amp; s[i] &gt;= g[j] &#123; // len不越界的条件需要在前边 res++ j++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"网站无法访问categories？","slug":"具/网站无法访问categories？","date":"2023-05-21T13:45:30.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-05-21-a827bdd2d159.html","link":"","permalink":"https://leiqi.top/2023-05-21-a827bdd2d159.html","excerpt":"","text":"在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。 可以显示啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 706. 设计哈希映射 Golang","slug":"eetcode/leetcode 706. 设计哈希映射 Golang","date":"2023-05-20T14:58:30.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-20-e3f31d125f9b.html","link":"","permalink":"https://leiqi.top/2023-05-20-e3f31d125f9b.html","excerpt":"","text":"706. 设计哈希映射 - 力扣（Leetcode）使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List 使用结构体（非指针）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;// func (this *MyHashMap) hash(key int, value int)&#123;// &#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(entry); et.k == key &#123; e.Value = entry&#123;key, value&#125; // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝 return &#125; &#125; this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123; return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 使用结构体指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(*entry); et.k == key &#123; // 注意list 的元素类型是空接口，需要断言类型 et.v = value // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针 return &#125; &#125; this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; // 可以缩写为if et := e.Value.(entry); et.k == key 用于断言，并找key return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode　705. 设计哈希集合","slug":"eetcode/leetcode　705. 设计哈希集合","date":"2023-05-19T15:06:26.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-05-19-2fa443568cc1.html","link":"","permalink":"https://leiqi.top/2023-05-19-2fa443568cc1.html","excerpt":"","text":"705. 设计哈希集合 - 力扣（Leetcode） 1234567891011121314151617181920212223242526272829303132333435363738394041const base = 769 // 哈希表的长度 质数type MyHashSet struct &#123; data []list.List // 使用链表储存冲突元素&#125;func Constructor() MyHashSet &#123; // 构造函数，返回一个空的哈希集合 return MyHashSet&#123;make([]list.List, base)&#125;&#125;// 哈希函数：对键值取模得到哈希值func (s *MyHashSet) hash(key int) int &#123; return key % base&#125;func (s *MyHashSet) Add(key int) &#123; // 向哈希集合中添加元素 if !s.Contains(key) &#123; // 如果元素不在集合中 h := s.hash(key) // 计算哈希值 s.data[h].PushBack(key) // 将元素加入到链表中 &#125;&#125;func (s *MyHashSet) Remove(key int) &#123; // 从哈希集合中删除元素 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要删除的元素 s.data[h].Remove(e) // 从链表中删除元素 &#125; &#125;&#125;func (s *MyHashSet) Contains(key int) bool &#123; // 判断某个元素是否在哈希集合中 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要查找的元素 return true // 返回 true &#125; &#125; return false // 没有找到元素，返回 false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1396.设计地铁系统","slug":"eetcode/leetcode 1396.设计地铁系统","date":"2023-05-18T15:31:58.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-18-0a0f1bd6a4a5.html","link":"","permalink":"https://leiqi.top/2023-05-18-0a0f1bd6a4a5.html","excerpt":"","text":"1396. 设计地铁系统 - 力扣（Leetcode） 设计题： 设计数据结构 user startTime int endTime int startStationName string endStatationName string UndergroundSystem userMap map[int]*user pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间 注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"leetcode 设计题 Constructor构建","slug":"eetcode/leetcode 设计题 Constructor构建","date":"2023-05-14T14:13:21.000Z","updated":"2025-04-11T05:09:01.866Z","comments":true,"path":"2023-05-14-776ea61b62a5.html","link":"","permalink":"https://leiqi.top/2023-05-14-776ea61b62a5.html","excerpt":"","text":"在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法： 123456789type ParkingSystem struct &#123; carNums map[int]int // 记录每种停车位的数量&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; return ParkingSystem&#123; carNums: map[int]int&#123;1: big, 2: medium, 3: small&#125;, // 初始化 carNums 映射 &#125;&#125; 在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。 请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。 具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现： 1234567891011121314151617type B struct &#123; m map[int]int&#125;type A struct &#123; m map[int]B&#125;func main() &#123; a := &amp;A&#123; m: make(map[int]B), &#125; b := &amp;B&#123; m: make(map[int]int), &#125; a.m[1] = *b // 给 A 中的第一个元素分配一个新的 B 结构体实例&#125; 在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 nil 引用错误，我们还在代码中使用了 make 函数创建了一个空映射。 例如, 下边结构体中map 嵌套了另外一个结构体的map,可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例： 12345678910111213141516type Res struct &#123; big map[int]int&#125;type ParkingSystem struct &#123;map carNums map[int]*Res // map 嵌套map&#125;func NewParkingSystem() *ParkingSystem &#123; return &amp;ParkingSystem&#123;carNums: make(map[int]*Res)&#125; // 只用先make 一个空map,指向Res&#125;func main() &#123; ps := NewParkingSystem() ps.carNums[1] = &amp;Res&#123;big: make(map[int]int)&#125;&#125; 在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。 然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。 总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"Go语言-copy","slug":"olang/Go语言-copy","date":"2023-05-11T16:27:16.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-05-11-27c67ecef2a3.html","link":"","permalink":"https://leiqi.top/2023-05-11-27c67ecef2a3.html","excerpt":"","text":"在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下： 1func copy(dst, src []Type) int 其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。 使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下： 123456789// 定义一个包含元素的数组a := [5]int&#123;1, 2, 3, 4, 5&#125;// 定义要删除的元素下标index := 2// 利用 append 函数和 copy 函数删除指定下标的元素copy(a[index:], a[index+1:])a = a[:len(a)-1]// 打印删除后的数组fmt.Println(a) // 输出 [1 2 4 5] 上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。 在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。 在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片： 1b := a[1:4] 这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。 在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作： 1copy(a[index:], a[index+1:]) 这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-byte和rune 有什么区别 byte rune 转为int","slug":"olang/Go语言-byte和rune 有什么区别 byte rune 转为int","date":"2023-05-11T16:06:34.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-05-11-257639a12a8e.html","link":"","permalink":"https://leiqi.top/2023-05-11-257639a12a8e.html","excerpt":"","text":"在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。 byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。 将 byte 或 rune 转换为 int 可以使用类型转换操作符： 123456b := byte(&#x27;0&#x27;)i := int(b) - int(&#x27;0&#x27;) // 将 byte &#x27;0&#x27; 转换为 int 0// 上边可以简写为i := b - &#x27;0&#x27;r := rune(&#x27;中&#x27;)i := int(r) // 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点） 将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如： 123456i := 10b := byte(i) // 溢出！编译器会忽略高位部分，直接取低位部分的字节r := rune(i)if r &lt; 0xFFFF &#123; r = rune(b) // 类型断言&#125; 可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Leetcode 200.岛屿数量","slug":"eetcode/Leetcode 200.岛屿数量【BFS DFS】","date":"2023-05-10T17:02:51.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-05-10-da8c57fb590a.html","link":"","permalink":"https://leiqi.top/2023-05-10-da8c57fb590a.html","excerpt":"","text":"200. 岛屿数量 - 力扣（Leetcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++func numIslands(grid [][]byte) int &#123; res := 0 r := len(grid) c := len(grid[0]) visited := make([][]byte, r) for i := 0; i &lt; r; i++ &#123; visited[i] = make([]byte, c) &#125; // 遍历二维slice for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; // 每个位置 if grid[i][j] == &#x27;1&#x27; &#123; dfs(grid, i, j, visited) res++ &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; //单层递归逻辑，四面八方递归 dfs(grid, i+1, j, visited) dfs(grid, i, j+1, visited) dfs(grid, i-1, j, visited) dfs(grid, i, j-1, visited)&#125; 也可以使用方向二维数组来遍历 可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下： 1234567891011121314151617181920212223242526272829303132func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 定义方向变化值dirs dirs := [][]int&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125; // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; // 循环遍历dirs，对四个方向进行递归 for _, d := range dirs &#123; new_i, new_j := i + d[0], j + d[1] dfs(grid, new_i, new_j, visited) &#125;&#125; 在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。 使用额外的visited 的时候，一定要作为dfs 的入参，让其拷贝一份在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化（leetcode 的测试环境会造成影响）。 为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： 需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。 对应BFS实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ bfs(grid, i, j) &#125; &#125; &#125; return res&#125;func bfs(grid [][]byte, i, j int) &#123; r := len(grid) c := len(grid[0]) queue := []point&#123;&#123;i, j&#125;&#125; grid[i][j] = &#x27;0&#x27; // 标记为已访问 for len(queue) &gt; 0 &#123; current := queue[0] queue = queue[1:] for _, item := range dirct &#123; myRow := current.x + item[0] myCol := current.y + item[1] if myRow &gt;= 0 &amp;&amp; myRow &lt; r &amp;&amp; myCol &gt;= 0 &amp;&amp; myCol &lt; c &amp;&amp; grid[myRow][myCol] == &#x27;1&#x27; &#123; grid[myRow][myCol] = &#x27;0&#x27; // 标记为已访问 queue = append(queue, point&#123;myRow, myCol&#125;) &#125; &#125; &#125;&#125;// DFS type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) visited := make(map[point]int) // 使用局部变量，每次调用都重新初始化 for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ dfs(grid, i, j, visited) &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i, j int, visited map[point]int) &#123; r := len(grid) c := len(grid[0]) if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 和visited 等价 if _, ok := visited[point&#123;i, j&#125;]; ok &#123; return &#125; grid[i][j] = &#x27;0&#x27; // 和visited 等价 visited[point&#123;i, j&#125;] = 1 for _, item := range dirct &#123; myRow := i + item[0] myCol := j + item[1] if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok &#123; // 这里和前边 if _, ok := visited[point&#123;i, j&#125;]; ok 二选一 dfs(grid, myRow, myCol, visited) &#125; &#125;&#125;// 需要注意的是岛屿数量的 Go 语言代码中，有一点需要注意。在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化。//为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/ 岛屿问题一文搞定","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"}]},{"title":"结构体指针作为map key 结构体值改变对map有影响吗","slug":"olang/结构体指针作为map key 结构体值改变对map有影响吗","date":"2023-05-10T16:37:20.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-05-10-7dfabb45bbc2.html","link":"","permalink":"https://leiqi.top/2023-05-10-7dfabb45bbc2.html","excerpt":"","text":"最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？接下来让我们一起看看： 当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据 例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; m := make(map[*int]string) x := 1 p := &amp;x m[p] = &quot;A&quot; // 添加数据 fmt.Println(m) // map[0xc000016088:A] *p = 2 // 修改变量x的值 fmt.Println(m) // map[0xc000016088:A]&#125; 在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。 接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。 总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言删除指定索引元素","slug":"olang/Go语言删除指定索引元素","date":"2023-05-10T15:47:04.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-05-10-741623f2e4fb.html","link":"","permalink":"https://leiqi.top/2023-05-10-741623f2e4fb.html","excerpt":"","text":"在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。 以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; i := 2 // 要删除的索引 // 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片 b := append(a[:i], a[i+1:]...) fmt.Println(b) // 输出 [1 2 4 5]&#125; 在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。 接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。 最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"Go语言指定索引插入元素","slug":"olang/Go语言指定索引插入元素","date":"2023-05-10T15:42:50.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-05-10-5e3b5c8e7446.html","link":"","permalink":"https://leiqi.top/2023-05-10-5e3b5c8e7446.html","excerpt":"","text":"在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。 下面是一个示例代码，它插入一个元素到切片的第二个位置： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; i := 1 // 要插入的位置 b := append(a[:i], append([]int&#123;5&#125;, a[i:]...)...) // 在切片的第二个位置插入数字5 fmt.Println(b) // 输出 [1 5 2 3 4]&#125; 在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。 接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。 最后，我们将结果赋值给变量 b 并打印输出它。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"leetcode 108.将有序数组转换为二叉搜索树","slug":"eetcode/leetcode 108.将有序数组转换为二叉搜索树","date":"2023-05-04T15:23:48.000Z","updated":"2025-04-11T05:09:01.865Z","comments":true,"path":"2023-05-04-ce9a22434c37.html","link":"","permalink":"https://leiqi.top/2023-05-04-ce9a22434c37.html","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode） 递归解法注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑注意递归函数定义，严格按照定义调用递归使用前序遍历 中左右 123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"删除ppt所有批注和备注","slug":"具/删除ppt所有批注和备注","date":"2023-04-24T14:25:04.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-04-24-4faf63eb321c.html","link":"","permalink":"https://leiqi.top/2023-04-24-4faf63eb321c.html","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Go语言-接口","slug":"olang/Go语言-接口","date":"2023-04-20T16:42:26.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-04-20-89710477a7ed.html","link":"","permalink":"https://leiqi.top/2023-04-20-89710477a7ed.html","excerpt":"","text":"在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。 以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()： 123456789101112131415161718192021222324type Printer interface &#123; Print()&#125;type User struct &#123; name string&#125;func (u User) Print() &#123; fmt.Println(u.name,&quot;我爱加班&quot;)&#125; func printAll(ps []Printer) &#123; for _, p := range ps &#123; p.Print() &#125;&#125;func main() &#123; var ps []Printer ps = append(ps, User&#123;&quot;Alice&quot;&#125;) ps = append(ps, User&#123;&quot;Bob&quot;&#125;) printAll(ps)&#125; 在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为： 12Alice 我爱加班Bob 我爱加班 在这段代码中，我们通过接口将User类型与PrintAll() 函数解耦，这样当我们需要添加新的类型时，只需要实现Print()方法即可，而不需要修改PrintAll()函数实现。 比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改PrintAll()函数实现。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，有相同的特征，我们将其抽象出来，降低代码耦合性。 1234567type Boss struct &#123; name string&#125;func (b Boss) Print() &#123; fmt.Println(&quot;你明天不用来了&quot;)&#125; 其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照合同的规定进行处理。 同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-多态","slug":"olang/Go语言-多态","date":"2023-04-20T16:32:20.000Z","updated":"2025-04-11T05:09:01.860Z","comments":true,"path":"2023-04-20-af074e588287.html","link":"","permalink":"https://leiqi.top/2023-04-20-af074e588287.html","excerpt":"","text":"Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。 我们来实现这样一个例子： 实现猫和狗两个对象，并且他们都有动作：叫，但叫声不同。再实现一个对象鸟，他除了叫，还会飞。 下面是基于Go语言，实现题目要求的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Animal interface &#123; Cry()&#125;type Cat struct&#123;&#125;func (c Cat) Cry() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;type Dog struct&#123;&#125;func (d Dog) Cry() &#123; fmt.Println(&quot;汪汪汪&quot;)&#125;type Bird struct&#123;&#125;func (b Bird) Cry() &#123; fmt.Println(&quot;叽叽喳喳&quot;)&#125;func (b Bird) Fly() &#123; fmt.Println(&quot;我会飞&quot;)&#125;func main() &#123; var animal Animal // 创建一只猫 animal = Cat&#123;&#125; animal.Cry() // 创建一只狗 animal = Dog&#123;&#125; animal.Cry() // 创建一只鸟 bird := Bird&#123;&#125; animal = bird animal.Cry() bird.Fly()&#125; 在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。 运行上述代码，输出如下： 1234喵喵喵汪汪汪叽叽喳喳我会飞 在这段代码中，我们使用了接口的多态特性，通过定义Animal接口，实现了不同类型的对象之间的通用性，并且在Bird中新增了Fly() 方法，符合面向对象的开放封闭原则。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"波纹","slug":"影/波纹","date":"2023-04-08T05:41:33.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-04-08-722322c4ddc3.html","link":"","permalink":"https://leiqi.top/2023-04-08-722322c4ddc3.html","excerpt":"","text":"波光粼粼","categories":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"}]},{"title":"Leetcode 513.找树左下角的值","slug":"eetcode/Leetcode 513.找树左下角的值","date":"2023-04-03T14:44:37.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-04-03-03cca064ab00.html","link":"","permalink":"https://leiqi.top/2023-04-03-03cca064ab00.html","excerpt":"","text":"513. 找树左下角的值 - 力扣（Leetcode） 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root &#x3D; [2,1,3]输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -2^31 &lt;= Node.val &lt;= 2^31 - 1 思考本题可以转化为什么呢？ 1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。 代码实现1.递归 12345678910111213141516171819202122var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; //这里判断nil ,后边左右节点就不用判断了 if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) dfs(root.Right, d+1)&#125; 2.迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return res&#125;// 迭代2 每层用一个切片func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; // 通过另外一个切片来添加的解法也要尝试学习一下 queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 使用nextqueue 保存每一层，然后追加到queue nextqueue := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] res = nextqueue[0] if top.Left != nil &#123; nextqueue = append(nextqueue, top.Left) &#125; if top.Right != nil &#123; nextqueue = append(nextqueue, top.Right) &#125; &#125; queue = append(queue,nextqueue...) &#125; return res&#125; 拓展思考如果要求最右边的值呢？这里该怎么求呢？ 只需要将 遍历左右的顺序颠倒一下即可 123456789101112131415161718192021222324252627282930313233343536func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 404.左叶子之和","slug":"eetcode/Leetcode 404.左叶子之和","date":"2023-03-29T14:44:37.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-03-29-c131676dd7b1.html","link":"","permalink":"https://leiqi.top/2023-03-29-c131676dd7b1.html","excerpt":"","text":"123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; // 递归 res := 0 // 终止条件 if root == nil &#123; return 0 &#125; leftNode := root.Left leftNodeVal := sumOfLeftLeaves(root.Left) // 左 rightNodeVal := sumOfLeftLeaves(root.Right)// 右 if leftNode != nil &amp;&amp; leftNode.Left == nil &amp;&amp; leftNode.Right == nil &#123; // 中 leftNodeVal = leftNode.Val &#125; // 单次循环 res = leftNodeVal + rightNodeVal // 中，左边+右边 return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 257.二叉树的所有路径","slug":"eetcode/Leetcode 257.二叉树的所有路径","date":"2023-03-28T15:47:29.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-03-28-53b6b0695943.html","link":"","permalink":"https://leiqi.top/2023-03-28-53b6b0695943.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res []stringvar path []stringfunc binaryTreePaths(root *TreeNode) []string &#123; res = make([]string,0) path = make([]string,0) if (root == nil) &#123; return res &#125; backTracking(root) return res&#125;func backTracking(root *TreeNode)&#123; // 终点 左右子节点都为nil if isLeafNode(root) &#123; NodeValStr := strconv.Itoa(root.Val) path = append(path, NodeValStr) pathStr := strings.Join(path, &quot;-&gt;&quot;) res = append(res, pathStr) return &#125; // 前序遍历 中左右 // 遍历 每次递归的操作 NodeVal:= strconv.Itoa(root.Val)// 中 path = append(path, NodeVal) if root.Left != nil &#123; // 左 backTracking(root.Left) path = path[:len(path)-1] &#125; if root.Right != nil &#123; // 右 backTracking(root.Right) path = path[:len(path)-1] &#125;&#125;func isLeafNode(node *TreeNode) bool&#123; if node.Right==nil &amp;&amp; node.Left== nil &amp;&amp; node!= nil&#123; return true &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 110.平衡二叉树","slug":"eetcode/Leetcode 110.平衡二叉树","date":"2023-03-28T03:18:47.000Z","updated":"2025-04-11T05:09:01.864Z","comments":true,"path":"2023-03-28-c58b9cf85e3e.html","link":"","permalink":"https://leiqi.top/2023-03-28-c58b9cf85e3e.html","excerpt":"","text":"110. 平衡二叉树 - 力扣（Leetcode） 简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 示例 2： 输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 输入：root &#x3D; []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 思路这里是求高度： 节点到叶子节点的最长距离，使用后序遍历深度是root 到该节点的最长距离（距离☞节点数），使用前序遍历 因此只要分别计算左右子树的高度，并且做差不大于1就行 代码实现使用-1 记录 res 不是平衡二叉树每次执行，都需要判断是不是等于-1，直接返回-1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"快来压缩你的博客图片","slug":"具/【TODO】快来压缩你的博客图片","date":"2023-03-23T16:00:00.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-03-23-4868b6a1c39c.html","link":"","permalink":"https://leiqi.top/2023-03-23-4868b6a1c39c.html","excerpt":"","text":"虽然没多大变化 哈哈哈再试试 更大更高清的图片 实测,效果不太行….但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下待更新…","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"给你的博客 安装上PWA吧","slug":"具/【TODO】给你的博客 安装上PWA吧","date":"2023-03-23T16:00:00.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-03-23-49ace33ca004.html","link":"","permalink":"https://leiqi.top/2023-03-23-49ace33ca004.html","excerpt":"","text":"TODO: 什么是PWA，可以提示添加到主屏幕渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站 安装 hexo-pwa 由于hexo-pwa停止维护，需要解决报错 设置全局_config.yml 文件(非主题)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 命令 将前台任务挂到后台运行","slug":"inux/Linux 命令 将前台任务挂到后台运行","date":"2023-03-18T16:00:00.000Z","updated":"2025-04-11T05:09:01.861Z","comments":true,"path":"2023-03-18-87649bcaf9cc.html","link":"","permalink":"https://leiqi.top/2023-03-18-87649bcaf9cc.html","excerpt":"","text":"背景 很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用bg 挂后台的命令。 第一步：ctrl + z 第二步：jobs 查看任务id 第三步： bg %任务id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"博客设置 obsidian 上传图片","slug":"具/博客设置 obsidian 上传图片","date":"2023-03-18T16:00:00.000Z","updated":"2025-04-11T05:09:01.868Z","comments":true,"path":"2023-03-18-4e4b648f656d.html","link":"","permalink":"https://leiqi.top/2023-03-18-4e4b648f656d.html","excerpt":"","text":"背景本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的相对路径就可以读取并显示图片。 而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。 操作1. 打开obsidian - 文件与链接2. 按照下图配置 * 将内部链接类型 设置为 “基于当前笔记的相对路径” &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用相对路径 取消wiki 链接 指定图片的默认路径为 source/imgs&gt; 如果没有该文件夹，则需要先新建一下。 成功网页可以成功显示图片","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"关于我","slug":"于我/关于我","date":"2023-03-13T16:00:00.000Z","updated":"2025-04-11T05:09:01.867Z","comments":true,"path":"2023-03-13-519b5e93f019.html","link":"","permalink":"https://leiqi.top/2023-03-13-519b5e93f019.html","excerpt":"","text":"博客链接链接 关于我大家好，我是Lei Qi, 毕业于复旦大学，任职于华为，主要做Golang、Python软件开发。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~ 爱生活，爱学习，爱分享希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！ 欢迎关注微信公众号~","categories":[{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}],"categories":[{"name":"速刷记录","slug":"速刷记录","permalink":"https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"},{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"},{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"},{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"},{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"},{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"},{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"},{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"},{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"},{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"},{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"},{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"},{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"},{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}