{"meta":{"title":"Lei Qi's Blog","subtitle":"Lei Qi博客","description":"Lei Qi Blog又名LeiQi论坛/中文网/社区/空间。是基于技术方面：Golang, Python, NLP, LLM, 云原生，大数据，生物信息，Linux学习，生活方面：摄影、经济理论、电影、读书、学习与分享为一体的综合性网络博客网站。本博客是非营利性博客，目的在于与各位编程爱好者和关注我的友友们通过本博客分享自己感兴趣的知识和一点见解。恰巧我爱写，恰巧你看到了，这就是缘分。","author":"Lei Qi","url":"https://leiqi.top","root":"/"},"pages":[{"title":"","date":"2025-06-16T15:02:17.313Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"manifest.json","permalink":"https://leiqi.top/manifest.json","excerpt":"","text":"{\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"name\":\"Lei Qi's blog\",\"short_name\":\"Lei Qi's blog\",\"icons\":[{\"src\":\"imgs/icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/apple-touch-icon.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2025-06-16T15:02:17.314Z","updated":"2025-06-16T15:02:17.314Z","comments":true,"path":"sw.js","permalink":"https://leiqi.top/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://leiqichn.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"categories","date":"2023-05-20T15:57:35.000Z","updated":"2025-06-16T15:02:16.977Z","comments":true,"path":"categories/index.html","permalink":"https://leiqi.top/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2023-03-13T17:15:57.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"about/index.html","permalink":"https://leiqi.top/about/index.html","excerpt":"","text":"欢迎来到我的空间! 我的第 个朋友！ 关于我 🌱 毕业于复旦大学 ⭐ 现就职于华为，软件开发工程师 兴趣 👨🏽‍💻 项目: NLP, Large Language Model, Golang Project, Python Project, Vue Project. 编程语言 : Golang, Python, C++&#x2F;C, Java 开源项目经验 👯As a manager ： 优酷x天池 「酷文」小说创作大模型挑战赛: DeepThinking Team Leader, Third Prize. As a member : PhenoBERT : PhenoBERT: A combined deep learning method for automated recognition of human phenotype ontology IEEE Journal of Biomedical and Health Informatics（IF&#x3D;5.77） : Reviewer 比赛 优酷x天池 「酷文」小说创作大模型挑战赛: DeepThinking Team Leader, Third Prize. 欢迎志同道合的朋友~本站是为了记录自己学习和生活，欢迎大家多多交流讨论。希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！ 微信公众号"},{"title":"经济","date":"2025-04-12T05:44:05.000Z","updated":"2025-06-16T15:02:16.977Z","comments":true,"path":"economics/index.html","permalink":"https://leiqi.top/economics/index.html","excerpt":"","text":"贷款怎么选还款方式和利率？一篇搞懂等额本金、等额本息、等本等息的秘密申请贷款时，面对“等额本金”“等额本息”“LPR浮动利率”等专业术语，很多人容易陷入选择困难。不同的还款方式和利率类型，直接关系到你的月供压力、总利息支出甚至长期财务规划。本文将用通俗语言解析主流贷款选项的优缺点，并给出实操建议，帮你做出最适合自己的选择。 一、贷款还款方式：哪种更适合你？1. 主流选项对比(1) 等额本金 特点： 每月偿还固定本金 + 递减利息，总利息较低。 前期月供高，后期逐渐减少（适合收入高且稳定人群）。 举例：100万房贷，利率4.9%，30年期 首月还款：6,861元 → 最后一个月还款：2,791元 总利息：约73.7万元 (2) 等额本息 特点： 每月还款额固定不变，利息占比前期高、本金占比后期高，总利息较多。 还款压力平均，适合现金流紧张者。 举例：同上贷款条件下 每月还款：5,307元（30年不变） 总利息：约91.1万元 (3) 等本等息（常见于消费贷） 特点： 每月偿还固定本金 + 固定利息，总利息最高（常见于信用卡分期、装修贷）。 实际利率陷阱：名义利率看似低，实际成本可能翻倍。 举例：贷款10万元，分12期，名义年利率12% 每月还款：本金8,333元 + 利息1,000元 实际年利率 ≈ 12%×2×12&#x2F;(12+1) ≈ 22.15% 2. 其他小众还款方式 方式 特点 适合场景 风险提示 先息后本 前期只还利息，到期还本金 短期周转（如企业经营贷） 到期需大额还本金，现金流压力大 组合还款 分阶段调整还款方式 收入波动大（如创业初期） 需与银行协商定制 双周供 每两周还款一次 工资发放频繁的工薪族 月供频率高，需严格规划 气球贷 前期月供低，末期还大额 短期过渡资金需求 末期还款压力集中 二、利率怎么选：固定利率 vs 浮动利率（LPR）1. 两种利率的核心区别 类型 特点 适合场景 固定利率 整个还款期利率不变 利率低位期、厌恶风险者 浮动利率 利率随LPR调整（通常1年1变） 预期利率下降、愿承担波动风险 2. 决策建议 看经济周期： 降息周期（如经济低迷）→ 选LPR浮动利率； 加息周期（如通胀高企）→ 选固定利率。 看贷款期限： 短期贷款（&lt;5年）→ 浮动利率风险低； 长期贷款（&gt;20年）→ 若判断利率长期走低，可选LPR。 注：中国当前房贷利率普遍挂钩LPR，浮动利率是主流选择。 三、4个核心原则，避开贷款陷阱原则1：匹配现金流 月供 ≤ 月收入的**30%-40%**（避免影响生活质量）。 极端情况测试：假设收入下降20%，能否覆盖月供？ 原则2：计算真实成本 等本等息、分期付款等“低息”宣传可能有陷阱，用IRR公式计算实际利率。 工具推荐：Excel的IRR函数或银行APP内置计算器。 原则3：评估灵活性 是否允许提前还款？是否有违约金？ 例如：等额本金前期多还本金，提前还款更划算。 原则4：考虑通胀影响 长期贷款（如房贷）中，后期的月供会被通胀稀释。 例如：30年后的5,000元购买力可能仅相当于现在的2,000元。 四、终极答案：不同场景下的最优选择场景1：房贷 推荐组合： 高收入、计划提前还款 → 等额本金 + LPR浮动利率； 普通收入、长期持有 → 等额本息 + LPR浮动利率。 关键理由：通胀稀释长期月供，LPR长期看可能下行。 场景2：消费贷&#x2F;信用卡分期 避坑建议： 优先选等额本息，慎用等本等息； 若必须用等本等息，期限尽量缩至1年内。 场景3：企业经营贷 灵活策略：先息后本 + 到期续贷（需确保现金流稳定）。 五、总结：没有完美选项，只有最适合的选择 年轻人&#x2F;首套房：优先等额本息，保留现金流用于自我投资； 高净值人群：选择等额本金，减少总利息支出； 创业者：组合还款或先息后本，匹配业务回款周期。 最后提醒：签订合同前，务必确认还款方式、利率类型、提前还款条款等细节。若有疑虑，可要求银行提供不同方案的对比测算表，数据比直觉更可靠。 康波周期康波周期（Kondratiev Wave）是前苏联经济学家尼古拉·康德拉季耶夫提出的经济长周期理论，认为资本主义经济存在约50-60年的波动周期，由技术革命驱动，分为四个阶段：复苏、繁荣、衰退、萧条。每个周期通常由一项或多项颠覆性技术引领生产力变革，例如蒸汽机、铁路、电力、石油化工、信息技术等。 2025年处于康波周期的什么位置？目前主流观点认为，我们正处在第五次康波周期（信息技术驱动）的末期或第六次康波周期的初期： 第五次康波（1970s-2020s）：以信息技术（计算机、互联网、移动通信）为核心驱动力，2010年代后进入衰退期，2020年代后可能进入萧条期。 第六次康波（2020s-?）：可能由人工智能、绿色能源、生物技术、量子计算等推动，目前处于技术积累的复苏初期。 2025年4月大概率处于第五次康波的萧条末期与第六次康波的复苏过渡阶段。此阶段的特点是： 全球经济增速放缓，传统产业面临转型压力； 新技术的商业化应用尚未完全成熟，但资本已开始向新兴领域集中（如AI、新能源）； 地缘政治冲突、债务风险、能源转型等加剧经济不确定性。 下一个生产力变革的核心方向第六次康波周期的核心驱动力可能是“数字+绿色”双轨革命，具体包括以下领域： 人工智能与自动化： 生成式AI（如ChatGPT）、通用人工智能（AGI）将重塑生产力和商业模式。 工业自动化、无人系统（自动驾驶、无人机）渗透到更多行业。 绿色能源与碳中和： 可再生能源（光伏、风电）、储能技术、氢能产业化。 碳捕捉、循环经济、智能电网推动能源结构转型。 生物科技与健康： 基因编辑（CRISPR）、合成生物学、个性化医疗。 抗衰老技术、脑机接口可能突破。 量子计算与新材料： 量子计算机解决传统算力瓶颈，新材料（如石墨烯）推动制造业升级。 太空经济与元宇宙： 低成本航天技术、卫星互联网、虚拟与现实融合的沉浸式生态。 如何抓住机遇？ 关注技术融合趋势： 单一技术难以主导，跨领域融合（如AI+生物、新能源+数字孪生）是突破点。 例：AI加速药物研发、区块链优化能源交易。 投资核心基础设施： 新能源电网、算力中心、生物实验室等“硬科技”基建是长期机会。 企业需布局数据资产和低碳供应链。 提升适应性技能： 个人：学习AI工具应用、数据分析、跨学科思维。 企业：培养敏捷组织，快速响应技术迭代。 政策与资本协同： 碳中和、数字经济等领域政策红利密集（如欧盟碳关税、中国“十四五”规划）。 关注风险投资流向（如OpenAI、SpaceX的融资模式）。 风险管理与长期视角： 技术泡沫可能伴随早期高波动（如2023年生成式AI的过热与回调）。 分散布局，避免押注单一赛道。 总结2025年可能是新旧康波周期的交接点，建议以“技术+可持续”为主线，聚焦AI、新能源、生物科技等领域的早期机会，同时警惕全球经济下行风险。个人和企业需保持开放性和灵活性，在变革中寻找结构性红利。"},{"title":"友情链接","date":"2025-04-12T13:57:13.000Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"link/index.html","permalink":"https://leiqi.top/link/index.html","excerpt":"","text":""},{"title":"movies","date":"2025-04-12T06:29:49.000Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"movies/index.html","permalink":"https://leiqi.top/movies/index.html","excerpt":"","text":""},{"title":"留言板","date":"2023-03-25T15:43:27.000Z","updated":"2025-06-16T15:02:16.977Z","comments":true,"path":"guestbook/index.html","permalink":"https://leiqi.top/guestbook/index.html","excerpt":"","text":"这里是留言板！欢迎留言哦~"},{"title":"music","date":"2025-04-12T06:29:56.000Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"music/index.html","permalink":"https://leiqi.top/music/index.html","excerpt":"","text":""},{"title":"<% tp.file.title %>","date":"2025-06-16T15:02:17.313Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"obsidian_tamplate/TemPlater.html","permalink":"https://leiqi.top/obsidian_tamplate/TemPlater.html","excerpt":"","text":""},{"title":"读书","date":"2025-04-12T05:44:05.000Z","updated":"2025-06-16T15:02:17.314Z","comments":true,"path":"readings/index.html","permalink":"https://leiqi.top/readings/index.html","excerpt":"","text":""},{"title":"摄影","date":"2025-04-12T05:23:27.000Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"photography/index.html","permalink":"https://leiqi.top/photography/index.html","excerpt":"","text":"风景 关于风景的摄影作品 人像 关于人像的摄影作品"},{"title":"说说","date":"2025-04-12T05:44:05.000Z","updated":"2025-06-16T15:02:17.314Z","comments":true,"path":"shuoshuo/index.html","permalink":"https://leiqi.top/shuoshuo/index.html","excerpt":"","text":""},{"title":"","date":"2025-06-16T15:02:16.977Z","updated":"2025-06-16T15:02:16.977Z","comments":true,"path":"assets/img/Snipaste_2023-03-19_12-43-32.png.html","permalink":"https://leiqi.top/assets/img/Snipaste_2023-03-19_12-43-32.png.html","excerpt":"","text":""},{"title":"","date":"2025-06-16T15:02:16.977Z","updated":"2025-06-16T15:02:16.977Z","comments":true,"path":"assets/img/微信图片_20230319125819.png.html","permalink":"https://leiqi.top/assets/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png.html","excerpt":"","text":""},{"title":"人像摄影","date":"2025-04-12T05:23:27.000Z","updated":"2025-06-16T15:02:17.313Z","comments":true,"path":"photography/portrait/index.html","permalink":"https://leiqi.top/photography/portrait/index.html","excerpt":"","text":"[{\"url\":\"../../imgs/IMG_3640.jpg\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"../../imgs/IMG_3898.jpg\",\"alt\":\"\",\"title\":\"\"}]"},{"title":"风景摄影","date":"2025-04-12T05:23:27.000Z","updated":"2025-06-16T15:02:17.314Z","comments":true,"path":"photography/scenery/index.html","permalink":"https://leiqi.top/photography/scenery/index.html","excerpt":"","text":"[{\"url\":\"../../imgs/IMG_3984%201.jpg\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"../../imgs/IMG_3715.jpg\",\"alt\":\"\",\"title\":\"\"}]"}],"posts":[{"title":"【转载】Golang 新手可能会踩的 50 个坑","slug":"olang/【转载】Golang 新手可能会踩的 50 个坑","date":"2025-06-15T16:58:17.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2025-06-15-bd60604455f8.html","link":"","permalink":"https://leiqi.top/2025-06-15-bd60604455f8.html","excerpt":"转载：wuYin&#x2F;blog 原文：50 Shades of Go: Traps, Gotchas, and Common Mistakes，翻译已获作者 kcqon 授权。","text":"转载：wuYin&#x2F;blog 原文：50 Shades of Go: Traps, Gotchas, and Common Mistakes，翻译已获作者 kcqon 授权。 不久前发现在知乎这篇质量很高的文章，打算加上自己的理解翻译一遍。文章分为三部分：初级篇 1-34，中级篇 35-50，高级篇 51-57 前言Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。 如果花时间学习官方 doc、wiki、讨论邮件列表、 Rob Pike 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。 初级篇：1-341. 左大括号 &#123; 一般不能单独放一行在其他大多数语言中，&#123; 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 ; 来分隔多条语句，比如会在 ) 后加分号： 1234567891011// 错误示例func main() &#123; println(&quot;hello world&quot;)&#125;// 等效于func main(); // 无函数体 &#123; println(&quot;hello world&quot;)&#125; .&#x2F;main.go: missing function body.&#x2F;main.go: syntax error: unexpected semicolon or newline before { 1234// 正确示例func main() &#123; println(&quot;hello world&quot;)&#125; 注意代码块等特殊情况： 1234567// &#123; 并不遵守分号注入规则，不会在其后边自动加分，此时可换行func main() &#123; &#123; println(&quot;hello world&quot;) &#125;&#125; 参考：Golang中自动加分号的特殊分隔符 2. 未使用的变量如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。 即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它： 1234567891011121314151617181920212223242526// 错误示例var gvar int // 全局变量，声明不使用也可以func main() &#123; var one int // error: one declared and not used two := 2 // error: two declared and not used var three int // error: three declared and not used three = 3 &#125;// 正确示例// 可以直接注释或移除未使用的变量func main() &#123; var one int _ = one two := 2 println(two) var three int one = three var four int four = four&#125; 3. 未使用的 import如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。 可以使用 _ 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 init() 1234567891011121314151617181920212223// 错误示例import ( &quot;fmt&quot; // imported and not used: &quot;fmt&quot; &quot;log&quot; // imported and not used: &quot;log&quot; &quot;time&quot; // imported and not used: &quot;time&quot;)func main() &#123;&#125;// 正确示例// 可以使用 goimports 工具来注释或移除未使用到的包import ( _ &quot;fmt&quot; &quot;log&quot; &quot;time&quot;)func main() &#123; _ = log.Println _ = time.Now&#125; 4. 简短声明的变量只能在函数内部使用12345678910// 错误示例myvar := 1 // syntax error: non-declaration statement outside function bodyfunc main() &#123;&#125;// 正确示例var myvar = 1func main() &#123;&#125; 5. 使用简短声明来重复声明变量不能用简短声明方式来单独为一个变量重复声明， := 左侧至少有一个新变量，才允许多变量的重复声明： 12345678910111213// 错误示例func main() &#123; one := 0 one := 1 // error: no new variables on left side of :=&#125;// 正确示例func main() &#123; one := 0 one, two := 1, 2 // two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err one, two = two, one // 交换两个变量值的简写&#125; 6. 不能使用简短声明来设置字段的值struct 的变量字段不能使用 := 来赋值以使用预定义的变量来避免解决： 1234567891011121314151617181920212223242526272829// 错误示例type info struct &#123; result int&#125;func work() (int, error) &#123; return 3, nil&#125;func main() &#123; var data info data.result, err := work() // error: non-name data.result on left side of := fmt.Printf(&quot;info: %+v\\n&quot;, data)&#125;// 正确示例func main() &#123; var data info var err error // err 需要预声明 data.result, err = work() if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;info: %+v\\n&quot;, data)&#125; 7. 不小心覆盖了变量对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 := 是一个赋值操作符。 如果你在新的代码块中像下边这样误用了 :=，编译不会报错，但是变量不会按你的预期工作： 12345678910func main() &#123; x := 1 println(x) // 1 &#123; println(x) // 1 x := 2 println(x) // 2 // 新的 x 变量的作用域只在代码块内部 &#125; println(x) // 1&#125; 这是 Go 开发者常犯的错，而且不易被发现。 可使用 vet 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 -shadow 选项来启用： 12&gt; go tool vet -shadow main.gomain.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5 注意 vet 不会报告全部被覆盖的变量，可以使用 go-nyet 来做进一步的检测： 12&gt; $GOPATH/bin/go-nyet main.gomain.go:10:3:Shadowing variable `x` 8. 显式类型的变量无法使用 nil 来初始化nil 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。 123456789101112// 错误示例func main() &#123; var x = nil // error: use of untyped nil _ = x&#125;// 正确示例func main() &#123; var x interface&#123;&#125; = nil _ = x&#125; 9. 直接使用值为 nil 的 slice、map允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic 12345678910111213// map 错误示例func main() &#123; var m map[string]int m[&quot;one&quot;] = 1 // error: panic: assignment to entry in nil map // m := make(map[string]int)// map 的正确声明，分配了实际的内存&#125; // slice 正确示例func main() &#123; var s []int s = append(s, 1)&#125; 10. map 容量在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 cap() 来检测分配空间的大小： 12345// 错误示例func main() &#123; m := make(map[string]int, 99) println(cap(m)) // error: invalid argument m1 (type map[string]int) for cap &#125; 11. string 类型的变量值不能为 nil对那些喜欢用 nil 初始化字符串的人来说，这就是坑： 12345678910111213141516// 错误示例func main() &#123; var s string = nil // cannot use nil as type string in assignment if s == nil &#123; // invalid operation: s == nil (mismatched types string and nil) s = &quot;default&quot; &#125;&#125;// 正确示例func main() &#123; var s string // 字符串类型的零值是空串 &quot;&quot; if s == &quot;&quot; &#123; s = &quot;default&quot; &#125;&#125; 12. Array 类型的值作为函数参数在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。 在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的： 12345678910// 数组使用值拷贝传参func main() &#123; x := [3]int&#123;1,2,3&#125; func(arr [3]int) &#123; arr[0] = 7 fmt.Println(arr) // [7 2 3] &#125;(x) fmt.Println(x) // [1 2 3] // 并不是你以为的 [7 2 3]&#125; 如果想修改参数数组： 直接传递指向这个数组的指针类型： 12345678910// 传址会修改原数据func main() &#123; x := [3]int&#123;1,2,3&#125; func(arr *[3]int) &#123; (*arr)[0] = 7 fmt.Println(arr) // &amp;[7 2 3] &#125;(&amp;x) fmt.Println(x) // [7 2 3]&#125; 直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array） 123456789// 会修改 slice 的底层 array，从而修改 slicefunc main() &#123; x := []int&#123;1, 2, 3&#125; func(arr []int) &#123; arr[0] = 7 fmt.Println(x) // [7 2 3] &#125;(x) fmt.Println(x) // [7 2 3]&#125; 13. range 遍历 slice 和 array 时混淆了返回值与其他编程语言中的 for-in 、foreach 遍历语句不同，Go 中的 range 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值： 12345678910111213141516// 错误示例func main() &#123; x := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; for v := range x &#123; fmt.Println(v) // 1 2 3 &#125;&#125;// 正确示例func main() &#123; x := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; for _, v := range x &#123; // 使用 _ 丢弃索引 fmt.Println(v) &#125;&#125; 14. slice 和 array 其实是一维数据看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。 对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。 可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。 使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。 使用“独立”的切片分两步： 创建外部 slice 对每个内部 slice 进行内存分配 注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice 12345678910// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组func main() &#123; x := 2 y := 4 table := make([][]int, x) for i := range table &#123; table[i] = make([]int, y) &#125;&#125; 使用“共享底层数组”的切片 创建一个存放原始数据的容器 slice 创建其他的 slice 切割原始 slice 来初始化其他的 slice 12345678910111213141516171819202122func main() &#123; h, w := 2, 4 raw := make([]int, h*w) for i := range raw &#123; raw[i] = i &#125; // 初始化原始 slice fmt.Println(raw, &amp;raw[4]) // [0 1 2 3 4 5 6 7] 0xc420012120 table := make([][]int, h) for i := range table &#123; // 等间距切割原始 slice，创建动态多维数组 table // 0: raw[0*4: 0*4 + 4] // 1: raw[1*4: 1*4 + 4] table[i] = raw[i*w : i*w + w] &#125; fmt.Println(table, &amp;table[1][0]) // [[0 1 2 3] [4 5 6 7]] 0xc420012120&#125; 更多关于多维数组的参考 go-how-is-two-dimensional-arrays-memory-representation what-is-a-concise-way-to-create-a-2d-slice-in-go 15. 访问 map 中不存在的 key和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中： 12&gt; php -r &#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;NULL Go 则会返回元素对应数据类型的零值，比如 nil、&#39;&#39; 、false 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。 检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可： 123456789101112131415// 错误的 key 检测方式func main() &#123; x := map[string]string&#123;&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;&#125; if v := x[&quot;two&quot;]; v == &quot;&quot; &#123; fmt.Println(&quot;key two is no entry&quot;) // 键 two 存不存在都会返回的空字符串 &#125;&#125;// 正确示例func main() &#123; x := map[string]string&#123;&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;&#125; if _, ok := x[&quot;two&quot;]; !ok &#123; fmt.Println(&quot;key two is no entry&quot;) &#125;&#125; 16. string 类型的值是常量，不可更改尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。 string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可： 12345678910111213141516// 修改字符串的错误示例func main() &#123; x := &quot;text&quot; x[0] = &quot;T&quot; // error: cannot assign to x[0] fmt.Println(x)&#125;// 修改示例func main() &#123; x := &quot;text&quot; xBytes := []byte(x) xBytes[0] = &#x27;T&#x27; // 注意此时的 T 是 rune 类型 x = string(xBytes) fmt.Println(x) // Text&#125; 注意： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。 更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符 1234567func main() &#123; x := &quot;text&quot; xRunes := []rune(x) xRunes[0] = &#x27;我&#x27; x = string(xRunes) fmt.Println(x) // 我ext&#125; 17. string 与 byte slice 之间的转换当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。 Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配： 在 map[string] 中查找 key 时，使用了对应的 []byte，避免做 m[string(key)] 的内存分配 使用 for range 迭代 string 转换为 []byte 的迭代：for i,v := range []byte(str) &#123;...&#125; 雾：参考原文 18. string 与索引操作符对字符串用索引访问返回的不是字符，而是一个 byte 值。 这种处理方式和其他语言一样，比如 PHP 中： 12345678&gt; php -r &#x27;$name=&quot;中文&quot;; var_dump($name);&#x27; # &quot;中文&quot; 占用 6 个字节string(6) &quot;中文&quot;&gt; php -r &#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27; # 把第一个字节当做 Unicode 字符读取，显示 U+FFFDstring(1) &quot;�&quot; &gt; php -r &#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;string(3) &quot;中&quot; 12345func main() &#123; x := &quot;ascii&quot; fmt.Println(x[0]) // 97 fmt.Printf(&quot;%T\\n&quot;, x[0])// uint8&#125; 如果需要使用 for range 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 &quot;unicode/utf8&quot; 包来做 UTF8 的相关解码编码。另外 utf8string 也有像 func (s *String) At(i int) rune 等很方便的库函数。 19. 字符串并不都是 UTF8 文本string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。 判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 ValidString() 函数： 12345678910func main() &#123; str1 := &quot;ABC&quot; fmt.Println(utf8.ValidString(str1)) // true str2 := &quot;A\\xfeC&quot; fmt.Println(utf8.ValidString(str2)) // false str3 := &quot;A\\\\xfeC&quot; fmt.Println(utf8.ValidString(str3)) // true // 把转义字符转义成字面值&#125; 20. 字符串的长度在 Python 中： 12data = u&#x27;♥&#x27; print(len(data)) # 1 然而在 Go 中： 1234func main() &#123; char := &quot;♥&quot; fmt.Println(len(char)) // 3&#125; Go 的内建函数 len() 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。 如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 RuneCountInString(str string) (n int) 1234func main() &#123; char := &quot;♥&quot; fmt.Println(utf8.RuneCountInString(char)) // 1&#125; 注意： RuneCountInString 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune： 123456func main() &#123; char := &quot;é&quot; fmt.Println(len(char)) // 3 fmt.Println(utf8.RuneCountInString(char)) // 2 fmt.Println(&quot;cafe\\u0301&quot;) // café // 法文的 cafe，实际上是两个 rune 的组合&#125; 参考：normalization 21. 在多行 array、slice、map 语句中缺少 , 号123456789func main() &#123; x := []int &#123; 1, 2 // syntax error: unexpected newline, expecting comma or &#125; &#125; y := []int&#123;1,2,&#125; z := []int&#123;1,2&#125; // ...&#125; 声明语句中 &#125; 折叠到单行后，尾部的 , 不是必需的。 22. log.Fatal 和 log.Panic 不只是 loglog 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal*()、Panic*() 时能做更多日志外的事，如中断程序的执行等： 1234func main() &#123; log.Fatal(&quot;Fatal level log: log entry&quot;) // 输出信息后，程序终止执行 log.Println(&quot;Nomal level log: log entry&quot;)&#125; 23. 对内建数据结构的操作并不是同步的尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。 goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。 24. range 迭代 string 得到的值range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。 注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用norm 包。 for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。 12345678910func main() &#123; data := &quot;A\\xfe\\x02\\xff\\x04&quot; for _, v := range data &#123; fmt.Printf(&quot;%#x &quot;, v) // 0x41 0xfffd 0x2 0xfffd 0x4 // 错误 &#125; for _, v := range []byte(data) &#123; fmt.Printf(&quot;%#x &quot;, v) // 0x41 0xfe 0x2 0xff 0x4 // 正确 &#125;&#125; 25. range 迭代 map如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。 Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如： 123456func main() &#123; m := map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4&#125; for k, v := range m &#123; fmt.Println(k, v) &#125;&#125; 如果你去 Go Playground 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的： 26. switch 中的 fallthrough 语句switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块。 12345678910111213func main() &#123; isSpace := func(char byte) bool &#123; switch char &#123; case &#x27; &#x27;: // 空格符会直接 break，返回 false // 和其他语言不一样 // fallthrough // 返回 true case &#x27;\\t&#x27;: return true &#125; return false &#125; fmt.Println(isSpace(&#x27;\\t&#x27;)) // true fmt.Println(isSpace(&#x27; &#x27;)) // false&#125; 不过你可以在 case 代码块末尾使用 fallthrough，强制执行下一个 case 代码块。 也可以改写 case 为多条件判断： 1234567891011func main() &#123; isSpace := func(char byte) bool &#123; switch char &#123; case &#x27; &#x27;, &#x27;\\t&#x27;: return true &#125; return false &#125; fmt.Println(isSpace(&#x27;\\t&#x27;)) // true fmt.Println(isSpace(&#x27; &#x27;)) // true&#125; 27. 自增和自减运算很多编程语言都自带前置后置的 ++、-- 运算。但 Go 特立独行，去掉了前置操作，同时 ++、— 只作为运算符而非表达式。 12345678910111213141516// 错误示例func main() &#123; data := []int&#123;1, 2, 3&#125; i := 0 ++i // syntax error: unexpected ++, expecting &#125; fmt.Println(data[i++]) // syntax error: unexpected ++, expecting :&#125;// 正确示例func main() &#123; data := []int&#123;1, 2, 3&#125; i := 0 i++ fmt.Println(data[i]) // 2&#125; 28. 按位取反很多编程语言使用 ~ 作为一元按位取反（NOT）操作符，Go 重用 ^ XOR 操作符来按位取反： 123456789101112// 错误的取反操作func main() &#123; fmt.Println(~2) // bitwise complement operator is ^&#125;// 正确示例func main() &#123; var d uint8 = 2 fmt.Printf(&quot;%08b\\n&quot;, d) // 00000010 fmt.Printf(&quot;%08b\\n&quot;, ^d) // 11111101&#125; 同时 ^ 也是按位异或（XOR）操作符。 一个操作符能重用两次，是因为一元的 NOT 操作 NOT 0x02，与二元的 XOR 操作 0x22 XOR 0xff 是一致的。 Go 也有特殊的操作符 AND NOT &amp;^ 操作符，不同位才取1。 1234567891011121314func main() &#123; var a uint8 = 0x82 var b uint8 = 0x02 fmt.Printf(&quot;%08b [A]\\n&quot;, a) fmt.Printf(&quot;%08b [B]\\n&quot;, b) fmt.Printf(&quot;%08b (NOT B)\\n&quot;, ^b) fmt.Printf(&quot;%08b ^ %08b = %08b [B XOR 0xff]\\n&quot;, b, 0xff, b^0xff) fmt.Printf(&quot;%08b ^ %08b = %08b [A XOR B]\\n&quot;, a, b, a^b) fmt.Printf(&quot;%08b &amp; %08b = %08b [A AND B]\\n&quot;, a, b, a&amp;b) fmt.Printf(&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\\n&quot;, a, b, a&amp;^b) fmt.Printf(&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\\n&quot;, a, b, a&amp;(^b))&#125; 1234567810000010 [A]00000010 [B]11111101 (NOT B)00000010 ^ 11111111 = 11111101 [B XOR 0xff]10000010 ^ 00000010 = 10000000 [A XOR B]10000010 &amp; 00000010 = 00000010 [A AND B]10000010 &amp;^00000010 = 10000000 [A &#x27;AND NOT&#x27; B]10000010&amp;(^00000010)= 10000000 [A AND (NOT B)] 29. 运算符的优先级除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。 12345678910111213141516func main() &#123; fmt.Printf(&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\\n&quot;, 0x2&amp;0x2+0x4) // &amp; 优先 + //prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6 //Go: (0x2 &amp; 0x2) + 0x4 //C++: 0x2 &amp; (0x2 + 0x4) -&gt; 0x2 fmt.Printf(&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\\n&quot;, 0x2+0x2&lt;&lt;0x1) // &lt;&lt; 优先 + //prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6 //Go: 0x2 + (0x2 &lt;&lt; 0x1) //C++: (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8 fmt.Printf(&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\\n&quot;, 0xf|0x2^0x2) // | 优先 ^ //prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd //Go: (0xf | 0x2) ^ 0x2 //C++: 0xf | (0x2 ^ 0x2) -&gt; 0xf&#125; 优先级列表： 123456Precedence Operator 5 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 4 + - | ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 || 30. 不导出的 struct 字段无法被 encode以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值： 1234567891011func main() &#123; in := MyData&#123;1, &quot;two&quot;&#125; fmt.Printf(&quot;%#v\\n&quot;, in) // main.MyData&#123;One:1, two:&quot;two&quot;&#125; encoded, _ := json.Marshal(in) fmt.Println(string(encoded)) // &#123;&quot;One&quot;:1&#125; // 私有字段 two 被忽略了 var out MyData json.Unmarshal(encoded, &amp;out) fmt.Printf(&quot;%#v\\n&quot;, out) // main.MyData&#123;One:1, two:&quot;&quot;&#125;&#125; 31. 程序退出时还有 goroutine 在执行程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意： 123456789101112131415// 主程序会直接退出func main() &#123; workerCount := 2 for i := 0; i &lt; workerCount; i++ &#123; go doIt(i) &#125; time.Sleep(1 * time.Second) fmt.Println(&quot;all done!&quot;)&#125;func doIt(workerID int) &#123; fmt.Printf(&quot;[%v] is running\\n&quot;, workerID) time.Sleep(3 * time.Second) // 模拟 goroutine 正在执行 fmt.Printf(&quot;[%v] is done\\n&quot;, workerID)&#125; 如下，main() 主程序不等两个 goroutine 执行完就直接退出了： 常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。 如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 kill 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel： 1234567891011121314151617181920212223// 等待所有 goroutine 执行完毕// 进入死锁func main() &#123; var wg sync.WaitGroup done := make(chan struct&#123;&#125;) workerCount := 2 for i := 0; i &lt; workerCount; i++ &#123; wg.Add(1) go doIt(i, done, wg) &#125; close(done) wg.Wait() fmt.Println(&quot;all done!&quot;)&#125;func doIt(workerID int, done &lt;-chan struct&#123;&#125;, wg sync.WaitGroup) &#123; fmt.Printf(&quot;[%v] is running\\n&quot;, workerID) defer wg.Done() &lt;-done fmt.Printf(&quot;[%v] is done\\n&quot;, workerID)&#125; 执行结果： 看起来好像 goroutine 都执行完了，然而报错： fatal error: all goroutines are asleep - deadlock! 为什么会发生死锁？goroutine 在退出前调用了 wg.Done() ，程序应该正常退出的。 原因是 goroutine 得到的 “WaitGroup” 变量是 var wg WaitGroup 的一份拷贝值，即 doIt() 传参只传值。所以哪怕在每个 goroutine 中都调用了 wg.Done()， 主程序中的 wg 变量并不会受到影响。 1234567891011121314151617181920212223242526272829303132333435363738// 等待所有 goroutine 执行完毕// 使用传址方式为 WaitGroup 变量传参// 使用 channel 关闭 goroutinefunc main() &#123; var wg sync.WaitGroup done := make(chan struct&#123;&#125;) ch := make(chan interface&#123;&#125;) workerCount := 2 for i := 0; i &lt; workerCount; i++ &#123; wg.Add(1) go doIt(i, ch, done, &amp;wg) // wg 传指针，doIt() 内部会改变 wg 的值 &#125; for i := 0; i &lt; workerCount; i++ &#123; // 向 ch 中发送数据，关闭 goroutine ch &lt;- i &#125; close(done) wg.Wait() close(ch) fmt.Println(&quot;all done!&quot;)&#125;func doIt(workerID int, ch &lt;-chan interface&#123;&#125;, done &lt;-chan struct&#123;&#125;, wg *sync.WaitGroup) &#123; fmt.Printf(&quot;[%v] is running\\n&quot;, workerID) defer wg.Done() for &#123; select &#123; case m := &lt;-ch: fmt.Printf(&quot;[%v] m =&gt; %v\\n&quot;, workerID, m) case &lt;-done: fmt.Printf(&quot;[%v] is done\\n&quot;, workerID) return &#125; &#125;&#125; 运行效果： 32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如： 12345678910111213func main() &#123; ch := make(chan string) go func() &#123; for m := range ch &#123; fmt.Println(&quot;Processed:&quot;, m) time.Sleep(1 * time.Second) // 模拟需要长时间运行的操作 &#125; &#125;() ch &lt;- &quot;cmd.1&quot; ch &lt;- &quot;cmd.2&quot; // 不会被接收处理&#125; 运行效果： 33. 向已关闭的 channel 发送数据会造成 panic从已关闭的 channel 接收数据是安全的： 接收状态值 ok 是 false 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 false 向已关闭的 channel 中发送数据会造成 panic： 123456789101112func main() &#123; ch := make(chan int) for i := 0; i &lt; 3; i++ &#123; go func(idx int) &#123; ch &lt;- idx &#125;(i) &#125; fmt.Println(&lt;-ch) // 输出第一个发送的值 close(ch) // 不能关闭，还有其他的 sender time.Sleep(2 * time.Second) // 模拟做其他的操作&#125; 运行结果： 针对上边有 bug 的这个例子，可使用一个废弃 channel done 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 &lt;- done 的结果是 &#123;&#125;： 12345678910111213141516171819func main() &#123; ch := make(chan int) done := make(chan struct&#123;&#125;) for i := 0; i &lt; 3; i++ &#123; go func(idx int) &#123; select &#123; case ch &lt;- (idx + 1) * 2: fmt.Println(idx, &quot;Send result&quot;) case &lt;-done: fmt.Println(idx, &quot;Exiting&quot;) &#125; &#125;(i) &#125; fmt.Println(&quot;Result: &quot;, &lt;-ch) close(done) time.Sleep(3 * time.Second)&#125; 运行效果： 34. 使用了值为 nil 的 channel在一个值为 nil 的 channel 上发送和接收数据将永久阻塞： 1234567891011func main() &#123; var ch chan int // 未初始化，值为 nil for i := 0; i &lt; 3; i++ &#123; go func(i int) &#123; ch &lt;- i &#125;(i) &#125; fmt.Println(&quot;Result: &quot;, &lt;-ch) time.Sleep(2 * time.Second)&#125; runtime 死锁错误： fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive (nil chan)] 利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块： 12345678910111213141516171819202122232425262728293031323334func main() &#123; inCh := make(chan int) outCh := make(chan int) go func() &#123; var in &lt;-chan int = inCh var out chan&lt;- int var val int for &#123; select &#123; case out &lt;- val: println(&quot;--------&quot;) out = nil in = inCh case val = &lt;-in: println(&quot;++++++++++&quot;) out = outCh in = nil &#125; &#125; &#125;() go func() &#123; for r := range outCh &#123; fmt.Println(&quot;Result: &quot;, r) &#125; &#125;() time.Sleep(0) inCh &lt;- 1 inCh &lt;- 2 time.Sleep(3 * time.Second)&#125; 运行效果： 34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。 除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值: 12345678910111213141516171819202122232425262728type data struct &#123; num int key *string items map[string]bool&#125;func (this *data) pointerFunc() &#123; this.num = 7&#125;func (this data) valueFunc() &#123; this.num = 8 *this.key = &quot;valueFunc.key&quot; this.items[&quot;valueFunc&quot;] = true&#125;func main() &#123; key := &quot;key1&quot; d := data&#123;1, &amp;key, make(map[string]bool)&#125; fmt.Printf(&quot;num=%v key=%v items=%v\\n&quot;, d.num, *d.key, d.items) d.pointerFunc() // 修改 num 的值为 7 fmt.Printf(&quot;num=%v key=%v items=%v\\n&quot;, d.num, *d.key, d.items) d.valueFunc() // 修改 key 和 items 的值 fmt.Printf(&quot;num=%v key=%v items=%v\\n&quot;, d.num, *d.key, d.items)&#125; 运行结果： 中级篇：35-5035. 关闭 HTTP 的响应体使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置： 1234567891011121314151617181920// 请求失败造成 panicfunc main() &#123; resp, err := http.Get(&quot;https://api.ipify.org?format=json&quot;) defer resp.Body.Close() // resp 可能为 nil，不能读取 Body if err != nil &#123; fmt.Println(err) return &#125; body, err := ioutil.ReadAll(resp.Body) checkError(err) fmt.Println(string(body))&#125;func checkError(err error) &#123; if err != nil&#123; log.Fatalln(err) &#125;&#125; 上边的代码能正确发起请求，但是一旦请求失败，变量 resp 值为 nil，造成 panic： panic: runtime error: invalid memory address or nil pointer dereference 应该先检查 HTTP 响应错误为 nil，再调用 resp.Body.Close() 来关闭响应体： 1234567891011// 大多数情况正确的示例func main() &#123; resp, err := http.Get(&quot;https://api.ipify.org?format=json&quot;) checkError(err) defer resp.Body.Close() // 绝大多数情况下的正确关闭方式 body, err := ioutil.ReadAll(resp.Body) checkError(err) fmt.Println(string(body))&#125; 输出： Get https://api.ipify.org?format=json: x509: certificate signed by unknown authority 绝大多数请求失败的情况下，resp 的值为 nil 且 err 为 non-nil。但如果你得到的是重定向错误，那它俩的值都是 non-nil，最后依旧可能发生内存泄露。2 个解决办法： 可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。 手动调用 defer 来关闭响应体： 12345678910111213141516// 正确示例func main() &#123; resp, err := http.Get(&quot;http://www.baidu.com&quot;) // 关闭 resp.Body 的正确姿势 if resp != nil &#123; defer resp.Body.Close() &#125; checkError(err) body, err := ioutil.ReadAll(resp.Body) checkError(err) fmt.Println(string(body))&#125; resp.Body.Close() 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。 如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入： 1_, err = io.Copy(ioutil.Discard, resp.Body) // 手动丢弃读取完毕的数据 如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据： 1json.NewDecoder(resp.Body).Decode(&amp;data) 36. 关闭 HTTP 连接一些支持 HTTP1.1 或 HTTP1.0 配置了 connection: keep-alive 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后： 直接设置请求变量的 Close 字段值为 true，每次请求结束后就会主动关闭连接。 设置 Header 请求头部选项 Connection: close，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。 12345678910111213141516171819// 主动关闭连接func main() &#123; req, err := http.NewRequest(&quot;GET&quot;, &quot;http://golang.org&quot;, nil) checkError(err) req.Close = true //req.Header.Add(&quot;Connection&quot;, &quot;close&quot;) // 等效的关闭方式 resp, err := http.DefaultClient.Do(req) if resp != nil &#123; defer resp.Body.Close() &#125; checkError(err) body, err := ioutil.ReadAll(resp.Body) checkError(err) fmt.Println(string(body))&#125; 你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接： 1234567891011121314151617func main() &#123; tr := http.Transport&#123;DisableKeepAlives: true&#125; client := http.Client&#123;Transport: &amp;tr&#125; resp, err := client.Get(&quot;https://golang.google.cn/&quot;) if resp != nil &#123; defer resp.Body.Close() &#125; checkError(err) fmt.Println(resp.StatusCode) // 200 body, err := ioutil.ReadAll(resp.Body) checkError(err) fmt.Println(len(string(body)))&#125; 根据需求选择使用场景： 若你的程序要向同一服务器发大量请求，使用默认的保持长连接。 若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 fs.file-max 的值。 37. 将 JSON 中的数字解码为 interface 类型在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic： 123456789101112func main() &#123; var data = []byte(`&#123;&quot;status&quot;: 200&#125;`) var result map[string]interface&#123;&#125; if err := json.Unmarshal(data, &amp;result); err != nil &#123; log.Fatalln(err) &#125; fmt.Printf(&quot;%T\\n&quot;, result[&quot;status&quot;]) // float64 var status = result[&quot;status&quot;].(int) // 类型断言错误 fmt.Println(&quot;Status value: &quot;, status)&#125; panic: interface conversion: interface {} is float64, not int 如果你尝试 decode 的 JSON 字段是整型，你可以： 将 int 值转为 float 统一使用 将 decode 后需要的 float 值转为 int 使用 123456789101112// 将 decode 的值转为 int 使用func main() &#123; var data = []byte(`&#123;&quot;status&quot;: 200&#125;`) var result map[string]interface&#123;&#125; if err := json.Unmarshal(data, &amp;result); err != nil &#123; log.Fatalln(err) &#125; var status = uint64(result[&quot;status&quot;].(float64)) fmt.Println(&quot;Status value: &quot;, status)&#125; 使用 Decoder 类型来 decode JSON 数据，明确表示字段的值类型 12345678910111213141516171819202122232425262728293031// 指定字段类型func main() &#123; var data = []byte(`&#123;&quot;status&quot;: 200&#125;`) var result map[string]interface&#123;&#125; var decoder = json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() if err := decoder.Decode(&amp;result); err != nil &#123; log.Fatalln(err) &#125; var status, _ = result[&quot;status&quot;].(json.Number).Int64() fmt.Println(&quot;Status value: &quot;, status)&#125; // 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用 // 将数据转为 decode 为 string func main() &#123; var data = []byte(&#123;&quot;status&quot;: 200&#125;) var result map[string]interface&#123;&#125; var decoder = json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() if err := decoder.Decode(&amp;result); err != nil &#123; log.Fatalln(err) &#125; var status uint64 err := json.Unmarshal([]byte(result[&quot;status&quot;].(json.Number).String()), &amp;status); checkError(err) fmt.Println(&quot;Status value: &quot;, status)&#125; ​- 使用 struct 类型将你需要的数据映射为数值型 1234567891011// struct 中指定字段类型func main() &#123; var data = []byte(`&#123;&quot;status&quot;: 200&#125;`) var result struct &#123; Status uint64 `json:&quot;status&quot;` &#125; err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result) checkError(err) fmt.Printf(&quot;Result: %+v&quot;, result)&#125; 可以使用 struct 将数值类型映射为 json.RawMessage 原生数据类型 适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况： 123456789101112131415161718192021222324252627282930313233// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型func main() &#123; records := [][]byte&#123; []byte(`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`), []byte(`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`), &#125; for idx, record := range records &#123; var result struct &#123; StatusCode uint64 StatusName string Status json.RawMessage `json:&quot;status&quot;` Tag string `json:&quot;tag&quot;` &#125; err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result) checkError(err) var name string err = json.Unmarshal(result.Status, &amp;name) if err == nil &#123; result.StatusName = name &#125; var code uint64 err = json.Unmarshal(result.Status, &amp;code) if err == nil &#123; result.StatusCode = code &#125; fmt.Printf(&quot;[%v] result =&gt; %+v\\n&quot;, idx, result) &#125;&#125; ​ 38. struct、array、slice 和 map 的值比较可以使用相等运算符 == 来比较结构体变量，前提是两个结构体的成员都是可比较的类型： 123456789101112131415161718type data struct &#123; num int fp float32 complex complex64 str string char rune yes bool events &lt;-chan string handler interface&#123;&#125; ref *byte raw [10]byte&#125;func main() &#123; v1 := data&#123;&#125; v2 := data&#123;&#125; fmt.Println(&quot;v1 == v2: &quot;, v1 == v2) // true&#125; 如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。 1234567891011121314type data struct &#123; num int checks [10]func() bool // 无法比较 doIt func() bool // 无法比较 m map[string]string // 无法比较 bytes []byte // 无法比较&#125;func main() &#123; v1 := data&#123;&#125; v2 := data&#123;&#125; fmt.Println(&quot;v1 == v2: &quot;, v1 == v2)&#125; invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared) Go 提供了一些库函数来比较那些无法使用 == 比较的变量，比如使用 “reflect” 包的 DeepEqual() ： 123456789101112131415// 比较相等运算符无法比较的元素func main() &#123; v1 := data&#123;&#125; v2 := data&#123;&#125; fmt.Println(&quot;v1 == v2: &quot;, reflect.DeepEqual(v1, v2)) // true m1 := map[string]string&#123;&quot;one&quot;: &quot;a&quot;, &quot;two&quot;: &quot;b&quot;&#125; m2 := map[string]string&#123;&quot;two&quot;: &quot;b&quot;, &quot;one&quot;: &quot;a&quot;&#125; fmt.Println(&quot;v1 == v2: &quot;, reflect.DeepEqual(m1, m2)) // true s1 := []int&#123;1, 2, 3&#125; s2 := []int&#123;1, 2, 3&#125; // 注意两个 slice 相等，值和顺序必须一致 fmt.Println(&quot;v1 == v2: &quot;, reflect.DeepEqual(s1, s2)) // true&#125; 这种比较方式可能比较慢，根据你的程序需求来使用。DeepEqual() 还有其他用法： 12345func main() &#123; var b1 []byte = nil b2 := []byte&#123;&#125; fmt.Println(&quot;b1 == b2: &quot;, reflect.DeepEqual(b1, b2)) // false&#125; 注意： DeepEqual() 并不总适合于比较 slice 123456789101112131415161718func main() &#123; var str = &quot;one&quot; var in interface&#123;&#125; = &quot;one&quot; fmt.Println(&quot;str == in: &quot;, reflect.DeepEqual(str, in)) // true v1 := []string&#123;&quot;one&quot;, &quot;two&quot;&#125; v2 := []string&#123;&quot;two&quot;, &quot;one&quot;&#125; fmt.Println(&quot;v1 == v2: &quot;, reflect.DeepEqual(v1, v2)) // false data := map[string]interface&#123;&#125;&#123; &quot;code&quot;: 200, &quot;value&quot;: []string&#123;&quot;one&quot;, &quot;two&quot;&#125;, &#125; encoded, _ := json.Marshal(data) var decoded map[string]interface&#123;&#125; json.Unmarshal(encoded, &amp;decoded) fmt.Println(&quot;data == decoded: &quot;, reflect.DeepEqual(data, decoded)) // false&#125; 如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 ToUpper() 和 ToLower() 函数。比较其他语言的 byte 或 string，应使用 bytes.EqualFold() 和 strings.EqualFold() 如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 reflect.DeepEqual()、bytes.Equal()、 bytes.Compare()。这三个函数容易对程序造成 timing attacks，此时应使用 “crypto&#x2F;subtle” 包中的 subtle.ConstantTimeCompare() 等函数 reflect.DeepEqual() 认为空 slice 与 nil slice 并不相等，但注意 byte.Equal() 会认为二者相等： 12345678func main() &#123; var b1 []byte = nil b2 := []byte&#123;&#125; // b1 与 b2 长度相等、有相同的字节序 // nil 与 slice 在字节上是相同的 fmt.Println(&quot;b1 == b2: &quot;, bytes.Equal(b1, b2)) // true&#125; 39. 从 panic 中恢复在一个 defer 延迟执行的函数中调用 recover() ，它便能捕捉 &#x2F; 中断 panic 123456789101112131415// 错误的 recover 调用示例func main() &#123; recover() // 什么都不会捕捉 panic(&quot;not good&quot;) // 发生 panic，主程序退出 recover() // 不会被执行 println(&quot;ok&quot;)&#125;// 正确的 recover 调用示例func main() &#123; defer func() &#123; fmt.Println(&quot;recovered: &quot;, recover()) &#125;() panic(&quot;not good&quot;)&#125; 从上边可以看出，recover() 仅在 defer 执行的函数中调用才会生效。 1234567891011// 错误的调用示例func main() &#123; defer func() &#123; doRecover() &#125;() panic(&quot;not good&quot;)&#125;func doRecover() &#123; fmt.Println(&quot;recobered: &quot;, recover())&#125; recobered: panic: not good 40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址： 1234567func main() &#123; data := []int&#123;1, 2, 3&#125; for _, v := range data &#123; v *= 10 // data 中原有元素是不会被修改的 &#125; fmt.Println(&quot;data: &quot;, data) // data: [1 2 3]&#125; 如果要修改原有元素的值，应该使用索引直接访问： 1234567func main() &#123; data := []int&#123;1, 2, 3&#125; for i, v := range data &#123; data[i] = v * 10 &#125; fmt.Println(&quot;data: &quot;, data) // data: [10 20 30]&#125; 如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值： 1234567func main() &#123; data := []*struct&#123; num int &#125;&#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;,&#125; for _, v := range data &#123; v.num *= 10 // 直接使用指针更新 &#125; fmt.Println(data[0], data[1], data[2]) // &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;&#125; 41. slice 中隐藏的数据从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。 12345678910func get() []byte &#123; raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), &amp;raw[0]) // 10000 10000 0xc420080000 return raw[:3] // 重新分配容量为 10000 的 slice&#125;func main() &#123; data := get() fmt.Println(len(data), cap(data), &amp;data[0]) // 3 10000 0xc420080000&#125; 可以通过拷贝临时 slice 的数据，而不是重新切片来解决： 123456789101112func get() (res []byte) &#123; raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), &amp;raw[0]) // 10000 10000 0xc420080000 res = make([]byte, 3) copy(res, raw[:3]) return&#125;func main() &#123; data := get() fmt.Println(len(data), cap(data), &amp;data[0]) // 3 3 0xc4200160b8&#125; 42. Slice 中数据的误用举个简单例子，重写文件路径（存储在 slice 中） 分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径： 1234567891011121314151617181920// 错误使用 slice 的拼接示例func main() &#123; path := []byte(&quot;AAAA/BBBBBBBBB&quot;) sepIndex := bytes.IndexByte(path, &#x27;/&#x27;) // 4 println(sepIndex) dir1 := path[:sepIndex] dir2 := path[sepIndex+1:] println(&quot;dir1: &quot;, string(dir1)) // AAAA println(&quot;dir2: &quot;, string(dir2)) // BBBBBBBBB dir1 = append(dir1, &quot;suffix&quot;...) println(&quot;current path: &quot;, string(path)) // AAAAsuffixBBBB path = bytes.Join([][]byte&#123;dir1, dir2&#125;, []byte&#123;&#x27;/&#x27;&#125;) println(&quot;dir1: &quot;, string(dir1)) // AAAAsuffix println(&quot;dir2: &quot;, string(dir2)) // uffixBBBB println(&quot;new path: &quot;, string(path)) // AAAAsuffix/uffixBBBB // 错误结果&#125; 拼接的结果不是正确的 AAAAsuffix/BBBBBBBBB，因为 dir1、 dir2 两个 slice 引用的数据都是 path 的底层数组，第 13 行修改 dir1 同时也修改了 path，也导致了 dir2 的修改 解决方法： 重新分配新的 slice 并拷贝你需要的数据 使用完整的 slice 表达式：input[low:high:max]，容量便调整为 max - low 1234567891011121314// 使用 full slice expressionfunc main() &#123; path := []byte(&quot;AAAA/BBBBBBBBB&quot;) sepIndex := bytes.IndexByte(path, &#x27;/&#x27;) // 4 dir1 := path[:sepIndex:sepIndex] // 此时 cap(dir1) 指定为4， 而不是先前的 16 dir2 := path[sepIndex+1:] dir1 = append(dir1, &quot;suffix&quot;...) path = bytes.Join([][]byte&#123;dir1, dir2&#125;, []byte&#123;&#x27;/&#x27;&#125;) println(&quot;dir1: &quot;, string(dir1)) // AAAAsuffix println(&quot;dir2: &quot;, string(dir2)) // BBBBBBBBB println(&quot;new path: &quot;, string(path)) // AAAAsuffix/BBBBBBBBB&#125; 第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组 43. 旧 slice当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。 某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。 1234567891011121314151617181920212223// 超过容量将重新分配数组来拷贝值、重新存储func main() &#123; s1 := []int&#123;1, 2, 3&#125; fmt.Println(len(s1), cap(s1), s1) // 3 3 [1 2 3 ] s2 := s1[1:] fmt.Println(len(s2), cap(s2), s2) // 2 2 [2 3] for i := range s2 &#123; s2[i] += 20 &#125; // 此时的 s1 与 s2 是指向同一个底层数组的 fmt.Println(s1) // [1 22 23] fmt.Println(s2) // [22 23] s2 = append(s2, 4) // 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存 for i := range s2 &#123; s2[i] += 10 &#125; fmt.Println(s1) // [1 22 23] // 此时的 s1 不再更新，为旧数据 fmt.Println(s2) // [32 33 14]&#125; 44. 类型声明与方法从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法： 12345678// 定义 Mutex 的自定义类型type myMutex sync.Mutexfunc main() &#123; var mtx myMutex mtx.Lock() mtx.UnLock()&#125; mtx.Lock undefined (type myMutex has no field or method Lock)… 如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中： 12345678910// 类型以字段形式直接嵌入type myLocker struct &#123; sync.Mutex&#125;func main() &#123; var locker myLocker locker.Lock() locker.Unlock()&#125; interface 类型声明也保留它的方法集： 1234567type myLocker sync.Lockerfunc main() &#123; var locker myLocker locker.Lock() locker.Unlock()&#125; 45. 跳出 for-switch 和 for-select 代码块没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块： 12345678910111213// break 配合 label 跳出指定代码块func main() &#123;loop: for &#123; switch &#123; case true: fmt.Println(&quot;breaking out...&quot;) //break // 死循环，一直打印 breaking out... break loop &#125; &#125; fmt.Println(&quot;out...&quot;)&#125; goto 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。 46. for 语句中的迭代变量与闭包函数for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值： 123456789101112func main() &#123; data := []string&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125; for _, v := range data &#123; go func() &#123; fmt.Println(v) &#125;() &#125; time.Sleep(3 * time.Second) // 输出 three three three&#125; 最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参： 12345678910111213func main() &#123; data := []string&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125; for _, v := range data &#123; vCopy := v go func() &#123; fmt.Println(vCopy) &#125;() &#125; time.Sleep(3 * time.Second) // 输出 one two three&#125; 另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数： 123456789101112func main() &#123; data := []string&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125; for _, v := range data &#123; go func(in string) &#123; fmt.Println(in) &#125;(v) &#125; time.Sleep(3 * time.Second) // 输出 one two three&#125; 注意下边这个稍复杂的 3 个示例区别： 123456789101112131415161718192021222324252627282930313233343536373839type field struct &#123; name string&#125;func (p *field) print() &#123; fmt.Println(p.name)&#125;// 错误示例func main() &#123; data := []field&#123;&#123;&quot;one&quot;&#125;, &#123;&quot;two&quot;&#125;, &#123;&quot;three&quot;&#125;&#125; for _, v := range data &#123; go v.print() &#125; time.Sleep(3 * time.Second) // 输出 three three three &#125;// 正确示例func main() &#123; data := []field&#123;&#123;&quot;one&quot;&#125;, &#123;&quot;two&quot;&#125;, &#123;&quot;three&quot;&#125;&#125; for _, v := range data &#123; v := v go v.print() &#125; time.Sleep(3 * time.Second) // 输出 one two three&#125;// 正确示例func main() &#123; data := []*field&#123;&#123;&quot;one&quot;&#125;, &#123;&quot;two&quot;&#125;, &#123;&quot;three&quot;&#125;&#125; for _, v := range data &#123; // 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同 go v.print() &#125; time.Sleep(3 * time.Second) // 输出 one two three&#125; 47. defer 函数的参数值对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值： 123456// 在 defer 函数中参数会提前求值func main() &#123; var i = 1 defer fmt.Println(&quot;result: &quot;, func() int &#123; return i * 2 &#125;()) i++&#125; result: 2 48. defer 函数的执行时机对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。 比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题： 123456789101112131415161718192021222324252627282930313233343536373839// 命令行参数指定目录名// 遍历读取目录下的文件func main() &#123; if len(os.Args) != 2 &#123; os.Exit(1) &#125; dir := os.Args[1] start, err := os.Stat(dir) if err != nil || !start.IsDir() &#123; os.Exit(2) &#125; var targets []string filepath.Walk(dir, func(fPath string, fInfo os.FileInfo, err error) error &#123; if err != nil &#123; return err &#125; if !fInfo.Mode().IsRegular() &#123; return nil &#125; targets = append(targets, fPath) return nil &#125;) for _, target := range targets &#123; f, err := os.Open(target) if err != nil &#123; fmt.Println(&quot;bad target:&quot;, target, &quot;error:&quot;, err) //error:too many open files break &#125; defer f.Close() // 在每次 for 语句块结束时，不会关闭文件资源 // 使用 f 资源 &#125;&#125; 先创建 10000 个文件： 1234#!/bin/bashfor n in &#123;1..10000&#125;; do echo content &gt; &quot;file$&#123;n&#125;.txt&quot;done 运行效果： 解决办法：defer 延迟执行的函数写入匿名函数中： 1234567891011121314151617// 目录遍历正常func main() &#123; // ... for _, target := range targets &#123; func() &#123; f, err := os.Open(target) if err != nil &#123; fmt.Println(&quot;bad target:&quot;, target, &quot;error:&quot;, err) return // 在匿名函数内使用 return 代替 break 即可 &#125; defer f.Close() // 匿名函数执行结束，调用关闭文件资源 // 使用 f 资源 &#125;() &#125;&#125; 当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 f.Close() 来关闭。 49. 失败的类型断言在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况： 1234567891011121314151617181920212223// 错误示例func main() &#123; var data interface&#123;&#125; = &quot;great&quot; // data 混用 if data, ok := data.(int); ok &#123; fmt.Println(&quot;[is an int], data: &quot;, data) &#125; else &#123; fmt.Println(&quot;[not an int], data: &quot;, data) // [isn&#x27;t a int], data: 0 &#125;&#125;// 正确示例func main() &#123; var data interface&#123;&#125; = &quot;great&quot; if res, ok := data.(int); ok &#123; fmt.Println(&quot;[is an int], data: &quot;, res) &#125; else &#123; fmt.Println(&quot;[not an int], data: &quot;, data) // [not an int], data: great &#125;&#125; 50. 阻塞的 gorutinue 与资源泄露在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 Go Concurrency Patterns 演讲讨论 Go 的几种基本并发模式，如 完整代码 中从数据集中获取第一条数据的函数： 12345678func First(query string, replicas []Search) Result &#123; c := make(chan Result) replicaSearch := func(i int) &#123; c &lt;- replicas[i](query) &#125; for i := range replicas &#123; go replicaSearch(i) &#125; return &lt;-c&#125; 在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。 返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？ 在 First() 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。 为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法： 使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果： 12345678func First(query string, replicas ...Search) Result &#123; c := make(chan Result,len(replicas)) searchReplica := func(i int) &#123; c &lt;- replicas[i](query) &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; 使用 select 语句，配合能保存一个缓冲值的 channel default 语句： default 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine 12345678910111213func First(query string, replicas ...Search) Result &#123; c := make(chan Result,1) searchReplica := func(i int) &#123; select &#123; case c &lt;- replicas[i](query): default: &#125; &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; 使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行： 12345678910111213141516func First(query string, replicas ...Search) Result &#123; c := make(chan Result) done := make(chan struct&#123;&#125;) defer close(done) searchReplica := func(i int) &#123; select &#123; case c &lt;- replicas[i](query): case &lt;- done: &#125; &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。 高级篇：51-5751. 使用指针作为方法的 receiver只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。 但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量： 123456789101112131415161718192021222324type data struct &#123; name string&#125;type printer interface &#123; print()&#125;func (p *data) print() &#123; fmt.Println(&quot;name: &quot;, p.name)&#125;func main() &#123; d1 := data&#123;&quot;one&quot;&#125; d1.print() // d1 变量可寻址，可直接调用指针 receiver 的方法 var in printer = data&#123;&quot;two&quot;&#125; in.print() // 类型不匹配 m := map[string]data&#123; &quot;x&quot;: data&#123;&quot;three&quot;&#125;, &#125; m[&quot;x&quot;].print() // m[&quot;x&quot;] 是不可寻址的 // 变动频繁&#125; cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver) cannot call pointer method on m[“x”]cannot take the address of m[“x”] 52. 更新 map 字段的值如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段： 1234567891011// 无法直接更新 struct 的字段值type data struct &#123; name string&#125;func main() &#123; m := map[string]data&#123; &quot;x&quot;: &#123;&quot;Tom&quot;&#125;, &#125; m[&quot;x&quot;].name = &quot;Jerry&quot;&#125; cannot assign to struct field m[“x”].name in map 因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址： 123456789type data struct &#123; name string&#125;func main() &#123; s := []data&#123;&#123;&quot;Tom&quot;&#125;&#125; s[0].name = &quot;Jerry&quot; fmt.Println(s) // [&#123;Jerry&#125;]&#125; 注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。 更新 map 中 struct 元素的字段值，有 2 个方法： 使用局部变量 1234567891011121314// 提取整个 struct 到局部变量中，修改字段值后再整个赋值type data struct &#123; name string&#125;func main() &#123; m := map[string]data&#123; &quot;x&quot;: &#123;&quot;Tom&quot;&#125;, &#125; r := m[&quot;x&quot;] r.name = &quot;Jerry&quot; m[&quot;x&quot;] = r fmt.Println(m) // map[x:&#123;Jerry&#125;]&#125; 使用指向元素的 map 指针 12345678func main() &#123; m := map[string]*data&#123; &quot;x&quot;: &#123;&quot;Tom&quot;&#125;, &#125; m[&quot;x&quot;].name = &quot;Jerry&quot; // 直接修改 m[&quot;x&quot;] 中的字段 fmt.Println(m[&quot;x&quot;]) // &amp;&#123;Jerry&#125;&#125; 但是要注意下边这种误用： 1234567func main() &#123; m := map[string]*data&#123; &quot;x&quot;: &#123;&quot;Tom&quot;&#125;, &#125; m[&quot;z&quot;].name = &quot;what???&quot; fmt.Println(m[&quot;x&quot;])&#125; panic: runtime error: invalid memory address or nil pointer dereference 53. nil interface 和 nil interface 值虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil 如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心： 12345678910func main() &#123; var data *byte var in interface&#123;&#125; fmt.Println(data, data == nil) // &lt;nil&gt; true fmt.Println(in, in == nil) // &lt;nil&gt; true in = data fmt.Println(in, in == nil) // &lt;nil&gt; false // data 值为 nil，但 in 值不为 nil&#125; 如果你的函数返回值类型是 interface，更要小心这个坑： 123456789101112131415161718192021222324252627282930313233343536// 错误示例func main() &#123; doIt := func(arg int) interface&#123;&#125; &#123; var result *struct&#123;&#125; = nil if arg &gt; 0 &#123; result = &amp;struct&#123;&#125;&#123;&#125; &#125; return result &#125; if res := doIt(-1); res != nil &#123; fmt.Println(&quot;Good result: &quot;, res) // Good result: &lt;nil&gt; fmt.Printf(&quot;%T\\n&quot;, res) // *struct &#123;&#125; // res 不是 nil，它的值为 nil fmt.Printf(&quot;%v\\n&quot;, res) // &lt;nil&gt; &#125;&#125;// 正确示例func main() &#123; doIt := func(arg int) interface&#123;&#125; &#123; var result *struct&#123;&#125; = nil if arg &gt; 0 &#123; result = &amp;struct&#123;&#125;&#123;&#125; &#125; else &#123; return nil // 明确指明返回 nil &#125; return result &#125; if res := doIt(-1); res != nil &#123; fmt.Println(&quot;Good result: &quot;, res) &#125; else &#123; fmt.Println(&quot;Bad result: &quot;, res) // Bad result: &lt;nil&gt; &#125;&#125; 54. 堆栈变量你并不总是清楚你的变量是分配到了堆还是栈。 在 C++ 中使用 new 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 new()、make() 来创建变量，变量为内存分配位置依旧归 Go 编译器管。 Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。 在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置： 55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。 Go 1.5 版本将可执行上下文的数量设置为 runtime.NumCPU() 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 GOMAXPROCS 环境变量或者动态的使用 runtime.GOMAXPROCS() 来调整。 误区：GOMAXPROCS 表示执行 goroutine 的 CPU 核心数，参考文档 GOMAXPROCS 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256 12345678func main() &#123; fmt.Println(runtime.GOMAXPROCS(-1)) // 4 fmt.Println(runtime.NumCPU()) // 4 runtime.GOMAXPROCS(20) fmt.Println(runtime.GOMAXPROCS(-1)) // 20 runtime.GOMAXPROCS(300) fmt.Println(runtime.GOMAXPROCS(-1)) // Go 1.9.2 // 300&#125; 56. 读写操作的重新排序Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序： 12345678910111213141516171819202122232425var _ = runtime.GOMAXPROCS(3)var a, b intfunc u1() &#123; a = 1 b = 2&#125;func u2() &#123; a = 3 b = 4&#125;func p() &#123; println(a) println(b)&#125;func main() &#123; go u1() // 多个 goroutine 的执行顺序不定 go u2() go p() time.Sleep(1 * time.Second)&#125; 运行效果： 如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。 57. 优先调度你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 for 循环： 123456789101112func main() &#123; done := false go func() &#123; done = true &#125;() for !done &#123; &#125; println(&quot;done !&quot;)&#125; for 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。 调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行： 12345678910111213func main() &#123; done := false go func() &#123; done = true &#125;() for !done &#123; println(&quot;not done !&quot;) // 并不内联执行 &#125; println(&quot;done !&quot;)&#125; 可以添加 -m 参数来分析 for 代码块中调用的内联函数： 你也可以使用 runtime 包中的 Gosched() 来 手动启动调度器： 12345678910111213func main() &#123; done := false go func() &#123; done = true &#125;() for !done &#123; runtime.Gosched() &#125; println(&quot;done !&quot;)&#125; 运行效果： 总结感谢原作者 kcqon 总结的这篇博客，让我受益匪浅。 由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。 后续再更新类似高质量文章的翻译 😍","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Golang 学习资料","slug":"olang/Golang 学习资料","date":"2025-06-15T16:56:12.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2025-06-15-4bfc586514c9.html","link":"","permalink":"https://leiqi.top/2025-06-15-4bfc586514c9.html","excerpt":"","text":"learning&#x2F;golang&#x2F;README.md at 8de2b0bd2ad36d296e1808080073cdb8521627af · anzhihe&#x2F;learning Golang learning book and source code- Head First Go英文版- Go程序设计语言- Go语言实战- Go语言核心编程笔记- Go学习笔记 第四版- Go源码剖析（书签版）- Go_web_编程- Go Web 编程- Go并发编程实战_第1版- Go并发编程实战_第2版_Lite- Go语言并发之道- Go网络编程- Go语言圣经(中文版)- 2020最新Gin框架中文文档- 大厂Go工程师面试题集锦- Golang常见面试题目解析 Golang官网 Golang doc The Go Blog Golang github Go by Example The Go Playground Golang 新手可能会踩的 50 个坑 Go语言101 Go语言中文网 Go 语言学习资料与社区索引 Go Books 《Go入门指南》 《Go语言入门教程》 build-web-application-with-golang Go 程序设计语言代码示例和练习题参考答案 Go 语言原本 Go 语言编程之旅 Go设计模式 地鼠文档 Go语言快速入门实战开发 参考：https://github.com/anzhihe/learning.git","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Golang list.List 双向链表实现LRU","slug":"eetcode/Golang list.List 双向链表实现LRU","date":"2025-06-15T16:36:57.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2025-06-15-60ed4ee14474.html","link":"","permalink":"https://leiqi.top/2025-06-15-60ed4ee14474.html","excerpt":"","text":"Go语言中使用双向链表(list.List)实现LRU缓存LeetCode第146题”LRU缓存”来演示如何在Go语言中使用container/list包中的双向链表。 LRU缓存题目要求设计一个LRU (Least Recently Used) 缓存机制，它应该支持以下操作： Get(key): 如果密钥存在则获取值，否则返回-1 Put(key, value): 如果密钥不存在，则写入数据；当缓存容量达到上限时，删除最久未使用的数据 实现方案我们将使用container/list包中的双向链表来跟踪访问顺序，同时使用map来实现快速查找。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import ( &quot;container/list&quot;)// LRUCache 结构体type LRUCache struct &#123; capacity int // 缓存容量 list *list.List // 双向链表用于维护访问顺序 cache map[int]*list.Element // 哈希表用于快速查找&#125;// entry 用于存储键值对type entry struct &#123; key int value int&#125;// Constructor 初始化LRU缓存func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; capacity: capacity, list: list.New(), cache: make(map[int]*list.Element), &#125;&#125;// Get 获取键对应的值func (l *LRUCache) Get(key int) int &#123; if elem, ok := l.cache[key]; ok &#123; // 将访问的元素移动到链表头部表示最近使用 l.list.MoveToFront(elem) return elem.Value.(*entry).value &#125; return -1&#125;// Put 插入或更新键值对func (l *LRUCache) Put(key int, value int) &#123; // 如果键已存在，更新值并移动到头部 if elem, ok := l.cache[key]; ok &#123; l.list.MoveToFront(elem) elem.Value.(*entry).value = value return &#125; // 如果缓存已满，删除最近最少使用的元素（链表尾部） if l.list.Len() == l.capacity &#123; tail := l.list.Back() if tail != nil &#123; delete(l.cache, tail.Value.(*entry).key) l.list.Remove(tail) &#125; &#125; // 添加新元素到链表头部 elem := l.list.PushFront(&amp;entry&#123;key, value&#125;) l.cache[key] = elem&#125; 使用slice 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type LRUCache struct &#123; capacity int keysList []int // 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间 keysMap map[int]int // 存放key value&#125;func Constructor(capacity int) LRUCache &#123; //return return LRUCache&#123;capacity, make([]int, 0), make(map[int]int, 0)&#125;&#125;// 如果key存在于缓存中，则返回关键字的值，否则返回-1func (this *LRUCache) Get(key int) int &#123; if ele, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) return ele &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; // 关键字存在 则更新值为value // 不存在，则插入value // 如果插入超过数量capacity 则删除最久没有使用的关键字【list] if _, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) this.keysMap[key] = value &#125; else &#123; this.updateListKey(key) this.keysMap[key] = value if len(this.keysList) &gt; this.capacity &#123; delete(this.keysMap, this.keysList[0]) // 这里删除key 从list队列中获取 this.keysList = this.keysList[1:] &#125; &#125;&#125;func (this *LRUCache) updateListKey(key int) &#123; for i := 0; i &lt; len(this.keysList); i++ &#123; if key == this.keysList[i] &#123; this.keysList = append(this.keysList[:i], this.keysList[i+1:]...) // 删除该key, 然后放在末尾 break &#125; &#125; this.keysList = append(this.keysList, key)&#125; 关键点解析 双向链表的使用: list.New() 创建一个新的双向链表 PushFront() 在链表头部插入元素 MoveToFront() 将元素移动到链表头部 Back() 获取链表尾部元素 Remove() 从链表中删除元素 LRU策略实现: 最近访问的元素总是放在链表头部 当需要淘汰元素时，删除链表尾部的元素 使用map实现O(1)时间的查找 性能分析: Get操作时间复杂度: O(1) Put操作时间复杂度: O(1) 空间复杂度: O(capacity)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Obsidian配置代理","slug":"具/Obsidian配置代理","date":"2025-06-15T16:07:58.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2025-06-15-980a140fe20b.html","link":"","permalink":"https://leiqi.top/2025-06-15-980a140fe20b.html","excerpt":"","text":"在 Obsidian 中设置代理（Proxy）需要通过 系统环境变量 或 插件 来实现，因为 Obsidian 本身没有内置的代理设置选项。以下是几种方法： 方法 1：通过环境变量设置全局代理（推荐）Obsidian 是基于 Electron 的应用程序，它会遵循系统的 HTTP&#x2F;HTTPS 代理设置。你可以通过以下方式设置： Windows 临时设置（仅当前终端窗口有效）在 CMD&#x2F;PowerShell 中运行： 123set http_proxy=http://127.0.0.1:7897set https_proxy=http://127.0.0.1:7897set all_proxy=socks5://127.0.0.1:7897 然后启动 Obsidian： 1start &quot;&quot; &quot;C:\\path\\to\\Obsidian.exe&quot; 永久设置（系统环境变量）我使用的这个 按 Win + R，输入 sysdm.cpl 打开 系统属性。 进入 高级 → 环境变量。 在 用户变量 或 系统变量 中添加：123HTTP_PROXY=http://127.0.0.1:7897HTTPS_PROXY=http://127.0.0.1:7897ALL_PROXY=socks5://127.0.0.1:7897 重启 Obsidian。 macOS&#x2F;Linux 临时设置（终端启动） 123export http_proxy=http://127.0.0.1:7897export https_proxy=http://127.0.0.1:7897export all_proxy=socks5://127.0.0.1:7897 然后启动 Obsidian： 12open -a Obsidian # macOSobsidian &amp; # Linux（如果安装正确） 永久设置（.bashrc&#x2F;.zshrc）在 ~/.bashrc 或 ~/.zshrc 中添加： 123export http_proxy=http://127.0.0.1:7897export https_proxy=http://127.0.0.1:7897export all_proxy=socks5://127.0.0.1:7897 然后运行： 1source ~/.bashrc # 或 source ~/.zshrc 重启 Obsidian。 方法 2：使用 Proxy 插件（如果 Obsidian 支持）Obsidian 本身没有官方代理插件，但你可以尝试： 安装 obsidian-proxy 插件（如果存在） 进入 设置 → 社区插件 → 浏览，搜索 proxy。 安装并配置代理地址。 使用第三方工具（如 Proxifier&#x2F;Clash） 在 Proxifier 中设置 Obsidian 走代理：1规则：Obsidian.exe → SOCKS5 127.0.0.1:7897 方法 3：修改 Electron 启动参数（高级）如果 Obsidian 是基于 Electron 的，可以尝试修改启动参数： 1obsidian --proxy-server=&quot;http://127.0.0.1:7897&quot; （需找到 Obsidian 的实际启动方式） 验证代理是否生效 在 Obsidian 中安装插件或同步数据，看是否正常访问。 使用 curl -v https://api.obsidian.md 测试代理是否生效。 总结 方法 适用场景 持久性 环境变量 推荐，全局生效 ✅ 永久 终端临时设置 测试用 ❌ 临时 Proxy 插件 如果 Obsidian 支持 ⚠️ 依赖插件 Proxifier&#x2F;Clash 强制代理所有流量 ✅ 系统级 如果你的代理是 http://127.0.0.1:7897 或 socks5://127.0.0.1:7897（如 Clash&#x2F;V2Ray），建议优先使用 环境变量 方法。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【Golang】 函数传入slice无法修改到原slice","slug":"eetcode/【Golang】 函数传入slice无法修改到原slice","date":"2025-06-15T05:53:49.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2025-06-15-f16e0f79fc66.html","link":"","permalink":"https://leiqi.top/2025-06-15-f16e0f79fc66.html","excerpt":"","text":"46. 全排列 - 力扣（LeetCode） 1234567891011121314151617181920212223242526272829303132333435363738func permute(nums []int) [][]int &#123; res := [][]int&#123;&#125; track := []int&#123;&#125; used := make([]bool, len(nums)) backtrack(nums, track, used, &amp;res) return res&#125;// 回溯函数func backtrack(nums []int, track []int, used []bool, res *[][]int) &#123; // 触发结束条件 if len(track) == len(nums) &#123; // 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列 temp := make([]int, len(track)) copy(temp, track) *res = append(*res, temp) return &#125; for i := range nums &#123; // 排除不合法的选择 if used[i] &#123; // 剪枝，避免重复使用同一个数字 continue &#125; // 做选择 track = append(track, nums[i]) used[i] = true // 进入下一层决策树 backtrack(nums, track, used, res) // 取消选择 track = track[:len(track)-1] used[i] = false &#125;&#125; 上边的res 代码slice中需要使用指针 我去掉指针不行。 使用闭包函数可以。 1234567891011121314151617181920212223242526272829303132333435363738func permute(nums []int) [][]int &#123; res := [][]int&#123;&#125; track := []int&#123;&#125; used := make([]bool, len(nums)) var backtrack func() backtrack = func() &#123; // 触发结束条件 if len(track) == len(nums) &#123; // 因为 track 是全局变量，因此需要新建一个数组来存储一份全排列 temp := make([]int, len(track)) copy(temp, track) res = append(res, temp) return &#125; for i := range nums &#123; // 排除不合法的选择 if used[i] &#123; // 剪枝，避免重复使用同一个数字 continue &#125; // 做选择 track = append(track, nums[i]) used[i] = true // 进入下一层决策树 backtrack() // 取消选择 track = track[:len(track)-1] used[i] = false &#125;&#125; backtrack() return res&#125;// 回溯函数 切片与指针的区别Go 中的切片是引用类型，但它们与指针在行为上还是有一些关键区别，这正是为什么在这个回溯算法中需要使用指针的原因。 切片作为引用类型的局限虽然切片是引用类型（底层数组的指针+长度+容量），但切片头（slice header）本身是按值传递的。这意味着： 可以修改底层数组元素：函数内部可以修改切片指向的数组元素，这些修改会反映到外部 不能修改切片头：对切片本身的修改（如追加元素导致重新分配）不会反映到外部 具体到代码回溯算法中： 1*res = append(*res, temp) // 使用指针可以修改外部的res 如果改为不使用指针： 1res = append(res, temp) // 这只修改了函数内部的切片头副本 为什么需要指针的详细解释 追加操作的特殊性： append 可能会返回一个新的切片头（当容量不足时） 不使用指针时，新切片头只存在于函数内部 递归调用的累积效果： 每次递归调用都需要累积结果 不使用指针时，每次递归的修改都会丢失 验证示例简单例子验证： 1234567891011121314151617func modifySlice(s []int) &#123; s = append(s, 100) // 不会影响外部 s[0] = 99 // 会影响外部（修改底层数组）&#125;func modifySliceByPtr(s *[]int) &#123; *s = append(*s, 100) // 会影响外部&#125;func main() &#123; a := []int&#123;1, 2, 3&#125; modifySlice(a) fmt.Println(a) // 输出: [99 2 3] modifySliceByPtr(&amp;a) fmt.Println(a) // 输出: [99 2 3 100]&#125; 结论在需要修改切片本身（如追加元素）并且希望这些修改在函数外部可见时，必须使用指针。这正是你的回溯算法中需要使用 *[][]int 的原因。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Golang LeetCode 刷题必备基础和常用模板","slug":"olang/Golang LeetCode 刷题必备基础和常用模板","date":"2025-06-13T16:03:18.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2025-06-13-e749796f24c2.html","link":"","permalink":"https://leiqi.top/2025-06-13-e749796f24c2.html","excerpt":"","text":"Golang LeetCode 刷题必备基础备忘录1. 基础数据结构用法数组&#x2F;切片 (Slice)12345678910// 初始化arr := []int&#123;1, 2, 3&#125;slice := make([]int, 5) // 长度5slice2 := make([]int, 0, 10) // 长度0，容量10// 操作slice = append(slice, 4) // 追加len(slice) // 长度copy(dest, src) // 复制sort.Ints(slice) // 排序 字符串 (String)1234567891011121314// 基本操作s := &quot;hello&quot;len(s) // 字节长度(非字符数)utf8.RuneCountInString(s) // 字符数strings.Contains(s, &quot;ell&quot;) // truestrings.Split(&quot;a,b,c&quot;, &quot;,&quot;) // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]strings.Join([]string&#123;&quot;a&quot;,&quot;b&quot;&#125;, &quot;-&quot;) // &quot;a-b&quot;strconv.Itoa(123) // &quot;123&quot;strconv.Atoi(&quot;123&quot;) // 123, error// 遍历字符for i, r := range s &#123; // r是rune类型(Unicode码点) fmt.Printf(&quot;%d: %c\\n&quot;, i, r)&#125; 映射 (Map)1234m := make(map[string]int)m[&quot;key&quot;] = 1val, exists := m[&quot;key&quot;] // exists为bool表示是否存在delete(m, &quot;key&quot;) // 删除键 链表 (List)1234567import &quot;container/list&quot;l := list.New()l.PushBack(1)l.PushFront(2)for e := l.Front(); e != nil; e = e.Next() &#123; fmt.Println(e.Value)&#125; 2. 常用算法模板二分查找1234567891011121314func binarySearch(nums []int, target int) int &#123; left, right := 0, len(nums)-1 for left &lt;= right &#123; mid := left + (right-left)/2 if nums[mid] == target &#123; return mid &#125; else if nums[mid] &lt; target &#123; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return -1&#125; 快速排序123456789101112131415161718192021func quickSort(nums []int) &#123; if len(nums) &lt;= 1 &#123; return &#125; pivot := nums[0] left, right := 0, len(nums)-1 for i := 1; i &lt;= right; &#123; if nums[i] &lt; pivot &#123; nums[i], nums[left] = nums[left], nums[i] left++ i++ &#125; else if nums[i] &gt; pivot &#123; nums[i], nums[right] = nums[right], nums[i] right-- &#125; else &#123; i++ &#125; &#125; quickSort(nums[:left]) quickSort(nums[right+1:])&#125; 3. 标准库重要包sort 排序包1234567891011import &quot;sort&quot;// 基本类型排序sort.Ints(arr)sort.Strings(arr)sort.Float64s(arr)// 自定义排序sort.Slice(people, func(i, j int) bool &#123; return people[i].Age &lt; people[j].Age&#125;) container/heap 堆实现123456789101112131415161718192021import &quot;container/heap&quot;// 最小堆示例type MinHeap []intfunc (h MinHeap) Len() int &#123; return len(h) &#125;func (h MinHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;func (h MinHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;func (h *MinHeap) Push(x any) &#123; *h = append(*h, x.(int)) &#125;func (h *MinHeap) Pop() any &#123; old := *h n := len(old) x := old[n-1] *h = old[:n-1] return x&#125;// 使用h := &amp;MinHeap&#123;2, 1, 5&#125;heap.Init(h)heap.Push(h, 3)smallest := heap.Pop(h) math 数学包1234567891011import &quot;math&quot;math.Max(float64, float64)math.Min(float64, float64)math.Abs(float64)math.Pow(x, y float64)math.Sqrt(float64)math.Ceil(float64)math.Floor(float64)math.MaxInt32 // 常量math.MinInt32 4. 并发编程基础Goroutine123go func() &#123; // 并发执行的代码&#125;() Channel1234567891011121314ch := make(chan int, 10) // 缓冲通道ch &lt;- 1 // 发送val := &lt;-ch // 接收close(ch) // 关闭通道// select多路复用select &#123;case v := &lt;-ch1: fmt.Println(v)case ch2 &lt;- 1: fmt.Println(&quot;sent&quot;)default: fmt.Println(&quot;default&quot;)&#125; 5. 常用技巧位运算12345n &amp; 1 // 判断奇偶n &gt;&gt; 1 // 除以2n &lt;&lt; 1 // 乘以2a ^ b // 异或a &amp;^ b // 位清除 常用常量12const INT_MAX = int(^uint(0) &gt;&gt; 1const INT_MIN = ^INT_MAX 快速输入输出 (竞赛用)1234567891011import ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)reader := bufio.NewReader(os.Stdin)writer := bufio.NewWriter(os.Stdout)defer writer.Flush()fmt.Fscan(reader, &amp;a, &amp;b)fmt.Fprintln(writer, a+b) 6. 测试用例写法1234567891011121314151617181920import &quot;testing&quot;func TestFunc(t *testing.T) &#123; tests := []struct &#123; name string input int want int &#125;&#123; &#123;&quot;case1&quot;, 1, 2&#125;, &#123;&quot;case2&quot;, 2, 4&#125;, &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if got := Func(tt.input); got != tt.want &#123; t.Errorf(&quot;Func() = %v, want %v&quot;, got, tt.want) &#125; &#125;) &#125;&#125; 7. 常见题型解题要点 双指针：数组&#x2F;链表问题，滑动窗口 DFS&#x2F;BFS：树&#x2F;图遍历，回溯问题 动态规划：状态转移方程，备忘录 贪心算法：局部最优解 并查集：连通性问题 前缀和&#x2F;差分数组：区间查询&#x2F;更新 单调栈：下一个更大&#x2F;小元素问题 1. 双指针技巧数组&#x2F;链表问题模板12345678910111213141516171819202122232425// 快慢指针找链表中点func middleNode(head *ListNode) *ListNode &#123; slow, fast := head, head for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; return slow&#125;// 有序数组两数之和func twoSum(nums []int, target int) []int &#123; left, right := 0, len(nums)-1 for left &lt; right &#123; sum := nums[left] + nums[right] if sum == target &#123; return []int&#123;left, right&#125; &#125; else if sum &lt; target &#123; left++ &#125; else &#123; right-- &#125; &#125; return nil&#125; 滑动窗口模板123456789101112131415func slidingWindow(s string) int &#123; freq := make(map[byte]int) left, maxLen := 0, 0 for right := 0; right &lt; len(s); right++ &#123; freq[s[right]]++ // 窗口收缩条件 for freq[s[right]] &gt; 1 &#123; freq[s[left]]-- left++ &#125; maxLen = max(maxLen, right-left+1) &#125; return maxLen&#125; 2. DFS&#x2F;BFS 算法树遍历模板12345678910111213141516171819202122232425262728293031323334353637// DFS 递归遍历func dfs(root *TreeNode) &#123; if root == nil &#123; return &#125; // 前序位置 dfs(root.Left) // 中序位置 dfs(root.Right) // 后序位置&#125;// BFS 层序遍历func bfs(root *TreeNode) [][]int &#123; var res [][]int if root == nil &#123; return res &#125; queue := []*TreeNode&#123;root&#125; for len(queue) &gt; 0 &#123; levelSize := len(queue) var level []int for i := 0; i &lt; levelSize; i++ &#123; node := queue[0] queue = queue[1:] level = append(level, node.Val) if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; res = append(res, level) &#125; return res&#125; 回溯算法模板12345678910111213141516171819202122232425func backtrack(nums []int) [][]int &#123; var res [][]int var path []int used := make([]bool, len(nums)) var dfs func() dfs = func() &#123; if len(path) == len(nums) &#123; res = append(res, append([]int&#123;&#125;, path...)) return &#125; for i := 0; i &lt; len(nums); i++ &#123; if used[i] &#123; continue &#125; used[i] = true path = append(path, nums[i]) dfs() path = path[:len(path)-1] used[i] = false &#125; &#125; dfs() return res&#125; 3. 动态规划经典DP模板1234567891011121314151617181920212223242526272829303132// 斐波那契数列 (备忘录)func fib(n int) int &#123; if n &lt;= 1 &#123; return n &#125; dp := make([]int, n+1) dp[0], dp[1] = 0, 1 for i := 2; i &lt;= n; i++ &#123; dp[i] = dp[i-1] + dp[i-2] &#125; return dp[n]&#125;// 0-1背包问题func knapsack(weights []int, values []int, W int) int &#123; n := len(weights) dp := make([][]int, n+1) for i := range dp &#123; dp[i] = make([]int, W+1) &#125; for i := 1; i &lt;= n; i++ &#123; for w := 1; w &lt;= W; w++ &#123; if weights[i-1] &gt; w &#123; dp[i][w] = dp[i-1][w] &#125; else &#123; dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1]) &#125; &#125; &#125; return dp[n][W]&#125; 4. 贪心算法区间调度问题1234567891011121314151617func intervalSchedule(intervals [][]int) int &#123; // 按结束时间排序 sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][1] &lt; intervals[j][1] &#125;) count := 1 end := intervals[0][1] for _, interval := range intervals &#123; start := interval[0] if start &gt;= end &#123; count++ end = interval[1] &#125; &#125; return count&#125; 5. 并查集标准实现123456789101112131415161718192021222324252627282930type UnionFind struct &#123; parent []int count int&#125;func NewUnionFind(n int) *UnionFind &#123; parent := make([]int, n) for i := range parent &#123; parent[i] = i &#125; return &amp;UnionFind&#123;parent, n&#125;&#125;func (uf *UnionFind) Find(x int) int &#123; for uf.parent[x] != x &#123; uf.parent[x] = uf.parent[uf.parent[x]] // 路径压缩 x = uf.parent[x] &#125; return x&#125;func (uf *UnionFind) Union(x, y int) &#123; rootX := uf.Find(x) rootY := uf.Find(y) if rootX == rootY &#123; return &#125; uf.parent[rootX] = rootY uf.count--&#125; 6. 前缀和与差分数组前缀和模板12345678910111213141516171819202122232425262728293031323334353637383940414243// 一维前缀和type PrefixSum struct &#123; prefix []int&#125;func NewPrefixSum(nums []int) *PrefixSum &#123; n := len(nums) prefix := make([]int, n+1) for i := 1; i &lt;= n; i++ &#123; prefix[i] = prefix[i-1] + nums[i-1] &#125; return &amp;PrefixSum&#123;prefix&#125;&#125;func (ps *PrefixSum) Query(i, j int) int &#123; return ps.prefix[j+1] - ps.prefix[i]&#125;// 二维前缀和type NumMatrix struct &#123; prefix [][]int&#125;func Constructor(matrix [][]int) NumMatrix &#123; if len(matrix) == 0 &#123; return NumMatrix&#123;&#125; &#125; m, n := len(matrix), len(matrix[0]) prefix := make([][]int, m+1) for i := range prefix &#123; prefix[i] = make([]int, n+1) &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + matrix[i-1][j-1] &#125; &#125; return NumMatrix&#123;prefix&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123; return this.prefix[row2+1][col2+1] - this.prefix[row1][col2+1] - this.prefix[row2+1][col1] + this.prefix[row1][col1]&#125; 7. 单调栈下一个更大元素123456789101112131415161718192021func nextGreaterElements(nums []int) []int &#123; n := len(nums) res := make([]int, n) for i := range res &#123; res[i] = -1 &#125; stack := []int&#123;&#125; // 存储索引 for i := 0; i &lt; 2*n; i++ &#123; num := nums[i%n] for len(stack) &gt; 0 &amp;&amp; num &gt; nums[stack[len(stack)-1]] &#123; top := stack[len(stack)-1] stack = stack[:len(stack)-1] res[top] = num &#125; if i &lt; n &#123; stack = append(stack, i) &#125; &#125; return res&#125; 柱状图中最大矩形12345678910111213141516func largestRectangleArea(heights []int) int &#123; heights = append(heights, 0) // 哨兵 stack := []int&#123;-1&#125; // 哨兵 maxArea := 0 for i := 0; i &lt; len(heights); i++ &#123; for len(stack) &gt; 1 &amp;&amp; heights[i] &lt; heights[stack[len(stack)-1]] &#123; h := heights[stack[len(stack)-1]] stack = stack[:len(stack)-1] w := i - stack[len(stack)-1] - 1 maxArea = max(maxArea, h*w) &#125; stack = append(stack, i) &#125; return maxArea&#125; 各题型解题要点总结 双指针： 数组问题：注意有序数组的特殊性质 滑动窗口：明确窗口收缩条件，维护窗口状态 DFS&#x2F;BFS： 树遍历：前中后序选择取决于问题需求 回溯：注意状态恢复，剪枝优化 动态规划： 明确状态定义和转移方程 考虑空间优化（滚动数组） 贪心算法： 证明贪心选择的正确性 通常需要先排序 并查集： 路径压缩和按秩合并优化 处理连通分量问题 前缀和&#x2F;差分： 前缀和用于快速区间查询 差分数组用于快速区间更新 单调栈： 维护栈内元素的单调性 用于解决”下一个更大&#x2F;小元素”类问题","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang 堆中返回的值为什么是最后一个，不是0位","slug":"olang/golang 堆中返回的值为什么是最后一个，不是0位","date":"2025-06-12T17:02:18.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2025-06-12-6ce91bef2b21.html","link":"","permalink":"https://leiqi.top/2025-06-12-6ce91bef2b21.html","excerpt":"","text":"这涉及到 Go 中 sort.Slice 和堆(container/heap) 实现的关键区别。虽然它们都使用 Less 函数，但行为完全不同： 1. sort.Slice 的 Less 函数（排序场景）123sort.Slice(people, func(i, j int) bool &#123; return people[i].Age &lt; people[j].Age // 升序排序&#125;) 作用：直接定义最终排序顺序 结果：当 people[i].Age &lt; people[j].Age 时，i 会排在 j 前面 → 升序排列 内存布局：切片物理位置就是有序的，索引0是最小值，最后索引是最大值 2. 堆的 Less 函数（堆场景）1234type IntHeap []intfunc (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] // 最小堆定义&#125; 作用：定义堆的父子节点关系（不是最终排序顺序！） 堆性质：在最小堆中，任意父节点 ≤ 子节点 内存布局：堆是半排序的树状结构（数组实现）： 索引0位置是根节点（最小值） 最后一个元素位置不固定（可能大也可能小） 关键区别：Pop() 的实现堆的 Pop() 操作有特殊处理： 1234567func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] // 取出最后一个元素 *h = old[0 : n-1] return x&#125; 为什么取最后一个元素？ 因为在标准库 heap.Pop() 中已经做了前置操作： 1234567// 标准库 heap.Pop() 的伪代码：func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() h.Swap(0, n-1) // 关键！交换根节点(最小值)和最后一个节点 down(h, 0, n-1) // 重新堆化 return h.Pop() // 此时调用用户实现的Pop（取最后元素）&#125; 堆操作流程（最小堆为例） 初始化堆：[3, 1, 5] → 堆化后: [1, 3, 5] 索引0&#x3D;1（最小值） 最后索引&#x3D;5 heap.Pop() 内部过程： 交换根节点和最后节点: [5, 3, 1] 重新堆化前n-1个元素: [3, 5] → 堆化后 [3, 5] 调用用户 Pop() 返回最后元素 1（最小值） 结果： 堆变为 [3, 5] 弹出值 1（最小值） 为什么最后位置不是最大值？ 堆的物理存储不是全排序的，只保证父≤子 最后一个元素是最后一片叶子节点，可能很小也可能很大 通过 Swap(0, n-1) 操作，实际弹出的是原根节点（最小值） 堆的视觉表示初始数组：[3, 1, 5]堆化后内存布局：[1, 3, 5]树状结构： 123 1 (根节点=最小值) / \\3 5 (5是最后一个叶子节点) Pop 时交换根和最后叶子： 123 5 (临时根) / 3 [1被交换到最后位置] 总结 特性 sort.Slice container/heap Less 作用 定义最终排序顺序 定义父子节点关系 内存布局 完全有序 半有序（树状结构） 索引0位置 最小值（升序时） 根节点（最小值） 最后索引位置 最大值（升序时） 不固定（最后一个叶子节点） Pop() 行为 无此操作 返回交换后的最后一个元素（原根节点） 因此，在堆实现中： h[i] &lt; h[j] 定义的是最小堆（根节点最小） Pop() 返回最小值，因为标准库在调用用户 Pop() 前已交换了根节点和最后节点","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"pycharm配置VPN代理","slug":"具/pycharm配置VPN代理","date":"2025-06-08T16:18:16.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2025-06-08-e7d1013a5402.html","link":"","permalink":"https://leiqi.top/2025-06-08-e7d1013a5402.html","excerpt":"","text":"确定本地VPN的代理端口： 点击check connetion 输入http://www.google.com 也可以使用requests 包验证, 返回内容，不爆红即可。 12345import requests if __name__ == &quot;__main__&quot;: response = requests.get(&quot;http://www.youtube.com&quot;) print(response.text)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"回溯总结","slug":"eetcode/回溯总结","date":"2025-06-03T15:53:20.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2025-06-03-fc6703ad881e.html","link":"","permalink":"https://leiqi.top/2025-06-03-fc6703ad881e.html","excerpt":"","text":"子集型回溯17. 电话号码的字母组合 - 力扣（LeetCode） 方法一：输入的视角（选或不选）对于输入的 nums，考虑每个 nums[i] 是选还是不选，由此组合出 2n 个不同的子集。 dfs 中的 i 表示当前考虑到 nums[i] 选或不选。 1234567891011121314151617181920212223func subsets(nums []int) [][]int &#123; n := len(nums) ans := make([][]int, 0, 1&lt;&lt;n) // 预分配空间 path := make([]int, 0, n) // 预分配空间 var dfs func(int) dfs = func(i int) &#123; if i == n &#123; // 子集构造完毕 ans = append(ans, slices.Clone(path)) // 复制 path return &#125; // 不选 nums[i] dfs(i + 1) // 选 nums[i] path = append(path, nums[i]) dfs(i + 1) path = path[:len(path)-1] // 恢复现场 &#125; dfs(0) return ans&#125; 方法二：答案的视角（枚举选哪个）枚举子集（答案）的第一个数选谁，第二个数选谁，第三个数选谁，依此类推。 dfs 中的 i 表示现在要枚举选 nums[i] 到 nums[n−1] 中的一个数，添加到 path 末尾。 如果选 nums[j] 添加到 path 末尾，那么下一个要添加到 path 末尾的数，就要在 nums[j+1] 到 nums[n−1] 中枚举了。 注意：不需要在回溯中判断 i&#x3D;n 的边界情况，因为此时不会进入循环，if i &#x3D;&#x3D; n: return 这句话写不写都一样. 12345678910111213141516171819202122232425262728293031323334353637383940414243func subsets(nums []int) [][]int &#123; n := len(nums) ans := make([][]int, 0, 1&lt;&lt;n) // 预分配空间 path := make([]int, 0, n) // 预分配空间 var dfs func(int) dfs = func(i int) &#123; if i == n &#123; return &#125; for j := i; j &lt; n; j++ &#123; // 从当前索引向后枚举 path = append(path, nums[j]) // 选择数字 dfs(j + 1) // 递归下一层 path = path[:len(path)-1] // 回溯 &#125; // 关键位置：在递归开始时记录当前路径 ans = append(ans, slices.Clone(path)) &#125; dfs(0) return ans&#125;func subsets(nums []int) [][]int &#123; n := len(nums) ans := make([][]int, 0, 1&lt;&lt;n) // 预分配空间 path := make([]int, 0, n) // 预分配空间 var dfs func(int) dfs = func(i int) &#123; if i == n &#123; return &#125; // 关键位置：在递归开始时记录当前路径 ans = append(ans, slices.Clone(path)) for j := i; j &lt; n; j++ &#123; // 从当前索引向后枚举 path = append(path, nums[j]) // 选择数字 dfs(j + 1) // 递归下一层 path = path[:len(path)-1] // 回溯 &#125; &#125; dfs(0) return ans&#125; 分割回文串 https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/ 从答案的角度，枚举选哪个，需要使用for循环： 123456789101112131415161718192021222324252627282930313233func isPalindrome(s string, left, right int) bool &#123; for i, j := left, right;i &lt; j; i, j = i+1, j-1 &#123; if s[i] != s[j] &#123; return false &#125; &#125; return true&#125;func partition(s string) (ans [][]string) &#123; n := len(s) path := []string&#123;&#125; // 考虑 s[i:] 怎么分割 var dfs func(int) dfs = func(i int) &#123; if i == n &#123; // s 分割完毕 ans = append(ans, slices.Clone(path)) return &#125; for j := i; j &lt; n; j++ &#123; // 枚举子串的结束位置 if isPalindrome(s, i, j) &#123; path = append(path, s[i:j+1]) // 分割！ // 考虑剩余的 s[j+1:] 怎么分割 dfs(j + 1) path = path[:len(path)-1] // 恢复现场 &#125; &#125; &#125; dfs(0) return&#125; 电话号码的字母组合 https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solutions/2059416/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-3orv/ 123456789101112131415161718192021222324252627282930313233var ( m []string path []byte res []string)func letterCombinations(digits string) []string &#123; // 将index 和 字符串对应起来 m = []string&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125; path, res = make([]byte,0),make([]string,0) if digits == &quot;&quot; &#123; return res &#125; backTracking(digits,0) return res&#125;func backTracking(digits string, start int) &#123; // 终止条件 ，遍历完digits if start == len(digits) &#123; tmp := string(path) res = append(res,tmp) return &#125; // 找到 digit digitNum := int(digits[start] - &#x27;0&#x27;) // 遍历 digit 对应的map 字符串 str := m[digitNum] for i:=0;i&lt; len(str);i++ &#123; // i 从0开始，因为每个字典都是一个独立的集合，之前的组合是一个集合，所以才从start 开始 path = append(path,str[i]) backTracking(digits,start+1) path =path[:len(path)-1] &#125;&#125; 组合型回溯 左边选或者不选 K&#x3D;3 右边k &#x3D; 2, 因为是组合，等于是重复的就能再出现了，再选了2 之后，只能选1 了， 不能再选其他的了。倒序的不等式简单点，正序的不等式为 n - i + 1 &lt; d 直接return 77. 组合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 倒序遍历减枝func combine(n int, k int) [][]int &#123; // 组合 if k &gt; n &#123; return [][]int&#123;&#125; &#125; res := [][]int&#123;&#125; path := []int&#123;&#125; var dfs func(start int) // 下一个位置的组合 dfs = func(start int) &#123; // base case if len(path) == k &#123; tmp := make([]int, k) copy(tmp, path) // copy 目标值在前边 res = append(res, tmp) &#125; for i := start; i &gt;= 1; i-- &#123; //path 还需要 k - len(path) 提前减枝 if i &lt; k-len(path) &#123; // 注意是k - len(path) break &#125; path = append(path, i) dfs(i - 1) path = path[:len(path)-1] &#125; &#125; dfs(n) return res&#125;// 正序遍历减枝func combine(n int, k int) [][]int &#123; // 组合 if k &gt; n &#123; return [][]int&#123;&#125; &#125; res := [][]int&#123;&#125; path := []int&#123;&#125; var dfs func(start int) // 下一个位置的组合 dfs = func(start int) &#123; // base case if len(path) == k &#123; tmp := make([]int, k) copy(tmp, path) // copy 目标值在前边 res = append(res, tmp) &#125; for i := start; i &lt;= n; i++ &#123; // 倒序方便 //path 还需要 k - len(path) 提前减枝 if n-i+1 &lt; k-len(path) &#123; // 注意是k - len(path) break &#125; path = append(path, i) dfs(i + 1) path = path[:len(path)-1] &#125; &#125; dfs(1) return res&#125; 组合3 12345678910111213141516171819202122232425262728293031323334package leetcode216func combinationSum3(k int, n int) [][]int &#123; res := [][]int&#123;&#125; path := []int&#123;&#125; var dfs func(start, sum int) dfs = func(start, sum int) &#123; // 找到一个合法组合 if len(path) == k &amp;&amp; sum == n &#123; tmp := make([]int, k) copy(tmp, path) res = append(res, tmp) return &#125; // 剪枝：剩余数字不足以填满 path 或无法达到 sum for i := start; i &gt;= 1; i-- &#123; if i &lt; k-len(path) &#123; // 确保剩余数字足够填满 path break &#125; if sum+i &gt; n &#123; // 提前终止，避免无效递归 如果 sum + i &gt; n，说明当前 i 太大，不能选它。但 更小的 i 仍然可能满足 sum + i &lt;= n，所以不能直接 break（否则会漏掉可能的解）。 continue &#125; path = append(path, i) dfs(i-1, sum+i) path = path[:len(path)-1] &#125; &#125; dfs(9, 0) // 数字范围是 1~9 return res&#125; 22. 括号生成 思路题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 动态数据 回退操作import &quot;strings&quot;func generateParenthesis(n int) []string &#123; //n 对括号 只要最后左右总和一样， m := n * 2 res := []string&#123;&#125; var dfs func(i, open int) path := []string&#123;&#125; dfs = func(i, open int) &#123; if i == m &#123; res = append(res, strings.Join(path, &quot;&quot;)) &#125; // 选左边 if open &lt; n &#123; path = append(path, &quot;(&quot;) dfs(i+1, open+1) path = path[:len(path)-1] &#125; // 选右边 if i-open &lt; open &#123; // 右边要小于左边才能加 path = append(path, &quot;)&quot;) dfs(i+1, open) path = path[:len(path)-1] &#125; &#125; dfs(0, 0) // 入口函数需要添加 return res&#125;// 固定长度+索引，不用回退func generateParenthesis(n int) (ans []string) &#123; m := n * 2 path := make([]byte, m) var dfs func(int, int) dfs = func(i, open int) &#123; if i == m &#123; ans = append(ans, string(path)) return &#125; if open &lt; n &#123; // 可以填左括号 path[i] = &#x27;(&#x27; dfs(i+1, open+1) &#125; if i-open &lt; open &#123; // 可以填右括号 path[i] = &#x27;)&#x27; dfs(i+1, open) &#125; &#125; dfs(0, 0) return&#125; 在你提供的这个实现中，不需要显式的回退操作（如 path = path[:len(path)-1]），是因为它采用了 固定长度的 []byte 数组 和 索引覆盖 的方式，这与常见的回溯算法实现有所不同。下面详细解释为什么可以省略回退操作： 关键原因分析1. 使用固定长度的 []byte 数组1path := make([]byte, m) // 长度为 m 的固定数组 数组 path 的长度在初始化时就固定为 m（=n*2），不会动态增长。 每个递归层级直接通过索引 i 修改 path[i] 的位置，不会影响其他层级的存储。 2. 索引覆盖写入1path[i] = &#x27;(&#x27; // 或 path[i] = &#x27;)&#x27; 每次写入都会精确覆盖 path[i] 的位置，而不会追加元素。 递归返回时，上层调用会覆盖当前层写入的值，因此不需要手动回退。 3. 递归的自然回溯 当递归从深层返回时，上层调用会继续修改 path 的后续位置，覆盖之前的值。 例如： 第一层递归写入 path[0] = &#39;(&#39;，然后进入第二层。 第二层写入 path[1] = &#39;(&#39; 或 path[1] = &#39;)&#39;。 当第二层递归返回后，第一层可能会写入 path[1] = &#39;)&#39;，覆盖之前的值。 对比需要回退操作的实现需要回退的版本（动态 append）1234path := []string&#123;&#125;path = append(path, &quot;(&quot;) // 修改切片长度dfs(...)path = path[:len(path)-1] // 必须回退 动态 append 会改变切片长度，必须显式回退以恢复状态。 不需要回退的版本（固定数组 + 索引覆盖）1234path := make([]byte, m)path[i] = &#x27;(&#x27; // 直接覆盖，不改变长度dfs(...)// 无需回退，上层调用会覆盖 path[i] 固定数组的长度不变，通过索引直接修改值，递归返回后自然被覆盖。 为什么这种写法是正确的？ 隐式回溯： 每一层递归的 path[i] 写入是独立的，递归返回后会被上层调用覆盖。 例如： 路径 &quot;(())&quot; 的生成过程：1234path[0] = &#x27;(&#x27; // 第一层path[1] = &#x27;(&#x27; // 第二层path[2] = &#x27;)&#x27; // 第三层path[3] = &#x27;)&#x27; // 第四层 如果第二层尝试 path[1] = &#39;)&#39;，它会覆盖之前的 &#39;(&#39;，但通过条件 i-open &lt; open 保证了合法性。 条件保证合法性： open &lt; n 确保左括号不超过 n 个。 i-open &lt; open 确保右括号数不超过左括号数。 不需要回退：因为使用了固定长度的 []byte 数组，通过索引直接覆盖写入，递归返回时上层调用会自然覆盖当前层的修改。 更高效：避免了动态切片的扩容和回退操作，减少了内存分配。 更简洁：代码更紧凑，但需要理解索引覆盖的隐式回溯逻辑。 这种写法是回溯算法的一种优化技巧，适用于结果长度固定的场景（如括号生成、排列问题等）。 排列型回溯","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"闭包介绍","slug":"eetcode/闭包介绍","date":"2025-05-28T15:10:41.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2025-05-28-3ec80348e81b.html","link":"","permalink":"https://leiqi.top/2025-05-28-3ec80348e81b.html","excerpt":"","text":"为什么闭包能共享变量 pre？在提供的代码中，闭包能够共享变量 pre 的关键在于 词法作用域（Lexical Scoping） 和 闭包捕获变量 的特性： 1234567891011func isValidBST(root *TreeNode) bool &#123; pre := math.MinInt64 // 外层函数变量 var dfs func(*TreeNode) bool dfs = func(node *TreeNode) bool &#123; // 这里可以访问并修改外层的 pre 变量 if node.Val &lt;= pre &#123; ... &#125; pre = node.Val &#125; return dfs(root)&#125; 工作原理： 词法作用域： Go 中函数可以访问定义时所在作用域的所有变量 dfs 匿名函数定义在 isValidBST 函数体内，自然能访问 pre 闭包捕获变量： 闭包不会复制变量值，而是捕获变量的引用 所有递归调用的 dfs 都指向同一个 pre 变量 修改 pre 会影响所有闭包实例 递归共享状态： 1234567graph LRA[pre=MinInt64] --&gt; B[dfs-根节点]B --&gt; C[dfs-左子节点]C --&gt; D[dfs-左孙节点]D --&gt;|更新pre| CC --&gt;|更新pre| BB --&gt;|更新pre| E[dfs-右子节点] 闭包名称的含义与起源名称来源“闭包”（Closure）一词来源于 函数”闭合”（close over）其定义环境 的概念： 最早由 Peter J. Landin 在 1964 年提出 源自数学中的 λ演算（Lambda Calculus） 和 闭包属性（Closure Property） 在编译原理中称为 词法闭包（Lexical Closure） 名称含义 术语 解释 闭（Close） 函数”封闭”地携带其定义时的环境 包（-ure） 将函数与其环境”打包”在一起 核心特性 环境捕获：函数记住并访问定义时的作用域 状态持久化：捕获的变量生命周期与闭包相同 私密状态：只有闭包能访问捕获的变量 闭包在 BST 验证中的优势1234pre := math.MinInt64 // 共享状态dfs := func(node *TreeNode) bool &#123; // 递归过程共享同一个 pre&#125; 状态管理简化：无需指针传递 代码更简洁：减少参数传递 逻辑更直观：直接读写共享状态 避免值复制：高效处理递归状态 闭包的本质闭包本质上是一个 （函数 + 绑定环境） 的组合体： 123456type Closure struct &#123; F func(*TreeNode) bool // 函数逻辑 Env struct &#123; // 捕获的环境 pre int &#125;&#125; 每次递归调用时，都使用同一个 Env 环境，这正是 BST 验证需要的中序遍历状态一致性保证。 闭包 vs 指针参数 特性 闭包 指针参数 状态共享 自动捕获 需显式传递 可读性 ★★★☆☆ ★★☆☆☆ 安全性 变量封装 暴露内存地址 递归适用性 非常适合 需要小心指针传递 在 BST 验证场景中，闭包方案更简洁安全，避免了指针传递的复杂性，是 Go 语言处理递归状态的首选模式。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"comet 生成临时文件导致磁盘满","slug":"赛/comet 生成临时文件导致磁盘满","date":"2025-05-01T13:50:34.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2025-05-01-d5e22ea4be8d.html","link":"","permalink":"https://leiqi.top/2025-05-01-d5e22ea4be8d.html","excerpt":"","text":"解决方案出现 OSError: [Errno 28] No space left on device 错误的原因是系统磁盘空间不足，尤其是在临时目录（如 /tmp）中。以下是分步解决方案： 1. 检查磁盘空间在终端运行以下命令，查看磁盘使用情况： 1df -h 2. 清理临时文件删除临时目录中的旧文件（确保无重要进程依赖这些文件）： 1sudo rm -rf /tmp/* 3. 查找并删除大文件使用以下命令定位大文件： 12345# 查看根目录下各文件夹的大小sudo du -sh /* | sort -hr# 查找当前目录下大于 1GB 的文件find / -type f -size +1G -exec ls -lh &#123;&#125; \\; 删除不再需要的大文件（如旧日志、缓存等）。 4. 清理系统缓存和日志12345678# 清理 APT 缓存（适用于 Ubuntu/Debian）sudo apt-get clean# 清理旧版 Linux 内核（谨慎操作）sudo apt-get autoremove --purge# 清理系统日志（保留最近7天）sudo journalctl --vacuum-time=7d 5. 更改临时目录路径如果 /tmp 所在分区空间不足，可以将临时目录指向其他分区： 方法一：在代码中设置临时目录 12import tempfiletempfile.tempdir = &quot;/path/to/your/large/disk/tmp&quot; # 替换为有足够空间的路径 方法二：通过环境变量设置在运行脚本前设置： 1export TMPDIR=/path/to/your/large/disk/tmp 6. 调整 Comet.ml 的存储路径在初始化 Experiment 时指定日志和临时文件目录： 123456experiment = Experiment( &quot;H62QCY6dW6Vg9lLl27jZn4C2O&quot;, project_name=&quot;IDRsPredictor-transformer&quot;, log_code=True, log_dir=&quot;/path/to/large/disk/comet_logs&quot; # 指定存储路径) 参考：chatGPT","categories":[{"name":"比赛","slug":"比赛","permalink":"https://leiqi.top/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[]},{"title":"Windows Git自动转换为Linux换行符","slug":"it/Windows Git自动转换为Linux换行符","date":"2025-04-28T13:15:32.000Z","updated":"2025-06-16T15:02:16.970Z","comments":true,"path":"2025-04-28-84ca2c3d5919.html","link":"","permalink":"https://leiqi.top/2025-04-28-84ca2c3d5919.html","excerpt":"","text":"在 Git 中处理不同操作系统（Windows&#x2F;Linux&#x2F;macOS）的换行符（LF 和 CRLF）时，自动转换是关键。以下是配置 Git 自动处理换行符的方法： 1. 核心配置：core.autocrlf通过设置 core.autocrlf 属性，让 Git 自动转换换行符： 不同操作系统的推荐设置 Windows（推荐）： 12git config --global core.autocrlf true# 提交时转换为 LF，检出时转换为 CRLF Linux&#x2F;macOS（推荐）： 12git config --global core.autocrlf input# 提交时转换为 LF，检出时不转换 2. 强制规范：.gitattributes 文件在项目根目录创建 .gitattributes 文件，优先级高于全局配置，适合团队协作。 示例配置：1234567891011# 所有文本文件使用 LF 换行符* text=auto eol=lf# 排除二进制文件（避免误处理）*.png binary*.jpg binary*.zip binary# 指定特定文件类型（可选）*.sh text eol=lf*.bat text eol=crlf text=auto：Git 自动识别文本文件。 eol=lf 或 eol=crlf：强制统一换行符。 3. 修复已存在的换行符问题步骤： 删除缓存并重置文件： 12git rm --cached -r . # 清除缓存git reset --hard # 重置文件 重新添加文件并提交： 12git add .git commit -m &quot;fix: normalize line endings&quot; 4. 检查换行符状态检查文件换行符： Linux&#x2F;macOS： 12file yourfile.txt# 输出中包含 &quot;LF&quot; 或 &quot;CRLF&quot; Windows（PowerShell）： 12Get-Content yourfile.txt -Encoding Byte | Select-String &quot;0D 0A&quot;# 存在 &quot;0D 0A&quot; 表示 CRLF 查看 Git 换行符转换日志：1git ls-files --eol 常见问题解决 **警告 LF will be replaced by CRLF**：正常提示，表示 Git 正在按配置转换换行符。 文件被标记为已修改（仅换行符变化）：运行以下命令清除差异： 12git config --global core.whitespace cr-at-eolgit add --renormalize . 混合换行符导致冲突：使用 .gitattributes 强制统一换行符，并重新提交文件。 最佳实践 团队协作：在项目中添加 .gitattributes 文件，统一换行符规则。 编辑器配置：设置 IDE（如 VSCode）默认使用 LF（配置示例）。 Windows 用户：安装 Git 时选择 Checkout as-is, commit Unix-style line endings。 通过上述配置，Git 会自动处理换行符，避免跨平台协作时的混乱！ 🛠️","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"更新网页url后，恢复valine网页评论","slug":"端/更新网页url后，恢复valine网页评论","date":"2025-04-13T04:28:35.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2025-04-13-8c397fc87827.html","link":"","permalink":"https://leiqi.top/2025-04-13-8c397fc87827.html","excerpt":"","text":"由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。具体步骤：登录&gt;选择你创建的应用&gt;数据存储&gt;结构化数据&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～ 修改 对应url 列为当前url 参考：https://valine.js.org/quickstart.html","categories":[{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"数据结构设计专题","slug":"刷记录/数据结构设计专题","date":"2025-03-06T14:56:44.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2025-03-06-dab119f1439d.html","link":"","permalink":"https://leiqi.top/2025-03-06-dab119f1439d.html","excerpt":"","text":"数据结构设计 LeetCode 力扣 难度 是否完成 146. LRU Cache 146. LRU 缓存 🟠 202050306🟢 460. LFU Cache 460. LFU 缓存 🔴 🔴 729. My Calendar I 729. 我的日程安排表 I 🟠 🔴 950. Reveal Cards In Increasing Order 950. 按递增顺序显示卡牌 🟠 🔴 1700. Number of Students Unable to Eat Lunch 1700. 无法吃午餐的学生数量 🟢 202050307🟢 155. Min Stack 155. 最小栈 🟠 🔴 1670. Design Front Middle Back Queue 1670. 设计前中后队列 🟠 🔴 895. Maximum Frequency Stack 895. 最大频率栈 🔴 🔴 224. Basic Calculator 224. 基本计算器 🔴 🔴 227. Basic Calculator II 227. 基本计算器 II 🟠 🔴 146. LRU 缓存请设计 最近 最少使用 约束的数据结构 20250307 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type LRUCache struct &#123; orderList []int cacheMaps map[int]int capacity int&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; orderList: make([]int, 0, capacity), // 39 分钟调试完成，需要确认的是，List初始化需要为空，而不是orderList: make([]int, capacity) 这个是创建capacity个0 cacheMaps: make(map[int]int, capacity), capacity: capacity, &#125;&#125;func (this *LRUCache) Get(key int) int &#123; // key 存在与单独的环境中 if _, ok := this.cacheMaps[key]; ok &#123; this.Update(key) return this.cacheMaps[key] &#125; return -1&#125;func (this *LRUCache) Update(key int) &#123; // 更新key 到最新位置 for i := 0; i &lt; len(this.orderList); i++ &#123; if this.orderList[i] == key &#123; this.orderList = append(this.orderList[:i], append(this.orderList[i+1:], this.orderList[i])...) &#125; &#125;&#125;func (this *LRUCache) Put(key int, value int) &#123; if _, ok := this.cacheMaps[key]; ok &#123; // 更新key this.cacheMaps[key] = value this.Update(key) &#125; else if len(this.cacheMaps) &gt;= this.capacity &#123; fmt.Println(&quot;=&quot;,len(this.orderList), len(this.cacheMaps), this.capacity) // 删除key oldKey := this.orderList[0] this.orderList = this.orderList[1:] delete(this.cacheMaps, oldKey) // 新建key this.cacheMaps[key] = value this.orderList = append(this.orderList, key) &#125;else if len(this.cacheMaps) &lt; this.capacity &#123; fmt.Println(&quot;&lt;&quot;, len(this.orderList), len(this.cacheMaps), this.capacity) // 新建key this.cacheMaps[key] = value this.orderList = append(this.orderList, key) &#125;&#125; O(1) 方法双向列表，map 中直接保存列表元素指针，123456789101112131415161718192021222324252627282930313233343536373839404142434445type LRUCache struct &#123; cacheMaps map[int]*list.Element orderList *list.List capacity int&#125;type entry struct &#123; key int value int&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cacheMaps: make(map[int]*list.Element, capacity), orderList: list.New(), capacity: capacity, &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cacheMaps[key]; ok &#123; this.orderList.MoveToBack(elem) return elem.Value.(entry).value &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cacheMaps[key]; ok &#123; // 更新已存在的键 elem.Value = entry&#123;key: key, value: value&#125; this.orderList.MoveToBack(elem) &#125; else &#123; // 插入新键 if len(this.cacheMaps) == this.capacity &#123; // 删除最久未使用的键 frontElem := this.orderList.Front() delete(this.cacheMaps, frontElem.Value.(entry).key) this.orderList.Remove(frontElem) &#125; // 插入新键到链表末尾 newElem := this.orderList.PushBack(entry&#123;key: key, value: value&#125;) this.cacheMaps[key] = newElem &#125;&#125; 1700. 无法吃午餐的学生数量 12345678910111213141516171819202122232425262728package leetcode1700 // 9分钟完成 func countStudents(students []int, sandwiches []int) int &#123; // 栈模拟 // 结束条件 // 同学中数字都相同，且不等于栈顶元素 [0] for !isEnd(students, sandwiches) &#123; if sandwiches[0] == students[0] &#123; sandwiches = sandwiches[1:] students = students[1:] &#125; else &#123; students = append(students[1:], students[0]) &#125; &#125; return len(students) &#125; func isEnd(students []int, sandwiches []int) bool &#123; for _, val := range students &#123; if val == sandwiches[0] &#123; return false &#125; &#125; return true &#125;","categories":[{"name":"速刷记录","slug":"速刷记录","permalink":"https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"系统序列图 - 时序图","slug":"客时间/架构/系统序列图 - 时序图","date":"2025-02-19T12:07:47.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2025-02-19-05250c3f88f5.html","link":"","permalink":"https://leiqi.top/2025-02-19-05250c3f88f5.html","excerpt":"","text":"","categories":[{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"如何画好一个架构图","slug":"客时间/架构/如何画好一个架构图","date":"2025-02-19T11:39:54.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2025-02-19-d829d1f5a9ea.html","link":"","permalink":"https://leiqi.top/2025-02-19-d829d1f5a9ea.html","excerpt":"","text":"业务架构 客户端架构、前端架构类似于逻辑视图 通过不同的颜色白标识不同颜色 系统架构技术架构或者是后端架构，后端的逻辑架构后端架构是核心架构两张图 左边说明功能，右边说明交互。和业务架构有区别。 应用架构描述后端系统有哪些应用组成 使用场景： 项目开发和测试 部署发布 子领域项目架构，下方就是个会员中心* 部署架构 - 物理视图描述后端系统具体是如何部署的，对应4+1 视图中的物理视图 使用场景 总体架构设计 运维规划和优化 画图技巧 使用图标代替区块*上边的球是网络加速点 前阿里 P9 教你如何画好一张架构图_哔哩哔哩_bilibili","categories":[{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"【sed】快速替换当前文件夹下文件中指定内容","slug":"inux/【sed】快速替换当前文件夹下文件中指定内容","date":"2025-01-13T15:40:59.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2025-01-13-1b5c01477594.html","link":"","permalink":"https://leiqi.top/2025-01-13-1b5c01477594.html","excerpt":"","text":"在 Linux 中，可以使用以下命令来实现这个需求： 1sed -i &#x27;s/hide: true/hide: false/g&#x27; * 解释一下这个命令： sed 是流编辑器，用于对文本进行过滤和转换。 -i 选项表示直接修改文件，而不是输出到终端。 &#39;s/hide: true/hide: false/g&#39; 是 sed 的替换命令，其中： s 表示替换操作。 hide: true 是要被替换的字符串。 hide: false 是替换后的字符串。 g 表示全局替换，即在每一行中将所有匹配的 hide: true 都替换为 hide: false。 * 表示当前文件夹下的所有文件。 需要注意的是，这个命令会修改当前文件夹下所有文件的内容，包括二进制文件等，可能会导致一些文件损坏。如果只想修改特定类型的文件，可以使用通配符指定文件类型，例如替换当前文件夹下所有 .txt 文件中的内容： 1sed -i &#x27;s/hide: true/hide: false/g&#x27; *.txt 另外，如果当前文件夹下有子文件夹，并且也想修改子文件夹中文件的内容，可以使用 find 命令结合 sed 来实现，例如： 1find . -type f -exec sed -i &#x27;s/hide: true/hide: false/g&#x27; &#123;&#125; + 这个命令会递归查找当前文件夹及其子文件夹下的所有文件（-type f），然后对每个文件执行 sed 命令进行替换。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[]},{"title":"【最强春节抢票攻略】火车票抢票攻略","slug":"具/【最强春节抢票攻略】火车票抢票攻略","date":"2025-01-13T15:06:26.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2025-01-13-facf42a009b6.html","link":"","permalink":"https://leiqi.top/2025-01-13-facf42a009b6.html","excerpt":"","text":"1. 下载分流抢票（windows) ，并安装https://www.bypass.cn/ 2. 登录，查询目标车票放票时间需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。 3 先同步服务器时间其他设置小黑屋设置为100秒&#x2F;次。 4.设置微信通知扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。 5.设置自动支付绑定支付宝，抢到票自动支付。 6. 设置定时抢票提前两秒时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击开始抢票！等待抢票成功吧！ 抢到啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【Golang】for range 数组指针遍历","slug":"eetcode/【Golang】for range 数组指针遍历","date":"2024-12-03T16:55:24.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-12-03-90d19c862e9c.html","link":"","permalink":"https://leiqi.top/2024-12-03-90d19c862e9c.html","excerpt":"","text":"在Go语言中，使用for range遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如[]*Student）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。 这意味着，即使for range对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点： 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type Student struct &#123; Name string Age int&#125;func main() &#123; students := []*Student&#123; &#123;Name: &quot;Alice&quot;, Age: 20&#125;, &#123;Name: &quot;Bob&quot;, Age: 22&#125;, &#125; // 使用for range遍历指针数组 for _, student := range students &#123; // 修改指向的结构体的内容 student.Age += 1 // 给每个学生的年龄加1 &#125; // 打印修改后的students数组 for _, student := range students &#123; fmt.Printf(&quot;Name: %s, Age: %d\\n&quot;, student.Name, student.Age) &#125;&#125; 在这个例子中，尽管for range对每个*Student指针进行了拷贝，但通过这个拷贝的指针修改Age字段时，修改的是原始Student结构体的内容。因此，当再次遍历students数组时，你会看到每个学生的年龄都已经增加了。 总结来说，当你使用for range遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 浮点数次方","slug":"olang/Go 浮点数次方","date":"2024-12-03T15:46:08.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-12-03-3d026e7b5bec.html","link":"","permalink":"https://leiqi.top/2024-12-03-3d026e7b5bec.html","excerpt":"","text":"在Go语言中，计算一个数的几次方可以通过标准库中的math包来实现。math包提供了一个Pow函数，用于计算x的y次方。 使用math.Pow函数math.Pow函数的签名如下： 1func Pow(x, y float64) float64 这个函数接受两个float64类型的参数：x是底数，y是指数，返回x的y次方的结果。 示例代码下面是一个使用math.Pow函数的示例： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; // 计算2的3次方 result := math.Pow(2, 3) fmt.Printf(&quot;2的3次方是: %v\\n&quot;, result) // 计算3的2次方 result = math.Pow(3, 2) fmt.Printf(&quot;3的2次方是: %v\\n&quot;, result) // 计算10的-2次方 result = math.Pow(10, -2) fmt.Printf(&quot;10的-2次方是: %v\\n&quot;, result)&#125; 输出1232的3次方是: 83的2次方是: 910的-2次方是: 0.01 注意事项 math.Pow函数的参数和返回值都是float64类型，因此如果你需要计算整数的次方，可能需要先将整数转换为float64，然后再进行计算。 如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"【基础知识】Golang  sort.Slice 复杂排序","slug":"eetcode/【基础知识】Golang  sort.Slice 复杂排序","date":"2024-11-24T04:47:52.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-11-24-24291296f81a.html","link":"","permalink":"https://leiqi.top/2024-11-24-24291296f81a.html","excerpt":"","text":"在 Go 语言中，你可以使用 sort.Slice 对 slice 按照复杂条件进行排序。 sort.Slice 函数接受一个 slice 和一个比较函数，该比较函数定义了两个元素之间的排序关系。 以下是实现复杂条件排序的步骤和示例： 1. 基本语法1234sort.Slice(slice, func(i, j int) bool &#123; // 比较 slice[i] 和 slice[j] return 条件&#125;) 2. 示例：对结构体切片进行多条件排序假设有一个包含多个 Person 的切片，我们希望按以下规则排序： 年龄从小到大排序。 如果年龄相同，则按名字的字母顺序排序。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Person struct &#123; Name string Age int&#125;func main() &#123; people := []Person&#123; &#123;&quot;Alice&quot;, 30&#125;, &#123;&quot;Bob&quot;, 25&#125;, &#123;&quot;Charlie&quot;, 30&#125;, &#123;&quot;Dave&quot;, 25&#125;, &#125; // 使用 sort.Slice 按多个条件排序 sort.Slice(people, func(i, j int) bool &#123; // 优先按年龄排序 if people[i].Age != people[j].Age &#123; return people[i].Age &lt; people[j].Age &#125; // 如果年龄相同，则按名字排序 return people[i].Name &lt; people[j].Name &#125;) fmt.Println(people)&#125; 3. 更复杂条件：按多个字段权重排序如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Product struct &#123; Name string Price float64 Rating int&#125;func main() &#123; products := []Product&#123; &#123;&quot;Laptop&quot;, 1000, 5&#125;, &#123;&quot;Phone&quot;, 800, 4&#125;, &#123;&quot;Tablet&quot;, 800, 5&#125;, &#123;&quot;Watch&quot;, 400, 4&#125;, &#125; // 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序 sort.Slice(products, func(i, j int) bool &#123; // 按价格降序 if products[i].Price != products[j].Price &#123; return products[i].Price &gt; products[j].Price &#125; // 如果价格相同，按评分降序 if products[i].Rating != products[j].Rating &#123; return products[i].Rating &gt; products[j].Rating &#125; // 如果评分也相同，按名称升序 return products[i].Name &lt; products[j].Name &#125;) fmt.Println(products)&#125; 4. 注意事项 如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。 sort.Slice 是不稳定的。如果需要稳定排序，可以使用 sort.SliceStable。 对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。 通过 sort.Slice 的灵活性，可以轻松实现各种复杂条件的排序逻辑。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【刨根问底】创建slice是否填第二个参数0的区别","slug":"eetcode/【刨根问底】创建slice是否填第二个参数0的区别","date":"2024-11-23T05:10:49.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-11-23-b80d94088ccd.html","link":"","permalink":"https://leiqi.top/2024-11-23-b80d94088ccd.html","excerpt":"","text":"在Go语言中，创建切片（slice）时使用make函数有两种常见的方式，它们之间有细微的差别： slice := make([]string, 0) 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是[]string），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。 slice := make([]string) 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，make函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。 两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用make([]string)（或者等价的make([]string, 0)）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。 总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","slug":"eetcode/【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","date":"2024-11-23T05:05:23.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-11-23-cf0eba4d8369.html","link":"","permalink":"https://leiqi.top/2024-11-23-cf0eba4d8369.html","excerpt":"","text":"确实，如果我们按照缩写的逻辑来看，Itos（Integer to String）可能更直观地表达了Itoa函数的功能，即把整数转换为字符串。 然而，Itoa这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，Itoa这个术语已经被广泛接受和使用。以下是一些可能的原因： 历史原因：Itoa这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，Itoa（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。 约定俗成：在编程社区中，Itoa已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。 ASCII与字符串的关系：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字123的ASCII表示和字符串表示都是&quot;123&quot;。因此，Itoa这个名字仍然适用。 简洁性：Itoa这个名称比较简洁，易于记忆。如果使用Itos，虽然直观，但可能不如Itoa简洁。 Itoa这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管Itos可能更直观地表示整数到字符串的转换，但Itoa已经成为一个广泛接受和使用的术语。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}]},{"title":"【基础知识】符号整数和非符号整数","slug":"eetcode/【基础知识】符号整数和非符号整数","date":"2024-11-23T04:47:02.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-11-23-dce4118b03a7.html","link":"","permalink":"https://leiqi.top/2024-11-23-dce4118b03a7.html","excerpt":"","text":"uint8 uint16和uint32是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。 unit8 : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255 **uint16**： uint16是一个16位的无符号整数。 它可以存储的数字数量是 2^16。 计算得出：216&#x3D;65536216&#x3D;65536。 因此，uint16能存储的数字范围是从0到65535。 **uint32**： uint32是一个32位的无符号整数。 它可以存储的数字数量是 2^32。 计算得出：232&#x3D;4294967296232&#x3D;4294967296。 因此，uint32能存储的数字范围是从0到4294967295。 总结： uint16能存储的数字数量是 216216，即65536个数字。 uint32能存储的数字数量是 232232，即4294967296个数字。 int32是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。 具体来说： 对于正数，最高位是0，剩下的31位可以表示 231231 个不同的正数值。 对于负数，最高位是1，剩下的31位可以表示 231231 个不同的负数值。 由于0既不是正数也不是负数，它单独占用了一个数值。 因此，int32的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说int32的范围是31次方而不是32次方的原因。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Golang】 byte和rune 有什么区别","slug":"eetcode/【Golang】 byte和rune 有什么区别","date":"2024-11-23T04:38:13.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-11-23-ff51ba651704.html","link":"","permalink":"https://leiqi.top/2024-11-23-ff51ba651704.html","excerpt":"","text":"byte 和rune 有什么区别？ 在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义： byte： byte是uint8的别名，即一个无符号的8位整数。在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。rune： rune是int32的别名，即一个有符号的32位整数。rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。区别： 大小：byte是8位的，而rune是32位的。用途：byte用于处理字节数据，rune用于处理Unicode字符。范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"申请域名绑定github pages","slug":"端/申请域名绑定github pages","date":"2024-09-01T02:17:17.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2024-09-01-ed1bf9078b39.html","link":"","permalink":"https://leiqi.top/2024-09-01-ed1bf9078b39.html","excerpt":"","text":"你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！ 前置需求 在Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo完成了域名的购买 完成了GitHub Pages的设置，有了可用的http://username.github.io库之后，可以访问 Github Pages 正文0. 进入我的账户 1. 无论是什么域名服务商，找到DNS Management页面如果是namesilo购买的域名，可以通过以下步骤：点击“domain manager”点击这个蓝色的小球（Manage DNS for this domain） 2. 写入 type A 的DNS记录 如果厂商提供了写入模板，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 DNS Templates。 找到GitHub的template，点击“Apply Template”，然后在弹出的窗口里直接点击“Accept”，你就会发现4条A记录已经自动写入了。 如果厂商不能自动添加，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图 [Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain! 上面圈起来的四个地址就是需要等会儿手动输入的。 不同厂商之间的手动添加方法不一样，但只要记住 type 后填“A”，address&#x2F;points to或其他同义表达后填这四个地址中的一个，其他默认就好了，一共需要添加四条，可以复制粘贴。 添加之后会多出四个### 3. 创建CNAME文件 这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成http://username.github.io， 上面的方法 save 之后看到报错不要慌，让子弹飞一会儿就好了 最终有这些配置即可： github 填写域名地址在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。 即刻访问你自己的域名网站吧！ 参考：将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)","categories":[{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"git stash","slug":"it/git stash 使用指南","date":"2024-08-21T16:26:46.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-08-21-d34ebab44074.html","link":"","permalink":"https://leiqi.top/2024-08-21-d34ebab44074.html","excerpt":"","text":"当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作： 放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。 1git checkout -- .obsidian/workspace.json 再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。 1git pull 如果不想放弃这些更改，而是想将它们暂时保存起来，可以使用 git stash 命令： 保存更改：使用 git stash 将更改保存到一个临时区域。 1git stash 拉取远程更新： 1git pull 恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。 1git stash apply git stash 是 Git 中用于临时保存工作目录和暂存区改动的工具，适用于需要切换分支或处理其他任务但不想提交未完成工作的场景。 基本命令 保存当前改动 12git stash # 默认保存，消息为自动生成git stash push -m &quot;备注&quot; # 保存并添加自定义备注 选项： -u 或 --include-untracked：包含未被跟踪的文件（新增但未 git add 的文件）。 -a 或 --all：包含所有文件（包括被 .gitignore 忽略的文件）。 --keep-index：仅保存工作区未暂存的改动，保留暂存区内容。 查看保存的 stash 列表 1git stash list 输出示例：stash@&#123;0&#125;: On main: 备注 恢复改动 恢复最近一次的 stash 并删除记录：1git stash pop 恢复指定 stash 但不删除记录：1git stash apply stash@&#123;n&#125; # n 为 stash 编号，如 stash@&#123;0&#125; 删除 stash 删除指定 stash：1git stash drop stash@&#123;n&#125; 清空所有 stash：1git stash clear 高级用法 从 stash 创建分支 1git stash branch 分支名 stash@&#123;n&#125; 基于指定 stash 创建新分支，并自动应用改动（适用于 stash 与当前分支冲突时）。 查看 stash 的改动详情 12git stash show stash@&#123;n&#125; # 显示简略差异git stash show -p stash@&#123;n&#125; # 显示完整差异（类似 git diff） 注意事项 默认行为： git stash 会保存 工作区未提交的修改 和 暂存区的修改。 恢复时，已暂存的改动会重新回到暂存区，未暂存的改动保留在工作区。 未跟踪文件： 默认不保存未被跟踪的文件（需用 -u 或 --include-untracked）。 冲突处理： 如果恢复时发生冲突，需手动解决后执行 git add 和 git restore --staged 或提交。 示例场景 临时切换分支： 12345git stash -m &quot;保存功能 A 的进度&quot;git checkout 其他分支# 处理其他任务后返回git checkout 原分支git stash pop 保存包含未跟踪文件： 1git stash -u -m &quot;包含新文件&quot; 恢复指定 stash： 12git stash list # 查看列表git stash apply stash@&#123;2&#125; # 应用第三个 stash","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leiqi.top/tags/git/"}]},{"title":"leetcode  1.两数之和","slug":"eetcode/leetcode  1.两数之和","date":"2024-08-21T15:53:21.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-08-21-64c0a1f316e6.html","link":"","permalink":"https://leiqi.top/2024-08-21-64c0a1f316e6.html","excerpt":"","text":"有两种思路： 使用暴力遍历， 复杂度的是 O(n ^2) 123456789101112func twoSum(nums []int, target int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; for j:= i+1; j &lt; len(nums); j++ &#123; if nums[i] + nums[j] == target &#123; return []int&#123;i, j&#125; &#125; &#125; &#125; return []int&#123;&#125;&#125; 使用哈希表，是O(n) 使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置1234567891011121314151617func twoSum(nums []int, target int) []int &#123; maps := make(map[int]int, len(nums)) for idx, num := range nums &#123; maps[num] = idx &#125; for idx, num := range nums &#123; if idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; // 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意 return []int&#123;idx, idx2&#125; &#125; &#125; return []int&#123;&#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"docker容器打包成本地压缩镜像并load","slug":"ocker/docker容器打包成本地压缩镜像并load","date":"2024-08-11T03:59:34.000Z","updated":"2025-06-16T15:02:16.966Z","comments":true,"path":"2024-08-11-a8e2c27fed87.html","link":"","permalink":"https://leiqi.top/2024-08-11-a8e2c27fed87.html","excerpt":"","text":"docker容器打包成镜像和压缩（1）将容器保存成新的镜像相当于加了一层，使用docker commit 1sudo docker commit -a &#x27;run_code&#x27; b4293c3b9202 myimage:v2 （2）将镜像打包 1docker save -o mask_detection_v5.tar myimage:v5 (3) 将镜像包压缩 1sudo tar -zcvf myimage.tar.gz myimage.tar 还有一种容器的打包和压缩一步到位的方法： 1docker save myimage:v5 | gzip &gt; myimage.tar.gz docker镜像压缩包解压及镜像载入 一步加载压缩的镜像命令 12docker load &lt; myimage.tar.gz （1）压缩包解压 1tar -zxvf myimage.tar.gz 得到.tar格式的镜像包 （2）镜像载入 1sudo docker load -i myimage.tar 载入后查看已经加载的镜像 1sudo docker images 运行镜像123# 交互式运行docker run -it myimage:v1 bash 进入已经运行的容器12docker exec -it [imagesID] bash","categories":[{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"}],"tags":[]},{"title":"查询深度学习环境python torch cuda版本","slug":"具/查询深度学习环境python torch cuda版本","date":"2024-08-08T14:55:03.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2024-08-08-efa703ec12d7.html","link":"","permalink":"https://leiqi.top/2024-08-08-efa703ec12d7.html","excerpt":"","text":"1234567import sysimport torch#sys模块提供了一系列有关Python运行环境的变量和函数。print(sys.version)print(torch.__version__)print(torch.cuda.is_available())","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"开机自启WSL","slug":"具/开机自启WSL","date":"2024-08-07T14:09:47.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2024-08-07-117ef9b8f4c6.html","link":"","permalink":"https://leiqi.top/2024-08-07-117ef9b8f4c6.html","excerpt":"","text":"在C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 目录下，新建vbs文件 文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址 123456Set ws = WScript.CreateObject(&quot;WScript.Shell&quot;)cmd = &quot;C:\\Windows\\System32\\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;&#x27;运行命令不显示cmd窗口ws.Run cmd, 0, falseSet ws = NothingWScript.quit","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git更新仓库地址","slug":"it/git更新仓库地址","date":"2024-07-23T15:34:45.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-07-23-764a3cd05cde.html","link":"","permalink":"https://leiqi.top/2024-07-23-764a3cd05cde.html","excerpt":"","text":"使用如下命令 1git remote set-url origin https://gitee.com/xxxxx","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"设置github 同步到gitee","slug":"it/设置github 同步到gitee","date":"2024-07-21T14:15:47.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-07-21-3ee37da7ed1c.html","link":"","permalink":"https://leiqi.top/2024-07-21-3ee37da7ed1c.html","excerpt":"","text":"复制自己电脑的私钥到github 复制自己电脑的公钥到gitee 获取gitee 的私人令牌 创建.github&#x2F;workflows&#x2F;xxx.ymal 12345678910111213141516171819202122232425name: Pageson: push: branches: - master # default branchjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v2 - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125; with: # 注意替换为你的 GitHub 源仓库地址 source-repo: git@github.com:leiqichn/novelBigModel.git # 注意替换为你的 Gitee 目标仓库地址 destination-repo: git@gitee.com:leiqichn/novelBigModel.git","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Golang 使用new创建slice","slug":"olang/Golang 使用new创建slice","date":"2024-07-21T06:14:35.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-07-21-01f71b57e534.html","link":"","permalink":"https://leiqi.top/2024-07-21-01f71b57e534.html","excerpt":"","text":"在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。 然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做： 12var s *[]int // 声明一个指向int类型slice的指针s = new([]int) // 分配一个int类型的slice，并将其地址赋给s 但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数： 1s := make([]int, length, capacity) // 创建一个长度为 length，容量为 capacity 的int类型slice 如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做： 12s := new([]int)*s = make([]int, length, capacity) // 通过解引用指针并使用make来初始化slice 在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"依赖注入","slug":"olang/依赖注入","date":"2024-07-21T05:03:46.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2024-07-21-618c8c29b962.html","link":"","permalink":"https://leiqi.top/2024-07-21-618c8c29b962.html","excerpt":"","text":"依赖注入使用接口来实现依赖注入，降低模块间的耦合。概念： 依赖注入是一种设计模式，它允许你将组件的依赖关系（即其他组件或服务）从组件本身中分离出来，并在组件外部进行配置。这样做可以减少组件之间的耦合，使得代码更加模块化，易于测试和维护。 Go 语言实现： 在 Go 语言中，可以通过接口来实现依赖注入。接口定义了组件所需的行为，然后你可以在运行时注入任何实现了这些行为的具体类型。 优点： 降低耦合：组件不直接依赖于具体的实现类，而是依赖于接口，这降低了组件之间的耦合度。 提高灵活性：可以轻易地替换依赖的具体实现，而不需要修改组件的代码。 易于测试：可以为测试注入模拟对象（mocks），从而可以隔离测试组件，不依赖于外部服务或组件。 1234567891011121314151617181920212223242526272829303132333435package maintype Logger interface &#123; Log(message string)&#125;type ConsoleLogger struct&#123;&#125;func (l ConsoleLogger) Log(message string) &#123; println(&quot;Log-DEBUG:&quot;, message)&#125;type ConsoleLoggerINFO struct&#123;&#125;func (l ConsoleLoggerINFO) Log(message string) &#123; println(&quot;Log-INFO:&quot;, message)&#125;type Application struct &#123; logger Logger&#125;func (a *Application) SetLogger(logger Logger) &#123; a.logger = logger&#125;func main() &#123; app := Application&#123;&#125; consoleLogger := ConsoleLogger&#123;&#125; app.SetLogger(consoleLogger) app.logger.Log(&quot;Application started&quot;) consoleLoggerInfo := ConsoleLoggerINFO&#123;&#125; app.SetLogger(consoleLoggerInfo)&#125; 上边通过Go语言的Logger接口包含了Log方法, Application包含了Logger接口。 Application可以通过SetLogger来设置任何实现接口中Log 方法的就，可以方便切换日志类型。这就是依赖注入，每个部分都是个组件，可以随意方便的更换","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"回调函数和直接调用的区别","slug":"olang/回调函数和直接调用的区别","date":"2024-07-21T04:51:05.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2024-07-21-023e6a227482.html","link":"","permalink":"https://leiqi.top/2024-07-21-023e6a227482.html","excerpt":"","text":"回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异： 调用时机： 直接调用：函数A直接调用函数B，函数B的执行是立即的，并且是在函数A的控制下进行的。 回调函数：函数A接收函数B作为参数，但函数B的执行时机可能由外部事件或条件触发，不一定立即执行。 控制流： 直接调用：控制流是线性的，函数B执行完毕后，控制权返回给函数A。 回调函数：控制流可能会中断，函数A执行到某个点后，将控制权交给函数B，函数B执行完毕后，控制权可能不会直接返回给函数A，而是等待某个条件满足后才继续执行。 执行环境： 直接调用：函数B在函数A的上下文中执行，可以访问函数A的局部变量。 回调函数：函数B可能在不同的上下文中执行，例如在异步操作完成后，此时它可能无法访问函数A的局部变量。 目的和用途： 直接调用：通常用于直接执行某个操作或计算。 回调函数：通常用于响应事件、处理异步操作的结果或在特定条件下触发后续操作。 编程模式： 直接调用：更符合同步编程模式，代码执行顺序明确。 回调函数：常用于异步编程模式，代码的执行顺序可能不那么明确，需要更多的控制结构来管理。 函数定义： 直接调用：函数B在被调用时不需要特定的定义或约束。 回调函数：函数B可能需要符合特定的接口或签名，以便作为回调被其他函数使用。 错误处理： 直接调用：错误处理通常在调用者（函数A）中进行。 回调函数：错误处理可能需要在回调函数本身中进行，调用者可能不知道回调函数何时被调用。 代码组织： 直接调用：代码组织可能更直观，因为函数调用关系清晰。 回调函数：代码组织可能需要更多的设计考虑，以确保回调函数在适当的时机被调用，并且逻辑清晰。 使用回调函数而不是直接调用的原因通常与程序设计的复杂性、灵活性和可扩展性有关。例如，在处理异步事件、网络请求或用户界面操作时，回调函数提供了一种有效的方式来处理这些操作的结果，而不需要阻塞主程序流程。此外，回调函数还可以帮助实现更高层次的抽象，如事件监听器、中间件等","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"github同步gitee","slug":"it/github同步gitee","date":"2024-07-18T16:38:12.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-07-18-e17dac938cf8.html","link":"","permalink":"https://leiqi.top/2024-07-18-e17dac938cf8.html","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"vue3快速实践","slug":"端/vue3/vue3 入门/vue3快速实践","date":"2024-06-24T14:32:19.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2024-06-24-1130f46a1ad4.html","link":"","permalink":"https://leiqi.top/2024-06-24-1130f46a1ad4.html","excerpt":"","text":"教程 | Vue.js (vuejs.org) 声明式渲染你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。SFC 是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 .vue 后缀的文件中。 Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。能在改变时触发更新的状态被称作是响应式的。我们可以使用 Vue 的 reactive() API 来声明响应式状态。由 reactive() 创建的对象都是 JavaScript Proxy 123456789import &#123; reactive &#125; from &#x27;vue&#x27;const counter = reactive(&#123; count: 0&#125;)console.log(counter.count) // 0counter.count++ reactive() 只适用于对象 (包括数组和内置类型，如 Map 和 Set)。而另一个 API ref() 则可以接受任何值类型。ref 会返回一个包裹对象，并在 .value 属性下暴露内部值。 在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。 template 1&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt; 现在，试着自己创建一些响应式状态， Attribute 绑定 v-bind1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const titleClass = ref(&#x27;title&#x27;)&lt;/script&gt;&lt;template&gt; &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;&lt;/template&gt;&lt;style&gt;.title &#123; color: red;&#125;&lt;/style&gt; 时间监听 v-on : clickv-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa” 123456789101112131415161718&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)function increment() &#123; // 更新组件状态 count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 使此按钮生效 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 表单绑定 v-modelv-model 会将被绑定的值与 &lt;input&gt; 的值自动同步，这样我们就不必再使用事件处理函数了。 v-model 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在指南 - 表单绑定中讨论了更多的细节。 1234567891011121314151617181920212223242526272829303132&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)function onInput(e) &#123; text.value = e.target.value&#125;&lt;/script&gt;&lt;template&gt; &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt;# 使用v-model 简化&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)&lt;/script&gt;&lt;template&gt; &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt; 条件渲染 12345678910111213141516&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const awesome = ref(true)function toggle() &#123; awesome.value = !awesome.value # 做取反&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;&lt;/template&gt;","categories":[{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"jupyter","slug":"ython/Linux环境上jupyter 安装","date":"2024-06-21T14:26:04.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2024-06-21-02cd02e81f22.html","link":"","permalink":"https://leiqi.top/2024-06-21-02cd02e81f22.html","excerpt":"","text":"安装pip install notebook 用于启动 Jupyter Notebook 服务的一系列命令 12345jupyter-notebook stop 8888JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)echo $JUPYTER_TOKENnohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;jupyter-notebook list 这里是每条命令的简要说明： 12345jupyter-notebook stop 8888：停止端口为 8888 的 Jupyter Notebook 服务。JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)：生成一个随机的 16 位的 token，用于 Jupyter Notebook 的安全认证。nohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。jupyter-notebook list：列出当前运行的 Jupyter Notebook 服务。 conda 对应版本12345# 创建glm4-demo python 3.10的虚拟环境conda create --name glm4-demo python=3.10conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch PyTorch 12conda install python=3.10 pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia 指定python版本：conda install python&#x3D;3.10 pytorch&#x3D;2.3.0 torchvision torchaudio pytorch-cuda&#x3D;12.1 -c pytorch -c nvidia","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"leetcode 每日温度 单调栈","slug":"eetcode/leetcode 每日温度 单调栈","date":"2024-05-20T16:16:04.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-05-20-1fbf9ee2486f.html","link":"","permalink":"https://leiqi.top/2024-05-20-1fbf9ee2486f.html","excerpt":"","text":"739. 每日温度 - 力扣（LeetCode） 栈里边存放的是还没有找到后边更大值的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从左向右，func dailyTemperatures(temperatures []int) []int &#123; length := len(temperatures) // 长度 ans := make([]int, length) // 返回的数组 stack := []int&#123;&#125; // 单调栈 for i := 0; i &lt; length; i ++ &#123; temperature := temperatures[i] fmt.Println(&quot;temperature:&quot;, temperature) fmt.Println(&quot;stack:&quot;, stack) for len(stack) &gt; 0 &amp;&amp; temperature &gt; temperatures[stack[len(stack) -1]] &#123; fmt.Println(&quot;temperature now:&quot;, temperature, temperatures[stack[len(stack) -1]], stack[len(stack) -1]) preindex := stack[len(stack)-1] // 上一个位置的index stack = stack[:len(stack) -1] // 栈顶找到了当前更大的数， ans[preindex] = i -preindex // 记录位置 &#125; stack = append(stack, i) // 如果不满足要求，则说明是小的数，需要添加到栈中 &#125; return ans&#125;// 从右向左func dailyTemperatures(temperatures []int) []int &#123; lens := len(temperatures) ans := make([]int, lens) stack := []int&#123;&#125; // 单调递增栈（从栈底到栈顶） for i := lens-1; i &gt;= 0; i-- &#123; temperature := temperatures[i] // 弹出所有小于等于当前温度的索引 for len(stack) &gt; 0 &amp;&amp; temperature &gt;= temperatures[stack[len(stack)-1]] &#123; stack = stack[:len(stack)-1] &#125; // 如果栈不为空，栈顶就是第一个比当前大的温度 if len(stack) &gt; 0 &#123; ans[i] = stack[len(stack)-1] - i &#125; stack = append(stack, i) &#125; return ans&#125; 单调栈 适用于 上一个更大(更小)元素，或者下一个更大（小）元素 这段代码是一个Go语言编写的函数，名为dailyTemperatures，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表temperatures，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。 代码思想解释： 问题定义：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。 单调栈的应用：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个索引栈，栈内元素代表尚未找到更大温度的天的索引。 初始化： n：记录输入温度数组的长度。 ans：初始化一个长度为n的数组，用于存储结果，初始值设为0。 st：初始化一个空的切片，用作单调栈。 遍历温度数组： 通过range关键字遍历temperatures数组，同时获取索引i和对应的温度值t。 维护单调栈： 当前温度t大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作： 弹出栈顶元素j，即st[len(st)-1]。 计算索引差i - j，并将这个差值赋给ans[j]。 更新栈st，移除栈顶元素。 压栈操作： 将当前索引i压入栈st中。这表示当前索引的天还没有找到之后的第一个更高温度。 返回结果： 遍历结束后，返回ans数组，其中每个元素表示对应天之后第一个更高温度的天数。 接雨水 42. 接雨水 - 力扣（LeetCode） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func trap(height []int) (ans int) &#123; st := []int&#123;&#125; for i, h := range height &#123; for len(st) &gt; 0 &amp;&amp; h &gt;= height[st[len(st)-1]] &#123; // 1. **处理相等高度的情况**：%% - 当遇到相等高度的柱子时，后面的柱子才是有效的右边界 - 使用`&gt;=`可以正确处理这种情况，确保弹出所有小于等于当前高度的柱子 - 如果只用`&gt;`，相等高度的柱子会留在栈中，导致计算错误 %% bottomH := height[st[len(st)-1]] st = st[:len(st)-1] if len(st) == 0 &#123; break &#125; left := st[len(st)-1] dh := min(height[left], h) - bottomH // 面积的高 ans += dh * (i - left - 1)// 面积高*宽 &#125; st = append(st, i) &#125; return&#125;## 示例分析以高度数组`[0,1,0,2,1,0,1,3,2,1,2,1]`为例：1. 遇到第二个高度为1的柱子时： - 弹出之前高度为0的柱子 - 计算它与左边高度1的柱子之间的雨水 2. 遇到高度为2的柱子时： - 弹出高度为1的柱子（因为2 &gt;= 1） - 计算它与左边更高柱子之间的雨水 3. 遇到相等高度1的柱子时： - 前面的1被弹出（因为1 &gt;= 1） - 确保新的1作为右边界参与后续计算 单调队列239. 滑动窗口最大值 12345678910111213141516171819202122232425func maxSlidingWindow(nums []int, k int) []int &#123; ans := make([]int, 0, len(nums)-k+1) // 预分配空间 q := []int&#123;&#125; for i, x := range nums &#123; // 1. 入 for len(q) &gt; 0 &amp;&amp; x &gt;= nums[q[len(q)-1]] &#123; q = q[:len(q)-1] // 维护 q 的单调性 从大到小 &#125; q = append(q, i) // 2. 出 if q[0] &lt;= i -k&#123; // 队首已经离开窗口了 q = q[1:] // Go 的切片是 O(1) 的 &#125; // 3. 记录答案 if i &gt;= k-1 &#123; // 由于队首到队尾单调递减，所以窗口最大值就是队首 ans = append(ans, nums[q[0]]) &#125; &#125; return ans&#125; 从「维护单调性」的角度上来说，单调队列和单调栈是一样的，一个弹出队尾元素，另一个弹出栈顶元素。在单调栈的基础上，单调队列多了一个「移除队首」的操作，这类似滑动窗口移动左指针 left 的过程。所以从某种程度上来说，单调队列 &#x3D; 单调栈 + 滑动窗口。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"go语言实现优先队列","slug":"eetcode/go语言实现优先队列","date":"2024-05-18T16:39:54.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-05-18-dfe0612e31db.html","link":"","permalink":"https://leiqi.top/2024-05-18-dfe0612e31db.html","excerpt":"","text":"Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。 1. 优先队列优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。 2. 最大堆最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。 3. 最小堆最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。 实现步骤定义堆的元素类型首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。 1type IntHeap []int 实现heap.Interface接口要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。 1234567891011121314151617type IntHeap []intfunc (h IntHeap) Len() int &#123; return len(h) &#125;func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125; // 对于最小堆func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125; 使用heap.Init初始化堆在使用堆之前，你需要调用heap.Init来初始化它。 123var h IntHeap // 先声明hheap.Init(&amp;h) // 再使用heap.Init(&amp;h) 初始化h指针 添加元素使用heap.Push来添加元素。 12345678heap.Push(&amp;h, 10)heap.Push(&amp;&amp;h, 20)h := &amp;MyHeap&#123;&#125; // 创建堆实例heap.Init(h) // 初始化堆heap.Push(h, item) // 添加元素item := heap.Pop(h) // 取出元素 移除元素使用heap.Pop来移除并获取堆顶元素。 12top := heap.Pop(&amp;h)fmt.Printf(&quot;top element: %v\\n&quot;, top) 修改元素如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。 转换为最大堆如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。 1func (h IntHeap) Less(i, j int) bool &#123; return h[i] &gt; h[j] &#125; // 对于最大堆 以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。 结构体 优先队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546type Item struct &#123; Value string Priority int Index int // 堆中的索引&#125;type PriorityQueue []*Itemfunc (pq PriorityQueue) Len() int &#123; return len(pq) &#125;func (pq PriorityQueue) Less(i, j int) bool &#123; // 优先值大的先出（最大堆） return pq[i].Priority &gt; pq[j].Priority&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].Index = i pq[j].Index = j&#125;func (pq *PriorityQueue) Push(x any) &#123; n := len(*pq) item := x.(*Item) item.Index = n *pq = append(*pq, item)&#125;func (pq *PriorityQueue) Pop() any &#123; old := *pq n := len(old) item := old[n-1] old[n-1] = nil // 避免内存泄漏 item.Index = -1 // 标记已移除 *pq = old[0 : n-1] return item&#125;// 更新元素的优先级func (pq *PriorityQueue) Update(item *Item, value string, priority int) &#123; item.Value = value item.Priority = priority heap.Fix(pq, item.Index)&#125; 例题215. 数组中的第K个最大元素 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * Copyright (c) 2024 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2024/5/20 上午12:00 */package leetcode215import &quot;container/heap&quot;func findKthLargest(nums []int, k int) int &#123; h := heapify(nums) // 转化为heap 类型 var res any for i := 0; i &lt; k; i++ &#123; res = heap.Pop(&amp;h) &#125; return res.(int)&#125;type BigHeap []intfunc (h BigHeap) Len() int &#123; return len(h) &#125;func (h BigHeap) Less(i, j int) bool &#123; // 大根堆 return h[i] &gt; h[j]&#125;func (h BigHeap) Swap(i, j int) &#123; tmp := h[i] h[i] = h[j] h[j] = tmp&#125;func (h *BigHeap) Push(x any) &#123; // 使用any 或者interface *h = append(*h, x.(int))&#125;// 删除元素待定func (h *BigHeap) Pop() any &#123; x := (*h)[h.Len()-1] *h = (*h)[:h.Len()-1] return x&#125;// 将 nums 转换成 BigHeapfunc heapify(nums []int) BigHeap &#123; h := BigHeap(nums) // bigHeap 本身就是slice 的别名，所以可以转换 // 或者使用下边两行 h := make(BigHeap, len(nums)) // 新建BigHeap，长度为lenNums copy(h, nums) // 将num copy 到 BigHeap 中去 heap.Init(&amp;h) // 需要输入指针 return h&#125; 347. 前 K 个高频元素 涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//方法一：小顶堆func topKFrequent(nums []int, k int) []int &#123; map_num:=map[int]int&#123;&#125; //记录每个元素出现的次数 for _,item:=range nums&#123; map_num[item]++ &#125; h:=&amp;IHeap&#123;&#125; heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num&#123; heap.Push(h,[2]int&#123;key,value&#125;) if h.Len()&gt;k&#123; heap.Pop(h) &#125; &#125; res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i&lt;k;i++&#123; res[k-i-1]=heap.Pop(h).([2]int)[0] &#125; return res&#125;//构建小顶堆type IHeap [][2]intfunc (h IHeap) Len()int &#123; return len(h)&#125;func (h IHeap) Less (i,j int) bool &#123; return h[i][1]&lt;h[j][1]&#125;func (h IHeap) Swap(i,j int) &#123; h[i],h[j]=h[j],h[i]&#125;func (h *IHeap) Push(x interface&#123;&#125;)&#123; *h=append(*h,x.([2]int))&#125;func (h *IHeap) Pop() interface&#123;&#125;&#123; old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 355设计推特","slug":"eetcode/leetcode 355设计推特","date":"2024-05-10T15:26:56.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2024-05-10-b1491b9671d6.html","link":"","permalink":"https://leiqi.top/2024-05-10-b1491b9671d6.html","excerpt":"","text":"Problem: 355. 设计推特 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"如何使用递归","slug":"olang/如何使用递归","date":"2024-05-08T15:15:21.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2024-05-08-23291165e2d9.html","link":"","permalink":"https://leiqi.top/2024-05-08-23291165e2d9.html","excerpt":"","text":"123456789101112131415func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125; 解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤： 识别重复模式： 确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。 定义递归函数： 根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。 确定基本情况： 找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。 分解问题： 将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。 递归工作： 描述递归如何工作，包括如何从子问题的解中构建出原问题的解。 合并结果： 确定如何将子问题的解合并为原问题的解。 编写伪代码： 在编写实际代码之前，先用伪代码描述递归逻辑。 考虑边界条件： 考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。 优化性能： 如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。 测试和调试： 编写测试用例来验证递归逻辑，并调试任何出现的问题。 以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成： 重复模式：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。 定义递归函数：traversal 函数接收一个数组和两个索引，表示当前考虑的子数组。 确定基本情况：如果左索引大于右索引，说明子数组为空，返回 nil。 分解问题：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 traversal 函数。 递归工作：递归地构建左子树和右子树，然后将它们连接到当前根节点。 合并结果：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。 编写伪代码：在脑中或纸上概述递归调用的流程。 考虑边界条件：确保数组索引不会超出数组边界。 优化性能：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。 测试和调试：通过在不同的数组输入上测试函数来确保其正确性。 通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"goland中debug 无法显示全局变量解决","slug":"olang/goland中debug 无法显示全局变量解决","date":"2024-05-07T16:22:44.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-05-07-c105be0dd846.html","link":"","permalink":"https://leiqi.top/2024-05-07-c105be0dd846.html","excerpt":"","text":"实际只会有局部变量，没有全局变量test 解决方法： 右键 选择+ New Watch ； 或者 按按键 Insert 添加变量 test 即可 添加成功之后每次单步执行都会显示变量结果：","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang 中格式化打印单个字符","slug":"olang/golang 中格式化打印单个字符Byte","date":"2024-05-03T08:58:56.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-05-03-ec16a5fd018e.html","link":"","permalink":"https://leiqi.top/2024-05-03-ec16a5fd018e.html","excerpt":"","text":"在Go语言中，fmt.Printf 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。 %c 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 fmt.Printf 中使用 %c，并且传入一个整数（int 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。 例如： 12345678package mainimport &quot;fmt&quot;func main() &#123; var codePoint int = 65 // ASCII码中A的码点 fmt.Printf(&quot;%c\\n&quot;, codePoint) // 输出: A&#125; 在这个例子中，变量 codePoint 的值为 65，它是大写字母 “A” 在ASCII编码中的码点。fmt.Printf(&quot;%c\\n&quot;, codePoint) 将这个整数值格式化为字符 “A” 并输出。 在处理字节数组 []byte 并想要将每个字节转换为对应的字符时，%c 非常有用，因为Go的 string 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; s := &quot;hello&quot; bytes := []byte(s) for i, b := range bytes &#123; fmt.Printf(&quot;Byte %d: %c\\n&quot;, i, b) &#125; // 输出: // Byte 0: h // Byte 1: e // Byte 2: l // Byte 3: l // Byte 4: o&#125; 在这个例子中，我们遍历字符串 &quot;hello&quot; 的字节表示，并使用 %c 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang slice无法添加指针","slug":"olang/golang slice无法添加指针","date":"2024-05-02T13:37:36.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-05-02-247b79126fb5.html","link":"","permalink":"https://leiqi.top/2024-05-02-247b79126fb5.html","excerpt":"","text":"在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向int的指针，比如timePtr *int，你可以通过*timePtr来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。 在你提供的add函数中： 1func add(timePtr *int) &#123; *timePtr += 1 &#125; // 增加一秒 timePtr是一个指向int的指针。虽然你可以通过*timePtr来间接修改它所指向的int值，但是你不能使用这个指针来创建一个关于*int的切片。原因如下： 指针的值是地址：timePtr变量存储的是currentTime变量的内存地址，而不是currentTime的值。切片是基于数组的，它们需要一个具体的数据集合来创建。 切片的元素类型：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于*int的切片，因为切片的元素类型是int，而不是*int（指向int的指针）。 切片创建语法：创建切片通常需要一个数组或另一个切片作为基础，或者使用make函数指定长度和容量。例如： 123var arr [5]intslice1 := arr[:] // 基于数组的切片slice2 := make([]int, 5, 10) // 使用make创建切片 如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在main函数中声明这样一个切片，并在CRUD操作中更新它： 1234567891011121314151617var currentTime intvar history []int // 用于记录历史时间func add(timePtr *int, historyPtr *[]int) &#123; *timePtr++ historyPtr = append(*historyPtr, *timePtr)&#125;func main() &#123; currentTime = 0 history = make([]int, 0) // 初始化历史切片 add(&amp;currentTime, &amp;history) // 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点 fmt.Println(&quot;History of times:&quot;, history)&#125; 在这个例子中，history是一个切片，用于存储时间点的历史记录。每次调用add函数时，我们不仅更新currentTime，还将新的时间点添加到history切片中。注意，由于切片是引用类型，我们传递&amp;history来允许函数修改原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"计算机网络概览","slug":"络/计算机网络概览","date":"2024-05-02T07:27:45.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2024-05-02-82705503428a.html","link":"","permalink":"https://leiqi.top/2024-05-02-82705503428a.html","excerpt":"","text":"【计算机网络】常识 知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；数据链路层；【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；【物理地址MAC】交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）【点对点连接】【全双工通讯】提高了带宽利用率；【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；【IP地址】用于标识不同的网络和网络设备；【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）【默认网关IP】不同网段连接到路由器的IP；【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；【海底光缆】","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"ssh 隧道 端口转发","slug":"具/ssh 隧道 端口转发","date":"2024-04-21T14:30:08.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2024-04-21-29ab33001840.html","link":"","permalink":"https://leiqi.top/2024-04-21-29ab33001840.html","excerpt":"","text":"使用SSH端口转发 如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用-L参数实现，如下所示： 1ssh -L 本地端口:localhost:13579 用户名@物理机IP 其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。 例如：我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC； 123ssh -L 13579:localhost:13579 root@110.43.203.19 -p 30005 // ssh -p 13579 root@localhost","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 208. 实现 Trie (前缀树)","slug":"eetcode/leetcode 208. 实现 Trie (前缀树)","date":"2024-04-16T16:34:47.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2024-04-16-1150f59f3df6.html","link":"","permalink":"https://leiqi.top/2024-04-16-1150f59f3df6.html","excerpt":"","text":"Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。 208. 实现 Trie (前缀树) - 力扣（LeetCode） Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。 为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的： 12345678type TrieNode struct &#123; Value int Next *TrieNode&#125; 而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)： 12345678type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package main import &quot;fmt&quot; // TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; // Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125; // Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125; // Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125; // Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125; // StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125; /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Golang slice作为参数传递给函数需要使用指针","slug":"olang/Golang slice作为参数传递给函数需要使用指针","date":"2024-04-11T16:35:04.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-04-11-22166b2f52d0.html","link":"","permalink":"https://leiqi.top/2024-04-11-22166b2f52d0.html","excerpt":"","text":"123456789101112131415161718func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; dfs(1,n,k,&amp;res,&amp;[]int&#123;&#125;) return res&#125;func dfs(s, n, k int, res *[][]int, item *[]int) &#123; if len(*item) == k &#123; *res = append(*res, append([]int&#123;&#125;, *item...)) return &#125; for i := s; i &lt;= n-(k-len(*item))+1; i++&#123; *item = append(*item, i) dfs(i+1, n, k, res, item) *item = (*item)[:len(*item)-1] &#125;&#125; 在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 append 函数或者直接索引赋值的方式，那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。 这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。 例如，在 combine 函数中，如果想要 dfs 函数能够修改 res slice 的长度（即添加新的组合到 res 中），那么需要传递 res 的指针的指针。这样，当 dfs 函数执行 *res = append(*res, newCombination...) 时，它会修改原始的 res slice 而不是它的副本。 传递指针的原因是为了： 避免不必要的副本创建：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。 确保函数内部的修改能够反映到原始数据上：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。 提高代码的效率和性能：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。 还可以转化为全局变量；需要注意的是go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化 123456789101112131415161718192021222324252627var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) // 需要进行初始化 path = make([]int, 0) // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return &#125; for i := startIdx;i&lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; tempPath :&#x3D; []int{},copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。copy(tempPath, path) 123456789101112131415161718192021222324252627282930var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) path = make([]int, 0) // 结束条件 var backtracking func(n int, k int, startIndex int) backtracking = func(n int, k int, startIndex int) &#123; if len(path) == k &#123; tempPath := make([]int, k) // tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。 copy(tempPath, path) res = append(res, tempPath) &#125; for i:= startIndex; i &lt;= n; i++ &#123; if (n -i +1 ) &lt; (k -len(path)) &#123; return &#125; path = append(path, i) backtracking(n, k, i+1) path = path[:len(path)-1] &#125; &#125; backtracking(n,k,1) return res&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"设计题 总结","slug":"eetcode/设计题 总结","date":"2024-04-05T17:21:04.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2024-04-05-d9f9294c39ef.html","link":"","permalink":"https://leiqi.top/2024-04-05-d9f9294c39ef.html","excerpt":"","text":"举个简单的例子：设计题 - 实现浏览器历史记录1.初始化 homepage 和历史记录容量2.浏览网页 和当前页相同，则直接返回 和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。3.实现前进和后退功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: 浏览器实现 * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; if b.GetCurrentPage() == newPageURL &#123; return newPageURL &#125; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。 第一步：理解需求在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能： 记录当前页面。支持前进和后退操作。能够跳转到新页面。考虑历史记录的容量限制。 第二步：建模接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素： 当前页面：表示用户当前正在浏览的页面。历史记录：表示用户访问过的页面的顺序列表。最大容量：限制历史记录的长度，以防止无限增长。一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。 第三步：选择数据结构和函数接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数： NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。GetCurrentPage() string：获取当前页面的URL。GoBack() string：执行后退操作，并返回当前页面的URL。GoForward() string：执行前进操作，并返回当前页面的URL。NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。 第四步：编写示例代码现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。 第五步：测试和优化一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。 根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。 总结在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。 练习下面，我们来按照难度多练习几道题目 简单题 232. 用栈实现队列 - 力扣（LeetCode） 思路：input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667type MyQueue struct &#123; inputStack []int outputStack []int&#125;func Constructor() MyQueue &#123; return MyQueue&#123; inputStack: make([]int, 0), outputStack: make([]int, 0), &#125;&#125;func (this *MyQueue) Push(x int) &#123; this.inputStack = append(this.inputStack, x)&#125;func (this *MyQueue) Pop() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return top&#125;func (this *MyQueue) Peek() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // return top&#125;func (this *MyQueue) Empty() bool &#123; if len(this.inputStack) == 0 &amp;&amp; len(this.outputStack) == 0 &#123; return true &#125; return false&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 - 力扣（LeetCode） 思路：用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type MyStack struct &#123; inputQueue []int outputQueue []int&#125;func Constructor() MyStack &#123; return MyStack&#123; inputQueue: make([]int, 0), outputQueue: make([]int, 0), &#125;&#125;func (this *MyStack) Push(x int) &#123; this.inputQueue = append(this.inputQueue, x)&#125;func (this *MyStack) Pop() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = this.outputQueue this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Top() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = append(this.outputQueue, this.inputQueue...) this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Empty() bool &#123; if (len(this.inputQueue) == 0) &amp;&amp; (len(this.outputQueue) == 0) &#123; return true &#125; return false&#125; 303. 区域和检索 - 数组不可变思路：简单题， 12345678910111213141516171819202122232425type NumArray struct &#123; nums []int&#125;func Constructor(nums []int) NumArray &#123; return NumArray&#123;nums: nums&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; sum := 0 for i:= left; i&lt;= right; i++ &#123; sum += this.nums[i] &#125; return sum&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用前缀和怎么求 preSum 数组利用前面提到的递推式: 遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，即preSum[0]为nums[0]（前提是nums有元素）。 预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。 需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。 后面会给出简化的写法。 123456789101112131415161718192021222324252627282930313233type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums)) preSum[0] = nums[0] for i:=1; i&lt;len(nums);i++ &#123; preSum[ i] = preSum[ i-1] + nums[i] &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; if left == 0 &#123; // 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j] if len(this.preSum) == 0 &#123; // 但如果nums根本没有长度，直接返回0 return 0 &#125; return this.preSum[right] &#125; return this.preSum[right] - this.preSum[left-1]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用多一位长度的前缀和之所以上面处理东西多，是因为preSum[i]的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index 要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]即： 1234567891011121314151617181920212223242526type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums) + 1) for index, value := range nums &#123; preSum[index + 1] = preSum[index] + value &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; return this.preSum[right + 1] - this.preSum[left]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 703. 数据流中的第 K 大元素暴力解法 1234567891011121314151617181920212223242526272829303132type KthLargest struct &#123; // 排序后的nums index int sortedNums []int&#125;func Constructor(k int, nums []int) KthLargest &#123; return KthLargest&#123;k, nums&#125;&#125;func (this *KthLargest) Add(val int) int &#123; this.sortedNums = append(this.sortedNums, val) sort.Ints(this.sortedNums) revert(this.sortedNums) return this.sortedNums[this.index-1]&#125;func revert(nums []int) &#123; for i, j := 0, len(nums)-1; i &lt; j; i, j = i+1, j-1 &#123; nums[i], nums[j] = nums[j], nums[i] &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * obj := Constructor(k, nums); * param_1 := obj.Add(val); */ 优先队列我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。 在单次插入的操作中，我们首先将元素 val\\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。 123456789101112131415161718192021222324252627282930313233type KthLargest struct &#123; sort.IntSlice k int&#125;func Constructor(k int, nums []int) KthLargest &#123; kl := KthLargest&#123;k: k&#125; for _, val := range nums &#123; kl.Add(val) &#125; return kl&#125;func (kl *KthLargest) Push(v interface&#123;&#125;) &#123; kl.IntSlice = append(kl.IntSlice, v.(int))&#125;func (kl *KthLargest) Pop() interface&#123;&#125; &#123; a := kl.IntSlice v := a[len(a)-1] kl.IntSlice = a[:len(a)-1] return v&#125;func (kl *KthLargest) Add(val int) int &#123; heap.Push(kl, val) if kl.Len() &gt; kl.k &#123; heap.Pop(kl) &#125; return kl.IntSlice[0]&#125; 146 LRU缓存146. LRU 缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type LRUCache struct &#123; capacity int // 容量 keysList []int // 实现最新时间 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间 keysMap map[int]int // 存放key value&#125;func Constructor(capacity int) LRUCache &#123; //return return LRUCache&#123;capacity, make([]int, 0), make(map[int]int, 0)&#125;&#125;// 如果key存在于缓存中，则返回关键字的值，否则返回-1func (this *LRUCache) Get(key int) int &#123; if ele, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) return ele &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; // 关键字存在 则更新值为value // 不存在，则插入value // 如果插入超过数量capacity 则删除最久没有使用的关键字【list] if _, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) this.keysMap[key] = value &#125; else &#123; this.updateListKey(key) this.keysMap[key] = value if len(this.keysList) &gt; this.capacity &#123; delete(this.keysMap, this.keysList[0]) // 这里删除key 从list队列中获取 this.keysList = this.keysList[1:] &#125; &#125;&#125;func (this *LRUCache) updateListKey(key int) &#123; for i := 0; i &lt; len(this.keysList); i++ &#123; if key == this.keysList[i] &#123; this.keysList = append(this.keysList[:i], this.keysList[i+1:]...) // 删除该key, 然后放在末尾 break &#125; &#125; this.keysList = append(this.keysList, key)&#125; 355 设计推特355. 设计推特 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特数目，用于时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 和时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125; 1234567891011// 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; 上边代码为什么需要使用 &amp;User 而不是直接使用 map 中的值： 当 key 不存在时，map 返回的是零值（对于 *User 就是 nil） 你不能对 nil 指针进行赋值操作 因此必须先创建一个新的 User 实例（使用 &amp;User&#123;&#125;），然后存入 map 这种模式在 Go 中很常见，特别是在需要”如果不存在则初始化”的场景中。 208. 实现 Trie (前缀树) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport &quot;fmt&quot;// TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125;// Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125;// Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125;// Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125;// Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125;// StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125;/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 211. 添加与搜索单词 - 数据结构设计 一次AC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &quot;strings&quot;type WordDictionary struct &#123; wordMap map[string]bool&#125;func Constructor() WordDictionary &#123; return WordDictionary&#123;make(map[string]bool, 0)&#125;&#125;func (this *WordDictionary) AddWord(word string) &#123; this.wordMap[word] = true&#125;func (this *WordDictionary) Search(word string) bool &#123; if _, ok := this.wordMap[word]; ok &#123; return true &#125; else if strings.Contains(word, &quot;.&quot;) &#123; for key, _ := range this.wordMap &#123; if len(key) == len(word) &#123; flag := true for i := 0; i &lt; len(word); i++ &#123; if key[i] == word[i] || word[i] == &#x27;.&#x27; &#123; &#125; else &#123; flag = false &#125; &#125; if flag == true &#123; return true &#125; &#125; &#125; return false &#125; return false&#125;/** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */ 284. 窥视迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142/* Below is the interface for Iterator, which is already defined for you. * * type Iterator struct &#123; * * &#125; * * func (this *Iterator) hasNext() bool &#123; * // Returns true if the iteration has more elements. * &#125; * * func (this *Iterator) next() int &#123; * // Returns the next element in the iteration. * &#125; */type PeekingIterator struct &#123; iter *Iterator _hasNext bool _next int&#125;func Constructor(iter *Iterator) *PeekingIterator &#123; return &amp;PeekingIterator&#123;iter, iter.hasNext(), iter.next()&#125;&#125;func (it *PeekingIterator) hasNext() bool &#123; return it._hasNext&#125;func (it *PeekingIterator) next() int &#123; ret := it._next it._hasNext = it.iter.hasNext() if it._hasNext &#123; it._next = it.iter.next() &#125; return ret&#125;func (it *PeekingIterator) peek() int &#123; return it._next&#125; 535. TinyURL 的加密与解密 12345678910111213141516171819202122232425262728293031323334// 通过自增id 的方式来实现encodetype Codec struct &#123; dataId map[int]string nums int&#125;func Constructor() Codec &#123; return Codec&#123;map[int]string&#123;&#125;, 0&#125;&#125;// Encodes a URL to a shortened URL.func (this *Codec) encode(longUrl string) string &#123; this.nums++ this.dataId[this.nums] = longUrl res := &quot;http://tinyurl.com/&quot; + strconv.Itoa(this.nums) return res&#125;// Decodes a shortened URL to its original URL.func (this *Codec) decode(shortUrl string) string &#123; index := strings.Split(shortUrl, &quot;/&quot;) tmp := index[len(index)-1] idx, _ := strconv.Atoi(tmp) long := this.dataId[idx] return long&#125;/** * Your Codec object will be instantiated and called as such: * obj := Constructor(); * url := obj.encode(longUrl); * ans := obj.decode(url); */ 707. 设计链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374type MyLinkedList struct &#123; // 如何确定结构体里应设置什么变量？ // 总的List 包含 有多少个节点，以及头节点是什么 Size int dummyHead *ListNode &#125;func Constructor() MyLinkedList &#123; // Constructor 该如何写？如何才能符合题目要求？ return MyLinkedList&#123;0, &amp;ListNode&#123;0,nil&#125;&#125; // 这个虚拟头节点不应该删掉吗？&#125;func (this *MyLinkedList) Get(index int) int &#123; if index &lt; 0 || index &gt;= this.Size &#123; return -1 &#125; //dummyHead := &amp;ListNode&#123;0, this.head&#125; cur := this.dummyHead.Next for index != 0 &amp;&amp; cur != nil &#123; cur = cur.Next index-- &#125; return cur.Val&#125;func (this *MyLinkedList) AddAtHead(val int) &#123; this.AddAtIndex(0, val)&#125;func (this *MyLinkedList) AddAtTail(val int) &#123; this.AddAtIndex(this.Size, val)&#125;func (this *MyLinkedList) AddAtIndex(index int, val int) &#123; if index &gt;= 0 &amp;&amp; index &lt;= this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; newNode := &amp;ListNode&#123;val, cur.Next&#125; cur.Next = newNode this.Size++ &#125; if index &lt; 0 &#123; this.AddAtIndex(0, val) this.Size++ &#125; if index &gt; this.Size &#123; return // 这个return 到哪里了？ 代表结束这个程序吗？ &#125;&#125;func (this *MyLinkedList) DeleteAtIndex(index int) &#123; if index &gt;= 0 &amp;&amp; index &lt; this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; cur.Next = cur.Next.Next this.Size-- &#125; return&#125;/** * Your MyLinkedList object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Get(index); * obj.AddAtHead(val); * obj.AddAtTail(val); * obj.AddAtIndex(index,val); * obj.DeleteAtIndex(index); */ 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 901. 股票价格跨度 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 1396. 设计地铁系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */ 1476. 子矩形查询 1234567891011121314151617181920212223242526272829303132type SubrectangleQueries struct &#123; // 需要什么数据结构呢？ 1. 一个二维数组 rectangle [][]int&#125;func Constructor(rectangle [][]int) SubrectangleQueries &#123; return SubrectangleQueries&#123;rectangle: rectangle&#125;&#125;func (this *SubrectangleQueries) UpdateSubrectangle(row1 int, col1 int, row2 int, col2 int, newValue int) &#123; for i:=row1;i &lt;= row2;i++ &#123; for j:= col1; j &lt;= col2; j++ &#123; this.rectangle[i][j] = newValue &#125; &#125;&#125;func (this *SubrectangleQueries) GetValue(row int, col int) int &#123; return this.rectangle[row][col]&#125;/** * Your SubrectangleQueries object will be instantiated and called as such: * obj := Constructor(rectangle); * obj.UpdateSubrectangle(row1,col1,row2,col2,newValue); * param_2 := obj.GetValue(row,col); */ 1845. 座位预约管理系统 1234567891011121314151617181920212223242526272829303132333435type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125; 1993. 树上的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869type LockingTree struct &#123; parent []int lockNodeUser []int children [][]int&#125;func Constructor(parent []int) LockingTree &#123; n := len(parent) lockNodeUser := make([]int, n) children := make([][]int, n) for i := 0; i &lt; n; i++ &#123; lockNodeUser[i] = -1 p := parent[i] if p != -1 &#123; children[p] = append(children[p], i) &#125; &#125; return LockingTree&#123;parent, lockNodeUser, children&#125;&#125;func (this *LockingTree) Lock(num int, user int) bool &#123; if this.lockNodeUser[num] == -1 &#123; this.lockNodeUser[num] = user return true &#125; return false&#125;func (this *LockingTree) Unlock(num int, user int) bool &#123; if this.lockNodeUser[num] == user &#123; this.lockNodeUser[num] = -1 return true &#125; return false&#125;func (this *LockingTree) Upgrade(num int, user int) bool &#123; res := this.lockNodeUser[num] == -1 &amp;&amp; !this.hasLockedAncestor(num) &amp;&amp; this.checkAndUnlockDescendant(num) if res &#123; this.lockNodeUser[num] = user &#125; return res&#125;func (this *LockingTree) hasLockedAncestor(num int) bool &#123; num = this.parent[num] for num != -1 &#123; if this.lockNodeUser[num] != -1 &#123; return true &#125; num = this.parent[num] &#125; return false&#125;func (this *LockingTree) checkAndUnlockDescendant(num int) bool &#123; res := false if this.lockNodeUser[num] != -1 &#123; res = true &#125; this.lockNodeUser[num] = -1 for _, child := range this.children[num] &#123; if this.checkAndUnlockDescendant(child) &#123; res = true &#125; &#125; return res&#125; 2241. 设计一个 ATM 机器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type ATM struct &#123; orderList []int amountMap map[int]int // map 是多余的&#125;func Constructor() ATM &#123; return ATM&#123; make([]int, 5), make(map[int]int),// 初始化 使用make 多练习多学习，保持手感。 &#125;&#125;var price [5]int = [5]int&#123;20, 50, 100, 200, 500&#125;func (this *ATM) Deposit(banknotesCount []int) &#123; for i , count := range banknotesCount&#123; this.orderList[i] += count &#125;&#125;func (this *ATM) Withdraw(amount int) []int &#123; //使用整除法 ans := make([]int, 5) for i := 4; i &gt;= 0; i-- &#123; ans[i] = min(amount/price[i],this.orderList[i]) amount -= ans[i]*price[i] &#125; if amount &gt; 0 &#123; return []int&#123;-1&#125; &#125; for idx,v := range ans &#123; this.orderList[idx] -= v &#125; return ans // 注意试着返回是需要钞票的数量，不是钞票的剩余数量&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 2353. 设计食物评分系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394type FoodRatings struct &#123; Map map[string]*FoodHeap NameMap map[string]*Food&#125;type Food struct &#123; Name, C string Rating, Idx int&#125;// 实现堆type FoodHeap []*Foodfunc (h FoodHeap) String() string &#123; res := &quot;&quot; for _, f := range h &#123; res = fmt.Sprintf(&quot;%s -&gt; (%v, %v)&quot;, res, f.Name, f.Rating) &#125; return res&#125;func (h FoodHeap) Len() int &#123; return len(h) &#125;func (h FoodHeap) Swap(i, j int) &#123; h[i], h[i].Idx, h[j], h[j].Idx = h[j], h[j].Idx, h[i], h[i].Idx&#125;// 大顶堆 如果分数相同，Name 字典序小的更大func (h FoodHeap) Less(i, j int) bool &#123; if h[j].Rating == h[i].Rating &#123; return h[i].Name &lt; h[j].Name &#125; return h[j].Rating &lt; h[i].Rating&#125;func (h *FoodHeap) Push(f interface&#123;&#125;) &#123; // Push and Pop use pointer receivers because they modify the slice&#x27;s length, // not just its contents. food := f.(*Food) food.Idx = h.Len() *h = append(*h, food)&#125;func (h *FoodHeap) Pop() interface&#123;&#125; &#123; a := *h; v := a[len(a) - 1]; *h = a[:len(a) - 1]; return v &#125;// 以烹饪方式对评分归类func Constructor(foods []string, cuisines []string, ratings []int) FoodRatings &#123; f := FoodRatings&#123; Map: make(map[string]*FoodHeap), NameMap: make(map[string]*Food, len(foods)), &#125; var ( food *Food h *FoodHeap has bool ) for idx := range foods &#123; food = &amp;Food &#123; foods[idx], cuisines[idx], ratings[idx], 0, &#125; f.NameMap[foods[idx]] = food if h, has = f.Map[cuisines[idx]]; !has &#123; h = &amp;FoodHeap&#123;&#125; f.Map[cuisines[idx]] = h &#125; heap.Push(h, food) &#125; return f&#125;func (this *FoodRatings) ChangeRating(food string, newRating int) &#123; f := this.NameMap[food] h := this.Map[f.C] f.Rating = newRating heap.Fix(h, f.Idx) &#125;func (this *FoodRatings) HighestRated(cuisine string) string &#123; h := this.Map[cuisine] if h.Len() == 0 &#123; return cuisine + &quot;No exist&quot; &#125; return (*h)[0].Name&#125; LCR 184. 设计自助结算系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type MaxQueue struct &#123; q1 []int max []int&#125;func Constructor() MaxQueue &#123; return MaxQueue&#123; make([]int,0), make([]int,0), &#125;&#125;func (this *MaxQueue) Max_value() int &#123; if len(this.max) == 0&#123; return -1 &#125; return this.max[0]&#125;func (this *MaxQueue) Push_back(value int) &#123; this.q1 = append(this.q1,value) for len(this.max) != 0 &amp;&amp; value &gt; this.max[len(this.max)-1]&#123; this.max = this.max[:len(this.max)-1] &#125; this.max = append(this.max,value)&#125;func (this *MaxQueue) Pop_front() int &#123; n := -1 if len(this.q1) != 0&#123; n = this.q1[0] this.q1 = this.q1[1:] if this.max[0] == n&#123; this.max = this.max[1:] &#125; &#125; return n&#125;/** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Max_value(); * obj.Push_back(value); * param_3 := obj.Pop_front(); */作者：Sakura链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solutions/135149/golang-shuang-dui-lie-by-sakura-151/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows IE代理问题解决","slug":"络/windows IE代理问题解决","date":"2024-04-05T05:11:29.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2024-04-05-e1116cf34b00.html","link":"","permalink":"https://leiqi.top/2024-04-05-e1116cf34b00.html","excerpt":"","text":"CMD 检查系统代理配置： - 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。 - 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 双指针","slug":"eetcode/leetcode 双指针","date":"2024-03-23T14:51:46.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-03-23-84678021105b.html","link":"","permalink":"https://leiqi.top/2024-03-23-84678021105b.html","excerpt":"","text":"1234567891011121314// 删除有序数组中的重复元素func removeDuplicates(nums []int) int &#123; slow:=0 for fast:=1;fast &lt;len(nums);fast++ &#123; if nums[fast] != nums[slow] &#123; slow++// 跳到下个位置，保存slow nums[slow] = nums[fast] &#125; &#125; return slow +1&#125; slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。 12345678910func moveZeroes(nums []int) &#123; slow, n := 0, len(nums) for fast := 0; fast &lt; n; fast++ &#123; // 注意第一个是0的时候需要比较 if nums[fast] != 0 &#123; // 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 nums[slow], nums[fast] = nums[fast], nums[slow] slow++ &#125; &#125;&#125; 思路： 1234567891011121314func maxArea(height []int) int &#123; ans := 0 for i := 0; i &lt; len(height); i++ &#123; for j := i + 1; j &lt; len(height); j++ &#123; area := (j - i) * min(height[i], height[j]) ans = max(area,ans) &#125; &#125; return ans&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 123456789101112131415161718func maxArea(height []int) (ans int) &#123; left, right := 0, len(height)-1 // 初始化两边指针 for left &lt; right &#123; area := (right - left) * min(height[left], height[right]) // 计算面积 ans = max(ans, area) // 计算最大值 if height[left] &lt; height[right] &#123; left++ // 移动短的那个 &#125; else &#123; right-- &#125; &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 前缀和，后缀和木桶效应，当前能装的水，取决于两边最大值 的最小值。 1234567891011121314151617181920212223242526func trap(height []int) (ans int) &#123; n := len(height) preMax := make([]int, n) // preMax[i] 表示从 height[0] 到 height[i] 的最大值 preMax[0] = height[0] for i := 1; i &lt; n; i++ &#123; preMax[i] = max(preMax[i-1], height[i]) &#125; sufMax := make([]int, n) // sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值 sufMax[n-1] = height[n-1] for i := n - 2; i &gt;= 0; i-- &#123; sufMax[i] = max(sufMax[i+1], height[i]) &#125; for i, h := range height &#123; ans += min(preMax[i], sufMax[i]) - h // 累加每个水桶能接多少水 &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 双指针 123456789101112131415161718func trap(height []int) (ans int) &#123; left, right, preMax, sufMax := 0, len(height)-1, 0, 0 for left &lt; right &#123; preMax = max(preMax, height[left]) sufMax = max(sufMax, height[right]) if preMax &lt; sufMax &#123; ans += preMax - height[left] left++ &#125; else &#123; ans += sufMax - height[right] right-- &#125; &#125; return&#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 单调栈","slug":"eetcode/leetcode 单调栈","date":"2024-02-24T15:57:54.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-02-24-dd95d981cb94.html","link":"","permalink":"https://leiqi.top/2024-02-24-dd95d981cb94.html","excerpt":"","text":"单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」 输入一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 1234567891011121314151617181920212223func nextGreaterElement(nums []int) []int &#123; n := len(nums) // 存放答案的数组 res := make([]int, n) // 倒着往栈里放 s := make([]int, 0) for i := n - 1; i &gt;= 0; i-- &#123; // 倒着入栈是为了后边正着出栈 // 判定个子高矮 for len(s) &gt; 0 &amp;&amp; s[len(s)-1] &lt;= nums[i] &#123; // 矮个起开，反正也被挡着了。。。 s = s[:len(s)-1] &#125; // nums[i] 身后的更大元素 if len(s) == 0 &#123; // 没有更大的元素 res[i] = -1 &#125; else &#123; res[i] = s[len(s)-1] // 正着出栈 &#125; s = append(s, nums[i]) // 当前元素 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"golang 修改函数传入参数切片需要指针","slug":"olang/golang 修改函数传入参数切片需要指针","date":"2024-02-24T14:50:06.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2024-02-24-4fbd7a88bf6f.html","link":"","permalink":"https://leiqi.top/2024-02-24-4fbd7a88bf6f.html","excerpt":"","text":"func dfs(root *TreeNode, res *[]int) { if root &#x3D;&#x3D; nil { return } *res = append(*res, root.Val) dfs(root.Left, res) dfs(root.Right, res) }在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。 在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。 但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。 这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"路由器设置桥接","slug":"络/路由器设置桥接","date":"2024-02-15T13:34:12.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2024-02-15-1f66da892e14.html","link":"","permalink":"https://leiqi.top/2024-02-15-1f66da892e14.html","excerpt":"","text":"设置密码类型和主路由一样 记得关闭DHCP服务器","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 406. 根据身高重建队列【贪心】","slug":"eetcode/leetcode 406. 根据身高重建队列【贪心】","date":"2024-01-23T16:13:30.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2024-01-23-1cb0809a7893.html","link":"","permalink":"https://leiqi.top/2024-01-23-1cb0809a7893.html","excerpt":"","text":"406. 根据身高重建队列 - 力扣（LeetCode） 12345678910111213141516func reconstructQueue(people [][]int) [][]int &#123; sort.Slice(people, func(i, j int) bool &#123; if people[i][0] == people[j][0]&#123; return people[i][1] &lt; people[j][1] &#125; return people[i][0] &gt; people[j][0] // 身高由大到小排列 &#125;)i // 再按照K进行插入排序，优先插入K小的 for i, p := range people &#123; copy(people[p[1]+1 :i+1], people[p[1] :i=1]) // 腾空出一个位置 people[p[1]] = pi &#125; return people&#125; sort.Slice(people, func(i, j int) bool &#123; ... &#125;): 使用 sort.Slice 对 people 进行排序，按照身高从大到小排列，如果身高相同则按照 k 从小到大排列。 for i, p := range people &#123; ... &#125;: 遍历排序后的数组，按照每个人的 k 值进行插入排序。 copy(people[p[1]+1:i+1], people[p[1]:i+1]): 在插入位置 p[1] 之后的位置腾出一个空位，为新的元素插入做准备。 people[p[1]] = p: 将当前人物 p 插入到正确的位置。 最终，返回重新排列后的队列 people。 在 copy(people[p[1]+1:i+1], people[p[1]:i+1]) 中，使用 i+1 而不是 len(people) 的原因是为了确保只复制有效的元素范围。这里的目标是将 people[p[1]:i+1] 复制到 people[p[1]+1:i+1]，而不是复制整个切片。 让我们考虑一下为什么使用 i+1： i 表示当前元素的索引，而我们想要复制的范围是从 p[1] 到 i。 使用 i+1 作为结束索引可以确保包含 i 在内的元素，而不会超出有效的范围。 如果使用 len(people) 作为结束索引，那么将会复制从 p[1] 到 len(people)-1 的所有元素，这超出了实际有效的范围。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 77.组合【回溯】","slug":"eetcode/leetcode 77.组合【回溯】","date":"2024-01-23T15:17:11.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2024-01-23-183e0ff5f5ef.html","link":"","permalink":"https://leiqi.top/2024-01-23-183e0ff5f5ef.html","excerpt":"","text":"77. 组合 - 力扣（LeetCode） 使用回溯的模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 12345678910111213141516171819202122232425func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; path := []int&#123;&#125; // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return // return &#125; for i := startIdx;i &lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) // i+1 进行下一轮 path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; 创建一个二维切片 res 用于存储最终结果，以及一个一维切片 path 用于存储当前路径。 定义回溯函数 backtracking，它接收三个参数：n 表示数字范围，k 表示组合长度，startIdx 表示当前起始数字的索引。 在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。 使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。 在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。 在主函数中初始调用回溯函数，然后返回最终结果。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【BFS DFS通用模板】","slug":"eetcode/【BFS DFS通用模板】","date":"2024-01-22T16:05:29.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-01-22-759654485d5d.html","link":"","permalink":"https://leiqi.top/2024-01-22-759654485d5d.html","excerpt":"","text":"深度优先搜索（DFS）通用模板123456789101112131415161718192021222324252627282930313233343536// 通用的深度优先搜索函数func dfs(node int, visited []bool, graph [][]int) &#123; // 边界终止条件 if m n &#123; &#125; // 终止条件 if visited[node] &#123; return &#125; // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 递归处理相邻节点 for _, neighbor := range graph[node] &#123; dfs(neighbor, visited, graph) &#125;&#125;// 在主函数中调用func main() &#123; // 初始化节点、访问数组等 // ... // 遍历所有节点 for node := 0; node &lt; len(graph); node++ &#123; if !visited[node] &#123; dfs(node, visited, graph) &#125; &#125;&#125; 广度优先搜索（BFS）通用模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 通用的广度优先搜索函数func bfs(start int, graph [][]int) &#123; queue := []int&#123;start&#125; visited := make([]bool, len(graph)) for len(queue) &gt; 0 &#123; // 出队列 node := queue[0] queue = queue[1:] // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 将相邻节点入队列 for _, neighbor := range graph[node] &#123; if !visited[neighbor] &#123; queue = append(queue, neighbor) &#125; &#125; &#125;&#125;// 在主函数中调用func main() &#123; // 初始化起始节点、图等 // ... // 调用BFS函数 bfs(start, graph)&#125;// 计算从起点 start 到终点 target 的最近距离func BFS(start Node, target Node) int &#123; // 核心数据结构 q := make([]Node, 0) // 避免走回头路 visited := make(map[Node]bool) // 将起点加入队列 q = append(q, start) visited[start] = true for len(q) &gt; 0 &#123; sz := len(q) // 将当前队列中的所有节点向四周扩散 for i := 0; i &lt; sz; i++ &#123; cur := q[0] q = q[1:] // 划重点：这里判断是否到达终点 if cur == target &#123; return step &#125; // 将 cur 的相邻节点加入队列 for _, x := range cur.adj() &#123; if _, ok := visited[x]; !ok &#123; q = append(q, x) visited[x] = true &#125; &#125; &#125; &#125; // 如果走到这里，说明在图中没有找到目标节点&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 94.二叉树的中序遍历","slug":"eetcode/leetcode 94.二叉树的中序遍历","date":"2024-01-22T15:01:59.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-01-22-f8790b7ced8e.html","link":"","permalink":"https://leiqi.top/2024-01-22-f8790b7ced8e.html","excerpt":"","text":"递归方法123456789101112131415func inorderTraversal(root *TreeNode) (res []int) &#123; var traversal func(node *TreeNode) traversal = func(node *TreeNode) &#123; if node == nil &#123; return &#125; traversal(node.Left) res = append(res,node.Val) traversal(node.Right) &#125; traversal(root) return res&#125; 非递归方法1234567891011121314151617181920212223func inorderTraversal(root *TreeNode) []int &#123; ans := []int&#123;&#125; if root == nil &#123; return ans &#125; st := list.New() cur := root for cur != nil || st.Len() &gt; 0 &#123; if cur != nil &#123; st.PushBack(cur) cur = cur.Left &#125; else &#123; cur = st.Remove(st.Back()).(*TreeNode) ans = append(ans, cur.Val) cur = cur.Right &#125; &#125; return ans&#125; 下面是对代码的解释： ans := []int&#123;&#125;: 创建一个空的整数切片，用于存储最终的中序遍历结果。 if root == nil &#123; return ans &#125;: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。 st := list.New(): 创建一个新的链表（list），用作栈。这里使用标准库中的list包，实现了一个双向链表作为栈。 cur := root: 初始化当前节点为根节点。 for cur != nil || st.Len() &gt; 0 &#123;: 进入循环，只要当前节点不为空或栈不为空就继续遍历。 if cur != nil &#123;: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。 st.PushBack(cur): 将当前节点入栈。 cur = cur.Left: 移动到左子树。 &#125; else &#123;: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。 cur = st.Remove(st.Back()).(*TreeNode): 弹出栈顶节点，即当前待处理的节点。 ans = append(ans, cur.Val): 将当前节点的值加入结果切片。 cur = cur.Right: 移动到右子树。 循环回到第5步，直到栈为空。 这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。 其中 进入循环的条件 for cur != nil || st.Len() &gt; 0 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件： cur != nil: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。 st.Len() &gt; 0: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。 这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。 在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【go】初始化双向列表List","slug":"eetcode/【go】初始化双向列表List","date":"2024-01-22T14:39:01.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-01-22-93119ce81a1c.html","link":"","permalink":"https://leiqi.top/2024-01-22-93119ce81a1c.html","excerpt":"","text":"在Go语言中，两种方法都可以用于初始化一个list.List。 queue := &amp;list.List&#123;&#125;: 这是使用结构体字面量的方式，创建一个 list.List 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。 queue := list.New(): 这是使用 list 包中的 New 函数来创建一个新的 list.List。New 函数返回一个指向新创建的 list.List 实例的指针。同样，这种方式也创建了一个空的链表。 两种方式都是有效的","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【20240114】LeetCode 83. 删除排序链表中的重复元素","slug":"eetcode/【20240114】LeetCode 83. 删除排序链表中的重复元素","date":"2024-01-14T10:10:30.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-01-14-e61755fec3db.html","link":"","permalink":"https://leiqi.top/2024-01-14-e61755fec3db.html","excerpt":"","text":"Problem: 83. 删除排序链表中的重复元素 [TOC] 思路 遍历 解题方法 描述你的解题方法 复杂度时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123; for i := head; i != nil &amp;&amp; i.Next != nil ; &#123; if i.Next.Val == i.Val &#123; i.Next = i.Next.Next // 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123; i = i.Next不需要 &#125; else &#123; i = i.Next &#125; &#125; return head&#125;2func deleteDuplicates(head *ListNode) *ListNode &#123; current := head for current != nil &amp;&amp; current.Next != nil &#123; if current.Next.Val == current.Val &#123; // 保存下一个节点的引用 nextNode := current.Next // 删除当前节点 current.Next = nextNode.Next // 释放内存 nextNode = nil &#125; else &#123; // 非重复元素，继续遍历 current = current.Next &#125; &#125; return head&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Win】键盘下键坏了，使用组合键模拟下方向键","slug":"具/【Win】键盘下键坏了，使用组合键模拟下方向键","date":"2024-01-14T09:05:02.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2024-01-14-2aaa71f8e7be.html","link":"","permalink":"https://leiqi.top/2024-01-14-2aaa71f8e7be.html","excerpt":"","text":"使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤： 下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中： 1!s::Send &#123;Down&#125; 这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。 运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。 现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【20240106】leetcode 2807. 在链表中插入最大公约数","slug":"eetcode/【20240106】leetcode 2807. 在链表中插入最大公约数","date":"2024-01-06T15:27:26.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2024-01-06-2b3ad028343c.html","link":"","permalink":"https://leiqi.top/2024-01-06-2b3ad028343c.html","excerpt":"","text":"2807. 在链表中插入最大公约数 - 力扣（LeetCode） 最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。 计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下： 用较大的数除以较小的数，得到余数。 将较小的数作为新的被除数，余数作为新的除数。 重复步骤 1 和 2，直到余数为零。 最后的非零余数即为最大公约数。 这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。 以下是一个用 Go 语言实现的最大公约数的辗转相除法示例： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;// 辗转相除法求最大公约数func gcd(a, b int) int &#123; for b != 0 &#123; temp := b b = a % b a = temp &#125; return a&#125;func main() &#123; num1 := 48 num2 := 18 result := gcd(num1, num2) fmt.Println(&quot;最大公约数为:&quot;, result)&#125; 在这个例子中，gcd 函数使用了辗转相除法来计算两个整数的最大公约数。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LeetCode 1071. 字符串的最大公因子","slug":"eetcode/LeetCode 1071. 字符串的最大公因子","date":"2024-01-03T15:12:16.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-01-03-58e186a9065e.html","link":"","permalink":"https://leiqi.top/2024-01-03-58e186a9065e.html","excerpt":"","text":"1071. 字符串的最大公因子 解题思路： 暴力解法123456789101112131415161718192021222324252627282930313233343536373839404142func gcdOfStrings(str1 string, str2 string) string &#123; n1, n2 := len(str1), len(str2) // 从最长的可能的子串长度开始尝试 for i := min(n1, n2); i &gt; 0; i-- &#123; if n1%i == 0 &amp;&amp; n2%i == 0 &#123; commonSubstring := str1[:i] // 检查是否满足条件 if checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123; return commonSubstring &#125; &#125; &#125; return &quot;&quot;&#125;// 检查字符串是否能够整除func checkDivisible(s string, sub string) bool &#123; repeats := len(s) / len(sub) concatenated := repeatString(sub, repeats) return s == concatenated&#125;// 重复字符串func repeatString(s string, count int) string &#123; result := &quot;&quot; for i := 0; i &lt; count; i++ &#123; result += s &#125; return result&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 数学方法辗转相除法 1234567891011121314151617func gcdOfStrings(str1 string, str2 string) string &#123; if str1 + str2 != str2 + str1 &#123; return &quot;&quot; &#125; gcd := gcd(len(str1), len(str2)) return str1[0:gcd]&#125; func gcd(a, b int) int &#123; for b != 0 &#123; a, b = b, a % b &#125; return a&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows新增wsl bash here键快捷方式","slug":"具/windows新增wsl bash here键快捷方式","date":"2024-01-01T10:23:10.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2024-01-01-38178c63ba17.html","link":"","permalink":"https://leiqi.top/2024-01-01-38178c63ba17.html","excerpt":"","text":"win + R 输入regedit输入到 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 新建wsl_bash_here目录, 设置如下默认值 新建command新建项，输入wsl.exe 的地址 成功可以看到右侧是有wsl bash here的选项的在当面目录打开wsl 成功原理和添加git bash here 类似, 参考:手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git 设置免密配置-全局免密-单仓库免密-SSH免密","slug":"it/git 设置免密配置-全局免密-单仓库免密-SSH免密","date":"2024-01-01T06:56:28.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2024-01-01-91517aa963bc.html","link":"","permalink":"https://leiqi.top/2024-01-01-91517aa963bc.html","excerpt":"","text":"介绍之前我们要首先知道一个简单的概念:https通过记住账号密码免登，ssh通过校验生成的密钥免登。 通常都用ssh校验。 查看通信方式 在项目目录中运行命令： 1git remote -v 如果出现提示是： 12origin https://gitee.com/xxx/xxx.git (fetch)origin https://gitee.com/xxx/xxx.git (push) 则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址 一、https 方式及免密码配置0. 项目中 git 基本配置全局用户名密码配置 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;lei_qi@outlook.com&quot; 项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。 1234567# 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令git init# 关联远程仓库git remote add origin https://gitee.com/xxx/xxx.gitgit add -Agit commit -m &quot;初始化&quot;git push -u origin master 需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。 这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。 1.全局免密码配置配置存储模式 1git config --global credential.helper store 执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store Linux 下查看： 1vim ~/.gitconfig windows10 下当前用户路径：%USERPROFILE%内容如下： 12345[user] name = lenovo email = xxxx@outlook.com[credential] helper = store 然后在项目目录，执行git pull&#x2F;git push命令，会提示输入账号密码。这次输入账号密码之后，就会记住账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。 2、单项目免密码配置编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项： 12[remote &quot;origin&quot;]url = https://gitee.com/xxx/xxx.git 修改为： 12[remote &quot;origin&quot;] url = https://yourusername:password@gitee.com/xxx/xxxx.git 也就是在 https:// 之后，增加 用户名:密码@ 二. SSH免密登录如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式, 1git remote rm origin 前提github 网页增加本机SSH key git ssh 方式免密提交方式需要将 ssh-keygen 生成的公钥放到服务器上 全局用户名密码配置 12git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx@qq.com&quot; 项目初始化，生成 .git 目录，配置 ssh 远程项目地址。 123# 如果是新仓库需要git init ;否则不需要git init; git init# git 关联远程仓库git remote add origin git@gitee.com:xxx/xxx.git 生成公钥和私钥1、首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，检查本机的ssh密钥。 12$ cd ~/.ssh $ ls 如果提示：No such file or directory ，说明是第一次使用 git。 如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。 123$ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 2、执行生成公钥和私钥的命令，生成新的密钥： 1ssh-keygen -t rsa -C &quot;xxx&quot; 代码参数： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。 按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 执行查看公钥信息： 1cat ~/.ssh/id_rsa.pub Windows 系统，位置在用户目录下 .ssh文件夹中。%USERPROFILE% 复制公钥信息到远端仓库gitee打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。 githubSettings -SSH and GPG keys - New SSH key然后，提交时就不再需要用户名和密码了 123git add -Agit commit -m &quot;ssh免密提交&quot;git push -u origin master 参考:https://zhuanlan.zhihu.com/p/358721423","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Windows设置Clion 下方Terminal为WSL linux 子系统","slug":"具/Windows设置Clion 下方Terminal为WSL linux 子系统","date":"2023-12-30T15:49:39.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-12-30-397a0b919639.html","link":"","permalink":"https://leiqi.top/2023-12-30-397a0b919639.html","excerpt":"","text":"终端上的小箭头下的设置 找到WSL的地址 粘贴到对应地址中 设置成功这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"免费使用Jetbrain 全家桶-服务器激活码激活软件","slug":"具/免费使用Jetbrain 全家桶-服务器激活码激活软件","date":"2023-12-30T15:08:29.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-12-30-6a1e804ab992.html","link":"","permalink":"https://leiqi.top/2023-12-30-6a1e804ab992.html","excerpt":"","text":"众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品. Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。 https://search.censys.io/ 搜索：services.http.response.headers.location: account.jetbrains.com/fls-auth https://www.shodan.io 搜索：Location: https://account.jetbrains.com/fls-auth https://fofa.info/ 搜索：fls-auth 随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是https://search.censys.io/ 网站, 搜索 1services.http.response.headers.location: account.jetbrains.com/fls-auth 例如上边就是 http://111.231.22.61:1024 激活成功激活成功，请开始愉快的编码吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"WPS设置打开文件自动同步云文档","slug":"具/WPS设置打开文件自动同步云文档","date":"2023-12-30T14:08:47.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-12-30-3a73bdfdd568.html","link":"","permalink":"https://leiqi.top/2023-12-30-3a73bdfdd568.html","excerpt":"","text":"不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作： 打开首页，设置中心 打开新文件会自动上传更新","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git强制拉取远端","slug":"it/git强制拉取远端","date":"2023-10-22T09:53:57.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-10-22-9bf76366f18c.html","link":"","permalink":"https://leiqi.top/2023-10-22-9bf76366f18c.html","excerpt":"","text":"12git fetch origingit reset --hard origin/&lt;branch_name&gt; 这里的 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下： git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。 git reset –hard origin&#x2F;：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。 这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"leetcode 1726.同积元组","slug":"eetcode/leetcode 1726.同积元组","date":"2023-10-20T15:21:57.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-10-20-9599b5db4d91.html","link":"","permalink":"https://leiqi.top/2023-10-20-9599b5db4d91.html","excerpt":"","text":"Problem: 1726. 同积元组 思路 使用排列组合的方法，开始使用三种语言同时写leetcode. 解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213func tupleSameProduct(nums []int) int &#123; n := len(nums) cnt := make(map[int]int) for i := 0; i &lt; n; i++ &#123; for j := i + 1; j &lt; n; j++ &#123;// j +1 不要重复 cnt[nums[i] * nums[j]]++ // 使用map 遍历每次乘积对应次数 &#125; &#125; ans := 0 for _, v := range cnt &#123; ans += v * (v - 1) * 4 &#125; []1234567891011121314151617class Solution &#123;public: int tupleSameProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = 0; unordered_map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; cnt[nums[i] * nums[j]]++; &#125; &#125; for (auto &amp;[k, v] : cnt) &#123; ans += v * (v - 1) * 4; &#125; return ans; &#125;&#125;; []12345678910111213141516class Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = dict() for i in range(n): for j in range(i+1,n): if nums[i]*nums[j] in maps: maps[nums[i] * nums[j]] += 1 else: maps[nums[i] * nums[j]] = 1 ans = 0 for _, v in maps.items(): ans += v*(v-1) *4 return ans","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"本地运行LeetCode的Python代码 调试","slug":"ython/本地运行LeetCode的Python代码 调试","date":"2023-10-19T16:57:22.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-10-19-6057db0e071e.html","link":"","permalink":"https://leiqi.top/2023-10-19-6057db0e071e.html","excerpt":"","text":"最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦 要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类： 创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。 导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。 1from typing import List 创建Solution类并在其中定义问题的解决方案。例如： 1234567891011class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: # 实现你的解决方案 # 例如，找到两个数的和等于目标，并返回它们的索引 num_to_index = &#123;&#125; for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] 创建一个main函数来测试你的解决方案。 12345def main(): solution = Solution() # 调用Solution类的方法进行测试 result = solution.twoSum([2, 7, 11, 15], 9) print(result) 12if __name__ == &quot;__main__&quot;: main() 执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行： 1python leetcode_solution.py 这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"三种Python3 判断字典中是否存在对应key的方法","slug":"ython/三种Python3 判断字典中是否存在对应key的方法","date":"2023-10-19T16:41:07.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-10-19-8f51ae9ef5a1.html","link":"","permalink":"https://leiqi.top/2023-10-19-8f51ae9ef5a1.html","excerpt":"","text":"第一种：使用get()方法 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; 打印返回值 12print(dict.get(&#x27;name&#x27;)) # 结果返回对应valprint(dict.get(&#x27;id&#x27;)) # 结果返回None 第二种：使用keys()方法 生成一个字典dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’} 判断是否存在，其中dict.keys()是列出字典所有的key 12print(&#x27;name&#x27; in dict.keys()) # 结果返回Trueprint(&#x27;id&#x27; in dict.keys()) # 结果返回False 除了使用in也可以使用not in，用于判定这个key不存在 第三种：使用 in 关键字 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; # 判断key是否存在于dict中 12print(&#x27;name&#x27; in dict) # 结果返回Trueprint(&#x27;id&#x27; in dict) # 结果返回False 补充：生成默认字典（collections.defaultdict）使用defaultdict(int)来创建maps，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。 123456789101112131415from collections import defaultdictclass Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = defaultdict(int) ans = 0 for i in range(n): for j in range(i+1, n): product = nums[i] * nums[j] ans += maps[product] * 4 maps[product] += 1 return ans","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"数据结构和操作的对比：Python vs. Go vs. C++","slug":"eetcode/数据结构和操作的对比：Python vs. Go vs. C++","date":"2023-10-19T16:25:56.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-10-19-86483682723b.html","link":"","permalink":"https://leiqi.top/2023-10-19-86483682723b.html","excerpt":"","text":"Python示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 数组my_list = [1, 2, 3, 4]# 切片sub_list = my_list[1:3]reversed_list = my_list[::-1python]# 字典my_dict = &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;# 双向链表（使用collections.deque）from collections import dequemy_linked_list = deque()my_linked_list.append(1)my_linked_list.append(2)my_linked_list.append(3)# 最大堆和最小堆（需要使用第三方库heapq）import heapqmax_heap = []min_heap = []# 二叉树（使用类或结构体）# 字符串操作my_string = &quot;Hello, World!&quot;substring = my_string[7:12]my_int = 42my_str = str(my_int)# 深度拷贝和浅拷贝（使用copy模块）import copyoriginal_list = [1, [2, 3], 4]shallow_copy = copy.copy(original_list)deep_copy = copy.deepcopy(original_list)# 删除元素my_list.pop(1) # 删除第二个元素# 查找小写字母if my_string.islower(): print(&quot;String contains only lowercase letters&quot;)# 遍历数组for item in my_list: print(item)# 使用循环遍历字典for key, value in my_dict.items(): print(key, value)# 判断字典是否包含键if &#x27;name&#x27; in my_dict: print(&quot;Dictionary contains &#x27;name&#x27;&quot;) Go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Go示例// 数组和切片mySlice := []int&#123;1, 2, 3, 4&#125;subSlice := mySlice[1:3]reversedSlice := reverseSlice(mySlice)// 字典myMap := map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30,&#125;// 双向链表（使用container/list）import &quot;container/list&quot;myList := list.New()myList.PushBack(1)myList.PushBack(2)myList.PushBack(3)// 最大堆和最小堆（需要使用heap包）import &quot;container/heap&quot;maxHeap := &amp;MaxHeap&#123;&#125;minHeap := &amp;MinHeap&#123;&#125;// 二叉树（使用结构体或指针）// 字符串操作myString := &quot;Hello, World!&quot;substring := myString[7:12]myInt := 42myStr := fmt.Sprintf(&quot;%d&quot;, myInt)// 深度拷贝和浅拷贝（使用复制切片或递归）originalSlice := []int&#123;1, 2, 3, 4&#125;shallowCopy := make([]int, len(originalSlice))copy(shallowCopy, originalSlice)deepCopy := append([]int(nil), originalSlice...)// 删除元素index := 1mySlice = append(mySlice[:index], mySlice[index+1:]...)// 查找小写字母containsLowercase := falsefor _, char := range myString &#123; if unicode.IsLower(char) &#123; containsLowercase = true break &#125;&#125;// 遍历切片for _, item := range mySlice &#123; fmt.Println(item)&#125;// 使用循环遍历字典for key, value := range myMap &#123; fmt.Println(key, value)&#125;// 判断字典是否包含键if _, exists := myMap[&quot;name&quot;]; exists &#123; fmt.Println(&quot;Map contains &#x27;name&#x27;&quot;)&#125; C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// C++示例// 数组和向量#include &lt;vector&gt;std::vector&lt;int&gt; myVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; subVector(myVector.begin() + 1, myVector.begin() + 3);std::vector&lt;int&gt; reversedVector(myVector.rbegin(), myVector.rend());// 字典（使用std::map）#include &lt;map&gt;std::map&lt;std::string, int&gt; myMap;myMap[&quot;name&quot;] = &quot;Alice&quot;;myMap[&quot;age&quot;] = 30;// 双向链表（使用std::list）#include &lt;list&gt;std::list&lt;int&gt; myList;myList.push_back(1);myList.push_back(2);myList.push_back(3);// 最大堆和最小堆（使用std::priority_queue）#include &lt;queue&gt;std::priority_queue&lt;int&gt; maxHeap;std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;// 二叉树（使用结构体或指针）// 字符串操作std::string myString = &quot;Hello, World!&quot;;std::string substring = myString.substr(7, 5);int myInt = 42;std::string myStr = std::to_string(myInt);// 深度拷贝和浅拷贝std::vector&lt;int&gt; originalVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; shallowCopy = originalVector;std::vector&lt;int&gt; deepCopy(originalVector);// 删除元素int index = 1;myVector.erase(myVector.begin() + index);// 查找小写字母bool containsLowercase = false;for (char c : myString) &#123; if (std::islower(c)) &#123; containsLowercase = true; break; &#125;&#125;// 遍历向量for (int item : myVector) &#123; std::cout &lt;&lt; item &lt;&lt; std::endl;&#125;// 使用循环遍历字典for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;// 判断字典是否包含键if (myMap.find(&quot;name&quot;) != myMap.end()) &#123; std::cout &lt;&lt; &quot;Map contains &#x27;name&#x27;&quot; &lt;&lt; std::endl;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 136.只出现一次的数字","slug":"eetcode/Leetcode 136.只出现一次的数字","date":"2023-10-16T15:23:24.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-10-16-66afbe22520d.html","link":"","permalink":"https://leiqi.top/2023-10-16-66afbe22520d.html","excerpt":"","text":"Problem: 136. 只出现一次的数字[TOC] 思路 如何才能做到线性时间复杂度和常数空间复杂度呢？ 答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。 任何数和 0做异或运算，结果仍然是原来的数任何数和其自身做异或运算，结果是 0 解题方法 描述你的解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code hash []1234567891011121314func singleNumber(nums []int) int &#123; numsMap := make(map[int]int) for _, val := range nums &#123; numsMap[val] += 1 &#125; for key, val := range numsMap &#123; if val == 1 &#123; return key &#125; &#125; return 0&#125; 位运算 []123456789func singleNumber(nums []int) int &#123; single := 0 for _, num := range nums &#123; single ^= num &#125; return single&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 155.最小栈","slug":"eetcode/leetcode 155.最小栈","date":"2023-10-12T16:07:58.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-10-12-cfa4d16bfad5.html","link":"","permalink":"https://leiqi.top/2023-10-12-cfa4d16bfad5.html","excerpt":"","text":"Problem: 155. 最小栈 思路 栈 解题方法 描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213141516171819202122232425262728293031323334353637383940// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好type MinStack struct &#123; stack []int // 主栈 minStack []int // 辅助栈&#125;func Constructor() MinStack &#123; minStacks := MinStack&#123;[]int&#123;&#125;, []int&#123;math.MaxInt&#125;&#125; return minStacks&#125;func (this *MinStack) Push(x int) &#123; // 同时比较辅助站的的top元素，如果更小 则添加到辅助站 this.stack = append(this.stack, x) minTmp := min(x, this.minStack[len(this.minStack)-1]) this.minStack = append(this.minStack, minTmp)&#125;func (this *MinStack) Pop() &#123; this.stack = this.stack[:len(this.stack)-1] this.minStack = this.minStack[:len(this.minStack)-1]&#125;func (this *MinStack) Top() int &#123; return (this.stack[len(this.stack)-1])&#125;func (this *MinStack) GetMin() int &#123; return (this.minStack[len(this.minStack)-1])&#125;func min(x, y int) int &#123; if x &lt; y &#123; return x &#125; return y&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"使用 Go 的 container list 包：双向链表的便捷工具","slug":"eetcode/使用 Go 的 container list 包：双向链表的便捷工具","date":"2023-10-09T16:44:33.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2023-10-09-5ecfb18fa495.html","link":"","permalink":"https://leiqi.top/2023-10-09-5ecfb18fa495.html","excerpt":"","text":"Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。 基本概念在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。 导入 container&#x2F;list 包要使用 container&#x2F;list 包，首先需要导入它： 1import &quot;container/list&quot; 创建链表创建一个新的链表非常简单： 1myList := list.New() 这将创建一个名为 myList 的新链表。 插入元素你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头： 12myList.PushBack(42)myList.PushFront(23) 访问元素要访问链表中的元素，你可以使用 Front 和 Back 方法： 12firstElement := myList.Front().ValuelastElement := myList.Back().Value 遍历链表遍历链表可以使用 for 循环来实现： 123for element := myList.Front(); element != nil; element = element.Next() &#123; // 处理 element.Value&#125; 删除元素要删除链表中的元素，可以使用 Remove 方法： 12elementToRemove := myList.Front()myList.Remove(elementToRemove) 容易混淆的地方1. 类型断言链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如： 1value := element.Value.(int) 如果断言失败，会导致运行时错误。 2. InsertAfter 和 InsertBefore这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。 示例：浏览器历史记录下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。 结论container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845. 座位预约管理系统","slug":"eetcode/leetcode 1845. 座位预约管理系统","date":"2023-10-06T04:09:42.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-10-06-c2afb6383992.html","link":"","permalink":"https://leiqi.top/2023-10-06-c2afb6383992.html","excerpt":"","text":"Problem: 1845. 座位预约管理系统 个人博客,记录学习: https://leiqicn.gitee.io/ [TOC] 思路 座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存. 解题方法 使用slice 的index来表示座位号,1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n; 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code使用slice []12345678910111213141516171819202122232425262728293031323334 type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125;使用mapmap 有个用例会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type SeatManager struct &#123; seatMap map[int]int minSeat int&#125;func Constructor(n int) SeatManager &#123; seatMap := make(map[int]int, n+1) for i := 0; i &lt;= n; i++ &#123; // 注意从0 开始初始化 seatMap[i] = 0 &#125; seatMan := SeatManager&#123; seatMap, 1, &#125; return seatMan&#125;func (this *SeatManager) Reserve() int &#123; value := this.minSeat this.seatMap[value] = 1 for i:= value; i &lt;= len(this.seatMap);i++ &#123; if this.seatMap[i] == 1 &#123; continue &#125; this.minSeat = i break &#125; return value&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seatMap[seatNumber] = 0 if seatNumber &lt; this.minSeat &#123; this.minSeat = seatNumber &#125;&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 中是否使用make创建slice的区别","slug":"olang/Go 中是否使用make创建slice的区别","date":"2023-10-05T09:01:37.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-10-05-9d3185fd2258.html","link":"","permalink":"https://leiqi.top/2023-10-05-9d3185fd2258.html","excerpt":"","text":"go slice 的make 会创建默认长度 且值为0 的slice 在 Go 语言中，可以使用 make 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 make 和不使用 make 创建切片的主要区别： 使用 make 创建切片： 12// 使用 make 创建切片，指定长度和容量 slice := make([]int, 5, 10) 指定长度和容量： 使用 make 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。 底层数组初始化： 使用 make 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，slice 是一个包含5个零值整数的切片。 不使用 make 创建切片： 12// 不使用 make 创建切片，长度为 5 slice := []int&#123;1, 2, 3, 4, 5&#125; &#96; 自动确定长度： 不使用 make 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，slice 的长度是5，因为提供了5个整数。 容量与长度相同： 如果不使用 make 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。 总结： 使用 make 创建切片时，您可以明确控制切片的容量，并按长度初始化为0值，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。 不使用 make 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。 无论使用哪种方式创建切片，都可以使用 append 函数来动态增长切片的长度。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"JetBrians 全家桶设置文件header","slug":"具/JetBrians 全家桶设置文件header","date":"2023-10-05T08:41:46.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-10-05-7527c8e47a8b.html","link":"","permalink":"https://leiqi.top/2023-10-05-7527c8e47a8b.html","excerpt":"","text":"前言我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。 先看下效果图 操作步骤1. file- settings 找到Copyright - CopyrightProfiles点击+ 号，新建一个name 为“copyRight” 的profile profile 的内容粘贴下面的问文本, 替换自己的名字 1234Copyright (c) $originalComment.match(&quot;Copyright \\(c\\) (\\d+)&quot;, 1, &quot;-&quot;, &quot;$today.year&quot;)$today.year YOUR NAME. All rights reserved. Author: YOUR NAME Description: Date: $today 点击Copyright 添加刚才的profile 点击应用即可 右键-generate-Copyright 插入","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Leetcode1603. 设计停车系统","slug":"eetcode/Leetcode 1603. 设计停车系统","date":"2023-09-26T17:09:22.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-09-26-aeddfdb3bdac.html","link":"","permalink":"https://leiqi.top/2023-09-26-aeddfdb3bdac.html","excerpt":"","text":"Problem: 1603. 设计停车系统 [TOC] 思路 首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。 虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。 解题方法 lastCar [3]int 添加上边的数组 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code []12345678910111213141516171819202122232425262728293031 type ParkingSystem struct &#123; lastCar [3]int&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; var parkingSystem ParkingSystem parkingSystem.lastCar[0] = big parkingSystem.lastCar[1] = medium parkingSystem.lastCar[2] = small return parkingSystem&#125;func (this *ParkingSystem) AddCar(carType int) bool &#123; carIdx := carType - 1 if this.lastCar[carIdx] &gt; 0 &#123; this.lastCar[carIdx]-- return true &#125; return false&#125;/** * Your ParkingSystem object will be instantiated and called as such: * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver） * param_1 := obj.AddCar(carType); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Linux非root用户通过X11运行图形界面程序-以Rstudio为例","slug":"具/Linux非root用户通过X11运行图形界面程序-以Rstudio为例","date":"2023-09-24T12:36:53.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-09-24-4fe5badbd053.html","link":"","permalink":"https://leiqi.top/2023-09-24-4fe5badbd053.html","excerpt":"","text":"问题由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！ X11是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。 操作步骤 使用mobaxTerm 登录对应服务器，需要显示X11 打开 创建虚拟环境1234567# 创建虚拟环境 conda create -n rstudio# 安装Ｒconda activate rstudio # 进入创建好的环境变量conda install r-base# 安装Rstudioconda install rstudio-desktop 成功 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面 画个图试试，顺利出图！开始愉快的coding吧！ 已知问题： 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。 总结我们可以通过X11来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 将用户追加到对应用户组","slug":"inux/Linux 将用户追加到对应用户组,新建文件默认同组读写权限","date":"2023-09-17T06:02:54.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-09-17-5141f57450ab.html","link":"","permalink":"https://leiqi.top/2023-09-17-5141f57450ab.html","excerpt":"","text":"前言本文目的是为了将多个用户设置同组用户，并且同组内用户新建文件的默认权限是同组内用户可读写。 解决方案 将test 添加到GroupA 1234usermod -a -G GroupName UserName# 例如将test 追加到GroupAusermod -a -G GroupA test 修改新建文件的默认权限 在.bashrc 里添加 1umask 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--) 1source ~/.bashrc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[]},{"title":"C++ 结构化设计","slug":"++/C++ 结构化设计","date":"2023-09-13T15:21:57.000Z","updated":"2025-06-16T15:02:16.966Z","comments":true,"path":"2023-09-13-476441b87811.html","link":"","permalink":"https://leiqi.top/2023-09-13-476441b87811.html","excerpt":"","text":"结构化程序设计自顶向下的设计 是自顶向下的分解 -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题 实现阶段自顶向上的实现，实现一个一个子问题 程序由三种基本结构组成，顺序-分支-循环 例子","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"clash在终端设置代理","slug":"具/clash在终端设置代理","date":"2023-09-12T15:38:32.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-09-12-b926f621cf15.html","link":"","permalink":"https://leiqi.top/2023-09-12-b926f621cf15.html","excerpt":"","text":"前言github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！ 开启代理前置条件：手动开打 clash 等VPN软件 12export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890 对应的网址是在settings- static-Host; 对应port 为General-Prot clash Verge复制环境变量 去github 执行 12export https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7897 all_proxy=socks5://127.0.0.1:7897 取消代理12unset http_proxyunset http_proxy git 里设置开启代理 alias 命令别名新建 .bashrc123456789101112131415161718cd ~vi .bashrc# 将以下内容复制进去# .bashrc# Source global definitionsif [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrcfi# Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:# export SYSTEMD_PAGER=# User specific aliases and functions# 别名设置，其他别名设置也是类似alias proxyon=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;alias proxyoff=&quot;unset http_proxy;unset https_proxy&quot; 测试是否成功可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 2594修车的最少时间","slug":"eetcode/leetcode 2594修车的最少时间","date":"2023-09-07T15:59:00.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-09-07-b8c038c07b41.html","link":"","permalink":"https://leiqi.top/2023-09-07-b8c038c07b41.html","excerpt":"","text":"2594. 修车的最少时间 - 力扣（LeetCode） 思路能力值为 r 的机械工可以在 t&#x3D; r * n2 分钟内修好 n 辆车。可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。 12345678910111213141516171819202122func repairCars(ranks []int, cars int) int64 &#123; l , r := 1, ranks[0] * cars * cars var check = func(m int) bool &#123; cnt := 0 for _, x := range ranks &#123; cnt += int(math.Sqrt(float64(m / x))) &#125; return cnt &gt;= cars &#125; for l &lt; r &#123; m := (l + r) &gt;&gt; 1 if check(m) &#123; r = m &#125; else &#123; l = m + 1 &#125; &#125; return int64(l)&#125; l 和 r 的初始化： l 初始化为1，表示最小可能的修理时间。 r 初始化为 ranks[0] * cars * cars，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。 check 函数定义： 这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 m 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 m 时间内能修理多少辆车，然后累加到 cnt 变量中。 如果 cnt 大于或等于需要修理的汽车数量 cars，则返回 true，否则返回 false。 二分查找循环： 使用一个二分查找循环来查找最小的修理时间。循环条件是 l &lt; r，即当最小时间小于最大时间时，继续循环。 在每次循环中，计算中间值 m，并调用 check(m) 检查是否满足修理所有汽车的条件。 如果满足条件，则将 r 更新为 m，因为我们希望找到更小的修理时间。 如果不满足条件，则将 l 更新为 m + 1，因为我们需要增加修理时间。 这样，不断地缩小时间范围，直到找到最小的修理时间。 最终返回结果： 一旦 l 不再小于 r，循环结束，说明已经找到了最小的修理时间，将其转换为 int64 类型并返回。 我们总结一下二分查找适用的场景 二分查找算法适用场景递增或递减规律：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。 有序数据集合：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。 快速查找：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。 确定性问题：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。 时间复杂度要求较高：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。 可比较性数据：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。 搜索范围可确定：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。 内存连续性：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。 一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"设计模式-抽象工厂","slug":"计模式/设计模式-抽象工厂","date":"2023-09-03T12:39:19.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2023-09-03-c6ab66461699.html","link":"","permalink":"https://leiqi.top/2023-09-03-c6ab66461699.html","excerpt":"","text":"抽象工厂模式结构多个工厂模式; 有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式-工厂方法模式","slug":"计模式/设计模式-工厂方法模式","date":"2023-09-03T05:09:25.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2023-09-03-c58ee0dac51b.html","link":"","permalink":"https://leiqi.top/2023-09-03-c58ee0dac51b.html","excerpt":"","text":"网站链接：工厂方法设计模式 (refactoringguru.cn) 简介工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。 简单工厂‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间. 工厂方法模式结构不同的类实现相同的动作,例如运输等 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 具体产品 （Concrete Products） 是产品接口的不同实现。 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。 注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 伪代码基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。 如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。 如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。 你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 简单工厂和工厂模式的区别1. 简单工厂设计模式（Simple Factory Design Pattern）： 定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。2. 工厂方法设计模式（Factory Method Design Pattern）： 定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。结构： 工厂方法模式包括抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。主要区别： 复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。 责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。 扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。 灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。 选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。 UML类图如何看看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。” 接口: ‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口. 类和类之间的关系: 继承的关系，继承关系用空心三角形+实线来表示 聚合: 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。 合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。 依赖","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"leetcode 2511 最多可以摧毁的敌人城堡数目","slug":"eetcode/leetcode 2511 最多可以摧毁的敌人城堡数目","date":"2023-09-02T12:51:41.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-09-02-72954cc13c19.html","link":"","permalink":"https://leiqi.top/2023-09-02-72954cc13c19.html","excerpt":"","text":"2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode） 思路抽象出来就是求1和-1间最大连续0 的数量。 有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？ 1.当然可以分类讨论，代码会很复杂，判断很多，容易出错 使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res 12345678910111213141516171819202122232425262728293031323334353637383940func captureForts(forts []int) int &#123; ans, pre := 0, -1 //pre 记录的是 1 或 -1 的位置 for i, fort := range forts &#123; if fort == -1 || fort == 1 &#123; if pre &gt;= 0 &amp;&amp; forts[pre] != fort &#123; ans = max(ans, i - pre - 1) &#125; pre = i &#125; &#125; return ans&#125; func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LRU","slug":"eetcode/LRU","date":"2023-08-07T15:29:00.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-08-07-e74632bdccbf.html","link":"","permalink":"https://leiqi.top/2023-08-07-e74632bdccbf.html","excerpt":"","text":"146. LRU 缓存 - 力扣（LeetCode） list Elemet 双向列表； 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &quot;container/list&quot;type LRUCache struct &#123; cap int // 缓存容量 cache map[int]*list.Element//!!! 双向链表 使用Element // 双向链表节点 指向的map list *list.List // 双向链表&#125;type keyVal struct &#123; key, val int // 节点的Key和Value&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cap: capacity, // 初始化缓存容量 cache: make(map[int]*list.Element), // 初始化map映射 list: list.New(), // 初始化双向链表 &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 return elem.Value.(*keyVal).val // 返回节点的value值 &#125; return -1 // 没有找到的情况下，返回-1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 //!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值； elem.Value.(*keyVal).val = value // 更新节点的value值 return &#125; if this.list.Len() &gt;= this.cap &#123; // 如果超过了缓存容量 tail := this.list.Back() // 获取链表的尾节点 k := tail.Value.(*keyVal).key // 获取节点的key this.list.Remove(tail) // 从链表中删除尾节点 delete(this.cache, k) // 从map中删除尾节点 &#125; elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) // 将节点添加到链表头 this.cache[key] = elem // 将节点映射到map中&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 最大深度和最小深度","slug":"eetcode/leetcode 最大深度和最小深度","date":"2023-07-29T15:46:22.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2023-07-29-4df215f63090.html","link":"","permalink":"https://leiqi.top/2023-07-29-4df215f63090.html","excerpt":"","text":"题目104. 二叉树的最大深度 - 力扣（LeetCode） 111. 二叉树的最小深度 - 力扣（LeetCode） 思路深度 是指从根节点到该节点的距离（节点数量）高度 是指从该节点到叶子节点的角力（节点数量） 最大深度 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)最小子树 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现： 最大深度递归分治后序遍历 需要调用自生函数，需要严格按照定义调用递归。 1234567891011121314151617// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := maxDepth(root.Right) leftMaxDepth := maxDepth(root.Left) return 1 + max(rightMaxDepth,leftMaxDepth)&#125;func max(a,b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 迭代 层序遍历1234567891011121314151617181920212223242526// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 最小深度递归后序遍历 12345678910111213141516171819202122232425262728293031// 定义：输入根节点，返回这棵二叉树的最小深度func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := minDepth(root.Right) leftMaxDepth := minDepth(root.Left) // 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论 if root.Right == nil &amp;&amp; root.Left !=nil &#123; return 1 + leftMaxDepth // 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。 &#125; if root.Left == nil &amp;&amp; root.Right !=nil &#123; return 1 + rightMaxDepth &#125; return 1 + min(rightMaxDepth,leftMaxDepth)&#125; func min(a,b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 迭代 层序遍历123456789101112131415161718192021222324252627282930func minDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; if top.Right == nil &amp;&amp; top.Left == nil &#123; return depth + 1 // 当前节点也算哦 &#125; &#125; depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go语言中的byte类型与Unicode码点与整数的转换","slug":"eetcode/Go语言中的byte类型与Unicode码点与整数的转换","date":"2023-07-09T14:22:16.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-07-09-dda1c4b9508f.html","link":"","permalink":"https://leiqi.top/2023-07-09-dda1c4b9508f.html","excerpt":"","text":"byte类型与Unicode码点的转换在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。 当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; b := byte(&#x27;A&#x27;) i := int(b) fmt.Printf(&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\\n&quot;, b, b, i)&#125; 在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下： 1Byte: A, Unicode码点: 65, 转换后的整数: 65 可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。 byte类型与整数的转换之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。 123456789101112package main import ( &quot;fmt&quot; ) func main() &#123; ch := &#x27;0&#x27; num := int(ch - &#x27;0&#x27;) fmt.Printf(&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\\n&quot;, ch, ch, num) &#125; 在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下： 1字符: 0, unicode码点或者byte对应的数值: 48, 转换后的整数: 0 可以看到，字符 ‘0’ 成功转换为整数 0。其中需要注意的是：在Go语言中，格式化输出时 %c 是一个占位符，用于表示要输出的值是一个Unicode字符。具体来说，%c 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48 这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。 总结byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Mesh组网：家庭路由和无线连接新方式","slug":"络/Mesh组网：家庭路由和无线连接新方式","date":"2023-06-25T14:24:32.000Z","updated":"2025-06-16T15:02:16.976Z","comments":true,"path":"2023-06-25-a45e5f4edabc.html","link":"","permalink":"https://leiqi.top/2023-06-25-a45e5f4edabc.html","excerpt":"","text":"在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。 what Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。 how Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释： 设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。 路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。 中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。 自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。 why 为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择： 扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。 提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。 可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。 鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。 应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。 与桥接路由对比 Mesh组网： 概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。 特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。 优点： 扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。 鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。 简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。 缺点： 延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。 多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。 网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。 桥接路由： 概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。 特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。 优点： 低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。 单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。 集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。 缺点： 单点故障：中央路由器的故障可能导致整个网络失去连接。 限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。 扩展性：增加节点时，可能需要重新配置和调整网络结构。 结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"链表总结","slug":"eetcode/链表总结","date":"2023-06-24T16:15:32.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-06-24-42b41b131ba0.html","link":"","permalink":"https://leiqi.top/2023-06-24-42b41b131ba0.html","excerpt":"","text":"链表的合并 虚拟头节点 拉拉链 1234567891011121314151617181920212223242526272829303132func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy p1 := l1 p2 := l2 for p1 != nil &amp;&amp; p2 != nil &#123; // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if p1.Val &gt; p2.Val &#123; p.Next = p2 p2 = p2.Next &#125; else &#123; p.Next = p1 p1 = p1.Next &#125; // p 指针不断前进 p = p.Next &#125; if p1 != nil &#123; p.Next = p1 &#125; if p2 != nil &#123; p.Next = p2 &#125; return dummy.Next&#125; 链表的拆分 初始化两个链表，分别添加 合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next 合并 12345678910111213141516171819202122232425262728293031func partition(head *ListNode, x int) *ListNode &#123; // 存放小于 x 的链表的虚拟头结点 dummy1 := &amp;ListNode&#123;-1, nil&#125; // 存放大于等于 x 的链表的虚拟头结点 dummy2 := &amp;ListNode&#123;-1, nil&#125; // p1, p2 指针负责生成结果链表 p1, p2 := dummy1, dummy2 // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 p := head for p != nil &#123; if p.Val &gt;= x &#123; p2.Next = p p2 = p2.Next &#125; else &#123; p1.Next = p p1 = p1.Next &#125; // 断开原链表中的每个节点的 next 指针 temp := p.Next p.Next = nil p = temp &#125; // 连接两个链表 p1.Next = dummy2.Next return dummy1.Next&#125; k 链表合并 最小堆 go语言的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162type ListNode struct &#123; Val int Next *ListNode&#125;func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy // 优先级队列，最小堆 pq := make(PriorityQueue, 0) heap.Init(&amp;pq) // 将 k 个链表的头结点加入最小堆 for _, head := range lists &#123; if head != nil &#123; heap.Push(&amp;pq, head) &#125; &#125; for pq.Len() &gt; 0 &#123; // 获取最小节点，接到结果链表中 node := heap.Pop(&amp;pq).(*ListNode) p.Next = node if node.Next != nil &#123; heap.Push(&amp;pq, node.Next) &#125; // p 指针不断前进 p = p.Next &#125; return dummy.Next&#125;type PriorityQueue []*ListNodefunc (pq PriorityQueue) Len() int &#123; return len(pq)&#125;func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].Val &lt; pq[j].Val&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i]&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; node := x.(*ListNode) *pq = append(*pq, node)&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) node := old[n-1] *pq = old[0 : n-1] return node&#125; 倒数K链表 n 是包含nil 的 一个fast 去探路，先走k步 slow 和fast 一起走 当fast为nil 时，到达k ,赋值为next.next 即可 1234567891011121314151617181920212223242526272829// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.Next = x.Next.Next return dummy.Next&#125; // 返回链表的倒数第 k 个节点func findFromEnd(head *ListNode, k int) *ListNode &#123; p1 := head // p1 先走 k 步 for i := 0; i &lt; k; i++ &#123; p1 = p1.Next &#125; p2 := head // p1 和 p2 同时走 n - k 步 for p1 != nil &#123; p1 = p1.Next p2 = p2.Next &#125; // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2&#125; 倒数K链表移除复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可 1234567891011121314// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.next = x.next.next return dummy.next&#125; func findFromEnd(head *ListNode, k int) *ListNode &#123; // 代码见上文&#125; 移除中间链表876. 链表的中间结点 - 力扣（LeetCode） slow 走一步，fast走两步 fast nil，slow 为中间每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 1234567891011121314func middleNode(head *ListNode) *ListNode &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 // for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步 for fast!= nil &amp;&amp; fast.Next != nil&#123; // 应该修改为这个，slow 会停在中点右边第二个部分 // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next &#125; // 慢指针指向中点 return slow&#125; 判断链表是否成环 slow 走一步，fast走两步 fast 和slow 相遇则成环，fast 遇到nil 则不成环。 1234567891011121314151617func hasCycle(head *ListNode) bool &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 for fast != nil &amp;&amp; fast.Next != nil &#123; // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，说明含有环 if slow == fast &#123; return true &#125; &#125; // 不包含环 return false&#125; labuladong","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"数组双指针刷题总结","slug":"eetcode/数组双指针刷题总结","date":"2023-06-22T14:01:13.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-06-22-079d0af75447.html","link":"","permalink":"https://leiqi.top/2023-06-22-079d0af75447.html","excerpt":"","text":"双指针技巧分为快慢指针和左右指针 快慢指针 原地修改数组 遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++ 去除有序数组&#x2F;链表中去重 和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast] 左右指针1.二分查找 * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界2.N sum 之和 * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大3.反转字符串 * 终止条件是i&gt;j4.回文串判断 * 判断条件s[i] &#x3D;&#x3D; s[j]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1170. 比较字符串最小字母出现频次","slug":"eetcode/leetcode 1170. 比较字符串最小字母出现频次","date":"2023-06-14T15:28:09.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-06-14-88f65f0a1bb7.html","link":"","permalink":"https://leiqi.top/2023-06-14-88f65f0a1bb7.html","excerpt":"","text":"1170. 比较字符串最小字母出现频次 - 力扣（Leetcode） 后缀和（Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。 具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。 在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。 不使用后缀和1234567891011121314151617181920212223242526272829303132func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量 for _, s := range words &#123; count[f(s)] += 1 &#125; res := make([]int, len(queries)) for i, s := range queries &#123; for idx, c := range count &#123; // 遍历count if c&gt;0 &amp;&amp; f(s) &lt; idx &#123;// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c res[i]+=c &#125; &#125; &#125; return res&#125; 使用后缀和12345678910111213141516171819202122232425262728293031func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 for _, s := range words &#123; count[f(s)] += 1 &#125; // 计算后缀和,i+1 就是大于i位置的所有个数 for i := 9; i &gt;= 1; i-- &#123; count[i] += count[i + 1] &#125; res := make([]int, len(queries)) for i, s := range queries &#123; res[i] = count[f(s) + 1] &#125; return res&#125; 为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？ 在numSmallerByFrequency函数中， count数组记录的是各个不同频次出现的次数，因此 count[i]代表所有最小字母出现频次不于 i 的字符串的数量。 如果对于 queries 中的某个字符串 s ，它的最小字母出现频次为 f(s)，那么可以依据 count 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 f(s)+1 开始的所有频次出现次数即可： res[i] = count[f(s) + 1] 这里使用的是 f(s)+1 而不是 f(s) 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"什么是二进制的按位或和按位异或","slug":"olang/什么是二进制的按位或和按位异或","date":"2023-06-08T15:59:19.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-06-08-3d1c210a715f.html","link":"","permalink":"https://leiqi.top/2023-06-08-3d1c210a715f.html","excerpt":"","text":"按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！ 按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下 123456input bit a | input bit b | output ------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 1 例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111): 12345 110| 011----- 111 按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下： 1234567input bit a | input bit b | output------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 0 12345 110^ 011----- 101 总结按位或，就是只要有1 就为1 (包含了1 1 ；0 1；1 0；三种)按位异或，必须一个0一个1，才为1 （包含0 1；1 0；两种）大家记住了吗？","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 2460.对数组执行操作 2023.05.06每日一题","slug":"eetcode/leetcode 2460.对数组执行操作 2023.05.06每日一题","date":"2023-06-05T14:46:05.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-06-05-869070f8049d.html","link":"","permalink":"https://leiqi.top/2023-06-05-869070f8049d.html","excerpt":"","text":"2460. 对数组执行操作 - 力扣（Leetcode） 思路直接模拟 Code第一版时间复杂度：O(n)空间复杂度：O(n) 123456789101112131415161718192021func applyOperations(nums []int) []int &#123; var res []int res = make([]int, len(nums)) index := 0 // 第一次遍历 进行赋值操作 for i := 0; i &lt; len(nums)-1; i++ &#123; if nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i+1] = 0 &#125; &#125; // 第二次遍历 将非0移动到前边 for i := 0; i &lt; len(nums); i++ &#123; if nums[i] != 0 &#123; res[index] = nums[i] index++ &#125; &#125; return res&#125; 第二版时间复杂度：O(n)空间复杂度：O(1) 12345678910111213141516func applyOperations(nums []int) []int &#123; n := len(nums) j := 0 for i := 0; i &lt; n; i++ &#123; if i+1 &lt; n &amp;&amp; nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i + 1] = 0 &#125; if nums[i] != 0 &#123; nums[i], nums[j] = nums[j], nums[i] j++ &#125; &#125; return nums&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 28.找出字符串中第一个匹配项的下标","slug":"eetcode/leetcode 28.找出字符串中第一个匹配项的下标","date":"2023-05-31T14:27:00.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-31-396a1cd3c61e.html","link":"","permalink":"https://leiqi.top/2023-05-31-396a1cd3c61e.html","excerpt":"","text":"28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode） 简单解法利用split 函数，判断是否能够拆分，如果 12345678910111213func strStr(haystack string, needle string) int &#123; // 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片 splitList := strings.Split(haystack, needle) // 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1 if len(splitList)== 1 &amp;&amp; needle!=haystack &#123; return -1 &#125; if len(splitList) &gt; 1 &#123; return len(splitList[0]) &#125; // needle 在haystack的最开头，返回0 return 0&#125; 123456789101112 func main() &#123; haystack := &quot;good&quot; needle := &quot;go&quot; splitList := strings.Split(haystack, needle) // 如果在首位相同，前边会有个空字符串。 fmt.Println(splitList, len(splitList)) fmt.Println(&quot;tmp:&quot;, splitList[0]) &#125;// [&quot;&quot; &quot;od&quot;] 2 双指针解法朴素解法直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配： 匹配成功：返回本次匹配的原串「发起点」。匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。 12345678910111213141516171819202122func strStr(haystack string, needle string) int &#123; cur := 0 for cur &lt; len(haystack) &#123; p1 := cur p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return cur &#125; cur++ &#125; return -1&#125; 可以修改为for 循环 1234567891011121314151617181920212223func strStr(haystack string, needle string) int &#123; if len(haystack) &lt; len(needle) &#123; return -1 &#125; for i:= 0; i &lt; len(haystack); i++ &#123; p1 := i p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return i &#125; &#125; return -1&#125; TODO KMP 算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 104.二叉树的深度","slug":"eetcode/leetcode 104.二叉树的深度","date":"2023-05-30T15:33:48.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-05-30-b1879d2b65d1.html","link":"","permalink":"https://leiqi.top/2023-05-30-b1879d2b65d1.html","excerpt":"","text":"个人网站：https://leiqicn.gitee.io/categories/leetcode/104. 二叉树的最大深度 - 力扣（Leetcode） 二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。 所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。 递归123456789101112131415func max (a, b int) int &#123; if a &gt; b &#123; return a; &#125; return b;&#125;// 递归func maxdepth(root *treenode) int &#123; if root == nil &#123; return 0; &#125; return max(maxdepth(root.left), maxdepth(root.right)) + 1;&#125; 迭代法可以使用模板层序遍历 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */import &quot;container/list&quot;func maxDepth(root *TreeNode) int &#123; depth := 0 if root == nil &#123; return 0 &#125; queue := list.New() queue.PushBack(root) for queue.Len() &gt; 0 &#123; size := queue.Len() for i := 0; i &lt; size; i++ &#123; // 切掉第一个元素 first := queue.Remove(queue.Front()).(*TreeNode) //注意层序遍历是切掉前边一个 if first.Left != nil &#123; queue.PushBack(first.Left) &#125; if first.Right != nil &#123; queue.PushBack(first.Right) &#125; &#125; depth++ &#125; return depth&#125; 切片实现12345678910111213141516171819202122232425262728// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 使用一个临时切片来存储当前层所有节点的子节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; // 使用切片实现队列 var queue []*TreeNode queue = append(queue, root) depth := 0 for len(queue) &gt; 0 &#123; // 当前层的节点数量 size := len(queue) // 使用一个临时切片来存储当前层所有节点的子节点 var nextLevel []*TreeNode for i := 0; i &lt; size; i++ &#123; // 从队列头部移除节点 node := queue[0] queue = queue[1:] // 移除队列的第一个元素 // 将左子树和右子树添加到下一层的队列 if node.Left != nil &#123; nextLevel = append(nextLevel, node.Left) &#125; if node.Right != nil &#123; nextLevel = append(nextLevel, node.Right) &#125; &#125; // 将下一层的节点赋值给当前层的队列 queue = nextLevel // 每次循环处理一层的节点 depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"leetcode 122买动态股票的最佳时机II","slug":"eetcode/leetcode 122买动态股票的最佳时机II","date":"2023-05-27T15:51:57.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-27-5cebfed1675b.html","link":"","permalink":"https://leiqi.top/2023-05-27-5cebfed1675b.html","excerpt":"","text":"122. 买卖股票的最佳时机 II - 力扣（Leetcode） 每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。 相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。 下面是代码解释： 首先定义变量 sum 记录当前总利润。然后从第二个价格开始遍历，计算当日价格与前一天价格之差。如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。最后返回累计的总利润。这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1091.二进制矩阵中的最短路径","slug":"eetcode/leetcode 1091.二进制矩阵中的最短路径","date":"2023-05-26T15:35:54.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-26-5abcbf266873.html","link":"","permalink":"https://leiqi.top/2023-05-26-5abcbf266873.html","excerpt":"","text":"1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）DFS 超时版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type point struct &#123; x int y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; n := len(grid) if grid[0][0] == 1 || grid[n-1][n-1] == 1 &#123; return -1 &#125; res := 0 dirs := [][]int&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125; var help func(i, j, tmp int) help = func(i, j, tmp int) &#123; // 判断是否越界或已经访问过当前节点 if i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n || grid[i][j] == 1 &#123; return &#125; if i == n-1 &amp;&amp; j == n-1 &#123; // 当到达终点时，更新res if tmp+1 &lt; res || res == 0 &#123; res = tmp + 1 &#125; return &#125; // 将当前点标记为已访问 grid[i][j] = 1 tmp++ for _, item := range dirs &#123; x := i + item[0] y := j + item[1] help(x, y, tmp) &#125; // 回溯操作，将当前点复原为未访问状态 grid[i][j] = 0 &#125; help(0, 0, 0) if res == 0 &#123; return -1 &#125; return res&#125; BFS，最短路径使用BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type point struct &#123; x,y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; // queue 维护 m,n := len(grid),len(grid[0]) visited := make(map[point]int) queue := make([]point,0) step := 1 start := point&#123;0,0&#125; end := point&#123;m-1,n-1&#125; dirs := []point&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125; // 起点为1 则直接返回 if grid[0][0] == 1 &#123; return -1 &#125; queue = append(queue,start) visited[start] = 1 for len(queue) &gt; 0 &#123; size := len(queue) // 将当前队列中的所有节点向四周扩散 for i:=0; i &lt; size; i++&#123; cur := queue[0] // 当前cur queue = queue[1:] // 切掉当前点 // 判断是否是终点 if cur == end &#123; return step &#125; // 遍历八个方向 判断是否符合边界条件 for _, dir :=range dirs&#123; newX := cur.x + dir.x newY := cur.y + dir.y newPoint := point&#123;newX,newY&#125; if newX &gt;=0 &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=0 &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==0 &amp;&amp; grid[newX][newY]==0 &#123; visited[point&#123;newX,newY&#125;] = 1 queue =append(queue,newPoint) &#125; &#125; &#125; step++ &#125; // 只能为0 的路径才可以更新到queue 边界控制 return -1&#125; &gt; 1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）### 解题思路 典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。 &gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？ 1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。 &gt; ### BFS解法中的visited为什么可以全局使用？ BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"leetcode 53.最大子数和","slug":"eetcode/leetcode 53.最大子数和","date":"2023-05-25T15:08:24.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-25-8fc7b96cd054.html","link":"","permalink":"https://leiqi.top/2023-05-25-8fc7b96cd054.html","excerpt":"","text":"Problem: 53. 最大子数组和 个人网站： https://leiqicn.gitee.io/categories/leetcode/[TOC] 思路 这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。 解题方法 方法1 算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。 方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums0; 遍历顺序，从idx &#x3D; 1 开始遍历。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code[]123456789101112131415161718192021222324252627282930313233// 方法1 func maxSubArray(nums []int) int &#123; count := 0 res := math.MinInt32 for i := 0; i &lt; len(nums); i++ &#123; count += nums[i] if count &gt; res &#123; res = count &#125; if count &lt; 0 &#123; count = 0 &#125; &#125; return res&#125;// 方法2 使用了类似动态规划的思想// 定义 nums[i] 当前元素，nums[i-1] 前序列之和func maxSubArray(nums []int) int &#123; max := nums[0] //初始化最大值为前边一个元素 // 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。 for i:= 0 ;i &lt;len(nums)-1; i++ &#123; if nums[i+1] + nums[i] &gt; nums[i+1] &#123; nums[i+1] = nums[i+1] + nums[i] &#125; // 超过最大值，则更新 if nums[i+1] &gt; max &#123; max = nums[i+1] &#125; &#125; return max&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"go语言-回调函数（钩子）","slug":"olang/go语言-回调函数（钩子）","date":"2023-05-25T13:56:41.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-05-25-2cbe3a05ec00.html","link":"","permalink":"https://leiqi.top/2023-05-25-2cbe3a05ec00.html","excerpt":"","text":"在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。 以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func printWithCallback(callback func(string)) &#123; text := &quot;Hello, world!&quot; fmt.Println(text) callback(text)&#125;func main() &#123; callback := func(text string) &#123; fmt.Printf(&quot;Printed: %s\\n&quot;, text) &#125; printWithCallback(callback)&#125; 以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。 当程序运行起来后，会输出如下内容： 12Hello, world!Printed: Hello, world! 这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。 对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;time&quot;)func TimeElapsedCallback(start time.Time) &#123; elapsed := time.Now().Sub(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func heavyCalculation(callback func(time.Time)) &#123; start := time.Now() // 这里进行任何需要测量时间的操作 callback(start)&#125;func main() &#123; heavyCalculation(TimeElapsedCallback)&#125; 在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。 在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容： Time elapsed: 1.001201ms以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。 回调函数的不同以下是不使用回调函数的方式实现计算程序执行时间的示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func heavyCalculation() &#123; start := time.Now() // 这里进行任何需要测量时间的操作 elapsed := time.Since(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func main() &#123; heavyCalculation()&#125; 和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。 在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。 当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。 使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。 而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。 钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。 以下是使用回调函数的优点：灵活性：可以轻松地将自定义代码插入到已有的代码流程中。可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 376.摆动序列","slug":"eetcode/leetcode 376.摆动序列","date":"2023-05-23T17:05:07.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-23-7b5e53100757.html","link":"","permalink":"https://leiqi.top/2023-05-23-7b5e53100757.html","excerpt":"","text":"376. 摆动序列 - 力扣（Leetcode） 12345678910111213141516171819func wiggleMaxLength(nums []int) int &#123; var count, preDiff, curDiff int count = 1 // 初始化计数为1，至少有一个数字是有效的 if len(nums) &lt; 2 &#123; return count // 如果数组长度小于2，直接返回计数值 &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; curDiff = nums[i+1] - nums[i] // 计算当前数字之间的差值 // 根据差值的正负和前一个差值的正负进行判断 // 如果满足摆动序列的条件，更新前一个差值和计数值 if (curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) &#123; preDiff = curDiff count++ &#125; &#125; return count // 返回最终的计数值&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 226. 翻转二叉树","slug":"eetcode/leetcode 226. 翻转二叉树","date":"2023-05-23T15:06:25.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-23-d59f64e0619b.html","link":"","permalink":"https://leiqi.top/2023-05-23-d59f64e0619b.html","excerpt":"","text":"226. 翻转二叉树 - 力扣（Leetcode） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ // 定义将二叉树翻转func invertTree(root *TreeNode) *TreeNode &#123; // 递归终止条件 if root == nil &#123; return nil &#125; // 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点 root.Right,root.Left = root.Left,root.Right // 将右子树翻转 invertTree(root.Right) // 将左子树翻转 invertTree(root.Left) return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 144. 二叉树的前序遍历","slug":"eetcode/leetcode 144. 二叉树的前序遍历","date":"2023-05-23T14:49:08.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-23-62bd8ef029a5.html","link":"","permalink":"https://leiqi.top/2023-05-23-62bd8ef029a5.html","excerpt":"","text":"144. 二叉树的前序遍历 - 力扣（Leetcode） 记得提前判断是否为空，否则会报找不到内存指针的错误 注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。leetcode 102. 二叉树的层序遍历 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; stack := list.New() res := []int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; stack.PushBack(root) for stack.Len() &gt; 0 &#123; top := stack.Remove(stack.Back()).(*TreeNode) res = append(res,top.Val) if top.Right !=nil &#123; stack.PushBack(top.Right) &#125; if top.Left !=nil &#123; stack.PushBack(top.Left) &#125; &#125; return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 102. 二叉树的层序遍历","slug":"eetcode/leetcode 102. 二叉树的层序遍历","date":"2023-05-23T14:46:19.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-05-23-a419f5d1c6af.html","link":"","permalink":"https://leiqi.top/2023-05-23-a419f5d1c6af.html","excerpt":"","text":"102. 二叉树的层序遍历 - 力扣（Leetcode） 使用slice123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; // 层序遍历 使用size 记录每层数组 queue node 队列 res := make([][]int, 0) queue := make([]*TreeNode, 0) if root != nil &#123; queue = append(queue, root) &#125; else &#123; return res &#125; for len(queue) != 0 &#123; size := len(queue) levels := make([]int, 0) for i:= 0; i &lt; size; i++ &#123; node := queue[0] queue = queue[1:len(queue)] //切掉元素0 levels = append(levels, node.Val) // 添加元素 if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; res = append(res, levels) &#125; return res&#125; 使用list123456789101112131415161718192021222324252627func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; queue := &amp;list.List&#123;&#125; queue.PushBack(root) for queue.Len() &gt; 0 &#123; length := queue.Len() //保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） var levelQueue []int fmt.Println(length) for i := 0; i &lt; length; i++ &#123; node := queue.Remove(queue.Front()).(*TreeNode) //出队列 if node.Left != nil &#123; queue.PushBack(node.Left) &#125; if node.Right != nil &#123; queue.PushBack(node.Right) &#125; levelQueue = append(levelQueue, node.Val) //将值加入本层切片中 &#125; res = append(res, levelQueue) //放入结果集 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845.座位预约管理系统","slug":"eetcode/leetcode 1845.座位预约管理系统","date":"2023-05-22T16:06:33.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-22-97adde03f66a.html","link":"","permalink":"https://leiqi.top/2023-05-22-97adde03f66a.html","excerpt":"","text":"1845. 座位预约管理系统 - 力扣（Leetcode） 超时版本123456789101112131415161718192021222324252627282930313233type seat struct &#123; seatId int isFree int // 空&#125;type SeatManager struct &#123; seats map[int]*seat isFrees []int // 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加&#125;func Constructor(n int) SeatManager &#123; var a = SeatManager&#123;make(map[int]*seat, n), make([]int, n)&#125; for i := 0; i &lt; n; i++ &#123; id := i + 1 a.seats[id] = &amp;seat&#123;id, 1&#125; a.isFrees[i] = id // 初始化 &#125; return a&#125;func (this *SeatManager) Reserve() int &#123; sort.Ints(this.isFrees) top := this.isFrees[0] this.seats[top].isFree = 0 this.isFrees = this.isFrees[1:] return top&#125;// 遍历 或者使用mapfunc (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber].isFree = 1 this.isFrees = append(this.isFrees,seatNumber)&#125; 通过版本123456789101112131415161718192021222324252627282930313233343536type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber]=0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125; return&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 455.分发饼干","slug":"eetcode/leetcode 455.分发饼干","date":"2023-05-21T15:10:15.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-21-c1aa51f444e0.html","link":"","permalink":"https://leiqi.top/2023-05-21-c1aa51f444e0.html","excerpt":"","text":"455. 分发饼干 - 力扣（Leetcode） https://leiqicn.gitee.io/ 欢迎关注我的博客，定时更新golang 刷题笔记 贪心的策略： 贪心算法一般分为如下四步： 将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;如果没有越界并且饼干大于等于胃口，则childIdx ++；res++ 12345678910111213141516171819func findContentChildren(g []int, s []int) int &#123; // g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值 sort.Ints(g) sort.Ints(s) j := 0 res := 0 // 用小饼干 来满足最小的胃口 for i := 0; i &lt; len(s); i++ &#123; // 判断越界 饼干大于胃口 if j &lt; len(g) &amp;&amp; s[i] &gt;= g[j] &#123; // len不越界的条件需要在前边 res++ j++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"网站无法访问categories？","slug":"具/网站无法访问categories？","date":"2023-05-21T13:45:30.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-05-21-a827bdd2d159.html","link":"","permalink":"https://leiqi.top/2023-05-21-a827bdd2d159.html","excerpt":"","text":"在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。 可以显示啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 706. 设计哈希映射 Golang","slug":"eetcode/leetcode 706. 设计哈希映射 Golang","date":"2023-05-20T14:58:30.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-20-e3f31d125f9b.html","link":"","permalink":"https://leiqi.top/2023-05-20-e3f31d125f9b.html","excerpt":"","text":"706. 设计哈希映射 - 力扣（Leetcode）使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List 使用结构体（非指针）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;// func (this *MyHashMap) hash(key int, value int)&#123;// &#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(entry); et.k == key &#123; e.Value = entry&#123;key, value&#125; // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝 return &#125; &#125; this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123; return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 使用结构体指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(*entry); et.k == key &#123; // 注意list 的元素类型是空接口，需要断言类型 et.v = value // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针 return &#125; &#125; this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; // 可以缩写为if et := e.Value.(entry); et.k == key 用于断言，并找key return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode　705. 设计哈希集合","slug":"eetcode/leetcode　705. 设计哈希集合","date":"2023-05-19T15:06:26.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2023-05-19-2fa443568cc1.html","link":"","permalink":"https://leiqi.top/2023-05-19-2fa443568cc1.html","excerpt":"","text":"705. 设计哈希集合 - 力扣（Leetcode） 1234567891011121314151617181920212223242526272829303132333435363738394041const base = 769 // 哈希表的长度 质数type MyHashSet struct &#123; data []list.List // 使用链表储存冲突元素&#125;func Constructor() MyHashSet &#123; // 构造函数，返回一个空的哈希集合 return MyHashSet&#123;make([]list.List, base)&#125;&#125;// 哈希函数：对键值取模得到哈希值func (s *MyHashSet) hash(key int) int &#123; return key % base&#125;func (s *MyHashSet) Add(key int) &#123; // 向哈希集合中添加元素 if !s.Contains(key) &#123; // 如果元素不在集合中 h := s.hash(key) // 计算哈希值 s.data[h].PushBack(key) // 将元素加入到链表中 &#125;&#125;func (s *MyHashSet) Remove(key int) &#123; // 从哈希集合中删除元素 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要删除的元素 s.data[h].Remove(e) // 从链表中删除元素 &#125; &#125;&#125;func (s *MyHashSet) Contains(key int) bool &#123; // 判断某个元素是否在哈希集合中 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要查找的元素 return true // 返回 true &#125; &#125; return false // 没有找到元素，返回 false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1396.设计地铁系统","slug":"eetcode/leetcode 1396.设计地铁系统","date":"2023-05-18T15:31:58.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-18-0a0f1bd6a4a5.html","link":"","permalink":"https://leiqi.top/2023-05-18-0a0f1bd6a4a5.html","excerpt":"","text":"1396. 设计地铁系统 - 力扣（Leetcode） 设计题： 设计数据结构 user startTime int endTime int startStationName string endStatationName string UndergroundSystem userMap map[int]*user pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间 注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"leetcode 设计题 Constructor构建","slug":"eetcode/leetcode 设计题 Constructor构建","date":"2023-05-14T14:13:21.000Z","updated":"2025-06-16T15:02:16.973Z","comments":true,"path":"2023-05-14-776ea61b62a5.html","link":"","permalink":"https://leiqi.top/2023-05-14-776ea61b62a5.html","excerpt":"","text":"在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法： 123456789type ParkingSystem struct &#123; carNums map[int]int // 记录每种停车位的数量&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; return ParkingSystem&#123; carNums: map[int]int&#123;1: big, 2: medium, 3: small&#125;, // 初始化 carNums 映射 &#125;&#125; 在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。 请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。 具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现： 1234567891011121314151617type B struct &#123; m map[int]int&#125;type A struct &#123; m map[int]B&#125;func main() &#123; a := &amp;A&#123; m: make(map[int]B), &#125; b := &amp;B&#123; m: make(map[int]int), &#125; a.m[1] = *b // 给 A 中的第一个元素分配一个新的 B 结构体实例&#125; 在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 nil 引用错误，我们还在代码中使用了 make 函数创建了一个空映射。 例如, 下边结构体中map 嵌套了另外一个结构体的map,可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例： 12345678910111213141516type Res struct &#123; big map[int]int&#125;type ParkingSystem struct &#123;map carNums map[int]*Res // map 嵌套map&#125;func NewParkingSystem() *ParkingSystem &#123; return &amp;ParkingSystem&#123;carNums: make(map[int]*Res)&#125; // 只用先make 一个空map,指向Res&#125;func main() &#123; ps := NewParkingSystem() ps.carNums[1] = &amp;Res&#123;big: make(map[int]int)&#125;&#125; 在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。 然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。 总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"Go语言-copy","slug":"olang/Go语言-copy","date":"2023-05-11T16:27:16.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-05-11-27c67ecef2a3.html","link":"","permalink":"https://leiqi.top/2023-05-11-27c67ecef2a3.html","excerpt":"","text":"在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下： 1func copy(dst, src []Type) int 其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。 使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下： 123456789// 定义一个包含元素的数组a := [5]int&#123;1, 2, 3, 4, 5&#125;// 定义要删除的元素下标index := 2// 利用 append 函数和 copy 函数删除指定下标的元素copy(a[index:], a[index+1:])a = a[:len(a)-1]// 打印删除后的数组fmt.Println(a) // 输出 [1 2 4 5] 上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。 在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。 在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片： 1b := a[1:4] 这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。 在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作： 1copy(a[index:], a[index+1:]) 这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-byte和rune 有什么区别 byte rune 转为int","slug":"olang/Go语言-byte和rune 有什么区别 byte rune 转为int","date":"2023-05-11T16:06:34.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-05-11-257639a12a8e.html","link":"","permalink":"https://leiqi.top/2023-05-11-257639a12a8e.html","excerpt":"","text":"在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。 byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。 将 byte 或 rune 转换为 int 可以使用类型转换操作符： 123456b := byte(&#x27;0&#x27;)i := int(b) - int(&#x27;0&#x27;) // 将 byte &#x27;0&#x27; 转换为 int 0// 上边可以简写为i := b - &#x27;0&#x27;r := rune(&#x27;中&#x27;)i := int(r) // 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点） 将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如： 123456i := 10b := byte(i) // 溢出！编译器会忽略高位部分，直接取低位部分的字节r := rune(i)if r &lt; 0xFFFF &#123; r = rune(b) // 类型断言&#125; 可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Leetcode 200.岛屿数量","slug":"eetcode/Leetcode 200.岛屿数量【BFS DFS】","date":"2023-05-10T17:02:51.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-05-10-da8c57fb590a.html","link":"","permalink":"https://leiqi.top/2023-05-10-da8c57fb590a.html","excerpt":"","text":"200. 岛屿数量 - 力扣（Leetcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++func numIslands(grid [][]byte) int &#123; res := 0 r := len(grid) c := len(grid[0]) visited := make([][]byte, r) for i := 0; i &lt; r; i++ &#123; visited[i] = make([]byte, c) &#125; // 遍历二维slice for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; // 每个位置 if grid[i][j] == &#x27;1&#x27; &#123; dfs(grid, i, j, visited) res++ &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; //单层递归逻辑，四面八方递归 dfs(grid, i+1, j, visited) dfs(grid, i, j+1, visited) dfs(grid, i-1, j, visited) dfs(grid, i, j-1, visited)&#125; 也可以使用方向二维数组来遍历 可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下： 1234567891011121314151617181920212223242526272829303132func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 定义方向变化值dirs dirs := [][]int&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125; // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; // 循环遍历dirs，对四个方向进行递归 for _, d := range dirs &#123; new_i, new_j := i + d[0], j + d[1] dfs(grid, new_i, new_j, visited) &#125;&#125; 在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。 使用额外的visited 的时候，一定要作为dfs 的入参，让其拷贝一份在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化（leetcode 的测试环境会造成影响）。 为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： 需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。 对应BFS实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ bfs(grid, i, j) &#125; &#125; &#125; return res&#125;func bfs(grid [][]byte, i, j int) &#123; r := len(grid) c := len(grid[0]) queue := []point&#123;&#123;i, j&#125;&#125; grid[i][j] = &#x27;0&#x27; // 标记为已访问 for len(queue) &gt; 0 &#123; current := queue[0] queue = queue[1:] for _, item := range dirct &#123; myRow := current.x + item[0] myCol := current.y + item[1] if myRow &gt;= 0 &amp;&amp; myRow &lt; r &amp;&amp; myCol &gt;= 0 &amp;&amp; myCol &lt; c &amp;&amp; grid[myRow][myCol] == &#x27;1&#x27; &#123; grid[myRow][myCol] = &#x27;0&#x27; // 标记为已访问 queue = append(queue, point&#123;myRow, myCol&#125;) &#125; &#125; &#125;&#125;// DFS type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) visited := make(map[point]int) // 使用局部变量，每次调用都重新初始化 for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ dfs(grid, i, j, visited) &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i, j int, visited map[point]int) &#123; r := len(grid) c := len(grid[0]) if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 和visited 等价 if _, ok := visited[point&#123;i, j&#125;]; ok &#123; return &#125; grid[i][j] = &#x27;0&#x27; // 和visited 等价 visited[point&#123;i, j&#125;] = 1 for _, item := range dirct &#123; myRow := i + item[0] myCol := j + item[1] if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok &#123; // 这里和前边 if _, ok := visited[point&#123;i, j&#125;]; ok 二选一 dfs(grid, myRow, myCol, visited) &#125; &#125;&#125;// 需要注意的是岛屿数量的 Go 语言代码中，有一点需要注意。在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化。//为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/ 岛屿问题一文搞定","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"}]},{"title":"结构体指针作为map key 结构体值改变对map有影响吗","slug":"olang/结构体指针作为map key 结构体值改变对map有影响吗","date":"2023-05-10T16:37:20.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-05-10-7dfabb45bbc2.html","link":"","permalink":"https://leiqi.top/2023-05-10-7dfabb45bbc2.html","excerpt":"","text":"最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？接下来让我们一起看看： 当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据 例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; m := make(map[*int]string) x := 1 p := &amp;x m[p] = &quot;A&quot; // 添加数据 fmt.Println(m) // map[0xc000016088:A] *p = 2 // 修改变量x的值 fmt.Println(m) // map[0xc000016088:A]&#125; 在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。 接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。 总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言删除指定索引元素","slug":"olang/Go语言删除指定索引元素","date":"2023-05-10T15:47:04.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-05-10-741623f2e4fb.html","link":"","permalink":"https://leiqi.top/2023-05-10-741623f2e4fb.html","excerpt":"","text":"在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。 以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; i := 2 // 要删除的索引 // 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片 b := append(a[:i], a[i+1:]...) fmt.Println(b) // 输出 [1 2 4 5]&#125; 在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。 接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。 最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"Go语言指定索引插入元素","slug":"olang/Go语言指定索引插入元素","date":"2023-05-10T15:42:50.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-05-10-5e3b5c8e7446.html","link":"","permalink":"https://leiqi.top/2023-05-10-5e3b5c8e7446.html","excerpt":"","text":"在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。 下面是一个示例代码，它插入一个元素到切片的第二个位置： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; i := 1 // 要插入的位置 b := append(a[:i], append([]int&#123;5&#125;, a[i:]...)...) // 在切片的第二个位置插入数字5 fmt.Println(b) // 输出 [1 5 2 3 4]&#125; 在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。 接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。 最后，我们将结果赋值给变量 b 并打印输出它。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"leetcode 108.将有序数组转换为二叉搜索树","slug":"eetcode/leetcode 108.将有序数组转换为二叉搜索树","date":"2023-05-04T15:23:48.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-05-04-ce9a22434c37.html","link":"","permalink":"https://leiqi.top/2023-05-04-ce9a22434c37.html","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode） 递归解法注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑注意递归函数定义，严格按照定义调用递归使用前序遍历 中左右 123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"删除ppt所有批注和备注","slug":"具/删除ppt所有批注和备注","date":"2023-04-24T14:25:04.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-04-24-4faf63eb321c.html","link":"","permalink":"https://leiqi.top/2023-04-24-4faf63eb321c.html","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Go语言-接口","slug":"olang/Go语言-接口","date":"2023-04-20T16:42:26.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-04-20-89710477a7ed.html","link":"","permalink":"https://leiqi.top/2023-04-20-89710477a7ed.html","excerpt":"","text":"在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。 以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()： 123456789101112131415161718192021222324type Printer interface &#123; Print()&#125;type User struct &#123; name string&#125;func (u User) Print() &#123; fmt.Println(u.name,&quot;我爱加班&quot;)&#125; func printAll(ps []Printer) &#123; for _, p := range ps &#123; p.Print() &#125;&#125;func main() &#123; var ps []Printer ps = append(ps, User&#123;&quot;Alice&quot;&#125;) ps = append(ps, User&#123;&quot;Bob&quot;&#125;) printAll(ps)&#125; 在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为： 12Alice 我爱加班Bob 我爱加班 在这段代码中，我们通过接口将User类型与PrintAll() 函数解耦，这样当我们需要添加新的类型时，只需要实现Print()方法即可，而不需要修改PrintAll()函数实现。 比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改PrintAll()函数实现。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，有相同的特征，我们将其抽象出来，降低代码耦合性。 1234567type Boss struct &#123; name string&#125;func (b Boss) Print() &#123; fmt.Println(&quot;你明天不用来了&quot;)&#125; 其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照合同的规定进行处理。 同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-多态","slug":"olang/Go语言-多态","date":"2023-04-20T16:32:20.000Z","updated":"2025-06-16T15:02:16.967Z","comments":true,"path":"2023-04-20-af074e588287.html","link":"","permalink":"https://leiqi.top/2023-04-20-af074e588287.html","excerpt":"","text":"Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。 我们来实现这样一个例子： 实现猫和狗两个对象，并且他们都有动作：叫，但叫声不同。再实现一个对象鸟，他除了叫，还会飞。 下面是基于Go语言，实现题目要求的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Animal interface &#123; Cry()&#125;type Cat struct&#123;&#125;func (c Cat) Cry() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;type Dog struct&#123;&#125;func (d Dog) Cry() &#123; fmt.Println(&quot;汪汪汪&quot;)&#125;type Bird struct&#123;&#125;func (b Bird) Cry() &#123; fmt.Println(&quot;叽叽喳喳&quot;)&#125;func (b Bird) Fly() &#123; fmt.Println(&quot;我会飞&quot;)&#125;func main() &#123; var animal Animal // 创建一只猫 animal = Cat&#123;&#125; animal.Cry() // 创建一只狗 animal = Dog&#123;&#125; animal.Cry() // 创建一只鸟 bird := Bird&#123;&#125; animal = bird animal.Cry() bird.Fly()&#125; 在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。 运行上述代码，输出如下： 1234喵喵喵汪汪汪叽叽喳喳我会飞 在这段代码中，我们使用了接口的多态特性，通过定义Animal接口，实现了不同类型的对象之间的通用性，并且在Bird中新增了Fly() 方法，符合面向对象的开放封闭原则。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"波纹","slug":"影/波纹","date":"2023-04-08T05:41:33.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-04-08-722322c4ddc3.html","link":"","permalink":"https://leiqi.top/2023-04-08-722322c4ddc3.html","excerpt":"","text":"波光粼粼","categories":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"}]},{"title":"Leetcode 513.找树左下角的值","slug":"eetcode/Leetcode 513.找树左下角的值","date":"2023-04-03T14:44:37.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-04-03-03cca064ab00.html","link":"","permalink":"https://leiqi.top/2023-04-03-03cca064ab00.html","excerpt":"","text":"513. 找树左下角的值 - 力扣（Leetcode） 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root &#x3D; [2,1,3]输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -2^31 &lt;= Node.val &lt;= 2^31 - 1 思考本题可以转化为什么呢？ 1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。 代码实现1.递归 12345678910111213141516171819202122var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; //这里判断nil ,后边左右节点就不用判断了 if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) dfs(root.Right, d+1)&#125; 2.迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return res&#125;// 迭代2 每层用一个切片func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; // 通过另外一个切片来添加的解法也要尝试学习一下 queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 使用nextqueue 保存每一层，然后追加到queue nextqueue := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] res = nextqueue[0] if top.Left != nil &#123; nextqueue = append(nextqueue, top.Left) &#125; if top.Right != nil &#123; nextqueue = append(nextqueue, top.Right) &#125; &#125; queue = append(queue,nextqueue...) &#125; return res&#125; 拓展思考如果要求最右边的值呢？这里该怎么求呢？ 只需要将 遍历左右的顺序颠倒一下即可 123456789101112131415161718192021222324252627282930313233343536func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 404.左叶子之和","slug":"eetcode/Leetcode 404.左叶子之和","date":"2023-03-29T14:44:37.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-03-29-c131676dd7b1.html","link":"","permalink":"https://leiqi.top/2023-03-29-c131676dd7b1.html","excerpt":"","text":"123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; // 递归 res := 0 // 终止条件 if root == nil &#123; return 0 &#125; leftNode := root.Left leftNodeVal := sumOfLeftLeaves(root.Left) // 左 rightNodeVal := sumOfLeftLeaves(root.Right)// 右 if leftNode != nil &amp;&amp; leftNode.Left == nil &amp;&amp; leftNode.Right == nil &#123; // 中 leftNodeVal = leftNode.Val &#125; // 单次循环 res = leftNodeVal + rightNodeVal // 中，左边+右边 return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 257.二叉树的所有路径","slug":"eetcode/Leetcode 257.二叉树的所有路径","date":"2023-03-28T15:47:29.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-03-28-53b6b0695943.html","link":"","permalink":"https://leiqi.top/2023-03-28-53b6b0695943.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res []stringvar path []stringfunc binaryTreePaths(root *TreeNode) []string &#123; res = make([]string,0) path = make([]string,0) if (root == nil) &#123; return res &#125; backTracking(root) return res&#125;func backTracking(root *TreeNode)&#123; // 终点 左右子节点都为nil if isLeafNode(root) &#123; NodeValStr := strconv.Itoa(root.Val) path = append(path, NodeValStr) pathStr := strings.Join(path, &quot;-&gt;&quot;) res = append(res, pathStr) return &#125; // 前序遍历 中左右 // 遍历 每次递归的操作 NodeVal:= strconv.Itoa(root.Val)// 中 path = append(path, NodeVal) if root.Left != nil &#123; // 左 backTracking(root.Left) path = path[:len(path)-1] &#125; if root.Right != nil &#123; // 右 backTracking(root.Right) path = path[:len(path)-1] &#125;&#125;func isLeafNode(node *TreeNode) bool&#123; if node.Right==nil &amp;&amp; node.Left== nil &amp;&amp; node!= nil&#123; return true &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 110.平衡二叉树","slug":"eetcode/Leetcode 110.平衡二叉树","date":"2023-03-28T03:18:47.000Z","updated":"2025-06-16T15:02:16.971Z","comments":true,"path":"2023-03-28-c58b9cf85e3e.html","link":"","permalink":"https://leiqi.top/2023-03-28-c58b9cf85e3e.html","excerpt":"","text":"110. 平衡二叉树 - 力扣（Leetcode） 简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 示例 2： 输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 输入：root &#x3D; []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 思路这里是求高度： 节点到叶子节点的最长距离，使用后序遍历深度是root 到该节点的最长距离（距离☞节点数），使用前序遍历 因此只要分别计算左右子树的高度，并且做差不大于1就行 代码实现使用-1 记录 res 不是平衡二叉树每次执行，都需要判断是不是等于-1，直接返回-1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 222.完全二叉树的节点个数","slug":"eetcode/leetcode 222.完全二叉树的节点个数","date":"2023-03-28T02:10:45.000Z","updated":"2025-06-16T15:02:16.972Z","comments":true,"path":"2023-03-28-da7418525964.html","link":"","permalink":"https://leiqi.top/2023-03-28-da7418525964.html","excerpt":"","text":"222. 完全二叉树的节点个数 - 力扣（Leetcode） 给出一个完全二叉树，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 输入：root &#x3D; [1,2,3,4,5,6] 输出：6 示例 2： 输入：root &#x3D; [] 输出：0 示例 3： 输入：root &#x3D; [1] 输出：1 提示： 树中节点的数目范围是[0, 5 * 10^4] 0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4 题目数据保证输入的树是 完全二叉树 思路 使用普通二叉树的思想来求，使用层序遍历 或者递归 增加一个变量来存node 的个数 利用完全二叉树的性质，他只有最后一层没有填满，并且是从左到右依次填满的。 代码实现思路1：普通二叉树 1234567891011121314// 递归func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; count := 1 //记录res, 递归算root=1 if root.Right != nil &#123; count += countNodes(root.Right) &#125; if root.Left != nil &#123; count += countNodes(root.Left) &#125; return count&#125; 1234567891011121314151617181920212223// 迭代func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; q := list.New() q.PushBack(root) res := 0 // 记录res, 这里root 加入到了队列，所以res=0 而不是1 for q.Len() &gt; 0 &#123; n := q.Len() for i := 0; i &lt; n; i++ &#123; node := q.Remove(q.Front()).(*TreeNode) if node.Left != nil &#123; q.PushBack(node.Left) &#125; if node.Right != nil &#123; q.PushBack(node.Right) &#125; res++ &#125; &#125; return res &#125; 思路2：完全二叉树 确定递归函数的参数和返回值 ： 输入根节点，返回int 节点数1func countNodes(root *TreeNode) int &#123; 递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node 单层递归逻辑： 需要先求左子右树的节点数量（我们转化为满二叉树，使用公式计算）然后加上root 结果等于 leftTreeNum + rightTreeNum + 1 （leftTreeNum为左子满二叉树，rightTreeNum为右子满二叉树，1是root） 12345678910111213141516171819202122232425func countNodes(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; leftH, rightH := 0, 0 leftNode := root.Left rightNode := root.Right for leftNode != nil &#123; leftNode = leftNode.Left leftH++ &#125; for rightNode != nil &#123; rightNode = rightNode.Right rightH++ &#125; // 递归终止条件，需要左右两边深度相同，则为满二叉树，调用 2^treeDepth - 1 计算node if leftH == rightH &#123; return (2 &lt;&lt; leftH) - 1 // 2左移 即为平方 &#125; leftTreeNum := countNodes(root.Left) // 左 rightTreeNum := countNodes(root.Right) // 右 res := leftTreeNum + rightTreeNum + 1 // 中 return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://leiqi.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"快来压缩你的博客图片","slug":"具/【TODO】快来压缩你的博客图片","date":"2023-03-23T16:00:00.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-03-23-4868b6a1c39c.html","link":"","permalink":"https://leiqi.top/2023-03-23-4868b6a1c39c.html","excerpt":"","text":"虽然没多大变化 哈哈哈再试试 更大更高清的图片 实测,效果不太行….但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下待更新…","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"给你的博客 安装上PWA吧","slug":"具/【TODO】给你的博客 安装上PWA吧","date":"2023-03-23T16:00:00.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-03-23-49ace33ca004.html","link":"","permalink":"https://leiqi.top/2023-03-23-49ace33ca004.html","excerpt":"","text":"TODO: 什么是PWA，可以提示添加到主屏幕渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站 安装 hexo-pwa 由于hexo-pwa停止维护，需要解决报错 设置全局_config.yml 文件(非主题)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 命令 将前台任务挂到后台运行","slug":"inux/Linux 命令 将前台任务挂到后台运行","date":"2023-03-18T16:00:00.000Z","updated":"2025-06-16T15:02:16.968Z","comments":true,"path":"2023-03-18-87649bcaf9cc.html","link":"","permalink":"https://leiqi.top/2023-03-18-87649bcaf9cc.html","excerpt":"","text":"背景 很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用bg 挂后台的命令。 第一步：ctrl + z 第二步：jobs 查看任务id 第三步： bg %任务id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"博客设置 obsidian 上传图片","slug":"具/博客设置 obsidian 上传图片","date":"2023-03-18T16:00:00.000Z","updated":"2025-06-16T15:02:16.975Z","comments":true,"path":"2023-03-18-4e4b648f656d.html","link":"","permalink":"https://leiqi.top/2023-03-18-4e4b648f656d.html","excerpt":"","text":"背景本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的相对路径就可以读取并显示图片。 而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。 操作1. 打开obsidian - 文件与链接2. 按照下图配置 * 将内部链接类型 设置为 “基于当前笔记的相对路径” &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用相对路径 取消wiki 链接 指定图片的默认路径为 source/imgs&gt; 如果没有该文件夹，则需要先新建一下。 成功网页可以成功显示图片","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"关于我","slug":"于我/关于我","date":"2023-03-13T16:00:00.000Z","updated":"2025-06-16T15:02:16.974Z","comments":true,"path":"2023-03-13-519b5e93f019.html","link":"","permalink":"https://leiqi.top/2023-03-13-519b5e93f019.html","excerpt":"","text":"欢迎来到我的空间! 我的第 个朋友！ 关于我 🌱 毕业于复旦大学 ⭐ 现就职于华为，软件开发工程师 兴趣 👨🏽‍💻 项目: NLP, Large Language Model, Golang Project, Python Project, Vue Project. 编程语言 : Golang, Python, C++&#x2F;C, Java 开源项目经验 👯As a manager ： 优酷x天池 「酷文」小说创作大模型挑战赛: DeepThinking Team Leader, Third Prize. As a member : PhenoBERT : PhenoBERT: A combined deep learning method for automated recognition of human phenotype ontology IEEE Journal of Biomedical and Health Informatics（IF&#x3D;5.77） : Reviewer 比赛 优酷x天池 「酷文」小说创作大模型挑战赛: DeepThinking Team Leader, Third Prize. 欢迎志同道合的朋友~本站是为了记录自己学习和生活，欢迎大家多多交流讨论。希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！ 微信公众号","categories":[{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"},{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"},{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"比赛","slug":"比赛","permalink":"https://leiqi.top/categories/%E6%AF%94%E8%B5%9B/"},{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"},{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"速刷记录","slug":"速刷记录","permalink":"https://leiqi.top/categories/%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95/"},{"name":"架构","slug":"架构","permalink":"https://leiqi.top/categories/%E6%9E%B6%E6%9E%84/"},{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"},{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"},{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"},{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"},{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"},{"name":"git","slug":"git","permalink":"https://leiqi.top/tags/git/"},{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"},{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"},{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"},{"name":"二叉树","slug":"二叉树","permalink":"https://leiqi.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}