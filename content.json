{"meta":{"title":"Lei Qi's Blog","subtitle":"","description":"Lei Qi Blog又名LeiQi论坛/中文网/社区/学习/是基于技术方面：Golang, 云原生，大数据，Linux学习，生活方面：摄影技术学习与分享 为一体的综合性网络博客网站。本博客是非营利性博客，目的在于让各位计算机爱好者通过本博客可以学到自己感兴趣的知识，也是记录自己学习成长的一个平台。","author":"Lei Qi","url":"https://leiqichn.github.io","root":"/"},"pages":[{"title":"","date":"2023-10-06T04:11:47.938Z","updated":"2023-10-06T04:11:47.938Z","comments":false,"path":"manifest.json","permalink":"https://leiqichn.github.io/manifest.json","excerpt":"","text":"{\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"name\":\"Lei Qi's blog\",\"short_name\":\"Lei Qi's blog\",\"icons\":[{\"src\":\"imgs/icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/apple-touch-icon.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-10-06T04:11:47.938Z","updated":"2023-10-06T04:11:47.938Z","comments":false,"path":"raw.manifest - 副本.json","permalink":"https://leiqichn.github.io/raw.manifest%20-%20%E5%89%AF%E6%9C%AC.json","excerpt":"","text":"{\"name\":\"Lei Qi's Blog\",\"short_name\":\"Lei Qi\",\"theme_color\":\"white\",\"background_color\":\"white\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/imgs/CLlogo.jpg\",\"sizes\":\"128x128\",\"type\":\"image/jpg\"},{\"src\":\"/imgs/CLlogo.jpg\",\"sizes\":\"512x512\",\"type\":\"image/jpg\"}]}"},{"title":"","date":"2023-10-06T04:11:47.938Z","updated":"2023-10-06T04:11:47.938Z","comments":false,"path":"sw.js","permalink":"https://leiqichn.github.io/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://leiqichn.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"<% tp.file.title %>","date":"2023-10-06T04:11:47.938Z","updated":"2023-10-06T04:11:47.938Z","comments":false,"path":"obsidian_tamplate/TemPlater.html","permalink":"https://leiqichn.github.io/obsidian_tamplate/TemPlater.html","excerpt":"","text":""},{"title":"about","date":"2023-03-13T17:15:57.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"about/index.html","permalink":"https://leiqichn.github.io/about/index.html","excerpt":"","text":"博客链接国外链接国内链接大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~ 爱生活，爱学习，爱分享希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！"},{"title":"categories","date":"2023-05-20T15:57:35.000Z","updated":"2023-10-06T04:11:47.774Z","comments":false,"path":"categories/index.html","permalink":"https://leiqichn.github.io/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-25T15:43:27.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"guestbook/index.html","permalink":"https://leiqichn.github.io/guestbook/index.html","excerpt":"","text":"这里是留言板！欢迎留言哦~"},{"title":"","date":"2023-10-06T04:11:47.774Z","updated":"2023-10-06T04:11:47.774Z","comments":false,"path":"assets/img/Snipaste_2023-03-19_12-43-32.png.html","permalink":"https://leiqichn.github.io/assets/img/Snipaste_2023-03-19_12-43-32.png.html","excerpt":"","text":""},{"title":"","date":"2023-10-06T04:11:47.774Z","updated":"2023-10-06T04:11:47.774Z","comments":false,"path":"assets/img/微信图片_20230319125819.png.html","permalink":"https://leiqichn.github.io/assets/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 1845. 座位预约管理系统","slug":"eetcode/leetcode 1845. 座位预约管理系统","date":"2023-10-06T04:09:42.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-10-06-c2afb6383992.html","link":"","permalink":"https://leiqichn.github.io/2023-10-06-c2afb6383992.html","excerpt":"","text":"Problem: 1845. 座位预约管理系统 个人博客,记录学习: https://leiqicn.gitee.io/ [TOC] 思路 座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存. 解题方法 使用slice 的index来表示座位号,1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n; 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code使用slice []12345678910111213141516171819202122232425262728293031323334 type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125;使用mapmap 有个用例会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type SeatManager struct &#123; seatMap map[int]int minSeat int&#125;func Constructor(n int) SeatManager &#123; seatMap := make(map[int]int, n+1) for i := 0; i &lt;= n; i++ &#123; // 注意从0 开始初始化 seatMap[i] = 0 &#125; seatMan := SeatManager&#123; seatMap, 1, &#125; return seatMan&#125;func (this *SeatManager) Reserve() int &#123; value := this.minSeat this.seatMap[value] = 1 for i:= value; i &lt;= len(this.seatMap);i++ &#123; if this.seatMap[i] == 1 &#123; continue &#125; this.minSeat = i break &#125; return value&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seatMap[seatNumber] = 0 if seatNumber &lt; this.minSeat &#123; this.minSeat = seatNumber &#125;&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Go 中是否使用make创建slice的区别","slug":"olang/Go 中是否使用make创建slice的区别","date":"2023-10-05T09:01:37.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-10-05-9d3185fd2258.html","link":"","permalink":"https://leiqichn.github.io/2023-10-05-9d3185fd2258.html","excerpt":"","text":"go slice 的make 会创建默认长度 且值为0 的slice 在 Go 语言中，可以使用 make 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 make 和不使用 make 创建切片的主要区别： 使用 make 创建切片： 12// 使用 make 创建切片，指定长度和容量 slice := make([]int, 5, 10) 指定长度和容量： 使用 make 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。 底层数组初始化： 使用 make 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，slice 是一个包含5个零值整数的切片。 不使用 make 创建切片： 12// 不使用 make 创建切片，长度为 5 slice := []int&#123;1, 2, 3, 4, 5&#125; &#96; 自动确定长度： 不使用 make 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，slice 的长度是5，因为提供了5个整数。 容量与长度相同： 如果不使用 make 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。 总结： 使用 make 创建切片时，您可以明确控制切片的容量，并按长度初始化为0值，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。 不使用 make 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。 无论使用哪种方式创建切片，都可以使用 append 函数来动态增长切片的长度。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"JetBrians 全家桶设置文件header","slug":"具/JetBrians 全家桶设置文件header","date":"2023-10-05T08:41:46.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-10-05-7527c8e47a8b.html","link":"","permalink":"https://leiqichn.github.io/2023-10-05-7527c8e47a8b.html","excerpt":"","text":"前言我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。 先看下效果图 操作步骤1. file- settings 找到Copyright - CopyrightProfiles点击+ 号，新建一个name 为“copyRight” 的profile profile 的内容粘贴下面的问文本, 替换自己的名字 1234Copyright (c) $originalComment.match(&quot;Copyright \\(c\\) (\\d+)&quot;, 1, &quot;-&quot;, &quot;$today.year&quot;)$today.year YOUR NAME. All rights reserved. Author: YOUR NAME Description: Date: $today 点击Copyright 添加刚才的profile 点击应用即可 右键-generate-Copyright 插入","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Leetcode1603. 设计停车系统","slug":"eetcode/Leetcode 1603. 设计停车系统","date":"2023-09-26T17:09:22.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-09-26-aeddfdb3bdac.html","link":"","permalink":"https://leiqichn.github.io/2023-09-26-aeddfdb3bdac.html","excerpt":"","text":"Problem: 1603. 设计停车系统 [TOC] 思路 首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。 虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。 解题方法 lastCar [3]int 添加上边的数组 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code []12345678910111213141516171819202122232425262728293031 type ParkingSystem struct &#123; lastCar [3]int&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; var parkingSystem ParkingSystem parkingSystem.lastCar[0] = big parkingSystem.lastCar[1] = medium parkingSystem.lastCar[2] = small return parkingSystem&#125;func (this *ParkingSystem) AddCar(carType int) bool &#123; carIdx := carType - 1 if this.lastCar[carIdx] &gt; 0 &#123; this.lastCar[carIdx]-- return true &#125; return false&#125;/** * Your ParkingSystem object will be instantiated and called as such: * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver） * param_1 := obj.AddCar(carType); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Linux非root用户通过X11运行图形界面程序-以Rstudio为例","slug":"具/Linux非root用户通过X11运行图形界面程序-以Rstudio为例","date":"2023-09-24T12:36:53.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-09-24-4fe5badbd053.html","link":"","permalink":"https://leiqichn.github.io/2023-09-24-4fe5badbd053.html","excerpt":"","text":"问题由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！ X11是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。 操作步骤 使用mobaxTerm 登录对应服务器，需要显示X11 打开 创建虚拟环境1234567# 创建虚拟环境 conda create -n rstudio# 安装Ｒconda activate rstudio # 进入创建好的环境变量conda install r-base# 安装Rstudioconda install rstudio-desktop 成功 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面 画个图试试，顺利出图！开始愉快的coding吧！ 已知问题： 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。 总结我们可以通过X11来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 将用户追加到对应用户组","slug":"inux/Linux 将用户追加到对应用户组,新建文件默认同组读写权限","date":"2023-09-17T06:02:54.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-09-17-5141f57450ab.html","link":"","permalink":"https://leiqichn.github.io/2023-09-17-5141f57450ab.html","excerpt":"","text":"前言本文目的是为了将多个用户设置同组用户，并且同组内用户新建文件的默认权限是同组内用户可读写。 解决方案 将test 添加到GroupA 1234usermod -a -G GroupName UserName# 例如将test 追加到GroupAusermod -a -G GroupA test 修改新建文件的默认权限 在.bashrc 里添加 1umask 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--) 1source ~/.bashrc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqichn.github.io/categories/Linux/"}],"tags":[]},{"title":"C++ 结构化设计","slug":"++/C++ 结构化设计","date":"2023-09-13T15:21:57.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-09-13-476441b87811.html","link":"","permalink":"https://leiqichn.github.io/2023-09-13-476441b87811.html","excerpt":"","text":"结构化程序设计自顶向下的设计 是自顶向下的分解 -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题 实现阶段自顶向上的实现，实现一个一个子问题 程序由三种基本结构组成，顺序-分支-循环 例子","categories":[{"name":"C++","slug":"C","permalink":"https://leiqichn.github.io/categories/C/"}],"tags":[]},{"title":"clash在终端设置代理","slug":"具/clash在终端设置代理","date":"2023-09-12T15:38:32.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-09-12-b926f621cf15.html","link":"","permalink":"https://leiqichn.github.io/2023-09-12-b926f621cf15.html","excerpt":"","text":"前言github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！ 开启代理前置条件：手动开打 clash 等VPN软件 12export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890 对应的网址是在settings- static-Host; 对应port 为General-Prot 取消代理12unset http_proxyunset http_proxy git 里设置开启代理 alias 命令别名新建 .bashrc123456789101112131415161718cd ~vi .bashrc# 将以下内容复制进去# .bashrc# Source global definitionsif [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrcfi# Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:# export SYSTEMD_PAGER=# User specific aliases and functions// 别名设置，其他别名设置也是类似alias proxyon=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;alias proxyoff=&quot;unset http_proxy;unset http_proxy&quot; 测试是否成功可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 2594修车的最少时间","slug":"eetcode/leetcode 2594修车的最少时间","date":"2023-09-07T15:59:00.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-09-07-b8c038c07b41.html","link":"","permalink":"https://leiqichn.github.io/2023-09-07-b8c038c07b41.html","excerpt":"","text":"2594. 修车的最少时间 - 力扣（LeetCode） 思路能力值为 r 的机械工可以在 t&#x3D; r * n2 分钟内修好 n 辆车。可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。 12345678910111213141516171819202122func repairCars(ranks []int, cars int) int64 &#123; l , r := 1, ranks[0] * cars * cars var check = func(m int) bool &#123; cnt := 0 for _, x := range ranks &#123; cnt += int(math.Sqrt(float64(m / x))) &#125; return cnt &gt;= cars &#125; for l &lt; r &#123; m := (l + r) &gt;&gt; 1 if check(m) &#123; r = m &#125; else &#123; l = m + 1 &#125; &#125; return int64(l)&#125; l 和 r 的初始化： l 初始化为1，表示最小可能的修理时间。 r 初始化为 ranks[0] * cars * cars，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。 check 函数定义： 这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 m 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 m 时间内能修理多少辆车，然后累加到 cnt 变量中。 如果 cnt 大于或等于需要修理的汽车数量 cars，则返回 true，否则返回 false。 二分查找循环： 使用一个二分查找循环来查找最小的修理时间。循环条件是 l &lt; r，即当最小时间小于最大时间时，继续循环。 在每次循环中，计算中间值 m，并调用 check(m) 检查是否满足修理所有汽车的条件。 如果满足条件，则将 r 更新为 m，因为我们希望找到更小的修理时间。 如果不满足条件，则将 l 更新为 m + 1，因为我们需要增加修理时间。 这样，不断地缩小时间范围，直到找到最小的修理时间。 最终返回结果： 一旦 l 不再小于 r，循环结束，说明已经找到了最小的修理时间，将其转换为 int64 类型并返回。 我们总结一下二分查找适用的场景 二分查找算法适用场景递增或递减规律：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。 有序数据集合：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。 快速查找：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。 确定性问题：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。 时间复杂度要求较高：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。 可比较性数据：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。 搜索范围可确定：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。 内存连续性：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。 一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"设计模式-抽象工厂","slug":"计模式/设计模式-抽象工厂","date":"2023-09-03T12:39:19.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-09-03-c6ab66461699.html","link":"","permalink":"https://leiqichn.github.io/2023-09-03-c6ab66461699.html","excerpt":"","text":"抽象工厂模式结构多个工厂模式; 有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式-工厂方法模式","slug":"计模式/设计模式-工厂方法模式","date":"2023-09-03T05:09:25.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-09-03-c58ee0dac51b.html","link":"","permalink":"https://leiqichn.github.io/2023-09-03-c58ee0dac51b.html","excerpt":"","text":"网站链接：工厂方法设计模式 (refactoringguru.cn) 简介工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。 简单工厂‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间. 工厂方法模式结构不同的类实现相同的动作,例如运输等 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 具体产品 （Concrete Products） 是产品接口的不同实现。 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。 注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 伪代码基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。 如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。 如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。 你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 简单工厂和工厂模式的区别1. 简单工厂设计模式（Simple Factory Design Pattern）： 定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。2. 工厂方法设计模式（Factory Method Design Pattern）： 定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。结构： 工厂方法模式包括抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。主要区别： 复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。 责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。 扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。 灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。 选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。 UML类图如何看看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。” 接口: ‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口. 类和类之间的关系: 继承的关系，继承关系用空心三角形+实线来表示 聚合: 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。 合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。 依赖","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"leetcode 2511 最多可以摧毁的敌人城堡数目","slug":"eetcode/leetcode 2511 最多可以摧毁的敌人城堡数目","date":"2023-09-02T12:51:41.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-09-02-72954cc13c19.html","link":"","permalink":"https://leiqichn.github.io/2023-09-02-72954cc13c19.html","excerpt":"","text":"2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode） 思路抽象出来就是求1和-1间最大连续0 的数量。 有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？ 1.当然可以分类讨论，代码会很复杂，判断很多，容易出错 使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res 12345678910111213141516171819202122232425262728293031323334353637383940func captureForts(forts []int) int &#123; ans, pre := 0, -1 //pre 记录的是 1 或 -1 的位置 for i, fort := range forts &#123; if fort == -1 || fort == 1 &#123; if pre &gt;= 0 &amp;&amp; forts[pre] != fort &#123; ans = max(ans, i - pre - 1) &#125; pre = i &#125; &#125; return ans&#125; func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"LRU","slug":"eetcode/LRU","date":"2023-08-07T15:29:00.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-08-07-e74632bdccbf.html","link":"","permalink":"https://leiqichn.github.io/2023-08-07-e74632bdccbf.html","excerpt":"","text":"146. LRU 缓存 - 力扣（LeetCode） list Elemet 双向列表； 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &quot;container/list&quot;type LRUCache struct &#123; cap int // 缓存容量 cache map[int]*list.Element//!!! 双向链表 使用Element // 双向链表节点 指向的map list *list.List // 双向链表&#125;type keyVal struct &#123; key, val int // 节点的Key和Value&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cap: capacity, // 初始化缓存容量 cache: make(map[int]*list.Element), // 初始化map映射 list: list.New(), // 初始化双向链表 &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 return elem.Value.(*keyVal).val // 返回节点的value值 &#125; return -1 // 没有找到的情况下，返回-1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 //!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值； elem.Value.(*keyVal).val = value // 更新节点的value值 return &#125; if this.list.Len() &gt;= this.cap &#123; // 如果超过了缓存容量 tail := this.list.Back() // 获取链表的尾节点 k := tail.Value.(*keyVal).key // 获取节点的key this.list.Remove(tail) // 从链表中删除尾节点 delete(this.cache, k) // 从map中删除尾节点 &#125; elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) // 将节点添加到链表头 this.cache[key] = elem // 将节点映射到map中&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 最大深度和最小深度","slug":"eetcode/leetcode 最大深度和最小深度","date":"2023-07-29T15:46:22.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-07-29-4df215f63090.html","link":"","permalink":"https://leiqichn.github.io/2023-07-29-4df215f63090.html","excerpt":"","text":"题目104. 二叉树的最大深度 - 力扣（LeetCode） 111. 二叉树的最小深度 - 力扣（LeetCode） 思路深度 是指从根节点到该节点的距离（节点数量）高度 是指从该节点到叶子节点的角力（节点数量） 最大深度 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)最小子树 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现： 最大深度递归分治后序遍历 需要调用自生函数，需要严格按照定义调用递归。 1234567891011121314151617// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := maxDepth(root.Right) leftMaxDepth := maxDepth(root.Left) return 1 + max(rightMaxDepth,leftMaxDepth)&#125;func max(a,b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 迭代 层序遍历1234567891011121314151617181920212223242526// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 最小深度递归后序遍历 12345678910111213141516171819202122232425262728293031// 定义：输入根节点，返回这棵二叉树的最小深度func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := minDepth(root.Right) leftMaxDepth := minDepth(root.Left) // 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论 if root.Right == nil &amp;&amp; root.Left !=nil &#123; return 1 + leftMaxDepth // 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。 &#125; if root.Left == nil &amp;&amp; root.Right !=nil &#123; return 1 + rightMaxDepth &#125; return 1 + min(rightMaxDepth,leftMaxDepth)&#125; func min(a,b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 迭代 层序遍历123456789101112131415161718192021222324252627282930func minDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; if top.Right == nil &amp;&amp; top.Left == nil &#123; return depth + 1 // 当前节点也算哦 &#125; &#125; depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Go语言中的byte类型与Unicode码点与整数的转换","slug":"eetcode/Go语言中的byte类型与Unicode码点与整数的转换","date":"2023-07-09T14:22:16.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-07-09-dda1c4b9508f.html","link":"","permalink":"https://leiqichn.github.io/2023-07-09-dda1c4b9508f.html","excerpt":"","text":"byte类型与Unicode码点的转换在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。 当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; b := byte(&#x27;A&#x27;) i := int(b) fmt.Printf(&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\\n&quot;, b, b, i)&#125; 在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下： 1Byte: A, Unicode码点: 65, 转换后的整数: 65 可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。 byte类型与整数的转换之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。 123456789101112package main import ( &quot;fmt&quot; ) func main() &#123; ch := &#x27;0&#x27; num := int(ch - &#x27;0&#x27;) fmt.Printf(&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\\n&quot;, ch, ch, num) &#125; 在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下： 1字符: 0, unicode码点或者byte对应的数值: 48, 转换后的整数: 0 可以看到，字符 ‘0’ 成功转换为整数 0。其中需要注意的是：在Go语言中，格式化输出时 %c 是一个占位符，用于表示要输出的值是一个Unicode字符。具体来说，%c 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48 这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。 总结byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Mesh组网：家庭路由和无线连接新方式","slug":"络/Mesh组网：家庭路由和无线连接新方式","date":"2023-06-25T14:24:32.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-06-25-a45e5f4edabc.html","link":"","permalink":"https://leiqichn.github.io/2023-06-25-a45e5f4edabc.html","excerpt":"","text":"在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。 what Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。 how Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释： 设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。 路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。 中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。 自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。 why 为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择： 扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。 提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。 可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。 鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。 应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。 与桥接路由对比 Mesh组网： 概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。 特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。 优点： 扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。 鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。 简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。 缺点： 延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。 多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。 网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。 桥接路由： 概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。 特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。 优点： 低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。 单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。 集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。 缺点： 单点故障：中央路由器的故障可能导致整个网络失去连接。 限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。 扩展性：增加节点时，可能需要重新配置和调整网络结构。 结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"链表总结","slug":"eetcode/链表总结","date":"2023-06-24T16:15:32.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-06-24-42b41b131ba0.html","link":"","permalink":"https://leiqichn.github.io/2023-06-24-42b41b131ba0.html","excerpt":"","text":"链表的合并 虚拟头节点 拉拉链 1234567891011121314151617181920212223242526272829303132func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy p1 := l1 p2 := l2 for p1 != nil &amp;&amp; p2 != nil &#123; // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if p1.Val &gt; p2.Val &#123; p.Next = p2 p2 = p2.Next &#125; else &#123; p.Next = p1 p1 = p1.Next &#125; // p 指针不断前进 p = p.Next &#125; if p1 != nil &#123; p.Next = p1 &#125; if p2 != nil &#123; p.Next = p2 &#125; return dummy.Next&#125; 链表的拆分 初始化两个链表，分别添加 合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next 合并 12345678910111213141516171819202122232425262728293031func partition(head *ListNode, x int) *ListNode &#123; // 存放小于 x 的链表的虚拟头结点 dummy1 := &amp;ListNode&#123;-1, nil&#125; // 存放大于等于 x 的链表的虚拟头结点 dummy2 := &amp;ListNode&#123;-1, nil&#125; // p1, p2 指针负责生成结果链表 p1, p2 := dummy1, dummy2 // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 p := head for p != nil &#123; if p.Val &gt;= x &#123; p2.Next = p p2 = p2.Next &#125; else &#123; p1.Next = p p1 = p1.Next &#125; // 断开原链表中的每个节点的 next 指针 temp := p.Next p.Next = nil p = temp &#125; // 连接两个链表 p1.Next = dummy2.Next return dummy1.Next&#125; k 链表合并 最小堆 go语言的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162type ListNode struct &#123; Val int Next *ListNode&#125;func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy // 优先级队列，最小堆 pq := make(PriorityQueue, 0) heap.Init(&amp;pq) // 将 k 个链表的头结点加入最小堆 for _, head := range lists &#123; if head != nil &#123; heap.Push(&amp;pq, head) &#125; &#125; for pq.Len() &gt; 0 &#123; // 获取最小节点，接到结果链表中 node := heap.Pop(&amp;pq).(*ListNode) p.Next = node if node.Next != nil &#123; heap.Push(&amp;pq, node.Next) &#125; // p 指针不断前进 p = p.Next &#125; return dummy.Next&#125;type PriorityQueue []*ListNodefunc (pq PriorityQueue) Len() int &#123; return len(pq)&#125;func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].Val &lt; pq[j].Val&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i]&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; node := x.(*ListNode) *pq = append(*pq, node)&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) node := old[n-1] *pq = old[0 : n-1] return node&#125; 倒数K链表 n 是包含nil 的 一个fast 去探路，先走k步 slow 和fast 一起走 当fast为nil 时，到达k ,赋值为next.next 即可 1234567891011121314151617181920212223242526272829// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.Next = x.Next.Next return dummy.Next&#125; // 返回链表的倒数第 k 个节点func findFromEnd(head *ListNode, k int) *ListNode &#123; p1 := head // p1 先走 k 步 for i := 0; i &lt; k; i++ &#123; p1 = p1.Next &#125; p2 := head // p1 和 p2 同时走 n - k 步 for p1 != nil &#123; p1 = p1.Next p2 = p2.Next &#125; // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2&#125; 倒数K链表移除复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可 1234567891011121314// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.next = x.next.next return dummy.next&#125; func findFromEnd(head *ListNode, k int) *ListNode &#123; // 代码见上文&#125; 移除中间链表876. 链表的中间结点 - 力扣（LeetCode） slow 走一步，fast走两步 fast nil，slow 为中间每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 1234567891011121314func middleNode(head *ListNode) *ListNode &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 // for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步 for fast!= nil &amp;&amp; fast.Next != nil&#123; // 应该修改为这个，slow 会停在中点右边第二个部分 // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next &#125; // 慢指针指向中点 return slow&#125; 判断链表是否成环 slow 走一步，fast走两步 fast 和slow 相遇则成环，fast 遇到nil 则不成环。 1234567891011121314151617func hasCycle(head *ListNode) bool &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 for fast != nil &amp;&amp; fast.Next != nil &#123; // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，说明含有环 if slow == fast &#123; return true &#125; &#125; // 不包含环 return false&#125; labuladong","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"数组双指针刷题总结","slug":"eetcode/数组双指针刷题总结","date":"2023-06-22T14:01:13.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-06-22-079d0af75447.html","link":"","permalink":"https://leiqichn.github.io/2023-06-22-079d0af75447.html","excerpt":"","text":"双指针技巧分为快慢指针和左右指针 快慢指针 原地修改数组 遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++ 去除有序数组&#x2F;链表中去重 和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast] 左右指针1.二分查找 * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界2.N sum 之和 * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大3.反转字符串 * 终止条件是i&gt;j4.回文串判断 * 判断条件s[i] &#x3D;&#x3D; s[j]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1170. 比较字符串最小字母出现频次","slug":"eetcode/leetcode 1170. 比较字符串最小字母出现频次","date":"2023-06-14T15:28:09.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-06-14-88f65f0a1bb7.html","link":"","permalink":"https://leiqichn.github.io/2023-06-14-88f65f0a1bb7.html","excerpt":"","text":"1170. 比较字符串最小字母出现频次 - 力扣（Leetcode） 后缀和（Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。 具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。 在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。 不使用后缀和1234567891011121314151617181920212223242526272829303132func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量 for _, s := range words &#123; count[f(s)] += 1 &#125; res := make([]int, len(queries)) for i, s := range queries &#123; for idx, c := range count &#123; // 遍历count if c&gt;0 &amp;&amp; f(s) &lt; idx &#123;// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c res[i]+=c &#125; &#125; &#125; return res&#125; 使用后缀和12345678910111213141516171819202122232425262728293031func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 for _, s := range words &#123; count[f(s)] += 1 &#125; // 计算后缀和,i+1 就是大于i位置的所有个数 for i := 9; i &gt;= 1; i-- &#123; count[i] += count[i + 1] &#125; res := make([]int, len(queries)) for i, s := range queries &#123; res[i] = count[f(s) + 1] &#125; return res&#125; 为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？ 在numSmallerByFrequency函数中， count数组记录的是各个不同频次出现的次数，因此 count[i]代表所有最小字母出现频次不于 i 的字符串的数量。 如果对于 queries 中的某个字符串 s ，它的最小字母出现频次为 f(s)，那么可以依据 count 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 f(s)+1 开始的所有频次出现次数即可： res[i] = count[f(s) + 1] 这里使用的是 f(s)+1 而不是 f(s) 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"什么是二进制的按位或和按位异或","slug":"olang/什么是二进制的按位或和按位异或","date":"2023-06-08T15:59:19.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-06-08-3d1c210a715f.html","link":"","permalink":"https://leiqichn.github.io/2023-06-08-3d1c210a715f.html","excerpt":"","text":"按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！ 按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下 123456input bit a | input bit b | output ------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 1 例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111): 12345 110| 011----- 111 按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下： 1234567input bit a | input bit b | output------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 0 12345 110^ 011----- 101 总结按位或，就是只要有1 就为1 (包含了1 1 ；0 1；1 0；三种)按位异或，必须一个0一个1，才为1 （包含0 1；1 0；两种）大家记住了吗？","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"leetcode 2460.对数组执行操作 2023.05.06每日一题","slug":"eetcode/leetcode 2460.对数组执行操作 2023.05.06每日一题","date":"2023-06-05T14:46:05.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-06-05-869070f8049d.html","link":"","permalink":"https://leiqichn.github.io/2023-06-05-869070f8049d.html","excerpt":"","text":"2460. 对数组执行操作 - 力扣（Leetcode） 思路直接模拟 Code第一版时间复杂度：O(n)空间复杂度：O(n) 123456789101112131415161718192021func applyOperations(nums []int) []int &#123; var res []int res = make([]int, len(nums)) index := 0 // 第一次遍历 进行赋值操作 for i := 0; i &lt; len(nums)-1; i++ &#123; if nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i+1] = 0 &#125; &#125; // 第二次遍历 将非0移动到前边 for i := 0; i &lt; len(nums); i++ &#123; if nums[i] != 0 &#123; res[index] = nums[i] index++ &#125; &#125; return res&#125; 第二版时间复杂度：O(n)空间复杂度：O(1) 12345678910111213141516func applyOperations(nums []int) []int &#123; n := len(nums) j := 0 for i := 0; i &lt; n; i++ &#123; if i+1 &lt; n &amp;&amp; nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i + 1] = 0 &#125; if nums[i] != 0 &#123; nums[i], nums[j] = nums[j], nums[i] j++ &#125; &#125; return nums&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 28.找出字符串中第一个匹配项的下标","slug":"eetcode/leetcode 28.找出字符串中第一个匹配项的下标","date":"2023-05-31T14:27:00.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-31-396a1cd3c61e.html","link":"","permalink":"https://leiqichn.github.io/2023-05-31-396a1cd3c61e.html","excerpt":"","text":"28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode） 简单解法利用split 函数 12345678910111213func strStr(haystack string, needle string) int &#123; // 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片 splitList := strings.Split(haystack, needle) // 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1 if len(splitList)== 1 &amp;&amp; needle!=haystack &#123; return -1 &#125; if len(splitList) &gt; 1 &#123; return len(splitList[0]) &#125; // needle 在haystack的最开头，返回0 return 0&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 104.二叉树的深度","slug":"eetcode/leetcode 104.二叉树的深度","date":"2023-05-30T15:33:48.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-30-b1879d2b65d1.html","link":"","permalink":"https://leiqichn.github.io/2023-05-30-b1879d2b65d1.html","excerpt":"","text":"个人网站：https://leiqicn.gitee.io/categories/leetcode/104. 二叉树的最大深度 - 力扣（Leetcode） 二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。 所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。 递归123456789101112131415func max (a, b int) int &#123; if a &gt; b &#123; return a; &#125; return b;&#125;// 递归func maxdepth(root *treenode) int &#123; if root == nil &#123; return 0; &#125; return max(maxdepth(root.left), maxdepth(root.right)) + 1;&#125; 迭代法可以使用模板层序遍历 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */import &quot;container/list&quot;func maxDepth(root *TreeNode) int &#123; depth := 0 if root == nil &#123; return 0 &#125; queue := list.New() queue.PushBack(root) for queue.Len() &gt; 0 &#123; size := queue.Len() for i := 0; i &lt; size; i++ &#123; // 切掉第一个元素 first := queue.Remove(queue.Front()).(*TreeNode) //注意层序遍历是切掉前边一个 if first.Left != nil &#123; queue.PushBack(first.Left) &#125; if first.Right != nil &#123; queue.PushBack(first.Right) &#125; &#125; depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://leiqichn.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqichn.github.io/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqichn.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"leetcode 122买动态股票的最佳时机II","slug":"eetcode/leetcode 122买动态股票的最佳时机II","date":"2023-05-27T15:51:57.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-27-5cebfed1675b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-27-5cebfed1675b.html","excerpt":"","text":"122. 买卖股票的最佳时机 II - 力扣（Leetcode） 每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。 相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。 下面是代码解释： 首先定义变量 sum 记录当前总利润。然后从第二个价格开始遍历，计算当日价格与前一天价格之差。如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。最后返回累计的总利润。这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1091.二进制矩阵中的最短路径","slug":"eetcode/leetcode 1091.二进制矩阵中的最短路径","date":"2023-05-26T15:35:54.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-26-5abcbf266873.html","link":"","permalink":"https://leiqichn.github.io/2023-05-26-5abcbf266873.html","excerpt":"","text":"1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）DFS 超时版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type point struct &#123; x int y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; n := len(grid) if grid[0][0] == 1 || grid[n-1][n-1] == 1 &#123; return -1 &#125; res := 0 dirs := [][]int&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125; var help func(i, j, tmp int) help = func(i, j, tmp int) &#123; // 判断是否越界或已经访问过当前节点 if i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n || grid[i][j] == 1 &#123; return &#125; if i == n-1 &amp;&amp; j == n-1 &#123; // 当到达终点时，更新res if tmp+1 &lt; res || res == 0 &#123; res = tmp + 1 &#125; return &#125; // 将当前点标记为已访问 grid[i][j] = 1 tmp++ for _, item := range dirs &#123; x := i + item[0] y := j + item[1] help(x, y, tmp) &#125; // 回溯操作，将当前点复原为未访问状态 grid[i][j] = 0 &#125; help(0, 0, 0) if res == 0 &#123; return -1 &#125; return res&#125; BFS，最短路径使用BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type point struct &#123; x,y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; // queue 维护 m,n := len(grid),len(grid[0]) visited := make(map[point]int) queue := make([]point,0) step := 1 start := point&#123;0,0&#125; end := point&#123;m-1,n-1&#125; dirs := []point&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125; // 起点为1 则直接返回 if grid[0][0] == 1 &#123; return -1 &#125; queue = append(queue,start) visited[start] = 1 for len(queue) &gt; 0 &#123; size := len(queue) // 将当前队列中的所有节点向四周扩散 for i:=0; i &lt; size; i++&#123; cur := queue[0] // 当前cur queue = queue[1:] // 切掉当前点 // 判断是否是终点 if cur == end &#123; return step &#125; // 遍历八个方向 判断是否符合边界条件 for _, dir :=range dirs&#123; newX := cur.x + dir.x newY := cur.y + dir.y newPoint := point&#123;newX,newY&#125; if newX &gt;=0 &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=0 &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==0 &amp;&amp; grid[newX][newY]==0 &#123; visited[point&#123;newX,newY&#125;] = 1 queue =append(queue,newPoint) &#125; &#125; &#125; step++ &#125; // 只能为0 的路径才可以更新到queue 边界控制 return -1&#125; &gt; 1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）### 解题思路 典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。 &gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？ 1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。 &gt; ### BFS解法中的visited为什么可以全局使用？ BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"leetcode 53.最大子数和","slug":"eetcode/leetcode 53.最大子数和","date":"2023-05-25T15:08:24.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-25-8fc7b96cd054.html","link":"","permalink":"https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html","excerpt":"","text":"Problem: 53. 最大子数组和 个人网站： https://leiqicn.gitee.io/categories/leetcode/[TOC] 思路 这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。 解题方法 方法1 算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。 方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums0; 遍历顺序，从idx &#x3D; 1 开始遍历。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code[]123456789101112131415161718192021222324252627282930313233// 方法1 func maxSubArray(nums []int) int &#123; count := 0 res := math.MinInt32 for i := 0; i &lt; len(nums); i++ &#123; count += nums[i] if count &gt; res &#123; res = count &#125; if count &lt; 0 &#123; count = 0 &#125; &#125; return res&#125;// 方法2 使用了类似动态规划的思想// 定义 nums[i] 当前元素，nums[i-1] 前序列之和func maxSubArray(nums []int) int &#123; max := nums[0] //初始化最大值为前边一个元素 // 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。 for i:= 0 ;i &lt;len(nums)-1; i++ &#123; if nums[i+1] + nums[i] &gt; nums[i+1] &#123; nums[i+1] = nums[i+1] + nums[i] &#125; // 超过最大值，则更新 if nums[i+1] &gt; max &#123; max = nums[i+1] &#125; &#125; return max&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"go语言-回调函数（钩子）","slug":"olang/go语言-回调函数（钩子）","date":"2023-05-25T13:56:41.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-25-2cbe3a05ec00.html","link":"","permalink":"https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html","excerpt":"","text":"在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。 以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func printWithCallback(callback func(string)) &#123; text := &quot;Hello, world!&quot; fmt.Println(text) callback(text)&#125;func main() &#123; callback := func(text string) &#123; fmt.Printf(&quot;Printed: %s\\n&quot;, text) &#125; printWithCallback(callback)&#125; 以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。 当程序运行起来后，会输出如下内容： 12Hello, world!Printed: Hello, world! 这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。 对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;time&quot;)func TimeElapsedCallback(start time.Time) &#123; elapsed := time.Now().Sub(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func heavyCalculation(callback func(time.Time)) &#123; start := time.Now() // 这里进行任何需要测量时间的操作 callback(start)&#125;func main() &#123; heavyCalculation(TimeElapsedCallback)&#125; 在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。 在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容： Time elapsed: 1.001201ms以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。 回调函数的不同以下是不使用回调函数的方式实现计算程序执行时间的示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func heavyCalculation() &#123; start := time.Now() // 这里进行任何需要测量时间的操作 elapsed := time.Since(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func main() &#123; heavyCalculation()&#125; 和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。 在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。 当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。 使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。 而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。 钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。 以下是使用回调函数的优点：灵活性：可以轻松地将自定义代码插入到已有的代码流程中。可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"leetcode 376.摆动序列","slug":"eetcode/leetcode 376.摆动序列","date":"2023-05-23T17:05:07.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-23-7b5e53100757.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-7b5e53100757.html","excerpt":"","text":"376. 摆动序列 - 力扣（Leetcode） 12345678910111213141516171819func wiggleMaxLength(nums []int) int &#123; var count, preDiff, curDiff int count = 1 // 初始化计数为1，至少有一个数字是有效的 if len(nums) &lt; 2 &#123; return count // 如果数组长度小于2，直接返回计数值 &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; curDiff = nums[i+1] - nums[i] // 计算当前数字之间的差值 // 根据差值的正负和前一个差值的正负进行判断 // 如果满足摆动序列的条件，更新前一个差值和计数值 if (curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) &#123; preDiff = curDiff count++ &#125; &#125; return count // 返回最终的计数值&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 226. 翻转二叉树","slug":"eetcode/leetcode 226. 翻转二叉树","date":"2023-05-23T15:06:25.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-23-d59f64e0619b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-d59f64e0619b.html","excerpt":"","text":"226. 翻转二叉树 - 力扣（Leetcode） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ // 定义将二叉树翻转func invertTree(root *TreeNode) *TreeNode &#123; // 递归终止条件 if root == nil &#123; return nil &#125; // 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点 root.Right,root.Left = root.Left,root.Right // 将右子树翻转 invertTree(root.Right) // 将左子树翻转 invertTree(root.Left) return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 144. 二叉树的前序遍历","slug":"eetcode/leetcode 144. 二叉树的前序遍历","date":"2023-05-23T14:49:08.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-23-62bd8ef029a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html","excerpt":"","text":"144. 二叉树的前序遍历 - 力扣（Leetcode） 记得提前判断是否为空，否则会报找不到内存指针的错误 注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。leetcode 102. 二叉树的层序遍历 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; stack := list.New() res := []int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; stack.PushBack(root) for stack.Len() &gt; 0 &#123; top := stack.Remove(stack.Back()).(*TreeNode) res = append(res,top.Val) if top.Right !=nil &#123; stack.PushBack(top.Right) &#125; if top.Left !=nil &#123; stack.PushBack(top.Left) &#125; &#125; return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 102. 二叉树的层序遍历","slug":"eetcode/leetcode 102. 二叉树的层序遍历","date":"2023-05-23T14:46:19.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-23-a419f5d1c6af.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-a419f5d1c6af.html","excerpt":"","text":"102. 二叉树的层序遍历 - 力扣（Leetcode） 123456789101112131415161718192021222324252627func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; queue := &amp;list.List&#123;&#125; queue.PushBack(root) for queue.Len() &gt; 0 &#123; length := queue.Len() //保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） var levelQueue []int fmt.Println(length) for i := 0; i &lt; length; i++ &#123; node := queue.Remove(queue.Front()).(*TreeNode) //出队列 if node.Left != nil &#123; queue.PushBack(node.Left) &#125; if node.Right != nil &#123; queue.PushBack(node.Right) &#125; levelQueue = append(levelQueue, node.Val) //将值加入本层切片中 &#125; res = append(res, levelQueue) //放入结果集 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845.座位预约管理系统","slug":"eetcode/leetcode 1845.座位预约管理系统","date":"2023-05-22T16:06:33.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-22-97adde03f66a.html","link":"","permalink":"https://leiqichn.github.io/2023-05-22-97adde03f66a.html","excerpt":"","text":"1845. 座位预约管理系统 - 力扣（Leetcode） 超时版本123456789101112131415161718192021222324252627282930313233type seat struct &#123; seatId int isFree int // 空&#125;type SeatManager struct &#123; seats map[int]*seat isFrees []int // 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加&#125;func Constructor(n int) SeatManager &#123; var a = SeatManager&#123;make(map[int]*seat, n), make([]int, n)&#125; for i := 0; i &lt; n; i++ &#123; id := i + 1 a.seats[id] = &amp;seat&#123;id, 1&#125; a.isFrees[i] = id // 初始化 &#125; return a&#125;func (this *SeatManager) Reserve() int &#123; sort.Ints(this.isFrees) top := this.isFrees[0] this.seats[top].isFree = 0 this.isFrees = this.isFrees[1:] return top&#125;// 遍历 或者使用mapfunc (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber].isFree = 1 this.isFrees = append(this.isFrees,seatNumber)&#125; 通过版本123456789101112131415161718192021222324252627282930313233343536type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber]=0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125; return&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 455.分发饼干","slug":"eetcode/leetcode 455.分发饼干","date":"2023-05-21T15:10:15.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-21-c1aa51f444e0.html","link":"","permalink":"https://leiqichn.github.io/2023-05-21-c1aa51f444e0.html","excerpt":"","text":"455. 分发饼干 - 力扣（Leetcode） https://leiqicn.gitee.io/ 欢迎关注我的博客，定时更新golang 刷题笔记 贪心的策略： 贪心算法一般分为如下四步： 将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;如果没有越界并且饼干大于等于胃口，则childIdx ++；res++ 12345678910111213141516171819func findContentChildren(g []int, s []int) int &#123; // g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值 sort.Ints(g) sort.Ints(s) j := 0 res := 0 // 用小饼干 来满足最小的胃口 for i := 0; i &lt; len(s); i++ &#123; // 判断越界 饼干大于胃口 if j &lt; len(g) &amp;&amp; s[i] &gt;= g[j] &#123; // len不越界的条件需要在前边 res++ j++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"网站无法访问categories？","slug":"具/网站无法访问categories？","date":"2023-05-21T13:45:30.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-05-21-a827bdd2d159.html","link":"","permalink":"https://leiqichn.github.io/2023-05-21-a827bdd2d159.html","excerpt":"","text":"在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。 可以显示啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 706. 设计哈希映射 Golang","slug":"eetcode/leetcode 706. 设计哈希映射 Golang","date":"2023-05-20T14:58:30.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-20-e3f31d125f9b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-20-e3f31d125f9b.html","excerpt":"","text":"706. 设计哈希映射 - 力扣（Leetcode）使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List 使用结构体（非指针）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;// func (this *MyHashMap) hash(key int, value int)&#123;// &#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(entry); et.k == key &#123; e.Value = entry&#123;key, value&#125; // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝 return &#125; &#125; this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123; return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 使用结构体指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(*entry); et.k == key &#123; // 注意list 的元素类型是空接口，需要断言类型 et.v = value // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针 return &#125; &#125; this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; // 可以缩写为if et := e.Value.(entry); et.k == key 用于断言，并找key return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode　705. 设计哈希集合","slug":"eetcode/leetcode　705. 设计哈希集合","date":"2023-05-19T15:06:26.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-19-2fa443568cc1.html","link":"","permalink":"https://leiqichn.github.io/2023-05-19-2fa443568cc1.html","excerpt":"","text":"705. 设计哈希集合 - 力扣（Leetcode） 1234567891011121314151617181920212223242526272829303132333435363738394041const base = 769 // 哈希表的长度 质数type MyHashSet struct &#123; data []list.List // 使用链表储存冲突元素&#125;func Constructor() MyHashSet &#123; // 构造函数，返回一个空的哈希集合 return MyHashSet&#123;make([]list.List, base)&#125;&#125;// 哈希函数：对键值取模得到哈希值func (s *MyHashSet) hash(key int) int &#123; return key % base&#125;func (s *MyHashSet) Add(key int) &#123; // 向哈希集合中添加元素 if !s.Contains(key) &#123; // 如果元素不在集合中 h := s.hash(key) // 计算哈希值 s.data[h].PushBack(key) // 将元素加入到链表中 &#125;&#125;func (s *MyHashSet) Remove(key int) &#123; // 从哈希集合中删除元素 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要删除的元素 s.data[h].Remove(e) // 从链表中删除元素 &#125; &#125;&#125;func (s *MyHashSet) Contains(key int) bool &#123; // 判断某个元素是否在哈希集合中 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要查找的元素 return true // 返回 true &#125; &#125; return false // 没有找到元素，返回 false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1396.设计地铁系统","slug":"eetcode/leetcode 1396.设计地铁系统","date":"2023-05-18T15:31:58.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-18-0a0f1bd6a4a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-18-0a0f1bd6a4a5.html","excerpt":"","text":"1396. 设计地铁系统 - 力扣（Leetcode） 设计题： 设计数据结构 user startTime int endTime int startStationName string endStatationName string UndergroundSystem userMap map[int]*user pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间 注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"leetcode 设计题 Constructor构建","slug":"eetcode/leetcode 设计题 Constructor构建","date":"2023-05-14T14:13:21.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-14-776ea61b62a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-14-776ea61b62a5.html","excerpt":"","text":"在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法： 123456789type ParkingSystem struct &#123; carNums map[int]int // 记录每种停车位的数量&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; return ParkingSystem&#123; carNums: map[int]int&#123;1: big, 2: medium, 3: small&#125;, // 初始化 carNums 映射 &#125;&#125; 在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。 请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。 具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现： 1234567891011121314151617type B struct &#123; m map[int]int&#125;type A struct &#123; m map[int]B&#125;func main() &#123; a := &amp;A&#123; m: make(map[int]B), &#125; b := &amp;B&#123; m: make(map[int]int), &#125; a.m[1] = *b // 给 A 中的第一个元素分配一个新的 B 结构体实例&#125; 在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 nil 引用错误，我们还在代码中使用了 make 函数创建了一个空映射。 例如, 下边结构体中map 嵌套了另外一个结构体的map,可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例： 12345678910111213141516type Res struct &#123; big map[int]int&#125;type ParkingSystem struct &#123;map carNums map[int]*Res // map 嵌套map&#125;func NewParkingSystem() *ParkingSystem &#123; return &amp;ParkingSystem&#123;carNums: make(map[int]*Res)&#125; // 只用先make 一个空map,指向Res&#125;func main() &#123; ps := NewParkingSystem() ps.carNums[1] = &amp;Res&#123;big: make(map[int]int)&#125;&#125; 在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。 然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。 总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"Go语言-copy","slug":"olang/Go语言-copy","date":"2023-05-11T16:27:16.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-11-27c67ecef2a3.html","link":"","permalink":"https://leiqichn.github.io/2023-05-11-27c67ecef2a3.html","excerpt":"","text":"在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下： 1func copy(dst, src []Type) int 其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。 使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下： 123456789// 定义一个包含元素的数组a := [5]int&#123;1, 2, 3, 4, 5&#125;// 定义要删除的元素下标index := 2// 利用 append 函数和 copy 函数删除指定下标的元素copy(a[index:], a[index+1:])a = a[:len(a)-1]// 打印删除后的数组fmt.Println(a) // 输出 [1 2 4 5] 上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。 在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。 在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片： 1b := a[1:4] 这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。 在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作： 1copy(a[index:], a[index+1:]) 这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言-byte和rune 有什么区别 byte rune 转为int","slug":"olang/Go语言-byte和rune 有什么区别 byte rune 转为int","date":"2023-05-11T16:06:34.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-11-257639a12a8e.html","link":"","permalink":"https://leiqichn.github.io/2023-05-11-257639a12a8e.html","excerpt":"","text":"在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。 byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。 将 byte 或 rune 转换为 int 可以使用类型转换操作符： 123456b := byte(&#x27;0&#x27;)i := int(b) - int(&#x27;0&#x27;) // 将 byte &#x27;0&#x27; 转换为 int 0// 上边可以简写为i := b - &#x27;0&#x27;r := rune(&#x27;中&#x27;)i := int(r) // 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点） 将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如： 123456i := 10b := byte(i) // 溢出！编译器会忽略高位部分，直接取低位部分的字节r := rune(i)if r &lt; 0xFFFF &#123; r = rune(b) // 类型断言&#125; 可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Leetcode 200.岛屿数量","slug":"eetcode/Leetcode 200.岛屿数量","date":"2023-05-10T17:02:51.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-10-fbf700fba68e.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-fbf700fba68e.html","excerpt":"","text":"200. 岛屿数量 - 力扣（Leetcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++func numIslands(grid [][]byte) int &#123; res := 0 r := len(grid) c := len(grid[0]) visited := make([][]byte, r) for i := 0; i &lt; r; i++ &#123; visited[i] = make([]byte, c) &#125; // 遍历二维slice for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; // 每个位置 if grid[i][j] == &#x27;1&#x27; &#123; dfs(grid, i, j, visited) res++ &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; //单层递归逻辑，四面八方递归 dfs(grid, i+1, j, visited) dfs(grid, i, j+1, visited) dfs(grid, i-1, j, visited) dfs(grid, i, j-1, visited)&#125; 也可以使用方向二维数组来遍历 可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下： 1234567891011121314151617181920212223242526272829303132func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 定义方向变化值dirs dirs := [][]int&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125; // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; // 循环遍历dirs，对四个方向进行递归 for _, d := range dirs &#123; new_i, new_j := i + d[0], j + d[1] dfs(grid, new_i, new_j, visited) &#125;&#125; 在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。 需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqichn.github.io/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"}]},{"title":"结构体指针作为map key 结构体值改变对map有影响吗","slug":"olang/结构体指针作为map key 结构体值改变对map有影响吗","date":"2023-05-10T16:37:20.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-10-7dfabb45bbc2.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-7dfabb45bbc2.html","excerpt":"","text":"最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？接下来让我们一起看看： 当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据 例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; m := make(map[*int]string) x := 1 p := &amp;x m[p] = &quot;A&quot; // 添加数据 fmt.Println(m) // map[0xc000016088:A] *p = 2 // 修改变量x的值 fmt.Println(m) // map[0xc000016088:A]&#125; 在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。 接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。 总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言删除指定索引元素","slug":"olang/Go语言删除指定索引元素","date":"2023-05-10T15:47:04.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-10-741623f2e4fb.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-741623f2e4fb.html","excerpt":"","text":"在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。 以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; i := 2 // 要删除的索引 // 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片 b := append(a[:i], a[i+1:]...) fmt.Println(b) // 输出 [1 2 4 5]&#125; 在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。 接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。 最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"}]},{"title":"Go语言指定索引插入元素","slug":"olang/Go语言指定索引插入元素","date":"2023-05-10T15:42:50.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-10-5e3b5c8e7446.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-5e3b5c8e7446.html","excerpt":"","text":"在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。 下面是一个示例代码，它插入一个元素到切片的第二个位置： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; i := 1 // 要插入的位置 b := append(a[:i], append([]int&#123;5&#125;, a[i:]...)...) // 在切片的第二个位置插入数字5 fmt.Println(b) // 输出 [1 5 2 3 4]&#125; 在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。 接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。 最后，我们将结果赋值给变量 b 并打印输出它。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"}]},{"title":"leetcode 108.将有序数组转换为二叉搜索树","slug":"eetcode/leetcode 108.将有序数组转换为二叉搜索树","date":"2023-05-04T15:23:48.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-05-04-ce9a22434c37.html","link":"","permalink":"https://leiqichn.github.io/2023-05-04-ce9a22434c37.html","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode） 递归解法注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑注意递归函数定义，严格按照定义调用递归使用前序遍历 中左右 123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"删除ppt所有批注和备注","slug":"具/删除ppt所有批注和备注","date":"2023-04-24T14:25:04.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-04-24-4faf63eb321c.html","link":"","permalink":"https://leiqichn.github.io/2023-04-24-4faf63eb321c.html","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Go语言-接口","slug":"olang/Go语言-接口","date":"2023-04-20T16:42:26.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-04-20-89710477a7ed.html","link":"","permalink":"https://leiqichn.github.io/2023-04-20-89710477a7ed.html","excerpt":"","text":"在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。 以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()： 123456789101112131415161718192021222324type Printer interface &#123; Print()&#125;type User struct &#123; name string&#125;func (u User) Print() &#123; fmt.Println(u.name,&quot;我爱加班&quot;)&#125; func printAll(ps []Printer) &#123; for _, p := range ps &#123; p.Print() &#125;&#125;func main() &#123; var ps []Printer ps = append(ps, User&#123;&quot;Alice&quot;&#125;) ps = append(ps, User&#123;&quot;Bob&quot;&#125;) printAll(ps)&#125; 在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为： 12Alice 我爱加班Bob 我爱加班 在这段代码中，我们通过接口将User类型与PrintAll() 函数解耦，这样当我们需要添加新的类型时，只需要实现Print()方法即可，而不需要修改PrintAll()函数实现。 比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改PrintAll()函数实现。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，有相同的特征，我们将其抽象出来，降低代码耦合性。 1234567type Boss struct &#123; name string&#125;func (b Boss) Print() &#123; fmt.Println(&quot;你明天不用来了&quot;)&#125; 其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照合同的规定进行处理。 同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言-多态","slug":"olang/Go语言-多态","date":"2023-04-20T16:32:20.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-04-20-af074e588287.html","link":"","permalink":"https://leiqichn.github.io/2023-04-20-af074e588287.html","excerpt":"","text":"Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。 我们来实现这样一个例子： 实现猫和狗两个对象，并且他们都有动作：叫，但叫声不同。再实现一个对象鸟，他除了叫，还会飞。 下面是基于Go语言，实现题目要求的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Animal interface &#123; Cry()&#125;type Cat struct&#123;&#125;func (c Cat) Cry() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;type Dog struct&#123;&#125;func (d Dog) Cry() &#123; fmt.Println(&quot;汪汪汪&quot;)&#125;type Bird struct&#123;&#125;func (b Bird) Cry() &#123; fmt.Println(&quot;叽叽喳喳&quot;)&#125;func (b Bird) Fly() &#123; fmt.Println(&quot;我会飞&quot;)&#125;func main() &#123; var animal Animal // 创建一只猫 animal = Cat&#123;&#125; animal.Cry() // 创建一只狗 animal = Dog&#123;&#125; animal.Cry() // 创建一只鸟 bird := Bird&#123;&#125; animal = bird animal.Cry() bird.Fly()&#125; 在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。 运行上述代码，输出如下： 1234喵喵喵汪汪汪叽叽喳喳我会飞 在这段代码中，我们使用了接口的多态特性，通过定义Animal接口，实现了不同类型的对象之间的通用性，并且在Bird中新增了Fly() 方法，符合面向对象的开放封闭原则。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"波纹","slug":"影/波纹","date":"2023-04-08T05:41:33.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-04-08-722322c4ddc3.html","link":"","permalink":"https://leiqichn.github.io/2023-04-08-722322c4ddc3.html","excerpt":"","text":"波光粼粼","categories":[{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqichn.github.io/tags/%E6%B0%B4/"}]},{"title":"Leetcode 513.找树左下角的值","slug":"eetcode/Leetcode 513.找树左下角的值","date":"2023-04-03T14:44:37.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-04-03-03cca064ab00.html","link":"","permalink":"https://leiqichn.github.io/2023-04-03-03cca064ab00.html","excerpt":"","text":"513. 找树左下角的值 - 力扣（Leetcode） 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root &#x3D; [2,1,3]输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -2^31 &lt;= Node.val &lt;= 2^31 - 1 思考本题可以转化为什么呢？ 1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。 代码实现1.递归 12345678910111213141516171819202122var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; //这里判断nil ,后边左右节点就不用判断了 if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) dfs(root.Right, d+1)&#125; 2.迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return res&#125;// 迭代2 每层用一个切片func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; // 通过另外一个切片来添加的解法也要尝试学习一下 queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 使用nextqueue 保存每一层，然后追加到queue nextqueue := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] res = nextqueue[0] if top.Left != nil &#123; nextqueue = append(nextqueue, top.Left) &#125; if top.Right != nil &#123; nextqueue = append(nextqueue, top.Right) &#125; &#125; queue = append(queue,nextqueue...) &#125; return res&#125; 拓展思考如果要求最右边的值呢？这里该怎么求呢？ 只需要将 遍历左右的顺序颠倒一下即可 123456789101112131415161718192021222324252627282930313233343536func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 404.左叶子之和","slug":"eetcode/Leetcode 404.左叶子之和","date":"2023-03-29T14:44:37.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-03-29-c131676dd7b1.html","link":"","permalink":"https://leiqichn.github.io/2023-03-29-c131676dd7b1.html","excerpt":"","text":"123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; // 递归 res := 0 // 终止条件 if root == nil &#123; return 0 &#125; leftNode := root.Left leftNodeVal := sumOfLeftLeaves(root.Left) // 左 rightNodeVal := sumOfLeftLeaves(root.Right)// 右 if leftNode != nil &amp;&amp; leftNode.Left == nil &amp;&amp; leftNode.Right == nil &#123; // 中 leftNodeVal = leftNode.Val &#125; // 单次循环 res = leftNodeVal + rightNodeVal // 中，左边+右边 return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 257.二叉树的所有路径","slug":"eetcode/Leetcode 257.二叉树的所有路径","date":"2023-03-28T15:47:29.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-03-28-53b6b0695943.html","link":"","permalink":"https://leiqichn.github.io/2023-03-28-53b6b0695943.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res []stringvar path []stringfunc binaryTreePaths(root *TreeNode) []string &#123; res = make([]string,0) path = make([]string,0) if (root == nil) &#123; return res &#125; backTracking(root) return res&#125;func backTracking(root *TreeNode)&#123; // 终点 左右子节点都为nil if isLeafNode(root) &#123; NodeValStr := strconv.Itoa(root.Val) path = append(path, NodeValStr) pathStr := strings.Join(path, &quot;-&gt;&quot;) res = append(res, pathStr) return &#125; // 前序遍历 中左右 // 遍历 每次递归的操作 NodeVal:= strconv.Itoa(root.Val)// 中 path = append(path, NodeVal) if root.Left != nil &#123; // 左 backTracking(root.Left) path = path[:len(path)-1] &#125; if root.Right != nil &#123; // 右 backTracking(root.Right) path = path[:len(path)-1] &#125;&#125;func isLeafNode(node *TreeNode) bool&#123; if node.Right==nil &amp;&amp; node.Left== nil &amp;&amp; node!= nil&#123; return true &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 110.平衡二叉树","slug":"eetcode/Leetcode 110.平衡二叉树","date":"2023-03-28T03:18:47.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-03-28-c58b9cf85e3e.html","link":"","permalink":"https://leiqichn.github.io/2023-03-28-c58b9cf85e3e.html","excerpt":"","text":"110. 平衡二叉树 - 力扣（Leetcode） 简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 示例 2： 输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 输入：root &#x3D; []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 思路这里是求高度： 节点到叶子节点的最长距离，使用后序遍历深度是root 到该节点的最长距离（距离☞节点数），使用前序遍历 因此只要分别计算左右子树的高度，并且做差不大于1就行 代码实现使用-1 记录 res 不是平衡二叉树每次执行，都需要判断是不是等于-1，直接返回-1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"快来压缩你的博客图片","slug":"具/【TODO】快来压缩你的博客图片","date":"2023-03-23T16:00:00.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-03-23-4868b6a1c39c.html","link":"","permalink":"https://leiqichn.github.io/2023-03-23-4868b6a1c39c.html","excerpt":"","text":"虽然没多大变化 哈哈哈再试试 更大更高清的图片 实测,效果不太行….但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下待更新…","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"给你的博客 安装上PWA吧","slug":"具/【TODO】给你的博客 安装上PWA吧","date":"2023-03-23T16:00:00.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-03-23-49ace33ca004.html","link":"","permalink":"https://leiqichn.github.io/2023-03-23-49ace33ca004.html","excerpt":"","text":"TODO: 什么是PWA，可以提示添加到主屏幕渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站 安装 hexo-pwa 由于hexo-pwa停止维护，需要解决报错 设置全局_config.yml 文件(非主题)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 命令 将前台任务挂到后台运行","slug":"inux/Linux 命令 将前台任务挂到后台运行","date":"2023-03-18T16:00:00.000Z","updated":"2023-10-06T04:11:47.770Z","comments":true,"path":"2023-03-18-87649bcaf9cc.html","link":"","permalink":"https://leiqichn.github.io/2023-03-18-87649bcaf9cc.html","excerpt":"","text":"背景 很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用bg 挂后台的命令。 第一步：ctrl + z 第二步：jobs 查看任务id 第三步： bg %任务id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqichn.github.io/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"博客设置 obsidian 上传图片","slug":"具/博客设置 obsidian 上传图片","date":"2023-03-18T16:00:00.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-03-18-4e4b648f656d.html","link":"","permalink":"https://leiqichn.github.io/2023-03-18-4e4b648f656d.html","excerpt":"","text":"背景本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的相对路径就可以读取并显示图片。 而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。 操作1. 打开obsidian - 文件与链接2. 按照下图配置 * 将内部链接类型 设置为 “基于当前笔记的相对路径” &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用相对路径 取消wiki 链接 指定图片的默认路径为 source/imgs&gt; 如果没有该文件夹，则需要先新建一下。 成功网页可以成功显示图片","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"关于我","slug":"于我/关于我","date":"2023-03-13T16:00:00.000Z","updated":"2023-10-06T04:11:47.774Z","comments":true,"path":"2023-03-13-519b5e93f019.html","link":"","permalink":"https://leiqichn.github.io/2023-03-13-519b5e93f019.html","excerpt":"","text":"博客链接国外链接国内链接大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~","categories":[{"name":"关于我","slug":"关于我","permalink":"https://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"about","slug":"about","permalink":"https://leiqichn.github.io/tags/about/"}]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"},{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"https://leiqichn.github.io/categories/Linux/"},{"name":"C++","slug":"C","permalink":"https://leiqichn.github.io/categories/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://leiqichn.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"网络","slug":"网络","permalink":"https://leiqichn.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/categories/%E6%91%84%E5%BD%B1/"},{"name":"关于我","slug":"关于我","permalink":"https://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://leiqichn.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqichn.github.io/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqichn.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"贪心","slug":"贪心","permalink":"https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"},{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqichn.github.io/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"},{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqichn.github.io/tags/%E6%B0%B4/"},{"name":"linux命令","slug":"linux命令","permalink":"https://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"about","slug":"about","permalink":"https://leiqichn.github.io/tags/about/"}]}