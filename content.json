{"meta":{"title":"Lei Qi's Blog","subtitle":"","description":"Lei Qi Blog又名LeiQi论坛/中文网/社区/学习/是基于技术方面：Golang, 云原生，大数据，Linux学习，生活方面：摄影技术学习与分享 为一体的综合性网络博客网站。本博客是非营利性博客，目的在于让各位计算机爱好者通过本博客可以学到自己感兴趣的知识，也是记录自己学习成长的一个平台。","author":"Lei Qi","url":"https://leiqichn.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-27T15:58:07.328Z","updated":"2023-05-27T15:58:07.328Z","comments":false,"path":"manifest.json","permalink":"https://leiqichn.github.io/manifest.json","excerpt":"","text":"{\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"name\":\"Lei Qi's blog\",\"short_name\":\"Lei Qi's blog\",\"icons\":[{\"src\":\"imgs/icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/apple-touch-icon.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-05-27T15:58:07.328Z","updated":"2023-05-27T15:58:07.328Z","comments":false,"path":"raw.manifest - 副本.json","permalink":"https://leiqichn.github.io/raw.manifest%20-%20%E5%89%AF%E6%9C%AC.json","excerpt":"","text":"{\"name\":\"Lei Qi's Blog\",\"short_name\":\"Lei Qi\",\"theme_color\":\"white\",\"background_color\":\"white\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/imgs/CLlogo.jpg\",\"sizes\":\"128x128\",\"type\":\"image/jpg\"},{\"src\":\"/imgs/CLlogo.jpg\",\"sizes\":\"512x512\",\"type\":\"image/jpg\"}]}"},{"title":"","date":"2023-05-27T15:58:07.328Z","updated":"2023-05-27T15:58:07.328Z","comments":false,"path":"sw.js","permalink":"https://leiqichn.github.io/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://leiqichn.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"about","date":"2023-03-13T17:15:57.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"about/index.html","permalink":"https://leiqichn.github.io/about/index.html","excerpt":"","text":"博客链接国外链接国内链接大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~ 爱生活，爱学习，爱分享希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！"},{"title":"categories","date":"2023-05-20T15:57:35.000Z","updated":"2023-05-27T15:58:07.236Z","comments":false,"path":"categories/index.html","permalink":"https://leiqichn.github.io/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-25T15:43:27.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"guestbook/index.html","permalink":"https://leiqichn.github.io/guestbook/index.html","excerpt":"","text":"这里是留言板！欢迎留言哦~"},{"title":"<% tp.file.title %>","date":"2023-05-27T15:58:07.328Z","updated":"2023-05-27T15:58:07.328Z","comments":false,"path":"obsidian_tamplate/TemPlater.html","permalink":"https://leiqichn.github.io/obsidian_tamplate/TemPlater.html","excerpt":"","text":""},{"title":"","date":"2023-05-27T15:58:07.236Z","updated":"2023-05-27T15:58:07.236Z","comments":false,"path":"assets/img/Snipaste_2023-03-19_12-43-32.png.html","permalink":"https://leiqichn.github.io/assets/img/Snipaste_2023-03-19_12-43-32.png.html","excerpt":"","text":""},{"title":"","date":"2023-05-27T15:58:07.236Z","updated":"2023-05-27T15:58:07.236Z","comments":false,"path":"assets/img/微信图片_20230319125819.png.html","permalink":"https://leiqichn.github.io/assets/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 122买动态股票的最佳时机II","slug":"eetcode/leetcode 122买动态股票的最佳时机II","date":"2023-05-27T15:51:57.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-27-5cebfed1675b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-27-5cebfed1675b.html","excerpt":"","text":"122. 买卖股票的最佳时机 II - 力扣（Leetcode） 每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。 相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。 下面是代码解释： 首先定义变量 sum 记录当前总利润。然后从第二个价格开始遍历，计算当日价格与前一天价格之差。如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。最后返回累计的总利润。这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1091.二进制矩阵中的最短路径","slug":"eetcode/leetcode 1091.二进制矩阵中的最短路径","date":"2023-05-26T15:35:54.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-26-5abcbf266873.html","link":"","permalink":"https://leiqichn.github.io/2023-05-26-5abcbf266873.html","excerpt":"","text":"1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）DFS 超时版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type point struct &#123; x int y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; n := len(grid) if grid[0][0] == 1 || grid[n-1][n-1] == 1 &#123; return -1 &#125; res := 0 dirs := [][]int&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125; var help func(i, j, tmp int) help = func(i, j, tmp int) &#123; // 判断是否越界或已经访问过当前节点 if i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n || grid[i][j] == 1 &#123; return &#125; if i == n-1 &amp;&amp; j == n-1 &#123; // 当到达终点时，更新res if tmp+1 &lt; res || res == 0 &#123; res = tmp + 1 &#125; return &#125; // 将当前点标记为已访问 grid[i][j] = 1 tmp++ for _, item := range dirs &#123; x := i + item[0] y := j + item[1] help(x, y, tmp) &#125; // 回溯操作，将当前点复原为未访问状态 grid[i][j] = 0 &#125; help(0, 0, 0) if res == 0 &#123; return -1 &#125; return res&#125; BFS，最短路径使用BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type point struct &#123; x,y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; // queue 维护 m,n := len(grid),len(grid[0]) visited := make(map[point]int) queue := make([]point,0) step := 1 start := point&#123;0,0&#125; end := point&#123;m-1,n-1&#125; dirs := []point&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125; // 起点为1 则直接返回 if grid[0][0] == 1 &#123; return -1 &#125; queue = append(queue,start) visited[start] = 1 for len(queue) &gt; 0 &#123; size := len(queue) // 将当前队列中的所有节点向四周扩散 for i:=0; i &lt; size; i++&#123; cur := queue[0] // 当前cur queue = queue[1:] // 切掉当前点 // 判断是否是终点 if cur == end &#123; return step &#125; // 遍历八个方向 判断是否符合边界条件 for _, dir :=range dirs&#123; newX := cur.x + dir.x newY := cur.y + dir.y newPoint := point&#123;newX,newY&#125; if newX &gt;=0 &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=0 &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==0 &amp;&amp; grid[newX][newY]==0 &#123; visited[point&#123;newX,newY&#125;] = 1 queue =append(queue,newPoint) &#125; &#125; &#125; step++ &#125; // 只能为0 的路径才可以更新到queue 边界控制 return -1&#125; &gt; 1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）### 解题思路 典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。 &gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？ 1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。 &gt; ### BFS解法中的visited为什么可以全局使用？ BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"leetcode 53.最大子数和","slug":"eetcode/leetcode 53.最大子数和","date":"2023-05-25T15:08:24.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-25-8fc7b96cd054.html","link":"","permalink":"https://leiqichn.github.io/2023-05-25-8fc7b96cd054.html","excerpt":"","text":"Problem: 53. 最大子数组和 个人网站： https://leiqicn.gitee.io/categories/leetcode/[TOC] 思路 这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。 解题方法 方法1 算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。 方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums0; 遍历顺序，从idx &#x3D; 1 开始遍历。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code[]123456789101112131415161718192021222324252627282930313233// 方法1 func maxSubArray(nums []int) int &#123; count := 0 res := math.MinInt32 for i := 0; i &lt; len(nums); i++ &#123; count += nums[i] if count &gt; res &#123; res = count &#125; if count &lt; 0 &#123; count = 0 &#125; &#125; return res&#125;// 方法2 使用了类似动态规划的思想// 定义 nums[i] 当前元素，nums[i-1] 前序列之和func maxSubArray(nums []int) int &#123; max := nums[0] //初始化最大值为前边一个元素 // 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。 for i:= 0 ;i &lt;len(nums)-1; i++ &#123; if nums[i+1] + nums[i] &gt; nums[i+1] &#123; nums[i+1] = nums[i+1] + nums[i] &#125; // 超过最大值，则更新 if nums[i+1] &gt; max &#123; max = nums[i+1] &#125; &#125; return max&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"go语言-回调函数（钩子）","slug":"olang/go语言-回调函数（钩子）","date":"2023-05-25T13:56:41.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-25-2cbe3a05ec00.html","link":"","permalink":"https://leiqichn.github.io/2023-05-25-2cbe3a05ec00.html","excerpt":"","text":"在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。 以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func printWithCallback(callback func(string)) &#123; text := &quot;Hello, world!&quot; fmt.Println(text) callback(text)&#125;func main() &#123; callback := func(text string) &#123; fmt.Printf(&quot;Printed: %s\\n&quot;, text) &#125; printWithCallback(callback)&#125; 以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。 当程序运行起来后，会输出如下内容： 12Hello, world!Printed: Hello, world! 这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。 对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;time&quot;)func TimeElapsedCallback(start time.Time) &#123; elapsed := time.Now().Sub(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func heavyCalculation(callback func(time.Time)) &#123; start := time.Now() // 这里进行任何需要测量时间的操作 callback(start)&#125;func main() &#123; heavyCalculation(TimeElapsedCallback)&#125; 在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。 在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容： Time elapsed: 1.001201ms以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。 回调函数的不同以下是不使用回调函数的方式实现计算程序执行时间的示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func heavyCalculation() &#123; start := time.Now() // 这里进行任何需要测量时间的操作 elapsed := time.Since(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func main() &#123; heavyCalculation()&#125; 和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。 在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。 当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。 使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。 而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。 钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。 以下是使用回调函数的优点：灵活性：可以轻松地将自定义代码插入到已有的代码流程中。可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"leetcode 376.摆动序列","slug":"eetcode/leetcode 376.摆动序列","date":"2023-05-23T17:05:07.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-23-7b5e53100757.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-7b5e53100757.html","excerpt":"","text":"376. 摆动序列 - 力扣（Leetcode） 12345678910111213141516171819func wiggleMaxLength(nums []int) int &#123; var count, preDiff, curDiff int count = 1 // 初始化计数为1，至少有一个数字是有效的 if len(nums) &lt; 2 &#123; return count // 如果数组长度小于2，直接返回计数值 &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; curDiff = nums[i+1] - nums[i] // 计算当前数字之间的差值 // 根据差值的正负和前一个差值的正负进行判断 // 如果满足摆动序列的条件，更新前一个差值和计数值 if (curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) &#123; preDiff = curDiff count++ &#125; &#125; return count // 返回最终的计数值&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 226. 翻转二叉树","slug":"eetcode/leetcode 226. 翻转二叉树","date":"2023-05-23T15:06:25.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-23-d59f64e0619b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-d59f64e0619b.html","excerpt":"","text":"226. 翻转二叉树 - 力扣（Leetcode） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ // 定义将二叉树翻转func invertTree(root *TreeNode) *TreeNode &#123; // 递归终止条件 if root == nil &#123; return nil &#125; // 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点 root.Right,root.Left = root.Left,root.Right // 将右子树翻转 invertTree(root.Right) // 将左子树翻转 invertTree(root.Left) return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 144. 二叉树的前序遍历","slug":"eetcode/leetcode 144. 二叉树的前序遍历","date":"2023-05-23T14:49:08.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-23-62bd8ef029a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-62bd8ef029a5.html","excerpt":"","text":"144. 二叉树的前序遍历 - 力扣（Leetcode） 记得提前判断是否为空，否则会报找不到内存指针的错误 注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。leetcode 102. 二叉树的层序遍历 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; stack := list.New() res := []int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; stack.PushBack(root) for stack.Len() &gt; 0 &#123; top := stack.Remove(stack.Back()).(*TreeNode) res = append(res,top.Val) if top.Right !=nil &#123; stack.PushBack(top.Right) &#125; if top.Left !=nil &#123; stack.PushBack(top.Left) &#125; &#125; return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 102. 二叉树的层序遍历","slug":"eetcode/leetcode 102. 二叉树的层序遍历","date":"2023-05-23T14:46:19.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-23-a419f5d1c6af.html","link":"","permalink":"https://leiqichn.github.io/2023-05-23-a419f5d1c6af.html","excerpt":"","text":"102. 二叉树的层序遍历 - 力扣（Leetcode） 123456789101112131415161718192021222324252627func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; queue := &amp;list.List&#123;&#125; queue.PushBack(root) for queue.Len() &gt; 0 &#123; length := queue.Len() //保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） var levelQueue []int fmt.Println(length) for i := 0; i &lt; length; i++ &#123; node := queue.Remove(queue.Front()).(*TreeNode) //出队列 if node.Left != nil &#123; queue.PushBack(node.Left) &#125; if node.Right != nil &#123; queue.PushBack(node.Right) &#125; levelQueue = append(levelQueue, node.Val) //将值加入本层切片中 &#125; res = append(res, levelQueue) //放入结果集 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845.座位预约管理系统","slug":"eetcode/leetcode 1845.座位预约管理系统","date":"2023-05-22T16:06:33.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-22-97adde03f66a.html","link":"","permalink":"https://leiqichn.github.io/2023-05-22-97adde03f66a.html","excerpt":"","text":"1845. 座位预约管理系统 - 力扣（Leetcode） 超时版本123456789101112131415161718192021222324252627282930313233type seat struct &#123; seatId int isFree int // 空&#125;type SeatManager struct &#123; seats map[int]*seat isFrees []int // 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加&#125;func Constructor(n int) SeatManager &#123; var a = SeatManager&#123;make(map[int]*seat, n), make([]int, n)&#125; for i := 0; i &lt; n; i++ &#123; id := i + 1 a.seats[id] = &amp;seat&#123;id, 1&#125; a.isFrees[i] = id // 初始化 &#125; return a&#125;func (this *SeatManager) Reserve() int &#123; sort.Ints(this.isFrees) top := this.isFrees[0] this.seats[top].isFree = 0 this.isFrees = this.isFrees[1:] return top&#125;// 遍历 或者使用mapfunc (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber].isFree = 1 this.isFrees = append(this.isFrees,seatNumber)&#125; 通过版本123456789101112131415161718192021222324252627282930313233343536type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber]=0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125; return&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 455.分发饼干","slug":"eetcode/leetcode 455.分发饼干","date":"2023-05-21T15:10:15.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-21-c1aa51f444e0.html","link":"","permalink":"https://leiqichn.github.io/2023-05-21-c1aa51f444e0.html","excerpt":"","text":"455. 分发饼干 - 力扣（Leetcode） https://leiqicn.gitee.io/ 欢迎关注我的博客，定时更新golang 刷题笔记 贪心的策略： 贪心算法一般分为如下四步： 将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;如果没有越界并且饼干大于等于胃口，则childIdx ++；res++ 12345678910111213141516171819func findContentChildren(g []int, s []int) int &#123; // g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值 sort.Ints(g) sort.Ints(s) j := 0 res := 0 // 用小饼干 来满足最小的胃口 for i := 0; i &lt; len(s); i++ &#123; // 判断越界 饼干大于胃口 if j &lt; len(g) &amp;&amp; s[i] &gt;= g[j] &#123; // len不越界的条件需要在前边 res++ j++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"网站无法访问categories？","slug":"具/网站无法访问categories？","date":"2023-05-21T13:45:30.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"2023-05-21-a827bdd2d159.html","link":"","permalink":"https://leiqichn.github.io/2023-05-21-a827bdd2d159.html","excerpt":"","text":"在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。 可以显示啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 706. 设计哈希映射 Golang","slug":"eetcode/leetcode 706. 设计哈希映射 Golang","date":"2023-05-20T14:58:30.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-20-e3f31d125f9b.html","link":"","permalink":"https://leiqichn.github.io/2023-05-20-e3f31d125f9b.html","excerpt":"","text":"706. 设计哈希映射 - 力扣（Leetcode）使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List 使用结构体（非指针）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;// func (this *MyHashMap) hash(key int, value int)&#123;// &#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(entry); et.k == key &#123; e.Value = entry&#123;key, value&#125; // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝 return &#125; &#125; this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123; return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 使用结构体指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(*entry); et.k == key &#123; // 注意list 的元素类型是空接口，需要断言类型 et.v = value // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针 return &#125; &#125; this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; // 可以缩写为if et := e.Value.(entry); et.k == key 用于断言，并找key return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode　705. 设计哈希集合","slug":"eetcode/leetcode　705. 设计哈希集合","date":"2023-05-19T15:06:26.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-19-2fa443568cc1.html","link":"","permalink":"https://leiqichn.github.io/2023-05-19-2fa443568cc1.html","excerpt":"","text":"705. 设计哈希集合 - 力扣（Leetcode） 1234567891011121314151617181920212223242526272829303132333435363738394041const base = 769 // 哈希表的长度 质数type MyHashSet struct &#123; data []list.List // 使用链表储存冲突元素&#125;func Constructor() MyHashSet &#123; // 构造函数，返回一个空的哈希集合 return MyHashSet&#123;make([]list.List, base)&#125;&#125;// 哈希函数：对键值取模得到哈希值func (s *MyHashSet) hash(key int) int &#123; return key % base&#125;func (s *MyHashSet) Add(key int) &#123; // 向哈希集合中添加元素 if !s.Contains(key) &#123; // 如果元素不在集合中 h := s.hash(key) // 计算哈希值 s.data[h].PushBack(key) // 将元素加入到链表中 &#125;&#125;func (s *MyHashSet) Remove(key int) &#123; // 从哈希集合中删除元素 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要删除的元素 s.data[h].Remove(e) // 从链表中删除元素 &#125; &#125;&#125;func (s *MyHashSet) Contains(key int) bool &#123; // 判断某个元素是否在哈希集合中 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要查找的元素 return true // 返回 true &#125; &#125; return false // 没有找到元素，返回 false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1396.设计地铁系统","slug":"eetcode/leetcode 1396.设计地铁系统","date":"2023-05-18T15:31:58.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-18-0a0f1bd6a4a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-18-0a0f1bd6a4a5.html","excerpt":"","text":"1396. 设计地铁系统 - 力扣（Leetcode） 设计题： 设计数据结构 user startTime int endTime int startStationName string endStatationName string UndergroundSystem userMap map[int]*user pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间 注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"leetcode 设计题 Constructor构建","slug":"eetcode/leetcode 设计题 Constructor构建","date":"2023-05-14T14:13:21.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-14-776ea61b62a5.html","link":"","permalink":"https://leiqichn.github.io/2023-05-14-776ea61b62a5.html","excerpt":"","text":"在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法： 123456789type ParkingSystem struct &#123; carNums map[int]int // 记录每种停车位的数量&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; return ParkingSystem&#123; carNums: map[int]int&#123;1: big, 2: medium, 3: small&#125;, // 初始化 carNums 映射 &#125;&#125; 在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。 请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。 具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现： 1234567891011121314151617type B struct &#123; m map[int]int&#125;type A struct &#123; m map[int]B&#125;func main() &#123; a := &amp;A&#123; m: make(map[int]B), &#125; b := &amp;B&#123; m: make(map[int]int), &#125; a.m[1] = *b // 给 A 中的第一个元素分配一个新的 B 结构体实例&#125; 在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 nil 引用错误，我们还在代码中使用了 make 函数创建了一个空映射。 例如, 下边结构体中map 嵌套了另外一个结构体的map,可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例： 12345678910111213141516type Res struct &#123; big map[int]int&#125;type ParkingSystem struct &#123;map carNums map[int]*Res // map 嵌套map&#125;func NewParkingSystem() *ParkingSystem &#123; return &amp;ParkingSystem&#123;carNums: make(map[int]*Res)&#125; // 只用先make 一个空map,指向Res&#125;func main() &#123; ps := NewParkingSystem() ps.carNums[1] = &amp;Res&#123;big: make(map[int]int)&#125;&#125; 在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。 然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。 总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"Go语言-copy","slug":"olang/Go语言-copy","date":"2023-05-11T16:27:16.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-11-27c67ecef2a3.html","link":"","permalink":"https://leiqichn.github.io/2023-05-11-27c67ecef2a3.html","excerpt":"","text":"在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下： 1func copy(dst, src []Type) int 其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。 使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下： 123456789// 定义一个包含元素的数组a := [5]int&#123;1, 2, 3, 4, 5&#125;// 定义要删除的元素下标index := 2// 利用 append 函数和 copy 函数删除指定下标的元素copy(a[index:], a[index+1:])a = a[:len(a)-1]// 打印删除后的数组fmt.Println(a) // 输出 [1 2 4 5] 上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。 在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。 在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片： 1b := a[1:4] 这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。 在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作： 1copy(a[index:], a[index+1:]) 这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言-byte和rune 有什么区别 byte rune 转为int","slug":"olang/Go语言-byte和rune 有什么区别 byte rune 转为int","date":"2023-05-11T16:06:34.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-11-257639a12a8e.html","link":"","permalink":"https://leiqichn.github.io/2023-05-11-257639a12a8e.html","excerpt":"","text":"在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。 byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。 将 byte 或 rune 转换为 int 可以使用类型转换操作符： 123456b := byte(&#x27;0&#x27;)i := int(b) - int(&#x27;0&#x27;) // 将 byte &#x27;0&#x27; 转换为 int 0// 上边可以简写为i := b - &#x27;0&#x27;r := rune(&#x27;中&#x27;)i := int(r) // 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点） 将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如： 123456i := 10b := byte(i) // 溢出！编译器会忽略高位部分，直接取低位部分的字节r := rune(i)if r &lt; 0xFFFF &#123; r = rune(b) // 类型断言&#125; 可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Leetcode 200.岛屿数量","slug":"eetcode/Leetcode 200.岛屿数量","date":"2023-05-10T17:02:51.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-10-fbf700fba68e.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-fbf700fba68e.html","excerpt":"","text":"200. 岛屿数量 - 力扣（Leetcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++func numIslands(grid [][]byte) int &#123; res := 0 r := len(grid) c := len(grid[0]) visited := make([][]byte, r) for i := 0; i &lt; r; i++ &#123; visited[i] = make([]byte, c) &#125; // 遍历二维slice for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; // 每个位置 if grid[i][j] == &#x27;1&#x27; &#123; dfs(grid, i, j, visited) res++ &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; //单层递归逻辑，四面八方递归 dfs(grid, i+1, j, visited) dfs(grid, i, j+1, visited) dfs(grid, i-1, j, visited) dfs(grid, i, j-1, visited)&#125; 也可以使用方向二维数组来遍历 可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下： 1234567891011121314151617181920212223242526272829303132func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 定义方向变化值dirs dirs := [][]int&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125; // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; // 循环遍历dirs，对四个方向进行递归 for _, d := range dirs &#123; new_i, new_j := i + d[0], j + d[1] dfs(grid, new_i, new_j, visited) &#125;&#125; 在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。 需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqichn.github.io/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"}]},{"title":"结构体指针作为map key 结构体值改变对map有影响吗","slug":"olang/结构体指针作为map key 结构体值改变对map有影响吗","date":"2023-05-10T16:37:20.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-10-7dfabb45bbc2.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-7dfabb45bbc2.html","excerpt":"","text":"最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？接下来让我们一起看看： 当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据 例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; m := make(map[*int]string) x := 1 p := &amp;x m[p] = &quot;A&quot; // 添加数据 fmt.Println(m) // map[0xc000016088:A] *p = 2 // 修改变量x的值 fmt.Println(m) // map[0xc000016088:A]&#125; 在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。 接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。 总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言删除指定索引元素","slug":"olang/Go语言删除指定索引元素","date":"2023-05-10T15:47:04.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-10-741623f2e4fb.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-741623f2e4fb.html","excerpt":"","text":"在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。 以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; i := 2 // 要删除的索引 // 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片 b := append(a[:i], a[i+1:]...) fmt.Println(b) // 输出 [1 2 4 5]&#125; 在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。 接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。 最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"}]},{"title":"Go语言指定索引插入元素","slug":"olang/Go语言指定索引插入元素","date":"2023-05-10T15:42:50.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-10-5e3b5c8e7446.html","link":"","permalink":"https://leiqichn.github.io/2023-05-10-5e3b5c8e7446.html","excerpt":"","text":"在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。 下面是一个示例代码，它插入一个元素到切片的第二个位置： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; i := 1 // 要插入的位置 b := append(a[:i], append([]int&#123;5&#125;, a[i:]...)...) // 在切片的第二个位置插入数字5 fmt.Println(b) // 输出 [1 5 2 3 4]&#125; 在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。 接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。 最后，我们将结果赋值给变量 b 并打印输出它。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"}]},{"title":"leetcode 108.将有序数组转换为二叉搜索树","slug":"eetcode/leetcode 108.将有序数组转换为二叉搜索树","date":"2023-05-04T15:23:48.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-05-04-ce9a22434c37.html","link":"","permalink":"https://leiqichn.github.io/2023-05-04-ce9a22434c37.html","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode） 递归解法注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑注意递归函数定义，严格按照定义调用递归使用前序遍历 中左右 123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"删除ppt所有批注和备注","slug":"具/删除ppt所有批注和备注","date":"2023-04-24T14:25:04.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"2023-04-24-4faf63eb321c.html","link":"","permalink":"https://leiqichn.github.io/2023-04-24-4faf63eb321c.html","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Go语言-接口","slug":"olang/Go语言-接口","date":"2023-04-20T16:42:26.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-04-20-89710477a7ed.html","link":"","permalink":"https://leiqichn.github.io/2023-04-20-89710477a7ed.html","excerpt":"","text":"在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。 以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()： 123456789101112131415161718192021222324type Printer interface &#123; Print()&#125;type User struct &#123; name string&#125;func (u User) Print() &#123; fmt.Println(u.name,&quot;我爱加班&quot;)&#125; func printAll(ps []Printer) &#123; for _, p := range ps &#123; p.Print() &#125;&#125;func main() &#123; var ps []Printer ps = append(ps, User&#123;&quot;Alice&quot;&#125;) ps = append(ps, User&#123;&quot;Bob&quot;&#125;) printAll(ps)&#125; 在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为： 12Alice 我爱加班Bob 我爱加班 在这段代码中，我们通过接口将User类型与PrintAll() 函数解耦，这样当我们需要添加新的类型时，只需要实现Print()方法即可，而不需要修改PrintAll()函数实现。 比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改PrintAll()函数实现。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，有相同的特征，我们将其抽象出来，降低代码耦合性。 1234567type Boss struct &#123; name string&#125;func (b Boss) Print() &#123; fmt.Println(&quot;你明天不用来了&quot;)&#125; 其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照合同的规定进行处理。 同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"Go语言-多态","slug":"olang/Go语言-多态","date":"2023-04-20T16:32:20.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-04-20-af074e588287.html","link":"","permalink":"https://leiqichn.github.io/2023-04-20-af074e588287.html","excerpt":"","text":"Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。 我们来实现这样一个例子： 实现猫和狗两个对象，并且他们都有动作：叫，但叫声不同。再实现一个对象鸟，他除了叫，还会飞。 下面是基于Go语言，实现题目要求的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Animal interface &#123; Cry()&#125;type Cat struct&#123;&#125;func (c Cat) Cry() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;type Dog struct&#123;&#125;func (d Dog) Cry() &#123; fmt.Println(&quot;汪汪汪&quot;)&#125;type Bird struct&#123;&#125;func (b Bird) Cry() &#123; fmt.Println(&quot;叽叽喳喳&quot;)&#125;func (b Bird) Fly() &#123; fmt.Println(&quot;我会飞&quot;)&#125;func main() &#123; var animal Animal // 创建一只猫 animal = Cat&#123;&#125; animal.Cry() // 创建一只狗 animal = Dog&#123;&#125; animal.Cry() // 创建一只鸟 bird := Bird&#123;&#125; animal = bird animal.Cry() bird.Fly()&#125; 在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。 运行上述代码，输出如下： 1234喵喵喵汪汪汪叽叽喳喳我会飞 在这段代码中，我们使用了接口的多态特性，通过定义Animal接口，实现了不同类型的对象之间的通用性，并且在Bird中新增了Fly() 方法，符合面向对象的开放封闭原则。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"}],"tags":[]},{"title":"波纹","slug":"影/波纹","date":"2023-04-08T05:41:33.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"2023-04-08-722322c4ddc3.html","link":"","permalink":"https://leiqichn.github.io/2023-04-08-722322c4ddc3.html","excerpt":"","text":"波光粼粼","categories":[{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqichn.github.io/tags/%E6%B0%B4/"}]},{"title":"Leetcode 513.找树左下角的值","slug":"eetcode/Leetcode 513.找树左下角的值","date":"2023-04-03T14:44:37.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-04-03-03cca064ab00.html","link":"","permalink":"https://leiqichn.github.io/2023-04-03-03cca064ab00.html","excerpt":"","text":"513. 找树左下角的值 - 力扣（Leetcode） 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root &#x3D; [2,1,3]输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -2^31 &lt;= Node.val &lt;= 2^31 - 1 思考本题可以转化为什么呢？ 1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。 代码实现1.递归 12345678910111213141516171819202122var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; //这里判断nil ,后边左右节点就不用判断了 if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) dfs(root.Right, d+1)&#125; 2.迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return res&#125;// 迭代2 每层用一个切片func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; // 通过另外一个切片来添加的解法也要尝试学习一下 queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 使用nextqueue 保存每一层，然后追加到queue nextqueue := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] res = nextqueue[0] if top.Left != nil &#123; nextqueue = append(nextqueue, top.Left) &#125; if top.Right != nil &#123; nextqueue = append(nextqueue, top.Right) &#125; &#125; queue = append(queue,nextqueue...) &#125; return res&#125; 拓展思考如果要求最右边的值呢？这里该怎么求呢？ 只需要将 遍历左右的顺序颠倒一下即可 123456789101112131415161718192021222324252627282930313233343536func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 404.左叶子之和","slug":"eetcode/Leetcode 404.左叶子之和","date":"2023-03-29T14:44:37.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-29-c131676dd7b1.html","link":"","permalink":"https://leiqichn.github.io/2023-03-29-c131676dd7b1.html","excerpt":"","text":"123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; // 递归 res := 0 // 终止条件 if root == nil &#123; return 0 &#125; leftNode := root.Left leftNodeVal := sumOfLeftLeaves(root.Left) // 左 rightNodeVal := sumOfLeftLeaves(root.Right)// 右 if leftNode != nil &amp;&amp; leftNode.Left == nil &amp;&amp; leftNode.Right == nil &#123; // 中 leftNodeVal = leftNode.Val &#125; // 单次循环 res = leftNodeVal + rightNodeVal // 中，左边+右边 return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 257.二叉树的所有路径","slug":"eetcode/Leetcode 257.二叉树的所有路径","date":"2023-03-28T15:47:29.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-28-53b6b0695943.html","link":"","permalink":"https://leiqichn.github.io/2023-03-28-53b6b0695943.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res []stringvar path []stringfunc binaryTreePaths(root *TreeNode) []string &#123; res = make([]string,0) path = make([]string,0) if (root == nil) &#123; return res &#125; backTracking(root) return res&#125;func backTracking(root *TreeNode)&#123; // 终点 左右子节点都为nil if isLeafNode(root) &#123; NodeValStr := strconv.Itoa(root.Val) path = append(path, NodeValStr) pathStr := strings.Join(path, &quot;-&gt;&quot;) res = append(res, pathStr) return &#125; // 前序遍历 中左右 // 遍历 每次递归的操作 NodeVal:= strconv.Itoa(root.Val)// 中 path = append(path, NodeVal) if root.Left != nil &#123; // 左 backTracking(root.Left) path = path[:len(path)-1] &#125; if root.Right != nil &#123; // 右 backTracking(root.Right) path = path[:len(path)-1] &#125;&#125;func isLeafNode(node *TreeNode) bool&#123; if node.Right==nil &amp;&amp; node.Left== nil &amp;&amp; node!= nil&#123; return true &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 110.平衡二叉树","slug":"eetcode/Leetcode 110.平衡二叉树","date":"2023-03-28T03:18:47.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-28-c58b9cf85e3e.html","link":"","permalink":"https://leiqichn.github.io/2023-03-28-c58b9cf85e3e.html","excerpt":"","text":"110. 平衡二叉树 - 力扣（Leetcode） 简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 示例 2： 输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 输入：root &#x3D; []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 思路这里是求高度： 节点到叶子节点的最长距离，使用后序遍历深度是root 到该节点的最长距离（距离☞节点数），使用前序遍历 因此只要分别计算左右子树的高度，并且做差不大于1就行 代码实现使用-1 记录 res 不是平衡二叉树每次执行，都需要判断是不是等于-1，直接返回-1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"}],"tags":[]},{"title":"快来压缩你的博客图片","slug":"具/【TODO】快来压缩你的博客图片","date":"2023-03-23T16:00:00.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-23-4868b6a1c39c.html","link":"","permalink":"https://leiqichn.github.io/2023-03-23-4868b6a1c39c.html","excerpt":"","text":"虽然没多大变化 哈哈哈再试试 更大更高清的图片 实测,效果不太行….但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下待更新…","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"给你的博客 安装上PWA吧","slug":"具/【TODO】给你的博客 安装上PWA吧","date":"2023-03-23T16:00:00.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-23-49ace33ca004.html","link":"","permalink":"https://leiqichn.github.io/2023-03-23-49ace33ca004.html","excerpt":"","text":"TODO: 什么是PWA，可以提示添加到主屏幕渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站 安装 hexo-pwa 由于hexo-pwa停止维护，需要解决报错 设置全局_config.yml 文件(非主题)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 命令 将前台任务挂到后台运行","slug":"inux/Linux 命令 将前台任务挂到后台运行","date":"2023-03-18T16:00:00.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-18-87649bcaf9cc.html","link":"","permalink":"https://leiqichn.github.io/2023-03-18-87649bcaf9cc.html","excerpt":"","text":"背景 很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用bg 挂后台的命令。 第一步：ctrl + z 第二步：jobs 查看任务id 第三步： bg %任务id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqichn.github.io/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"博客设置 obsidian 上传图片","slug":"具/博客设置 obsidian 上传图片","date":"2023-03-18T16:00:00.000Z","updated":"2023-05-27T15:58:07.236Z","comments":true,"path":"2023-03-18-4e4b648f656d.html","link":"","permalink":"https://leiqichn.github.io/2023-03-18-4e4b648f656d.html","excerpt":"","text":"背景本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的相对路径就可以读取并显示图片。 而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。 操作1. 打开obsidian - 文件与链接2. 按照下图配置 * 将内部链接类型 设置为 “基于当前笔记的相对路径” &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用相对路径 取消wiki 链接 指定图片的默认路径为 source/imgs&gt; 如果没有该文件夹，则需要先新建一下。 成功网页可以成功显示图片","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"关于我","slug":"于我/关于我","date":"2023-03-13T16:00:00.000Z","updated":"2023-05-27T15:58:07.232Z","comments":true,"path":"2023-03-13-519b5e93f019.html","link":"","permalink":"https://leiqichn.github.io/2023-03-13-519b5e93f019.html","excerpt":"","text":"博客链接国外链接国内链接大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~","categories":[{"name":"关于我","slug":"关于我","permalink":"https://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"about","slug":"about","permalink":"https://leiqichn.github.io/tags/about/"}]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqichn.github.io/categories/leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://leiqichn.github.io/categories/Golang/"},{"name":"工具","slug":"工具","permalink":"https://leiqichn.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/categories/%E6%91%84%E5%BD%B1/"},{"name":"Linux","slug":"Linux","permalink":"https://leiqichn.github.io/categories/Linux/"},{"name":"关于我","slug":"关于我","permalink":"https://leiqichn.github.io/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqichn.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"贪心","slug":"贪心","permalink":"https://leiqichn.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqichn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"设计题","slug":"设计题","permalink":"https://leiqichn.github.io/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"},{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqichn.github.io/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"},{"name":"golang","slug":"golang","permalink":"https://leiqichn.github.io/tags/golang/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqichn.github.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqichn.github.io/tags/%E6%B0%B4/"},{"name":"linux命令","slug":"linux命令","permalink":"https://leiqichn.github.io/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"about","slug":"about","permalink":"https://leiqichn.github.io/tags/about/"}]}