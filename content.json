{"meta":{"title":"Lei Qi's Blog","subtitle":"","description":"Lei Qi Blog又名LeiQi论坛/中文网/社区/学习/是基于技术方面：Golang, 云原生，大数据，Linux学习，生活方面：摄影技术学习与分享 为一体的综合性网络博客网站。本博客是非营利性博客，目的在于让各位计算机爱好者通过本博客可以学到自己感兴趣的知识，也是记录自己学习成长的一个平台。","author":"Lei Qi","url":"https://leiqi.top","root":"/"},"pages":[{"title":"","date":"2025-01-13T15:35:14.765Z","updated":"2025-01-13T15:35:14.765Z","comments":false,"path":"manifest.json","permalink":"https://leiqi.top/manifest.json","excerpt":"","text":"{\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"name\":\"Lei Qi's blog\",\"short_name\":\"Lei Qi's blog\",\"icons\":[{\"src\":\"imgs/icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"imgs/icon-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"},{\"src\":\"/apple-touch-icon.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2025-01-13T15:35:14.765Z","updated":"2025-01-13T15:35:14.765Z","comments":false,"path":"sw.js","permalink":"https://leiqi.top/sw.js","excerpt":"","text":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'); if (workbox) { workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' }); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://leiqichn.github.io/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css|jpg|png|gif)'), workbox.strategies.staleWhileRevalidate()); }"},{"title":"about","date":"2023-03-13T17:15:57.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"about/index.html","permalink":"https://leiqi.top/about/index.html","excerpt":"","text":"博客链接链接 关于我大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~ 爱生活，爱学习，爱分享希望在这里能开辟出我的第二宇宙，与大家一起分享，学习，进步！"},{"title":"categories","date":"2023-05-20T15:57:35.000Z","updated":"2025-01-13T15:35:14.517Z","comments":false,"path":"categories/index.html","permalink":"https://leiqi.top/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-25T15:43:27.000Z","updated":"2025-01-13T15:35:14.517Z","comments":true,"path":"guestbook/index.html","permalink":"https://leiqi.top/guestbook/index.html","excerpt":"","text":"这里是留言板！欢迎留言哦~"},{"title":"<% tp.file.title %>","date":"2025-01-13T15:35:14.765Z","updated":"2025-01-13T15:35:14.765Z","comments":false,"path":"obsidian_tamplate/TemPlater.html","permalink":"https://leiqi.top/obsidian_tamplate/TemPlater.html","excerpt":"","text":""},{"title":"","date":"2025-01-13T15:35:14.516Z","updated":"2025-01-13T15:35:14.516Z","comments":false,"path":"assets/img/Snipaste_2023-03-19_12-43-32.png.html","permalink":"https://leiqi.top/assets/img/Snipaste_2023-03-19_12-43-32.png.html","excerpt":"","text":""},{"title":"","date":"2025-01-13T15:35:14.517Z","updated":"2025-01-13T15:35:14.517Z","comments":false,"path":"assets/img/微信图片_20230319125819.png.html","permalink":"https://leiqi.top/assets/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"arl/代码随想录 day60 第十一章 图论part10","date":"2025-01-13T15:35:14.511Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-13-bca61020ebe8.html","link":"","permalink":"https://leiqi.top/2025-01-13-bca61020ebe8.html","excerpt":"","text":"title: 代码随想录 day60 第十一章 图论part10date: 2025-01-05 22:04:51modificationDate: 2025 一月 5日 星期日 22:04:51categories: - carltags: []sticky: []hide: falsecategory_bar: true第十一章：图论part10今天大家会感受到 Bellman_ford 算法系列在不同场景下的应用。 建议依然是：一刷的时候，能理解 原理，知道Bellman_ford 解决不同场景的问题 ，照着代码随想录能抄下来代码就好，就算达标。 二刷的时候自己尝试独立去写，三刷的时候 才能有一定深度理解各个最短路算法。 Bellman_ford 队列优化算法（又名SPFA）https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA.html 123456789101112131415161718192021222324252627282930313233import collectionsdef main(): n, m = map(int, input().strip().split()) edges = [[] for _ in range(n + 1)] for _ in range(m): src, dest, weight = map(int, input().strip().split()) edges[src].append([dest, weight]) minDist = [float(&quot;inf&quot;)] * (n + 1) minDist[1] = 0 que = collections.deque([1]) visited = [False] * (n + 1) visited[1] = True while que: cur = que.popleft() visited[cur] = False for dest, weight in edges[cur]: if minDist[cur] != float(&quot;inf&quot;) and minDist[cur] + weight &lt; minDist[dest]: minDist[dest] = minDist[cur] + weight if visited[dest] == False: que.append(dest) visited[dest] = True if minDist[-1] == float(&quot;inf&quot;): return &quot;unconnected&quot; return minDist[-1]if __name__ == &quot;__main__&quot;: print(main()) bellman_ford之判断负权回路https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import sysdef main(): input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 m = int(data[index]) index += 1 grid = [] for i in range(m): p1 = int(data[index]) index += 1 p2 = int(data[index]) index += 1 val = int(data[index]) index += 1 # p1 指向 p2，权值为 val grid.append([p1, p2, val]) start = 1 # 起点 end = n # 终点 minDist = [float(&#x27;inf&#x27;)] * (n + 1) minDist[start] = 0 flag = False for i in range(1, n + 1): # 这里我们松弛n次，最后一次判断负权回路 for side in grid: from_node = side[0] to = side[1] price = side[2] if i &lt; n: if minDist[from_node] != float(&#x27;inf&#x27;) and minDist[to] &gt; minDist[from_node] + price: minDist[to] = minDist[from_node] + price else: # 多加一次松弛判断负权回路 if minDist[from_node] != float(&#x27;inf&#x27;) and minDist[to] &gt; minDist[from_node] + price: flag = True if flag: print(&quot;circle&quot;) elif minDist[end] == float(&#x27;inf&#x27;): print(&quot;unconnected&quot;) else: print(minDist[end])if __name__ == &quot;__main__&quot;: main() bellman_ford之单源有限最短路https://www.programmercarl.com/kamacoder/0096.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93III.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;climits&gt;using namespace std;struct Edge &#123; //邻接表 int to; // 链接的节点 int val; // 边的权重 Edge(int t, int w): to(t), val(w) &#123;&#125; // 构造函数&#125;;int main() &#123; int n, m, p1, p2, val; cin &gt;&gt; n &gt;&gt; m; vector&lt;list&lt;Edge&gt;&gt; grid(n + 1); // 邻接表 // 将所有边保存起来 for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; // p1 指向 p2，权值为 val grid[p1].push_back(Edge(p2, val)); &#125; int start, end, k; cin &gt;&gt; start &gt;&gt; end &gt;&gt; k; k++; vector&lt;int&gt; minDist(n + 1 , INT_MAX); vector&lt;int&gt; minDist_copy(n + 1); // 用来记录每一次遍历的结果 minDist[start] = 0; queue&lt;int&gt; que; que.push(start); // 队列里放入起点 int que_size; while (k-- &amp;&amp; !que.empty()) &#123; vector&lt;bool&gt; visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列 minDist_copy = minDist; que_size = que.size(); while (que_size--) &#123; int node = que.front(); que.pop(); for (Edge edge : grid[node]) &#123; int from = node; int to = edge.to; int price = edge.val; if (minDist[to] &gt; minDist_copy[from] + price) &#123; minDist[to] = minDist_copy[from] + price; if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置 visited[to] = true; que.push(to); &#125; &#125; &#125; &#125; if (minDist[end] == INT_MAX) cout &lt;&lt; &quot;unreachable&quot; &lt;&lt; endl; else cout &lt;&lt; minDist[end] &lt;&lt; endl;&#125;","categories":[{"name":"c","slug":"c","permalink":"https://leiqi.top/categories/c/"}],"tags":[]},{"title":"","slug":"arl/day32","date":"2025-01-13T15:35:14.509Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-13-03eb288cbf31.html","link":"","permalink":"https://leiqi.top/2025-01-13-03eb288cbf31.html","excerpt":"","text":"title: day32date: 2025-01-05 22:46:55modificationDate: 2025 一月 5日 星期日 22:46:55categories: - carltags: []sticky: []hide: falsecategory_bar: true第九章 动态规划part01今天正式开始动态规划！ 理论基础无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。 如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？ 其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！ 如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。 https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 视频：https://www.bilibili.com/video/BV13Q4y197Wg 509. 斐波那契数很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。 https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html 视频：https://www.bilibili.com/video/BV1f5411K7mo 70. 爬楼梯本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。 https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html 视频：https://www.bilibili.com/video/BV17h411h7UH 746. 使用最小花费爬楼梯这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。 更改题目描述之后，相当于是 文章中 「拓展」的解法 https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html 视频讲解：https://www.bilibili.com/video/BV16G411c7yZ","categories":[{"name":"c","slug":"c","permalink":"https://leiqi.top/categories/c/"}],"tags":[]},{"title":"【最强春节抢票攻略】火车票抢票攻略","slug":"具/【最强春节抢票攻略】火车票抢票攻略","date":"2025-01-13T15:06:26.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2025-01-13-facf42a009b6.html","link":"","permalink":"https://leiqi.top/2025-01-13-facf42a009b6.html","excerpt":"","text":"1. 下载分流抢票（windows) ，并安装https://www.bypass.cn/ 2. 登录，查询目标车票放票时间需要注意的是，最好不要超过提前5小时来抢票，有可能会存在中途让你重新登录的情况，最稳妥的是在放票前10多分钟登录好，然后开始抢票。 3 先同步服务器时间其他设置小黑屋设置为100秒&#x2F;次。 4.设置微信通知扫码绑定微信即可，绑定完成后可以测试一下效果。这个是起到通知作用，如果抢到了，我们收到通知后去12306付钱就行啦。当然你如果想更自动化一点，可以设置自动支付。 5.设置自动支付绑定支付宝，抢到票自动支付。 6. 设置定时抢票提前两秒时间间隔修改为200，设置更低的话IP容易被封（200我抢成功了），点击开始抢票！等待抢票成功吧！ 抢到啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"day34","slug":"arl/day34","date":"2025-01-05T14:58:46.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-fd59568f4fb6.html","link":"","permalink":"https://leiqi.top/2025-01-05-fd59568f4fb6.html","excerpt":"","text":"第九章 动态规划part02今天开始逐渐有 dp的感觉了，前 两题 不同路径，可以好好研究一下，适合进阶 详细布置 62.不同路径本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。 https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html 视频讲解：https://www.bilibili.com/video/BV1ve4y1x7Eu 63. 不同路径 IIhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.htmlhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html 视频讲解：https://www.bilibili.com/video/BV1Ld4y1k7c6 343. 整数拆分 （可跳过）本题思路并不容易想，一刷建议可以跳过。如果学有余力，可以看视频理解一波。 https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html 视频讲解：https://www.bilibili.com/video/BV1Mg411q7YJ 96. .不同的二叉搜索树 （可跳过）本题思路并不容易想，一刷建议可以跳过。 如果学有余力，可以看视频理解一波。 https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV1eK411o7QA","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 25","slug":"arl/代码随想录 day 25","date":"2025-01-05T14:42:38.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-7bbcb5258390.html","link":"","permalink":"https://leiqi.top/2025-01-05-7bbcb5258390.html","excerpt":"","text":"第七章 回溯算法 part04491.递增子序列本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。 https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html 视频讲解：https://www.bilibili.com/video/BV1EG4y1h78v 46.全排列本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html 视频讲解：https://www.bilibili.com/video/BV19v4y1S79W 47.全排列 II本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容： used[i - 1] &#x3D;&#x3D; true 也行，used[i - 1] &#x3D;&#x3D; false 也行 https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html 视频讲解：https://www.bilibili.com/video/BV1R84y1i7Tm 下面这三道题都非常难，建议大家一刷的时候 可以适当选择跳过。 因为 一刷 也不求大家能把这么难的问题解决，大家目前能了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。 332. 重新安排行程（可跳过）本题很难，一刷的录友刷起来 比较费力，可以留给二刷的时候再去解决。 本题没有录制视频，当初录视频是按照 《代码随想录》出版的目录来的，当时没有这道题所以就没有录制。 https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html 51. N皇后（适当跳过）N皇后这道题目还是很经典的，一刷的录友们建议看看视频了解了解大体思路 就可以 （如果没时间本次就直接跳过） ，先有个印象，二刷的时候重点解决。 https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html 视频讲解：https://www.bilibili.com/video/BV1Rd4y1c7Bq 37. 解数独（适当跳过）同样，一刷的录友们建议看看视频了解了解大体思路（如果没时间本次就直接跳过），先有个印象，二刷的时候重点解决。 。 https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html 视频讲解：https://www.bilibili.com/video/BV1TW4y1471V 总结刷了这么多回溯算法的题目，可以做一做总结了！ https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 24","slug":"arl/代码随想录 day 24","date":"2025-01-05T14:40:19.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-919f81267a1c.html","link":"","permalink":"https://leiqi.top/2025-01-05-919f81267a1c.html","excerpt":"","text":"第七章 回溯算法part0393.复原IP地址本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了 题目链接&#x2F;文章讲解：https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html 视频讲解：https://www.bilibili.com/video/BV1XP4y1U73i/ 1234567891011121314151617181920212223242526272829303132var ( path []string res []string)func restoreIpAddresses(s string) []string &#123; path, res = make([]string, 0, len(s)), make([]string, 0) dfs(s, 0) return res&#125;func dfs(s string, start int) &#123; if len(path) == 4 &#123; // 够四段后就不再继续往下递归 if start == len(s) &#123; str := strings.Join(path, &quot;.&quot;) res = append(res, str) &#125; return &#125; for i := start; i &lt; len(s); i++ &#123; if i != start &amp;&amp; s[start] == &#x27;0&#x27; &#123; // 含有前导 0，无效 break &#125; str := s[start : i+1] num, _ := strconv.Atoi(str) if num &gt;= 0 &amp;&amp; num &lt;= 255 &#123; path = append(path, str) // 符合条件的就进入下一层 dfs(s, i+1) path = path[:len(path) - 1] &#125; else &#123; // 如果不满足条件，再往后也不可能满足条件，直接退出 break &#125; &#125;&#125; 78.子集子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。 题目链接&#x2F;文章讲解：https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html 视频讲解：https://www.bilibili.com/video/BV1U84y1q7Ci 12345678910111213141516171819202122var ( path []int res [][]int)func subsets(nums []int) [][]int &#123; res, path = make([][]int, 0), make([]int, 0, len(nums)) dfs(nums, 0) return res&#125;func dfs(nums []int, start int) &#123; tmp := make([]int, len(path)) copy(tmp, path) res = append(res, tmp) for i := start; i &lt; len(nums); i++ &#123; path = append(path, nums[i]) dfs(nums, i+1) path = path[:len(path)-1] &#125;&#125; 90.子集II大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。 题目链接&#x2F;文章讲解：https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html 视频讲解：https://www.bilibili.com/video/BV1vm4y1F71J 123456789101112131415161718192021222324252627282930313233var ( result [][]int path []int)func subsetsWithDup(nums []int) [][]int &#123; result = make([][]int, 0) path = make([]int, 0) used := make([]bool, len(nums)) sort.Ints(nums) // 去重需要排序 backtracing(nums, 0, used) return result&#125;func backtracing(nums []int, startIndex int, used []bool) &#123; tmp := make([]int, len(path)) copy(tmp, path) result = append(result, tmp) for i := startIndex; i &lt; len(nums); i++ &#123; // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 而我们要对同一树层使用过的元素进行跳过 if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false &#123; continue &#125; path = append(path, nums[i]) used[i] = true backtracing(nums, i + 1, used) path = path[:len(path)-1] used[i] = false &#125;&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 22 回溯算法 part01","slug":"arl/代码随想录 day 22 回溯算法 part01","date":"2025-01-05T14:36:08.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-b394fdddf846.html","link":"","permalink":"https://leiqi.top/2025-01-05-b394fdddf846.html","excerpt":"","text":"第七章 回溯算法part01理论基础其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。 题目链接&#x2F;文章讲解：https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 视频讲解：https://www.bilibili.com/video/BV1cy4y167mM 77. 组合对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。 在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。 本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。 题目链接&#x2F;文章讲解：https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html 视频讲解：https://www.bilibili.com/video/BV1ti4y1L7cv 剪枝操作：https://www.bilibili.com/video/BV1wi4y157er 1234567891011121314151617181920212223242526272829var ( path []int res [][]int)func combine(n int, k int) [][]int &#123; path, res = make([]int, 0, k), make([][]int, 0) dfs(n, k, 1) return res&#125;func dfs(n int, k int, start int) &#123; if len(path) == k &#123; // 说明已经满足了k个数的要求 tmp := make([]int, k) copy(tmp, path) res = append(res, tmp) return &#125; for i := start; i &lt;= n; i++ &#123; // 从start开始，不往回走，避免出现重复组合 if n - i + 1 &lt; k - len(path) &#123; // 剪枝 break &#125; path = append(path, i) dfs(n, k, i+1) path = path[:len(path)-1] &#125;&#125; 216.组合总和III如果把 组合问题理解了，本题就容易一些了。 题目链接&#x2F;文章讲解：https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html 视频讲解：https://www.bilibili.com/video/BV1wg411873x 12345678910111213141516171819202122232425262728var ( res [][]int path []int)func combinationSum3(k int, n int) [][]int &#123; res, path = make([][]int, 0), make([]int, 0, k) dfs(k, n, 1, 0) return res&#125;func dfs(k, n int, start int, sum int) &#123; if len(path) == k &#123; if sum == n &#123; tmp := make([]int, k) copy(tmp, path) res = append(res, tmp) &#125; return &#125; for i := start; i &lt;= 9; i++ &#123; if sum + i &gt; n || 9-i+1 &lt; k-len(path) &#123; break &#125; path = append(path, i) dfs(k, n, i+1, sum+i) path = path[:len(path)-1] &#125;&#125; 17.电话号码的字母组合本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。 题目链接&#x2F;文章讲解：https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html 视频讲解：https://www.bilibili.com/video/BV1yV4y1V7Ug 12345678910111213141516171819202122232425262728293031var ( m []string path []byte res []string)func letterCombinations(digits string) []string &#123; m = []string&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125; path, res = make([]byte, 0), make([]string, 0) if digits == &quot;&quot; &#123; return res &#125; dfs(digits, 0) return res&#125;func dfs(digits string, start int) &#123; if len(path) == len(digits) &#123; //终止条件，字符串长度等于digits的长度 tmp := string(path) res = append(res, tmp) return &#125; digit := int(digits[start] - &#x27;0&#x27;) // 将index指向的数字转为int（确定下一个数字） str := m[digit-2] // 取数字对应的字符集（注意和map中的对应） for j := 0; j &lt; len(str); j++ &#123; path = append(path, str[j]) dfs(digits, start+1) path = path[:len(path)-1] &#125;&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 8  字符串 part 01","slug":"arl/代码随想录 day 8  字符串 part 01","date":"2025-01-05T14:26:21.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2025-01-05-ec41d1d27b42.html","link":"","permalink":"https://leiqi.top/2025-01-05-ec41d1d27b42.html","excerpt":"","text":"第四章 字符串part01今日任务● 344.反转字符串 ● 541. 反转字符串II ● 卡码网：54.替换数字 详细布置344.反转字符串建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html 1234567891011func reverseString(s []byte) &#123; left := 0 right := len(s)-1 for left &lt; right &#123; s[left], s[right] = s[right], s[left] left++ right-- &#125;&#125; 541. 反转字符串II建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html 123456789101112131415161718192021222324252627func reverseStr(s string, k int) string &#123; ss := []byte(s) length := len(s) for i := 0; i &lt; length; i += 2 * k &#123; // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if i + k &lt;= length &#123; reverse(ss[i:i+k]) &#125; else &#123; reverse(ss[i:length]) &#125; &#125; return string(ss)&#125;func reverse(b []byte) &#123; left := 0 right := len(b) - 1 for left &lt; right &#123; b[left], b[right] = b[right], b[left] left++ right-- &#125;&#125;#JavaScript: 卡码网：54.替换数字建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。 题目链接&#x2F;文章讲解：替换数字 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main()&#123; var strByte []byte fmt.Scanln(&amp;strByte) for i := 0; i &lt; len(strByte); i++&#123; if strByte[i] &lt;= &#x27;9&#x27; &amp;&amp; strByte[i] &gt;= &#x27;0&#x27; &#123; inserElement := []byte&#123;&#x27;n&#x27;,&#x27;u&#x27;,&#x27;m&#x27;,&#x27;b&#x27;,&#x27;e&#x27;,&#x27;r&#x27;&#125; strByte = append(strByte[:i], append(inserElement, strByte[i+1:]...)...) i = i + len(inserElement) -1 &#125; &#125; fmt.Printf(string(strByte))&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 6  哈希表 part01","slug":"arl/代码随想录 day 6  哈希表 part01","date":"2025-01-05T14:22:36.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2025-01-05-69753cd7e9a4.html","link":"","permalink":"https://leiqi.top/2025-01-05-69753cd7e9a4.html","excerpt":"","text":"第三章 哈希表part01今日任务● 哈希表理论基础 ● 242.有效的字母异位词 ● 349. 两个数组的交集 ● 202. 快乐数 ● 1. 两数之和 详细布置哈希表理论基础建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。 什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。 文章讲解：https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 242.有效的字母异位词建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。 题目链接&#x2F;文章讲解&#x2F;视频讲解： https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html 12345678910111213func isAnagram(s string, t string) bool &#123; record := [26]int&#123;&#125; for _, r := range s &#123; record[r-rune(&#x27;a&#x27;)]++ &#125; for _, r := range t &#123; record[r-rune(&#x27;a&#x27;)]-- &#125; return record == [26]int&#123;&#125; // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。&#125; 349. 两个数组的交集建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html 12345678910111213141516171819func intersection(nums1 []int, nums2 []int) []int &#123; count1 := make([]int, 1001, 1001) count2 := make([]int, 1001, 1001) res := make([]int, 0) for _, v := range nums1 &#123; count1[v] = 1 &#125; for _, v := range nums2 &#123; count2[v] = 1 &#125; for i := 0; i &lt;= 1000; i++ &#123; if count1[i] + count2[i] == 2 &#123; res = append(res, i) &#125; &#125; return res&#125; 202. 快乐数建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子 题目链接&#x2F;文章讲解：https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html 12345678910111213141516func isHappy(n int) bool &#123; m := make(map[int]bool) for n != 1 &amp;&amp; !m[n] &#123; n, m[n] = getSum(n), true &#125; return n == 1&#125;func getSum(n int) int &#123; sum := 0 for n &gt; 0 &#123; sum += (n % 10) * (n % 10) n = n / 10 &#125; return sum&#125; 1. 两数之和建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。 建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html 123456789101112// 暴力解法func twoSum(nums []int, target int) []int &#123; for k1, _ := range nums &#123; for k2 := k1 + 1; k2 &lt; len(nums); k2++ &#123; if target == nums[k1] + nums[k2] &#123; return []int&#123;k1, k2&#125; &#125; &#125; &#125; return []int&#123;&#125;&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 4  链表 part02","slug":"arl/代码随想录 day 4  链表 part02","date":"2025-01-05T14:19:48.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2025-01-05-1621131dcfb5.html","link":"","permalink":"https://leiqi.top/2025-01-05-1621131dcfb5.html","excerpt":"","text":"第二章 链表part02今日任务详细布置24. 两两交换链表中的节点用虚拟头结点，这样会方便很多。 本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。 题目链接&#x2F;文章讲解&#x2F;视频讲解： https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html 123456789101112131415161718192021func swapPairs(head *ListNode) *ListNode &#123; dummy := &amp;ListNode&#123; Next: head, &#125; //head=list[i] //pre=list[i-1] pre := dummy for head != nil &amp;&amp; head.Next != nil &#123; pre.Next = head.Next next := head.Next.Next head.Next.Next = head head.Next = next //pre=list[(i+2)-1] pre = head //head=list[(i+2)] head = next &#125; return dummy.Next&#125; 19.删除链表的倒数第N个节点双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html 12345678910111213141516171819202122/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; dummyNode := &amp;ListNode&#123;0, head&#125; fast, slow := dummyNode, dummyNode for i := 0; i &lt;= n; i++ &#123; // 注意&lt;=，否则快指针为空时，慢指针正好在倒数第n个上面 fast = fast.Next &#125; for fast != nil &#123; fast = fast.Next slow = slow.Next &#125; slow.Next = slow.Next.Next return dummyNode.Next&#125; 面试题 02.07. 链表相交本题没有视频讲解，大家注意 数值相同，不代表指针相同。 题目链接&#x2F;文章讲解：https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html 12345678910111213141516171819func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; l1,l2 := headA, headB for l1 != l2 &#123; if l1 != nil &#123; l1 = l1.Next &#125; else &#123; l1 = headB &#125; if l2 != nil &#123; l2 = l2.Next &#125; else &#123; l2 = headA &#125; &#125; return l1&#125; 142.环形链表II算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html 12345678910111213141516func detectCycle(head *ListNode) *ListNode &#123; slow, fast := head, head for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next if slow == fast &#123; for slow != head &#123; slow = slow.Next head = head.Next &#125; return head &#125; &#125; return nil&#125; 总结对于链表的题目，大家最大的困惑可能就是 什么使用用虚拟头结点，什么时候不用虚拟头结点？ 一般涉及到 增删改操作，用虚拟头结点都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。 当然大家也可以为了方便记忆，统一都用虚拟头结点。 https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 3  链表 part01","slug":"arl/代码随想录 day 3  链表 part01","date":"2025-01-05T14:16:31.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-78490681613a.html","link":"","permalink":"https://leiqi.top/2025-01-05-78490681613a.html","excerpt":"","text":"第二章 链表part01day1 任务以及具体安排：https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY day 2 任务以及具体安排：https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG 今日任务● 链表理论基础 ● 203.移除链表元素 ● 707.设计链表 ● 206.反转链表 详细布置链表理论基础建议：了解一下链表基础，以及链表和数组的区别 文章链接：https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 203.移除链表元素建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。 题目链接&#x2F;文章讲解&#x2F;视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html 12345678910111213141516171819202122/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeElements(head *ListNode, val int) *ListNode &#123; dummyHead := &amp;ListNode&#123;&#125; dummyHead.Next = head cur := dummyHead for cur != nil &amp;&amp; cur.Next != nil &#123; if cur.Next.Val == val &#123; cur.Next = cur.Next.Next &#125; else &#123; cur = cur.Next &#125; &#125; return dummyHead.Next&#125; 707.设计链表建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//单链表实现package mainimport ( &quot;fmt&quot;)type SingleNode struct &#123; Val int // 节点的值 Next *SingleNode // 下一个节点的指针&#125;type MyLinkedList struct &#123; dummyHead *SingleNode // 虚拟头节点 Size int // 链表大小&#125;func main() &#123; list := Constructor() // 初始化链表 list.AddAtHead(100) // 在头部添加元素 list.AddAtTail(242) // 在尾部添加元素 list.AddAtTail(777) // 在尾部添加元素 list.AddAtIndex(1, 99999) // 在指定位置添加元素 list.printLinkedList() // 打印链表&#125;/** Initialize your data structure here. */func Constructor() MyLinkedList &#123; newNode := &amp;SingleNode&#123; // 创建新节点 -999, nil, &#125; return MyLinkedList&#123; // 返回链表 dummyHead: newNode, Size: 0, &#125;&#125;/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */func (this *MyLinkedList) Get(index int) int &#123; /*if this != nil || index &lt; 0 || index &gt; this.Size &#123; return -1 &#125;*/ if this == nil || index &lt; 0 || index &gt;= this.Size &#123; // 如果索引无效则返回-1 return -1 &#125; // 让cur等于真正头节点 cur := this.dummyHead.Next // 设置当前节点为真实头节点 for i := 0; i &lt; index; i++ &#123; // 遍历到索引所在的节点 cur = cur.Next &#125; return cur.Val // 返回节点值&#125;/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */func (this *MyLinkedList) AddAtHead(val int) &#123; // 以下两行代码可用一行代替 // newNode := new(SingleNode) // newNode.Val = val newNode := &amp;SingleNode&#123;Val: val&#125; // 创建新节点 newNode.Next = this.dummyHead.Next // 新节点指向当前头节点 this.dummyHead.Next = newNode // 新节点变为头节点 this.Size++ // 链表大小增加1&#125;/** Append a node of value val to the last element of the linked list. */func (this *MyLinkedList) AddAtTail(val int) &#123; newNode := &amp;SingleNode&#123;Val: val&#125; // 创建新节点 cur := this.dummyHead // 设置当前节点为虚拟头节点 for cur.Next != nil &#123; // 遍历到最后一个节点 cur = cur.Next &#125; cur.Next = newNode // 在尾部添加新节点 this.Size++ // 链表大小增加1&#125;/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */func (this *MyLinkedList) AddAtIndex(index int, val int) &#123; if index &lt; 0 &#123; // 如果索引小于0，设置为0 index = 0 &#125; else if index &gt; this.Size &#123; // 如果索引大于链表长度，直接返回 return &#125; newNode := &amp;SingleNode&#123;Val: val&#125; // 创建新节点 cur := this.dummyHead // 设置当前节点为虚拟头节点 for i := 0; i &lt; index; i++ &#123; // 遍历到指定索引的前一个节点 cur = cur.Next &#125; newNode.Next = cur.Next // 新节点指向原索引节点 cur.Next = newNode // 原索引的前一个节点指向新节点 this.Size++ // 链表大小增加1&#125;/** Delete the index-th node in the linked list, if the index is valid. */func (this *MyLinkedList) DeleteAtIndex(index int) &#123; if index &lt; 0 || index &gt;= this.Size &#123; // 如果索引无效则直接返回 return &#125; cur := this.dummyHead // 设置当前节点为虚拟头节点 for i := 0; i &lt; index; i++ &#123; // 遍历到要删除节点的前一个节点 cur = cur.Next &#125; if cur.Next != nil &#123; cur.Next = cur.Next.Next // 当前节点直接指向下下个节点，即删除了下一个节点 &#125; this.Size-- // 注意删除节点后应将链表大小减一&#125;// 打印链表func (list *MyLinkedList) printLinkedList() &#123; cur := list.dummyHead // 设置当前节点为虚拟头节点 for cur.Next != nil &#123; // 遍历链表 fmt.Println(cur.Next.Val) // 打印节点值 cur = cur.Next // 切换到下一个节点 &#125;&#125; 206.反转链表建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html 12345678910111213141516171819202122232425262728//双指针func reverseList(head *ListNode) *ListNode &#123; var pre *ListNode cur := head for cur != nil &#123; next := cur.Next cur.Next = pre pre = cur cur = next &#125; return pre&#125;//递归func reverseList(head *ListNode) *ListNode &#123; return help(nil, head)&#125;func help(pre, head *ListNode)*ListNode&#123; if head == nil &#123; return pre &#125; next := head.Next head.Next = pre return help(head, next)&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"day63 总结","slug":"arl/day63 总结","date":"2025-01-05T14:11:59.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2025-01-05-363590304609.html","link":"","permalink":"https://leiqi.top/2025-01-05-363590304609.html","excerpt":"","text":"总结的一句话就是：唯手熟尔，专业知识还要不断精深，代码能力需要不断的增强，然后还要不断的提升架构设计能力。","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day62 第十一章 图论part11","slug":"arl/代码随想录 day62 第十一章 图论part11","date":"2025-01-05T14:08:53.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-28ad0b8af774.html","link":"","permalink":"https://leiqi.top/2025-01-05-28ad0b8af774.html","excerpt":"","text":"第十一章：图论part11Floyd 算法精讲Floyd 算法代码很简单，但真正理解起原理 还是需要花点功夫，大家在看代码的时候，会发现 Floyd 的代码很简单，甚至看一眼就背下来了，但我为了讲清楚原理，本篇还是花了大篇幅来讲解。 https://www.programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html 123456789101112131415161718192021222324252627if __name__ == &#x27;__main__&#x27;: max_int = 10005 # 设置最大路径，因为边最大距离为10^4 n, m = map(int, input().split()) grid = [[[max_int] * (n+1) for _ in range(n+1)] for _ in range(n+1)] # 初始化三维dp数组 for _ in range(m): p1, p2, w = map(int, input().split()) grid[p1][p2][0] = w grid[p2][p1][0] = w # 开始floyd for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): grid[i][j][k] = min(grid[i][j][k-1], grid[i][k][k-1] + grid[k][j][k-1]) # 输出结果 z = int(input()) for _ in range(z): start, end = map(int, input().split()) if grid[start][end][n] == max_int: print(-1) else: print(grid[start][end][n]) A * 算法精讲 （A star算法）一般 笔试或者 面试的时候，不会考察A， 都是会结合具体业务场景问 A算法，例如：地图导航，游戏开发 等等。 其实基础版的A* 并不难，所以大家不要畏惧，理解本篇内容，甚至独立写出代码，大家可以做到，加油 https://www.programmercarl.com/kamacoder/0126.%E9%AA%91%E5%A3%AB%E7%9A%84%E6%94%BB%E5%87%BBastar.html 123456789101112131415161718192021222324252627282930import heapq n = int(input()) moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)] def distance(a, b): return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5 def bfs(start, end): q = [(distance(start, end), start)] step = &#123;start: 0&#125; while q: d, cur = heapq.heappop(q) if cur == end: return step[cur] for move in moves: new = (move[0] + cur[0], move[1] + cur[1]) if 1 &lt;= new[0] &lt;= 1000 and 1 &lt;= new[1] &lt;= 1000: step_new = step[cur] + 1 if step_new &lt; step.get(new, float(&#x27;inf&#x27;)): step[new] = step_new heapq.heappush(q, (distance(new, end) + step_new, new)) return False for _ in range(n): a1, a2, b1, b2 = map(int, input().split()) print(bfs((a1, a2), (b1, b2))) 最短路算法总结篇最各个最短路算法有个全面的了解 https://www.programmercarl.com/kamacoder/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html 如果遇到单源且边为正数，直接Dijkstra。 至于 使用朴素版还是 堆优化版 还是取决于图的稠密度， 多少节点多少边算是稠密图，多少算是稀疏图，这个没有量化，如果想量化只能写出两个版本然后做实验去测试，不同的判题机得出的结果还不太一样。 一般情况下，可以直接用堆优化版本。 如果遇到单源边可为负数，直接 Bellman-Ford，同样 SPFA 还是 Bellman-Ford 取决于图的稠密度。 一般情况下，直接用 SPFA。 如果有负权回路，优先 Bellman-Ford， 如果是有限节点最短路 也优先 Bellman-Ford，理由是写代码比较方便。 如果是遇到多源点求最短路，直接 Floyd。 图论总结https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93%E7%AF%87.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day59 第十一章 图论part09","slug":"arl/代码随想录 day59 第十一章 图论part09","date":"2025-01-05T14:02:10.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-5314163e2a3e.html","link":"","permalink":"https://leiqi.top/2025-01-05-5314163e2a3e.html","excerpt":"","text":"第十一章：图论part09今天的建议依然是，一刷的时候，能了解 原理，照着代码随想录能抄下来代码就好，就算达标。 二刷的时候自己尝试独立去写，三刷的时候 才能有一定深度理解各个最短路算法。 dijkstra（堆优化版）精讲https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport ( &quot;container/heap&quot; &quot;fmt&quot; &quot;math&quot;)// Edge 表示带权重的边type Edge struct &#123; to, val int&#125;// PriorityQueue 实现一个小顶堆type Item struct &#123; node, dist int&#125;type PriorityQueue []*Itemfunc (pq PriorityQueue) Len() int &#123; return len(pq) &#125;func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].dist &lt; pq[j].dist&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i]&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; *pq = append(*pq, x.(*Item))&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] *pq = old[0 : n-1] return item&#125;func dijkstra(n, m int, edges [][]int, start, end int) int &#123; grid := make([][]Edge, n+1) for _, edge := range edges &#123; p1, p2, val := edge[0], edge[1], edge[2] grid[p1] = append(grid[p1], Edge&#123;to: p2, val: val&#125;) &#125; minDist := make([]int, n+1) for i := range minDist &#123; minDist[i] = math.MaxInt64 &#125; visited := make([]bool, n+1) pq := &amp;PriorityQueue&#123;&#125; heap.Init(pq) heap.Push(pq, &amp;Item&#123;node: start, dist: 0&#125;) minDist[start] = 0 for pq.Len() &gt; 0 &#123; cur := heap.Pop(pq).(*Item) if visited[cur.node] &#123; continue &#125; visited[cur.node] = true for _, edge := range grid[cur.node] &#123; if !visited[edge.to] &amp;&amp; minDist[cur.node]+edge.val &lt; minDist[edge.to] &#123; minDist[edge.to] = minDist[cur.node] + edge.val heap.Push(pq, &amp;Item&#123;node: edge.to, dist: minDist[edge.to]&#125;) &#125; &#125; &#125; if minDist[end] == math.MaxInt64 &#123; return -1 &#125; return minDist[end]&#125;func main() &#123; var n, m int fmt.Scan(&amp;n, &amp;m) edges := make([][]int, m) for i := 0; i &lt; m; i++ &#123; var p1, p2, val int fmt.Scan(&amp;p1, &amp;p2, &amp;val) edges[i] = []int&#123;p1, p2, val&#125; &#125; start := 1 // 起点 end := n // 终点 result := dijkstra(n, m, edges, start, end) fmt.Println(result)&#125; Bellman_ford 算法精讲https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html 123456789101112131415161718192021222324252627def main(): n, m = map(int, input().strip().split()) edges = [] for _ in range(m): src, dest, weight = map(int, input().strip().split()) edges.append([src, dest, weight]) minDist = [float(&quot;inf&quot;)] * (n + 1) minDist[1] = 0 # 起点处距离为0 for i in range(1, n): updated = False for src, dest, weight in edges: if minDist[src] != float(&quot;inf&quot;) and minDist[src] + weight &lt; minDist[dest]: minDist[dest] = minDist[src] + weight updated = True if not updated: # 若边不再更新，即停止回圈 break if minDist[-1] == float(&quot;inf&quot;): # 返还终点权重 return &quot;unconnected&quot; return minDist[-1] if __name__ == &quot;__main__&quot;: print(main())","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day58 第十一章 图论part08","slug":"arl/代码随想录 day58 第十一章 图论part08","date":"2025-01-05T14:00:15.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-e90cac159cd5.html","link":"","permalink":"https://leiqi.top/2025-01-05-e90cac159cd5.html","excerpt":"","text":"第十一章：图论part08拓扑排序精讲拓扑排序看上去很复杂，其实了解其原理之后，代码不难 https://www.programmercarl.com/kamacoder/0117.%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA.html 1234567891011121314151617181920212223242526272829303132333435from collections import deque, defaultdictdef topological_sort(n, edges): inDegree = [0] * n # inDegree 记录每个文件的入度 umap = defaultdict(list) # 记录文件依赖关系 # 构建图和入度表 for s, t in edges: inDegree[t] += 1 umap[s].append(t) # 初始化队列，加入所有入度为0的节点 queue = deque([i for i in range(n) if inDegree[i] == 0]) result = [] while queue: cur = queue.popleft() # 当前选中的文件 result.append(cur) for file in umap[cur]: # 获取该文件指向的文件 inDegree[file] -= 1 # cur的指向的文件入度-1 if inDegree[file] == 0: queue.append(file) if len(result) == n: print(&quot; &quot;.join(map(str, result))) else: print(-1)if __name__ == &quot;__main__&quot;: n, m = map(int, input().split()) edges = [tuple(map(int, input().split())) for _ in range(m)] topological_sort(n, edges) dijkstra（朴素版）精讲后面几天都是最短路系列了，对于最短路系列，我的建议是，如果第一次接触最短路算法的话，能看懂原理，能照着代码随想录把代码抄下来就可以了，二刷的时候 再尝试自己去写出来。 三刷的时候，差不多才能把最短路吃透。 对于一刷的录友们，不要强行去逼迫自己去学透，很难刚接触到最短路算法就学透。 https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E6%9C%B4%E7%B4%A0.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import sysdef dijkstra(n, m, edges, start, end): # 初始化邻接矩阵 grid = [[float(&#x27;inf&#x27;)] * (n + 1) for _ in range(n + 1)] for p1, p2, val in edges: grid[p1][p2] = val # 初始化距离数组和访问数组 minDist = [float(&#x27;inf&#x27;)] * (n + 1) visited = [False] * (n + 1) minDist[start] = 0 # 起始点到自身的距离为0 for _ in range(1, n + 1): # 遍历所有节点 minVal = float(&#x27;inf&#x27;) cur = -1 # 选择距离源点最近且未访问过的节点 for v in range(1, n + 1): if not visited[v] and minDist[v] &lt; minVal: minVal = minDist[v] cur = v if cur == -1: # 如果找不到未访问过的节点，提前结束 break visited[cur] = True # 标记该节点已被访问 # 更新未访问节点到源点的距离 for v in range(1, n + 1): if not visited[v] and grid[cur][v] != float(&#x27;inf&#x27;) and minDist[cur] + grid[cur][v] &lt; minDist[v]: minDist[v] = minDist[cur] + grid[cur][v] return -1 if minDist[end] == float(&#x27;inf&#x27;) else minDist[end]if __name__ == &quot;__main__&quot;: input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) edges = [] index = 2 for _ in range(m): p1 = int(data[index]) p2 = int(data[index + 1]) val = int(data[index + 2]) edges.append((p1, p2, val)) index += 3 start = 1 # 起点 end = n # 终点 result = dijkstra(n, m, edges, start, end) print(result)","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day57 第十一章 图论part07","slug":"arl/代码随想录 day57 第十一章 图论part07","date":"2025-01-05T13:53:42.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-a0b5241802ae.html","link":"","permalink":"https://leiqi.top/2025-01-05-a0b5241802ae.html","excerpt":"","text":"第十一章：图论part07今天在学习prim 和 kruskal的同时，也要清楚这两个算法的区别所在。 prim算法精讲https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html 123456789101112131415161718192021222324252627282930313233# 接收输入v, e = list(map(int, input().strip().split()))# 按照常规的邻接矩阵存储图信息，不可达的初始化为10001graph = [[10001] * (v+1) for _ in range(v+1)]for _ in range(e): x, y, w = list(map(int, input().strip().split())) graph[x][y] = w graph[y][x] = w# 定义加入生成树的标记数组和未加入生成树的最近距离visited = [False] * (v + 1)minDist = [10001] * (v + 1)# 循环 n - 1 次，建立 n - 1 条边# 从节点视角来看：每次选中一个节点加入树，更新剩余的节点到树的最短距离，# 这一步其实蕴含了确定下一条选取的边，计入总路程 ans 的计算for _ in range(1, v + 1): min_val = 10002 cur = -1 for j in range(1, v + 1): if visited[j] == False and minDist[j] &lt; min_val: cur = j min_val = minDist[j] visited[cur] = True for j in range(1, v + 1): if visited[j] == False and minDist[j] &gt; graph[cur][j]: minDist[j] = graph[cur][j]ans = 0for i in range(2, v + 1): ans += minDist[i]print(ans) kruskal算法精讲https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Edge: def __init__(self, l, r, val): self.l = l self.r = r self.val = valn = 10001father = list(range(n))def init(): global father father = list(range(n))def find(u): if u != father[u]: father[u] = find(father[u]) return father[u]def join(u, v): u = find(u) v = find(v) if u != v: father[v] = udef kruskal(v, edges): edges.sort(key=lambda edge: edge.val) init() result_val = 0 for edge in edges: x = find(edge.l) y = find(edge.r) if x != y: result_val += edge.val join(x, y) return result_valif __name__ == &quot;__main__&quot;: import sys input = sys.stdin.read data = input().split() v = int(data[0]) e = int(data[1]) edges = [] index = 2 for _ in range(e): v1 = int(data[index]) v2 = int(data[index + 1]) val = int(data[index + 2]) edges.append(Edge(v1, v2, val)) index += 3 result_val = kruskal(v, edges) print(result_val)","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day56 第十一章 图论part056","slug":"arl/代码随想录 day56 第十一章 图论part056","date":"2025-01-05T13:47:28.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-fcd714ee88f8.html","link":"","permalink":"https://leiqi.top/2025-01-05-fcd714ee88f8.html","excerpt":"","text":"第十一章：图论part06108. 冗余连接并查集应用类题目，关键是如何把题意转化成并查集问题 https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html 1234567891011121314151617181920212223242526272829303132333435363738father = list()def find(u): if u == father[u]: return u else: father[u] = find(father[u]) return father[u] def is_same(u, v): u = find(u) v = find(v) return u == v def join(u, v): u = find(u) v = find(v) if u != v: father[u] = v if __name__ == &quot;__main__&quot;: # 輸入 n = int(input()) for i in range(n + 1): father.append(i) # 尋找冗余邊 result = None for i in range(n): s, t = map(int, input().split()) if is_same(s, t): result = str(s) + &#x27; &#x27; + str(t) else: join(s, t) # 輸出 print(result) 109. 冗余连接II上面两道题目是不是感觉做出自信了，感觉并查集不过如此？ 来这道题目 给大家适当一些打击， 难度上来了。 https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from collections import defaultdictfather = list()def find(u): if u == father[u]: return u else: father[u] = find(father[u]) return father[u] def is_same(u, v): u = find(u) v = find(v) return u == v def join(u, v): u = find(u) v = find(v) if u != v: father[u] = v def is_tree_after_remove_edge(edges, edge, n): # 初始化并查集 global father father = [i for i in range(n + 1)] for i in range(len(edges)): if i == edge: continue s, t = edges[i] if is_same(s, t): # 成環，即不是有向樹 return False else: # 將s,t放入集合中 join(s, t) return True def get_remove_edge(edges): # 初始化并查集 global father father = [i for i in range(n + 1)] for s, t in edges: if is_same(s, t): print(s, t) return else: join(s, t) if __name__ == &quot;__main__&quot;: # 輸入 n = int(input()) edges = list() in_degree = defaultdict(int) for i in range(n): s, t = map(int, input().split()) in_degree[t] += 1 edges.append([s, t]) # 尋找入度為2的邊，並紀錄其下標(index) vec = list() for i in range(n - 1, -1, -1): if in_degree[edges[i][1]] == 2: vec.append(i) # 輸出 if len(vec) &gt; 0: # 情況一：刪除輸出順序靠後的邊 if is_tree_after_remove_edge(edges, vec[0], n): print(edges[vec[0]][0], edges[vec[0]][1]) # 情況二：只能刪除特定的邊 else: print(edges[vec[1]][0], edges[vec[1]][1]) else: # 情況三： 原圖有環 get_remove_edge(edges)","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day55 第十一章 图论part05","slug":"arl/代码随想录 day55 第十一章 图论part05","date":"2025-01-05T13:26:28.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2025-01-05-d289514fd119.html","link":"","permalink":"https://leiqi.top/2025-01-05-d289514fd119.html","excerpt":"","text":"并查集理论基础并查集理论基础很重要，明确并查集解决什么问题，代码如何写，对后面做并查集类题目很有帮助。 https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 并查集 可以解决什么问题呢？主要有两个功能： 将两个元素添加到一个集合中 判断两个元素在不在同一个集合中 代码模板 那么此时并查集的模板就出来了， 整体模板C++代码如下： 12345678910111213141516171819202122232425262728int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好vector&lt;int&gt; father = vector&lt;int&gt; (n, 0); // C++里的一种数组结构// 并查集初始化void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125;&#125;// 并查集里寻根的过程int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩&#125;// 判断 u 和 v是否找到同一个根bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v;&#125;// 将v-&gt;u 这条边加入并查集void join(int u, int v) &#123; u = find(u); // 寻找u的根 v = find(v); // 寻找v的根 if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回 father[v] = u;&#125; 寻找存在的路径并查集裸题，学会理论基础后，本题直接可以直接刷过 https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot;)const MaxNodes = 101var n intvar father [MaxNodes]int// 初始化并查集func initialize() &#123; for i := 1; i &lt;= n; i++ &#123; father[i] = i &#125;&#125;// 并查集里寻根的过程func find(u int) int &#123; if u == father[u] &#123; return u &#125; father[u] = find(father[u]) return father[u]&#125;// 判断 u 和 v 是否找到同一个根func isSame(u, v int) bool &#123; return find(u) == find(v)&#125;// 将 v-&gt;u 这条边加入并查集func join(u, v int) &#123; rootU := find(u) rootV := find(v) if rootU != rootV &#123; father[rootV] = rootU &#125;&#125;func main() &#123; var m, s, t, source, destination int fmt.Scan(&amp;n, &amp;m) initialize() for i := 0; i &lt; m; i++ &#123; fmt.Scan(&amp;s, &amp;t) join(s, t) &#125; fmt.Scan(&amp;source, &amp;destination) if isSame(source, destination) &#123; fmt.Println(1) &#125; else &#123; fmt.Println(0) &#125;&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day52 第十一章 图论part03","slug":"arl/代码随想录 day52 第十一章 图论part03","date":"2024-12-22T17:35:07.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-22-c7c9bbc04318.html","link":"","permalink":"https://leiqi.top/2024-12-22-c7c9bbc04318.html","excerpt":"","text":"第十一章：图论part03101. 孤岛的总面积基础题目 可以自己尝试做一做 。 https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( &quot;fmt&quot;)var count intvar dir = [4][2]int&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125; // 四个方向func bfs(grid [][]int, x, y int) &#123; queue := [][2]int&#123;&#123;x, y&#125;&#125; grid[x][y] = 0 // 只要加入队列，立刻标记 count++ for len(queue) &gt; 0 &#123; cur := queue[0] queue = queue[1:] curx, cury := cur[0], cur[1] for i := 0; i &lt; 4; i++ &#123; nextx := curx + dir[i][0] nexty := cury + dir[i][1] if nextx &lt; 0 || nextx &gt;= len(grid) || nexty &lt; 0 || nexty &gt;= len(grid[0]) &#123; continue // 越界了，直接跳过 &#125; if grid[nextx][nexty] == 1 &#123; queue = append(queue, [2]int&#123;nextx, nexty&#125;) count++ grid[nextx][nexty] = 0 // 只要加入队列立刻标记 &#125; &#125; &#125;&#125;func main() &#123; var n, m int fmt.Scan(&amp;n, &amp;m) grid := make([][]int, n) for i := range grid &#123; grid[i] = make([]int, m) &#125; for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; fmt.Scan(&amp;grid[i][j]) &#125; &#125; // 从左侧边，和右侧边向中间遍历 for i := 0; i &lt; n; i++ &#123; if grid[i][0] == 1 &#123; bfs(grid, i, 0) &#125; if grid[i][m-1] == 1 &#123; bfs(grid, i, m-1) &#125; &#125; // 从上边和下边向中间遍历 for j := 0; j &lt; m; j++ &#123; if grid[0][j] == 1 &#123; bfs(grid, 0, j) &#125; if grid[n-1][j] == 1 &#123; bfs(grid, n-1, j) &#125; &#125; // 清空之前的计数 count = 0 // 遍历所有位置 for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; if grid[i][j] == 1 &#123; bfs(grid, i, j) &#125; &#125; &#125; fmt.Println(count)&#125; 102. 沉没孤岛和上一题差不多，尝试自己做做 https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html 103. 水流问题需要点优化思路，建议先自己读题，相处一个解题方法，有时间就自己写代码，没时间就直接看题解，优化方式 会让你 耳目一新。 https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html 104.建造最大岛屿同样优化思路也会让你耳目一新，自己想比较难想出来。 https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day51 第十一章 图论part02","slug":"arl/代码随想录 day51 第十一章 图论part02","date":"2024-12-22T17:34:38.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-22-4fb27f021208.html","link":"","permalink":"https://leiqi.top/2024-12-22-4fb27f021208.html","excerpt":"","text":"第十一章：图论part0299. 岛屿数量 深搜注意深搜的两种写法，熟练掌握这两种写法 以及 知道区别在哪里，才算掌握的深搜。 https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html 99. 岛屿数量 广搜注意广搜的两种写法，第一种写法为什么会超时， 如果自己做的录友，题目通过了，也要仔细看第一种写法的超时版本，弄清楚为什么会超时，因为你第一次 幸运 没那么想，第二次可就不一定了。 https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot;)var dir = [4][2]int&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125; // 四个方向func dfs(grid [][]int, visited [][]bool, x, y int) &#123; for i := 0; i &lt; 4; i++ &#123; nextx := x + dir[i][0] nexty := y + dir[i][1] if nextx &lt; 0 || nextx &gt;= len(grid) || nexty &lt; 0 || nexty &gt;= len(grid[0]) &#123; continue // 越界了，直接跳过 &#125; if !visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1 &#123; // 没有访问过的 同时 是陆地的 visited[nextx][nexty] = true dfs(grid, visited, nextx, nexty) &#125; &#125;&#125;func main() &#123; reader := bufio.NewReader(os.Stdin) var n, m int fmt.Scanf(&quot;%d %d&quot;, &amp;n, &amp;m) grid := make([][]int, n) for i := 0; i &lt; n; i++ &#123; grid[i] = make([]int, m) line, _ := reader.ReadString(&#x27;\\n&#x27;) line = strings.TrimSpace(line) elements := strings.Split(line, &quot; &quot;) for j := 0; j &lt; m; j++ &#123; grid[i][j], _ = strconv.Atoi(elements[j]) &#125; &#125; visited := make([][]bool, n) for i := 0; i &lt; n; i++ &#123; visited[i] = make([]bool, m) &#125; result := 0 for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; if !visited[i][j] &amp;&amp; grid[i][j] == 1 &#123; visited[i][j] = true result++ // 遇到没访问过的陆地，+1 dfs(grid, visited, i, j) // 将与其链接的陆地都标记上 true &#125; &#125; &#125; fmt.Println(result)&#125; 100. 岛屿的最大面积本题就是基础题了，做过上面的题目，本题很快。 https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot;)var count intvar dir = [][]int&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125; // 四个方向func dfs(grid [][]int, visited [][]bool, x, y int) &#123; for i := 0; i &lt; 4; i++ &#123; nextx := x + dir[i][0] nexty := y + dir[i][1] if nextx &lt; 0 || nextx &gt;= len(grid) || nexty &lt; 0 || nexty &gt;= len(grid[0]) &#123; continue // 越界了，直接跳过 &#125; if !visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1 &#123; // 没有访问过的 同时 是陆地的 visited[nextx][nexty] = true count++ dfs(grid, visited, nextx, nexty) &#125; &#125;&#125;func main() &#123; var n, m int fmt.Scan(&amp;n, &amp;m) grid := make([][]int, n) for i := 0; i &lt; n; i++ &#123; grid[i] = make([]int, m) for j := 0; j &lt; m; j++ &#123; fmt.Scan(&amp;grid[i][j]) &#125; &#125; visited := make([][]bool, n) for i := 0; i &lt; n; i++ &#123; visited[i] = make([]bool, m) &#125; result := 0 for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; if !visited[i][j] &amp;&amp; grid[i][j] == 1 &#123; count = 1 // 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地 visited[i][j] = true dfs(grid, visited, i, j) if count &gt; result &#123; result = count &#125; &#125; &#125; &#125; fmt.Println(result)&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day50 第十一章 图论part01","slug":"arl/代码随想录 day50 第十一章 图论part01","date":"2024-12-22T16:56:29.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-22-0ec5317ca5c4.html","link":"","permalink":"https://leiqi.top/2024-12-22-0ec5317ca5c4.html","excerpt":"","text":"第十一章：图论part01图论理论基础大家可以在看图论理论基础的时候，很多内容 看不懂，例如也不知道 看完之后 还是不知道 邻接矩阵，邻接表怎么用， 别着急。 理论基础大家先对各个概念有个印象就好，后面在刷题的过程中，每个知识点都会得到巩固。 https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 深搜理论基础了解一下深搜的原理和过程 https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 可以使用邻接矩阵来表示图邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。 例如： grid[2][5] &#x3D; 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。 如果想表示无向图，即：grid[2][5] &#x3D; 6，grid[5][2] &#x3D; 6，表示节点2 与 节点5 相互连通，权值为6。 如图： 在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。 98. 所有可达路径https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot;)var result [][]int // 收集符合条件的路径var path []int // 1节点到终点的路径func dfs(graph [][]int, x, n int) &#123; // 当前遍历的节点x 到达节点n if x == n &#123; // 找到符合条件的一条路径 temp := make([]int, len(path)) copy(temp, path) result = append(result, temp) return &#125; for i := 1; i &lt;= n; i++ &#123; // 遍历节点x链接的所有节点 if graph[x][i] == 1 &#123; // 找到 x链接的节点 path = append(path, i) // 遍历到的节点加入到路径中来 dfs(graph, i, n) // 进入下一层递归 path = path[:len(path)-1] // 回溯，撤销本节点 &#125; &#125;&#125;func main() &#123; var n, m int fmt.Scanf(&quot;%d %d&quot;, &amp;n, &amp;m) // 节点编号从1到n，所以申请 n+1 这么大的数组 graph := make([][]int, n+1) for i := range graph &#123; graph[i] = make([]int, n+1) &#125; for i := 0; i &lt; m; i++ &#123; var s, t int fmt.Scanf(&quot;%d %d&quot;, &amp;s, &amp;t) // 使用邻接矩阵表示无向图，1 表示 s 与 t 是相连的 graph[s][t] = 1 &#125; path = append(path, 1) // 无论什么路径已经是从1节点出发 dfs(graph, 1, n) // 开始遍历 // 输出结果 if len(result) == 0 &#123; fmt.Println(-1) &#125; else &#123; for _, pa := range result &#123; for i := 0; i &lt; len(pa)-1; i++ &#123; fmt.Print(pa[i], &quot; &quot;) &#125; fmt.Println(pa[len(pa)-1]) &#125; &#125;&#125; 广搜理论基础https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 广搜（bfs）是一圈一圈的搜索过程，和深搜（dfs）是一条路跑到黑然后再回溯。 广搜的搜索方式就适合于解决两个点之间的最短路径问题。 因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。 当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day49 第十章 单调栈 part02","slug":"arl/代码随想录 day49 第十章 单调栈 part02","date":"2024-12-22T16:25:11.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-22-e7d0274fb533.html","link":"","permalink":"https://leiqi.top/2024-12-22-e7d0274fb533.html","excerpt":"","text":"第十章 单调栈part0242. 接雨水接雨水这道题目是 面试中特别高频的一道题，也是单调栈 应用的题目，大家好好做做。 建议是掌握 双指针 和单调栈，因为在面试中 写出单调栈可能 有点难度，但双指针思路更直接一些。 在时间紧张的情况有，能写出双指针法也是不错的，然后可以和面试官在慢慢讨论如何优化。 https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html 列4 左侧最高的柱子是列3，高度为2（以下用lHeight表示）。 列4 右侧最高的柱子是列7，高度为3（以下用rHeight表示）。 列4 柱子的高度为1（以下用height表示） 那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： min(lHeight, rHeight) - height。 列4的雨水高度求出来了，宽度为1，相乘就是列4的雨水体积了。 此时求出了列4的雨水体积。 需要注意的是第一个柱子和最后一个柱子不接水 单调栈就是保持栈内元素有序。和栈与队列：单调队列 (opens new window)一样，需要我们自己维持顺序，没有现成的容器可以用。 通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。 而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。 取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]（就是图中的高度1）。 此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。 当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度3）。 此时大家应该可以发现其实就是栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！ 那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：int h = min(height[st.top()], height[i]) - height[mid]; 雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：int w = i - st.top() - 1 ; 当前凹槽雨水的体积就是：h * w。 求当前凹槽雨水的体积代码如下： 123456789101112131415161718192021222324func trap(height []int) int &#123; var left, right, leftMax, rightMax, res int right = len(height) - 1 for left &lt; right &#123; if height[left] &lt; height[right] &#123; if height[left] &gt;= leftMax &#123; leftMax = height[left] // 设置左边最高柱子 &#125; else &#123; res += leftMax - height[left] // //右边必定有柱子挡水，所以遇到所有值小于等于leftMax的，全部加入水池中 &#125; left++ &#125; else &#123; if height[right] &gt; rightMax &#123; rightMax = height[right] // //设置右边最高柱子 &#125; else &#123; res += rightMax - height[right] // //左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池 &#125; right-- &#125; &#125; return res&#125; 84. 柱状图中最大的矩形有了之前单调栈的铺垫，这道题目就不难了。 https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html 12345678910111213141516171819202122232425262728293031func largestRectangleArea(heights []int) int &#123; max := 0 // 使用切片实现栈 stack := make([]int, 0) // 数组头部加入0 heights = append([]int&#123;0&#125;, heights...) // 数组尾部加入0 heights = append(heights, 0) // 初始化栈，序号从0开始 stack = append(stack, 0) for i := 1; i &lt; len(heights); i ++ &#123; // 结束循环条件为：当即将入栈元素&gt;top元素，也就是形成非单调递增的趋势 for heights[stack[len(stack) - 1]] &gt; heights[i] &#123; // mid 是top mid := stack[len(stack) - 1] // 出栈 stack = stack[0 : len(stack) - 1] // left是top的下一位元素，i是将要入栈的元素 left := stack[len(stack) - 1] // 高度x宽度 tmp := heights[mid] * (i - left - 1) if tmp &gt; max &#123; max = tmp &#125; &#125; stack = append(stack, i) &#125; return max&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day53 第11章 图论part04","slug":"arl/代码随想录 day53 第11章 图论part04","date":"2024-12-22T15:48:48.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-22-c8ce87131dd0.html","link":"","permalink":"https://leiqi.top/2024-12-22-c8ce87131dd0.html","excerpt":"","text":"第十一章：图论part04经过上面的练习，大家可能会感觉 广搜不过如此，都刷出自信了，本题让大家初步感受一下，广搜难不在广搜本身，而是如何应用广搜。 https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ladderLength 实现 BFS 查找最短路径长度func ladderLength(beginWord, endWord string, wordList []string) int &#123; wordSet := make(map[string]struct&#123;&#125;) for _, word := range wordList &#123; wordSet[word] = struct&#123;&#125;&#123;&#125; &#125; if _, exists := wordSet[endWord]; !exists &#123; return 0 &#125; queue := []string&#123;beginWord&#125; visitMap := make(map[string]int) visitMap[beginWord] = 1 for len(queue) &gt; 0 &#123; currentWord := queue[0] queue = queue[1:] path := visitMap[currentWord] for i := 0; i &lt; len(currentWord); i++ &#123; chars := []rune(currentWord) for ch := &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ch++ &#123; chars[i] = ch newWord := string(chars) if newWord == endWord &#123; return path + 1 &#125; if _, exists := wordSet[newWord]; exists &#123; if _, visited := visitMap[newWord]; !visited &#123; visitMap[newWord] = path + 1 queue = append(queue, newWord) &#125; &#125; &#125; &#125; &#125; return 0&#125; 深搜有细节，同样是深搜两种写法的区别，以及什么时候需要回溯操作呢？ https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html 1234567891011121314151617181920212223242526272829303132import collectionspath = set() # 纪录 BFS 所经过之节点def bfs(root, graph): global path que = collections.deque([root]) while que: cur = que.popleft() path.add(cur) for nei in graph[cur]: que.append(nei) graph[cur] = [] returndef main(): N, K = map(int, input().strip().split()) graph = collections.defaultdict(list) for _ in range(K): src, dest = map(int, input().strip().split()) graph[src].append(dest) bfs(1, graph) if path == &#123;i for i in range(1, N + 1)&#125;: return 1 return -1 if __name__ == &quot;__main__&quot;: print(main()) 106. 岛屿的周长卡码网题目链接（ACM模式）(opens new window) 简单题，避免大家惯性思维，建议大家先独立做题。 https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html 思路： 计算出总的岛屿数，并计算相邻岛屿数目。 123456789101112131415161718192021222324252627282930313233343536373839def main(): import sys input = sys.stdin.read data = input().split() # 读取 n 和 m n = int(data[0]) m = int(data[1]) # 初始化 grid grid = [] index = 2 for i in range(n): grid.append([int(data[index + j]) for j in range(m)]) index += m sum_land = 0 # 陆地数量 cover = 0 # 相邻数量 for i in range(n): for j in range(m): if grid[i][j] == 1: sum_land += 1 # 统计上边相邻陆地 if i - 1 &gt;= 0 and grid[i - 1][j] == 1: cover += 1 # 统计左边相邻陆地 if j - 1 &gt;= 0 and grid[i][j - 1] == 1: cover += 1 # 不统计下边和右边，避免重复计算 result = sum_land * 4 - cover * 2 print(result)if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day48 第十章 单调栈 part01","slug":"arl/代码随想录 day48 第十章 单调栈 part01","date":"2024-12-16T15:44:58.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-12-16-6a0a8c08fb7c.html","link":"","permalink":"https://leiqi.top/2024-12-16-6a0a8c08fb7c.html","excerpt":"","text":"第十章 单调栈part01 每日温度 今天正式开始单调栈，这是单调栈一篇扫盲题目，也是经典题。 大家可以读题，思考暴力的解法，然后在看单调栈的解法。 就能感受出单调栈的巧妙 https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 使用单调栈的思路遍历保存值 123456789101112131415161718192021func dailyTemperatures(t []int) []int &#123; var res []int for i := 0; i &lt; len(t)-1; i++ &#123; j := i + 1 for ; j &lt; len(t); j++ &#123; // 如果之后出现更高，说明找到了 if t[j] &gt; t[i] &#123; res = append(res, j-i) break &#125; &#125; // 找完了都没找到 if j == len(t) &#123; res = append(res, 0) &#125; &#125; // 最后一个肯定是 0 return append(res, 0)&#125; 496.下一个更大元素 I 本题和 739. 每日温度 看似差不多，其实 有加了点难度。 https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html力扣题目链接(opens new window) 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。 请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。 示例 1: 输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].输出: [-1,3,-1]解释:对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 示例 2:输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].输出: [3,-1]解释:对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。 提示： 1 &lt;&#x3D; nums1.length &lt;&#x3D; nums2.length &lt;&#x3D; 1000 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^4 nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 1234567891011121314151617181920212223242526272829func nextGreaterElement(nums1 []int, nums2 []int) []int &#123; res := make([]int, len(nums1)) for i := range res &#123; res[i] = -1 &#125; m := make(map[int]int, len(nums1)) for k, v := range nums1 &#123; m[v] = k &#125; stack := []int&#123;0&#125; for i := 1; i &lt; len(nums2); i++ &#123; top := stack[len(stack)-1] if nums2[i] &lt; nums2[top] &#123; stack = append(stack, i) &#125; else if nums2[i] == nums2[top] &#123; stack = append(stack, i) &#125; else &#123; for len(stack) != 0 &amp;&amp; nums2[i] &gt; nums2[top] &#123; if v, ok := m[nums2[top]]; ok &#123; res[v] = nums2[i] &#125; stack = stack[:len(stack)-1] if len(stack) != 0 &#123; top = stack[len(stack)-1] &#125; &#125; stack = append(stack, i) &#125; &#125; return res&#125; 503.下一个更大元素II 这道题和 739. 每日温度 几乎如出一辙，可以自己尝试做一做 https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html 1234567891011121314151617181920func nextGreaterElements(nums []int) []int &#123; length := len(nums) result := make([]int,length) for i:=0;i&lt;len(result);i++&#123; result[i] = -1 &#125; //单调递减，存储数组下标索引 stack := make([]int,0) for i:=0;i&lt;length*2;i++&#123; for len(stack)&gt;0&amp;&amp;nums[i%length]&gt;nums[stack[len(stack)-1]]&#123; index := stack[len(stack)-1] stack = stack[:len(stack)-1] // pop result[index] = nums[i%length] &#125; stack = append(stack,i%length) &#125; return result&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"【Golang】for range 数组指针遍历","slug":"eetcode/【Golang】for range 数组指针遍历","date":"2024-12-03T16:55:24.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-12-03-90d19c862e9c.html","link":"","permalink":"https://leiqi.top/2024-12-03-90d19c862e9c.html","excerpt":"","text":"在Go语言中，使用for range遍历数组或切片时，确实会对每个元素进行值拷贝。但是，当你遍历的是指针数组（如[]*Student）时，虽然指针本身是被拷贝的，但拷贝的指针仍然指向原始的内存地址。因此，通过这个拷贝的指针修改指向的值会影响到原始数据。 这意味着，即使for range对指针进行了拷贝，你仍然可以通过这个拷贝的指针修改原始结构体的内容。下面是一个例子来说明这一点： 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type Student struct &#123; Name string Age int&#125;func main() &#123; students := []*Student&#123; &#123;Name: &quot;Alice&quot;, Age: 20&#125;, &#123;Name: &quot;Bob&quot;, Age: 22&#125;, &#125; // 使用for range遍历指针数组 for _, student := range students &#123; // 修改指向的结构体的内容 student.Age += 1 // 给每个学生的年龄加1 &#125; // 打印修改后的students数组 for _, student := range students &#123; fmt.Printf(&quot;Name: %s, Age: %d\\n&quot;, student.Name, student.Age) &#125;&#125; 在这个例子中，尽管for range对每个*Student指针进行了拷贝，但通过这个拷贝的指针修改Age字段时，修改的是原始Student结构体的内容。因此，当再次遍历students数组时，你会看到每个学生的年龄都已经增加了。 总结来说，当你使用for range遍历指针数组并修改指向的值时，这些修改会反映在原始数组上，因为指针拷贝仍然指向原始的内存地址。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 浮点数次方","slug":"olang/Go 浮点数次方","date":"2024-12-03T15:46:08.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-12-03-3d026e7b5bec.html","link":"","permalink":"https://leiqi.top/2024-12-03-3d026e7b5bec.html","excerpt":"","text":"在Go语言中，计算一个数的几次方可以通过标准库中的math包来实现。math包提供了一个Pow函数，用于计算x的y次方。 使用math.Pow函数math.Pow函数的签名如下： 1func Pow(x, y float64) float64 这个函数接受两个float64类型的参数：x是底数，y是指数，返回x的y次方的结果。 示例代码下面是一个使用math.Pow函数的示例： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; // 计算2的3次方 result := math.Pow(2, 3) fmt.Printf(&quot;2的3次方是: %v\\n&quot;, result) // 计算3的2次方 result = math.Pow(3, 2) fmt.Printf(&quot;3的2次方是: %v\\n&quot;, result) // 计算10的-2次方 result = math.Pow(10, -2) fmt.Printf(&quot;10的-2次方是: %v\\n&quot;, result)&#125; 输出1232的3次方是: 83的2次方是: 910的-2次方是: 0.01 注意事项 math.Pow函数的参数和返回值都是float64类型，因此如果你需要计算整数的次方，可能需要先将整数转换为float64，然后再进行计算。 如果需要计算整数的整数次方，并且结果也是整数，可以使用循环来实现，或者使用第三方库提供的整数次方函数。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"代码随想录 day31 贪心算法part04","slug":"arl/代码随想录 day31 贪心算法part04","date":"2024-11-28T15:52:48.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-11-28-02c175ea0d55.html","link":"","permalink":"https://leiqi.top/2024-11-28-02c175ea0d55.html","excerpt":"","text":"第八章 贪心算法 part0556. 合并区间本题也是重叠区间问题，如果昨天三道都吸收的话，本题就容易理解了。 https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html 738.单调递增的数字https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html 968.监控二叉树 （可跳过）本题是贪心和二叉树的一个结合，比较难，一刷大家就跳过吧。 https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html 总结 总结可以看看贪心算法的总结，贪心本来就没啥规律，能写出个总结篇真的不容易了。 https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.htmls","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day30 贪心算法 part04","slug":"arl/代码随想录 day30 贪心算法 part04","date":"2024-11-27T15:40:15.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-27-162479ca7de4.html","link":"","permalink":"https://leiqi.top/2024-11-27-162479ca7de4.html","excerpt":"","text":"第八章 贪心算法 part04今天的三道题目，都算是 重叠区间 问题，大家可以好好感受一下。 都属于那种看起来好复杂，但一看贪心解法，惊呼：这么巧妙！ 这种题还是属于那种，做过了也就会了，没做过就很难想出来。 不过大家把如下三题做了之后， 重叠区间 基本上差不多了 452. 用最少数量的箭引爆气球https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html 435. 无重叠区间https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html 763.划分字母区间https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day29 贪心算法part03","slug":"arl/代码随想录 day29 贪心算法part03","date":"2024-11-27T15:39:43.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-27-cbd6800ff589.html","link":"","permalink":"https://leiqi.top/2024-11-27-cbd6800ff589.html","excerpt":"","text":"第八章 贪心算法 part03134. 加油站本题有点难度，不太好想，推荐大家熟悉一下方法二 https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html 123456789101112131415161718func canCompleteCircuit(gas []int, cost []int) int &#123; curSum := 0 totalSum := 0 start := 0 for i := 0; i &lt; len(gas); i++ &#123; // 这里不用模拟环吗 一次环就行 curSum += gas[i] - cost[i] totalSum += gas[i] - cost[i] if curSum &lt; 0 &#123; start = i+1 curSum = 0 &#125; &#125; if totalSum &lt; 0 &#123; return -1 &#125; return start&#125; 135. 分发糖果本题涉及到一个思想，就是想处理好一边再处理另一边，不要两边想着一起兼顾，后面还会有题目用到这个思路 https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html 860.柠檬水找零本题看上好像挺难，其实很简单，大家先尝试自己做一做。 https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html 406.根据身高重建队列本题有点难度，和分发糖果类似，不要两头兼顾，处理好一边再处理另一边。 https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day28 贪心算法part02","slug":"arl/代码随想录 day28 贪心算法part02","date":"2024-11-27T15:39:10.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-27-f0d1900ba634.html","link":"","permalink":"https://leiqi.top/2024-11-27-f0d1900ba634.html","excerpt":"","text":"第八章 贪心算法 part02122.买卖股票的最佳时机II本题解法很巧妙，本题大家可以先自己思考一下然后再看题解，会有惊喜！ https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html 因为买卖可以是不连续的，所以和之前的题目还是有区别的。只要选后一天相对前一天是正数即可。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125; 55. 跳跃游戏本题如果没接触过，很难想到，所以不要自己憋时间太久，读题思考一会，没思路立刻看题解 https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html 123456789101112131415161718// 贪心func canJump(nums []int) bool &#123; cover := 0 n := len(nums)-1 for i := 0; i &lt;= cover; i++ &#123; // 每次与覆盖值比较 cover = max(i+nums[i], cover) //每走一步都将 cover 更新为最大值 if cover &gt;= n &#123; return true &#125; &#125; return false&#125;func max(a, b int ) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 45.跳跃游戏II本题同样不容易想出来。贪心就是这样，有的时候 会感觉简单到离谱，有时候，难的不行，主要是不容易想到。 https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html需要重新看TODO 12345678910111213141516func jump(nums []int) int &#123; // 根据题目规则，初始位置为nums[0] lastDistance := 0 // 上一次覆盖范围 curDistance := 0 // 当前覆盖范围（可达最大范围） minStep := 0 // 记录最少跳跃次数 for i := 0; i &lt; len(nums); i++ &#123; if i == lastDistance+1 &#123; // 在上一次可达范围+1的位置，记录步骤 minStep++ // 跳跃次数+1 lastDistance = curDistance // 记录时才可以更新 &#125; curDistance = max(nums[i]+i, curDistance) // 更新当前可达的最大范围 &#125; return minStep&#125; 1005.K次取反后最大化的数组和本题简单一些，估计大家不用想着贪心 ，用自己直觉也会有思路。 https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html 需要重新看TODO 1234567891011121314151617181920212223func largestSumAfterKNegations(nums []int, K int) int &#123; sort.Slice(nums, func(i, j int) bool &#123; return math.Abs(float64(nums[i])) &gt; math.Abs(float64(nums[j])) &#125;) for i := 0; i &lt; len(nums); i++ &#123; if K &gt; 0 &amp;&amp; nums[i] &lt; 0 &#123; nums[i] = -nums[i] K-- &#125; &#125; if K%2 == 1 &#123; nums[len(nums)-1] = -nums[len(nums)-1] &#125; result := 0 for i := 0; i &lt; len(nums); i++ &#123; result += nums[i] &#125; return result&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day27 贪心算法part01","slug":"arl/代码随想录 day27 贪心算法part01","date":"2024-11-27T15:37:36.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-27-df4c83a930fe.html","link":"","permalink":"https://leiqi.top/2024-11-27-df4c83a930fe.html","excerpt":"","text":"第八章 贪心算法 part01贪心算法其实就是没有什么规律可言，所以大家了解贪心算法 就了解它没有规律的本质就够了。 不用花心思去研究其规律， 没有思路就立刻看题解。 基本贪心的题目 有两个极端，要不就是特简单，要不就是死活想不出来。 学完贪心之后再去看动态规划，就会了解贪心和动规的区别。 详细布置理论基础https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 贪心算法不要想着数学证明，只要举不出来反例就行。 455.分发饼干https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html思路就是小的饼干满足最小的胃口。需要注意的是，数组需要排序。并且遍历的时候需要保证index 不要越界。 123456789101112131415161718func findContentChildren(g []int, s []int) int &#123; // 使用大的饼干gIndex 来满足孩子 sIndex // 都排序 sort.Ints(g) sort.Ints(s) // 遍历饼干s 遍历孩子胃口g res := 0 sIndex := 0 for i := 0; i &lt; len(s); i++ &#123; if sIndex &lt; len(g) &amp;&amp; s[i] &gt;= g[sIndex] &#123; res++ sIndex++ &#125; &#125; return res&#125; 376. 摆动序列https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html使用prediff 和curDiff nums[i] - nums[i-1] 来判断是否有斜率变化。 1234567891011121314151617181920func wiggleMaxLength(nums []int) int &#123; n := len(nums) if n &lt; 2 &#123; // 小于2 场景 return n &#125; ans := 1 prevDiff := nums[1] - nums[0] if prevDiff != 0 &#123; // 两个数不同场景 ans = 2 &#125; for i := 2; i &lt; n; i++ &#123; diff := nums[i] - nums[i-1] if diff &gt; 0 &amp;&amp; prevDiff &lt;= 0 || diff &lt; 0 &amp;&amp; prevDiff &gt;= 0 &#123; ans++ prevDiff = diff &#125; &#125; return ans&#125; 53. 最大子序和https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html 误区二： 大家在使用贪心算法求解本题，经常陷入的误区，就是分不清，是遇到 负数就选择起始位置，还是连续和为负选择起始位置。 在动画演示用，大家可以发现， 4，遇到 -1 的时候，我们依然累加了，为什么呢？ 因为和为 3，只要连续和还是正数就会 对后面的元素 起到增大总和的作用。 所以只要连续和为正数我们就保留。 12345678910111213141516func maxSubArray(nums []int) int &#123; max := nums[0] count := 0 for i := 0; i &lt; len(nums); i++&#123; count += nums[i] if count &gt; max&#123; max = count &#125; // 小于0 重新开始 if count &lt; 0 &#123; count = 0 &#125; &#125; return max&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"【基础知识】Golang  sort.Slice 复杂排序","slug":"eetcode/【基础知识】Golang  sort.Slice 复杂排序","date":"2024-11-24T04:47:52.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-11-24-24291296f81a.html","link":"","permalink":"https://leiqi.top/2024-11-24-24291296f81a.html","excerpt":"","text":"在 Go 语言中，你可以使用 sort.Slice 对 slice 按照复杂条件进行排序。 sort.Slice 函数接受一个 slice 和一个比较函数，该比较函数定义了两个元素之间的排序关系。 以下是实现复杂条件排序的步骤和示例： 1. 基本语法1234sort.Slice(slice, func(i, j int) bool &#123; // 比较 slice[i] 和 slice[j] return 条件&#125;) 2. 示例：对结构体切片进行多条件排序假设有一个包含多个 Person 的切片，我们希望按以下规则排序： 年龄从小到大排序。 如果年龄相同，则按名字的字母顺序排序。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Person struct &#123; Name string Age int&#125;func main() &#123; people := []Person&#123; &#123;&quot;Alice&quot;, 30&#125;, &#123;&quot;Bob&quot;, 25&#125;, &#123;&quot;Charlie&quot;, 30&#125;, &#123;&quot;Dave&quot;, 25&#125;, &#125; // 使用 sort.Slice 按多个条件排序 sort.Slice(people, func(i, j int) bool &#123; // 优先按年龄排序 if people[i].Age != people[j].Age &#123; return people[i].Age &lt; people[j].Age &#125; // 如果年龄相同，则按名字排序 return people[i].Name &lt; people[j].Name &#125;) fmt.Println(people)&#125; 3. 更复杂条件：按多个字段权重排序如果排序条件较为复杂，可以通过一个辅助函数生成比较结果。例如： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;sort&quot;)type Product struct &#123; Name string Price float64 Rating int&#125;func main() &#123; products := []Product&#123; &#123;&quot;Laptop&quot;, 1000, 5&#125;, &#123;&quot;Phone&quot;, 800, 4&#125;, &#123;&quot;Tablet&quot;, 800, 5&#125;, &#123;&quot;Watch&quot;, 400, 4&#125;, &#125; // 按价格降序 -&gt; 评分降序 -&gt; 名称升序排序 sort.Slice(products, func(i, j int) bool &#123; // 按价格降序 if products[i].Price != products[j].Price &#123; return products[i].Price &gt; products[j].Price &#125; // 如果价格相同，按评分降序 if products[i].Rating != products[j].Rating &#123; return products[i].Rating &gt; products[j].Rating &#125; // 如果评分也相同，按名称升序 return products[i].Name &lt; products[j].Name &#125;) fmt.Println(products)&#125; 4. 注意事项 如果需要对不同的维度进行排序，可以考虑在比较函数中依次判断。 sort.Slice 是不稳定的。如果需要稳定排序，可以使用 sort.SliceStable。 对于大数据排序，可以先构造权重或转换为单一排序值，减少比较复杂度。 通过 sort.Slice 的灵活性，可以轻松实现各种复杂条件的排序逻辑。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"代码随想录 day25 回溯part04","slug":"arl/代码随想录 day25 回溯part04","date":"2024-11-24T03:32:10.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-24-f08ab207d619.html","link":"","permalink":"https://leiqi.top/2024-11-24-f08ab207d619.html","excerpt":"","text":"第七章 回溯算法 part04491.递增子序列本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。 https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html 视频讲解：https://www.bilibili.com/video/BV1EG4y1h78v 46.全排列本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html 视频讲解：https://www.bilibili.com/video/BV19v4y1S79W 47.全排列 II本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容： used[i - 1] &#x3D;&#x3D; true 也行，used[i - 1] &#x3D;&#x3D; false 也行 https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html 视频讲解：https://www.bilibili.com/video/BV1R84y1i7Tm 下面这三道题都非常难，建议大家一刷的时候 可以适当选择跳过。 因为 一刷 也不求大家能把这么难的问题解决，大家目前能了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。 332. 重新安排行程（可跳过）本题很难，一刷的录友刷起来 比较费力，可以留给二刷的时候再去解决。 本题没有录制视频，当初录视频是按照 《代码随想录》出版的目录来的，当时没有这道题所以就没有录制。 https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html 51. N皇后（适当跳过）N皇后这道题目还是很经典的，一刷的录友们建议看看视频了解了解大体思路 就可以 （如果没时间本次就直接跳过） ，先有个印象，二刷的时候重点解决。 https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html 视频讲解：https://www.bilibili.com/video/BV1Rd4y1c7Bq 37. 解数独（适当跳过）同样，一刷的录友们建议看看视频了解了解大体思路（如果没时间本次就直接跳过），先有个印象，二刷的时候重点解决。 。 https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html 视频讲解：https://www.bilibili.com/video/BV1TW4y1471V 总结刷了这么多回溯算法的题目，可以做一做总结了！ https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day24 回溯part03","slug":"arl/代码随想录 day24 回溯part03","date":"2024-11-23T07:08:22.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-23-cdc4f69b29f0.html","link":"","permalink":"https://leiqi.top/2024-11-23-cdc4f69b29f0.html","excerpt":"","text":"第七章 回溯算法part0393.复原IP地址本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了 题目链接&#x2F;文章讲解：https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html 视频讲解：https://www.bilibili.com/video/BV1XP4y1U73i/ 78.子集子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。 题目链接&#x2F;文章讲解：https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html 视频讲解：https://www.bilibili.com/video/BV1U84y1q7Ci 90.子集II大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。 题目链接&#x2F;文章讲解：https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html 视频讲解：https://www.bilibili.com/video/BV1vm4y1F71J","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"【刨根问底】创建slice是否填第二个参数0的区别","slug":"eetcode/【刨根问底】创建slice是否填第二个参数0的区别","date":"2024-11-23T05:10:49.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-11-23-b80d94088ccd.html","link":"","permalink":"https://leiqi.top/2024-11-23-b80d94088ccd.html","excerpt":"","text":"在Go语言中，创建切片（slice）时使用make函数有两种常见的方式，它们之间有细微的差别： slice := make([]string, 0) 这种方式明确指定了切片的初始长度为0。这意味着你创建了一个容量和长度都是0的字符串切片。在这种形式中，你可以指定切片的类型（这里是[]string），并且设置其长度为0。由于长度和容量都是0，这个切片一开始是空的，没有任何元素。 slice := make([]string) 这种方式创建了一个切片，但没有指定其长度和容量。在这种情况下，make函数会创建一个长度和容量都是0的切片，但是它默认会分配一个初始容量。这个初始容量通常是底层数组的最小大小，比如在Go中，对于字符串切片，默认的初始容量可能是2（这个值可能会根据Go的版本和实现有所不同）。这意味着虽然长度是0，但是你可以在不触发重新分配内存的情况下至少添加两个元素。 两种方式都会创建一个空的字符串切片，但是第二种方式在内部会预分配一些容量，这可以减少在添加元素时可能发生的内存重新分配的次数。如果你预计会向切片中添加一些元素，使用make([]string)（或者等价的make([]string, 0)）可能会稍微高效一些，因为它避免了第一次添加元素时的内存分配。 总结来说，两种方式在功能上没有太大区别，都会创建一个空的字符串切片，但是第二种方式可能会在内部预分配一些额外的空间，这有助于提高在添加元素时的性能。在实际编程中，选择哪种方式取决于你的具体需求和偏好。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","slug":"eetcode/【刨根问底】为什么Itoa代表整型转化为字符串，为什么不是ItoSting","date":"2024-11-23T05:05:23.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-11-23-cf0eba4d8369.html","link":"","permalink":"https://leiqi.top/2024-11-23-cf0eba4d8369.html","excerpt":"","text":"确实，如果我们按照缩写的逻辑来看，Itos（Integer to String）可能更直观地表达了Itoa函数的功能，即把整数转换为字符串。 然而，Itoa这个名称的由来实际上与历史和传统有关。在计算机科学和编程语言的历史中，Itoa这个术语已经被广泛接受和使用。以下是一些可能的原因： 历史原因：Itoa这个名称可能起源于早期的编程语言和库，当时ASCII码（American Standard Code for Information Interchange）被广泛使用。因此，Itoa（Integer to ASCII）这个名字被保留下来，以表示将整数转换为其对应的ASCII字符表示。 约定俗成：在编程社区中，Itoa已经成为一个广泛认可的术语。改变它可能会引起混淆，因为许多开发者已经习惯了这个名字。 ASCII与字符串的关系：虽然现代编程语言中字符串通常以Unicode表示，但在许多情况下，整数的ASCII表示和字符串表示是相同的。例如，数字123的ASCII表示和字符串表示都是&quot;123&quot;。因此，Itoa这个名字仍然适用。 简洁性：Itoa这个名称比较简洁，易于记忆。如果使用Itos，虽然直观，但可能不如Itoa简洁。 Itoa这个名字更多是基于历史和传统，而不是严格的缩写逻辑。尽管Itos可能更直观地表示整数到字符串的转换，但Itoa已经成为一个广泛接受和使用的术语。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}]},{"title":"【基础知识】符号整数和非符号整数","slug":"eetcode/【基础知识】符号整数和非符号整数","date":"2024-11-23T04:47:02.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-11-23-dce4118b03a7.html","link":"","permalink":"https://leiqi.top/2024-11-23-dce4118b03a7.html","excerpt":"","text":"uint8 uint16和uint32是无符号整数类型，分别有16位和32位。它们能存储的数字数量由其位数决定。 unit8 : 是8位无符号整数，可以存储的数量是2^8 ; 因为包括一个0， 所以范围是0~255 **uint16**： uint16是一个16位的无符号整数。 它可以存储的数字数量是 2^16。 计算得出：216&#x3D;65536216&#x3D;65536。 因此，uint16能存储的数字范围是从0到65535。 **uint32**： uint32是一个32位的无符号整数。 它可以存储的数字数量是 2^32。 计算得出：232&#x3D;4294967296232&#x3D;4294967296。 因此，uint32能存储的数字范围是从0到4294967295。 总结： uint16能存储的数字数量是 216216，即65536个数字。 uint32能存储的数字数量是 232232，即4294967296个数字。 int32是一个32位的有符号整数，其数值范围是从 −231−231 到 231−1231−1。这里使用31次方而不是32次方的原因是，有符号整数的最高位（即最左边的位）用于表示符号，其中0表示正数，1表示负数。因此，实际用于表示数值的位数是31位。 具体来说： 对于正数，最高位是0，剩下的31位可以表示 231231 个不同的正数值。 对于负数，最高位是1，剩下的31位可以表示 231231 个不同的负数值。 由于0既不是正数也不是负数，它单独占用了一个数值。 因此，int32的总数值范围是从 −231−231 到 231−1231−1，包括了 231231 个负数，231−1231−1 个正数，以及0。这就是为什么我们说int32的范围是31次方而不是32次方的原因。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Golang】 byte和rune 有什么区别","slug":"eetcode/【Golang】 byte和rune 有什么区别","date":"2024-11-23T04:38:13.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-11-23-ff51ba651704.html","link":"","permalink":"https://leiqi.top/2024-11-23-ff51ba651704.html","excerpt":"","text":"byte 和rune 有什么区别？ 在Go语言（Golang）中，byte和rune是两种不同的数据类型，它们在处理文本数据时有不同的用途和含义： byte： byte是uint8的别名，即一个无符号的8位整数。在Go语言中，byte通常用于表示字节（byte），即数据的基本单位。byte可以存储任何0到255之间的值，因为一个字节有8位，每位可以是0或1，所以总共有256种可能的值（从0到255）。rune： rune是int32的别名，即一个有符号的32位整数。rune在Go语言中用于表示一个Unicode码点（Unicode scalar value），可以表示任何Unicode字符。rune类型用于处理字符串中的单个字符，特别是对于需要表示多字节字符（如中文、日文、韩文等）的Unicode字符非常有用。由于rune是一个32位整数，它可以表示从0到0x10FFFF（即Unicode的最大值）的任何值。区别： 大小：byte是8位的，而rune是32位的。用途：byte用于处理字节数据，rune用于处理Unicode字符。范围：byte的范围是0到255，而rune的范围是0到0x10FFFF。编码：在字符串中，byte类型表示的是UTF-8编码的字节序列，而rune类型表示的是Unicode码点。例如，一个包含中文字符的字符串在byte切片中可能包含多个字节，但在rune切片中，每个rune值对应一个Unicode字符。在处理文本数据时，选择byte还是rune取决于你的具体需求，如果你需要处理原始字节数据，比如文件I&#x2F;O或者网络传输，可能会使用byte。而如果你需要处理文本数据，特别是涉及到多字节字符集的文本，使用rune会更加方便。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"代码随想录 day23 回溯part02","slug":"arl/代码随想录 day23 回溯part02","date":"2024-11-22T14:29:32.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-22-60569219839f.html","link":"","permalink":"https://leiqi.top/2024-11-22-60569219839f.html","excerpt":"","text":"第七章 回溯算法part0239. 组合总和本题是 集合里元素可以用无数次87651，那么和组合问题的差别 其实仅在于 startIndex上的控制 题目链接&#x2F;文章讲解：https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html 视频讲解：https://www.bilibili.com/video/BV1KT4y1M7HJ 40.组合总和II本题开始涉及到一个问题了：去重。 注意题目中给我们 集合是有重复元素的，那么求出来的 组合有可能重复，但题目要求不能有重复组合。 题目链接&#x2F;文章讲解：https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html 视频讲解：https://www.bilibili.com/video/BV12V4y1V73A 131.分割回文串本题较难，大家先看视频来理解 分割问题，明天还会有一道分割问题，先打打基础。 https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html 视频讲解：https://www.bilibili.com/video/BV1c54y1e7k6","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day22 回溯 part01","slug":"arl/代码随想录 day22 回溯 part01","date":"2024-11-21T16:10:40.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-21-60b5e288dafc.html","link":"","permalink":"https://leiqi.top/2024-11-21-60b5e288dafc.html","excerpt":"","text":"第七章 回溯算法part01理论基础其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。 题目链接&#x2F;文章讲解：https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 视频讲解：https://www.bilibili.com/video/BV1cy4y167mM 77. 组合对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。 在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。 本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。 题目链接&#x2F;文章讲解：https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html 视频讲解：https://www.bilibili.com/video/BV1ti4y1L7cv 剪枝操作：https://www.bilibili.com/video/BV1wi4y157er 216.组合总和III如果把 组合问题理解了，本题就容易一些了。 题目链接&#x2F;文章讲解：https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html 视频讲解：https://www.bilibili.com/video/BV1wg411873x 17.电话号码的字母组合本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。 题目链接&#x2F;文章讲解：https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html 视频讲解：https://www.bilibili.com/video/BV1yV4y1V7Ug","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day21 二叉树 part08","slug":"arl/代码随想录 day21 二叉树 part08","date":"2024-11-19T16:31:50.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-19-6cee042feb5e.html","link":"","permalink":"https://leiqi.top/2024-11-19-6cee042feb5e.html","excerpt":"","text":"第六章 二叉树part08669. 修剪二叉搜索树这道题目比较难，比 添加增加和删除节点难的多，建议先看视频理解。 题目链接&#x2F;文章讲解： https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html 视频讲解： https://www.bilibili.com/video/BV17P41177ud 12345678910111213141516171819// 递归func trimBST(root *TreeNode, low int, high int) *TreeNode &#123; if root == nil &#123; return nil &#125; if root.Val &lt; low &#123; //如果该节点值小于最小值，则该节点更换为该节点的右节点值，继续遍历 right := trimBST(root.Right, low, high) return right &#125; if root.Val &gt; high &#123; //如果该节点的值大于最大值，则该节点更换为该节点的左节点值，继续遍历 left := trimBST(root.Left, low, high) return left &#125; root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) return root&#125; 108.将有序数组转换为二叉搜索树本题就简单一些，可以尝试先自己做做。 https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV1uR4y1X7qL 思路：二分法： 12345678910111213func sortedArrayToBST(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; //终止条件，最后数组为空则可以返回 return nil &#125; idx := len(nums)/2 root := &amp;TreeNode&#123;Val: nums[idx]&#125; root.Left = sortedArrayToBST(nums[:idx]) root.Right = sortedArrayToBST(nums[idx+1:]) return root&#125; 538.把二叉搜索树转换为累加树本题也不难，在 求二叉搜索树的最小绝对差 和 众数 那两道题目 都讲过了 双指针法，思路是一样的。 https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV1d44y1f7wP 1234567891011121314151617var pre intfunc convertBST(root *TreeNode) *TreeNode &#123; pre = 0 traversal(root) return root&#125;func traversal(cur *TreeNode) &#123; if cur == nil &#123; return &#125; traversal(cur.Right) cur.Val += pre pre = cur.Val traversal(cur.Left)&#125; 总结篇好了，二叉树大家就这样刷完了，做一个总结吧 https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day20 二叉树 part07","slug":"arl/代码随想录 day20 二叉树 part07","date":"2024-11-19T15:08:59.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-19-2a75dddde4cb.html","link":"","permalink":"https://leiqi.top/2024-11-19-2a75dddde4cb.html","excerpt":"","text":"235. 二叉搜索树的最近公共祖先相对于 二叉树的最近公共祖先 本题就简单一些了，因为 可以利用二叉搜索树的特性。 题目链接&#x2F;文章讲解：https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html 视频讲解：https://www.bilibili.com/video/BV1Zt4y1F7ww 123456789func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; if root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123; return lowestCommonAncestor(root.Left, p, q) &#125; else if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123; return lowestCommonAncestor(root.Right, p, q) &#125; else &#123; return root &#125;&#125; 701.二叉搜索树中的插入操作本题比想象中的简单，大家可以先自己想一想应该怎么做，然后看视频讲解，就发现 本题为什么比较简单了。 题目链接&#x2F;文章讲解：https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html 视频讲解：https://www.bilibili.com/video/BV1Et4y1c78Y 123456789101112func insertIntoBST(root *TreeNode, val int) *TreeNode &#123; if root == nil &#123; root = &amp;TreeNode&#123;Val: val&#125; return root &#125; if root.Val &gt; val &#123; root.Left = insertIntoBST(root.Left, val) // 接住新的节点 **有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作** &#125; else &#123; root.Right = insertIntoBST(root.Right, val) &#125; return root&#125; 450.删除二叉搜索树中的节点相对于 插入操作，本题就有难度了，涉及到改树的结构 题目链接&#x2F;文章讲解：https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html 视频讲解：https://www.bilibili.com/video/BV1tP41177us 12345678910111213141516171819202122232425262728293031323334353637// 递归版本func deleteNode(root *TreeNode, key int) *TreeNode &#123; if root == nil &#123; return nil &#125; if key &lt; root.Val &#123; root.Left = deleteNode(root.Left, key) return root &#125; if key &gt; root.Val &#123; root.Right = deleteNode(root.Right, key) return root &#125; if root.Right == nil &#123; return root.Left &#125; if root.Left == nil&#123; return root.Right &#125; minnode := root.Right for minnode.Left != nil &#123; minnode = minnode.Left &#125; root.Val = minnode.Val root.Right = deleteNode1(root.Right) return root&#125;func deleteNode1(root *TreeNode)*TreeNode &#123; if root.Left == nil &#123; pRight := root.Right root.Right = nil return pRight &#125; root.Left = deleteNode1(root.Left) return root&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码","slug":"arl/代码随想录 day18 二叉树 part06","date":"2024-11-16T05:32:31.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-16-f3d3de2cc120.html","link":"","permalink":"https://leiqi.top/2024-11-16-f3d3de2cc120.html","excerpt":"","text":"第六章 二叉树part06详细布置530.二叉搜索树的最小绝对差530. 二叉搜索树的最小绝对差需要领悟一下二叉树遍历上双指针操作，优先掌握递归 题目链接&#x2F;文章讲解：https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html 视频讲解：https://www.bilibili.com/video/BV1DD4y11779一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。 代码如下： 12345678910111213141516171819class Solution &#123;private:int result = INT_MAX;TreeNode* pre = NULL;void traversal(TreeNode* cur) &#123; if (cur == NULL) return; traversal(cur-&gt;left); // 左 if (pre != NULL)&#123; // 中 result = min(result, cur-&gt;val - pre-&gt;val); &#125; pre = cur; // 记录前一个 traversal(cur-&gt;right); // 右&#125;public: int getMinimumDifference(TreeNode* root) &#123; traversal(root); return result; &#125;&#125;; 12345678910111213141516171819202122// 中序遍历的同时计算最小值func getMinimumDifference(root *TreeNode) int &#123; // 保留前一个节点的指针 var prev *TreeNode // 定义一个比较大的值 min := math.MaxInt64 var travel func(node *TreeNode) travel = func(node *TreeNode) &#123; if node == nil &#123; return &#125; travel(node.Left) // 在中间操作 if prev != nil &amp;&amp; node.Val - prev.Val &lt; min &#123; min = node.Val - prev.Val &#125; prev = node travel(node.Right) &#125; travel(root) return min&#125; 501.二叉搜索树中的众数和 530差不多双指针思路，不过 这里涉及到一个很巧妙的代码技巧。 可以先自己做做看，然后看我的视频讲解。 https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html 视频讲解：https://www.bilibili.com/video/BV1fD4y117gp 12345678910111213141516171819202122232425262728293031func findMode(root *TreeNode) []int &#123; res := make([]int, 0) count := 1 max := 1 var prev *TreeNode var travel func(node *TreeNode) travel = func(node *TreeNode) &#123; if node == nil &#123; return &#125; travel(node.Left) if prev != nil &amp;&amp; prev.Val == node.Val &#123; count++ &#125; else &#123; count = 1 &#125; if count &gt;= max &#123; if count &gt; max &amp;&amp; len(res) &gt; 0 &#123; res = []int&#123;node.Val&#125; &#125; else &#123; res = append(res, node.Val) &#125; max = count &#125; prev = node travel(node.Right) &#125; travel(root) return res&#125; 236. 二叉树的最近公共祖先本题其实是比较难的，可以先看我的视频讲解 https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html 视频讲解：https://www.bilibili.com/video/BV1jd4y1B7E2 123456789101112131415161718192021222324252627func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; // check if root == nil &#123; return root &#125; // 相等 直接返回root节点即可 if root == p || root == q &#123; return root &#125; // Divide left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) // Conquer // 左右两边都不为空，则根节点为祖先 if left != nil &amp;&amp; right != nil &#123; return root &#125; if left != nil &#123; return left &#125; if right != nil &#123; return right &#125; return nil&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day17 二叉树 part05","slug":"arl/代码随想录 day17 二叉树 part05","date":"2024-11-15T14:46:40.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-15-af7cd10ca4b4.html","link":"","permalink":"https://leiqi.top/2024-11-15-af7cd10ca4b4.html","excerpt":"","text":"第六章 二叉树 part05详细布置654.最大二叉树又是构造二叉树，昨天大家刚刚做完 中序后序确定二叉树，今天做这个 应该会容易一些， 先看视频，好好体会一下 为什么构造二叉树都是 前序遍历 题目链接&#x2F;文章讲解：https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV1MG411G7ox思路： 构造树，一般采用前序遍历，因为先构造中间节点。然后构造左子树和右子树。 确定递归函数的参数和返回值 func constructMaximumBinaryTree(nums []int) *TreeNode 返回头节点即可 确定终止条件： 题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。或者判断nums &#x3D;&#x3D; 0的时候直接返回nil 确定三层递归的逻辑 3步操作：1. 先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。 2. 最大值所在的下标左区间 构造左子树 3. 最大值所在的下标右区间 构造右子树 1234567891011121314151617181920212223func constructMaximumBinaryTree(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; // 找到最大值 index := findMax(nums) // 构造二叉树 root := &amp;TreeNode &#123; Val: nums[index], Left: constructMaximumBinaryTree(nums[:index]), //左半边 Right: constructMaximumBinaryTree(nums[index+1:]),//右半边 &#125; return root&#125;func findMax(nums []int) (index int) &#123; // 获取最大元素的index for i, v := range nums &#123; if nums[index] &lt; v &#123; index = i &#125; &#125; return &#125; 617.合并二叉树这次是一起操作两个二叉树了， 估计大家也没一起操作过两个二叉树，也不知道该如何一起操作，可以看视频先理解一下。 优先掌握递归。 题目链接&#x2F;文章讲解：https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV1m14y1Y7JK 确定递归函数的参数和返回值： 首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。2. 确定终止条件： 因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。 反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。 确定单层递归的逻辑： 单层递归的逻辑就比较好写了，这里我们重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。 那么单层递归中，就要把两棵树的元素加到一起。 12345678910111213// 前序遍历func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123; if root1 == nil &#123; return root2 &#125; if root2 == nil &#123; return root1 &#125; root1.Val += root2.Val root1.Left = mergeTrees(root1.Left, root2.Left) // 同时遍历两个二叉树 root1.Right = mergeTrees(root1.Right, root2.Right) return root1&#125; 迭代法使用迭代法，如何同时处理两棵树呢？ 思路我们在二叉树：我对称么？ (opens new window)中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。 12345678910111213141516171819202122232425262728293031323334353637383940func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123; queue := make([]*TreeNode,0) if root1 == nil&#123; return root2 &#125; if root2 == nil&#123; return root1 &#125; queue = append(queue,root1) queue = append(queue,root2) for size := len(queue); size&gt;0; size=len(queue) &#123; node1 := queue[0] queue = queue[1:] node2 := queue[0] queue = queue[1:] node1.Val += node2.Val // 左子树都不为空 if node1.Left != nil &amp;&amp; node2.Left != nil &#123; queue = append(queue,node1.Left) queue = append(queue,node2.Left) &#125; // 右子树都不为空 if node1.Right !=nil &amp;&amp; node2.Right !=nil &#123; queue = append(queue, node1.Right) queue = append(queue, node2.Right) &#125; // 树 1 的左子树为 nil，直接接上树 2 的左子树 if node1.Left == nil &#123; node1.Left = node2.Left &#125; // 树 1 的右子树为 nil，直接接上树 2 的右子树 if node1.Right == nil &#123; node1.Right = node2.Right &#125; &#125; return root1&#125; 700.二叉搜索树中的搜索700. 二叉搜索树中的搜索 递归和迭代 都可以掌握以下，因为本题比较简单， 了解一下 二叉搜索树的特性 题目链接&#x2F;文章讲解: https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html 视频讲解：https://www.bilibili.com/video/BV1wG411g7sF 思路：二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树 递归方法 确定递归函数的参数和返回值 递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。 确定终止条件 如果root为空，或者找到这个数值了，就返回root节点。3. 确定单层递归的逻辑 看看二叉搜索树的单层递归逻辑有何不同。 因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。 如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。 12345678910func searchBST(root *TreeNode, val int) *TreeNode &#123; if root == nil || root.Val == val &#123; return root &#125; if root.Val &gt; val &#123; return searchBST(root.Left, val) &#125; return searchBST(root.Right, val)&#125; 迭代方法对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。 例如要搜索元素为3的节点，我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了 123456789101112131415 //迭代法func searchBST(root *TreeNode, val int) *TreeNode &#123; for root != nil &#123; if root.Val &gt; val &#123; root = root.Left &#125; else if root.Val &lt; val &#123; root = root.Right &#125; else &#123; return root &#125; &#125; return nil&#125; 98.验证二叉搜索树98. 验证二叉搜索树遇到 搜索树，一定想着中序遍历，这样才能利用上特性。 但本题是有陷阱的，可以自己先做一做，然后在看题解，看看自己是不是掉陷阱里了。这样理解的更深刻。 题目链接&#x2F;文章讲解：https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html 视频讲解：https://www.bilibili.com/video/BV18P411n7Q4 思路要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。 有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的 1234567891011121314151617181920212223// 中序遍历解法func isValidBST(root *TreeNode) bool &#123; // 保存上一个指针 var prev *TreeNode var travel func(node *TreeNode) bool travel = func(node *TreeNode) bool &#123; if node == nil &#123; return true &#125; leftRes := travel(node.Left) // 当前值小于等于前一个节点的值，返回false if prev != nil &amp;&amp; node.Val &lt;= prev.Val &#123; return false &#125; prev = node rightRes := travel(node.Right) return leftRes &amp;&amp; rightRes &#125; return travel(root)&#125; 当然也可以中序遍历将值放入到对应的列表中。然后遍历列表中前一个值是否是小于等于后边一个值。","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day16","slug":"arl/代码随想录 day16 二叉树 part04","date":"2024-11-14T16:52:00.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-14-479004f2a78a.html","link":"","permalink":"https://leiqi.top/2024-11-14-479004f2a78a.html","excerpt":"","text":"第六章 二叉树 part04找树左下角的值本题递归偏难，反而迭代简单属于模板题， 两种方法掌握一下 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html TODO： 迭代法 迭代法，找到记录最后一层中i &#x3D; 0 的value 即可。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var result int queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) &gt; 0 &#123; size := len(queue) for i := 0; i&lt; size; i++ &#123; top := queue[0] // 取最顶上的元素 queue = queue[1:] if i == 0 &#123; result = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return result&#125; 路径总和本题 又一次涉及到回溯的过程，而且回溯的过程隐藏的还挺深，建议先看视频来理解 路径总和，和 113. 路径总和ii 一起做了。 优先掌握递归法。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html 12345678910111213141516171819202122232425262728293031func hasPathSum(root *TreeNode, targetSum int) bool &#123; if root == nil &#123; return false &#125; return traversal(root, targetSum - root.Val)&#125;func traversal(cur *TreeNode, count int) bool &#123; if cur.Left == nil &amp;&amp; cur.Right == nil &amp;&amp; count == 0 &#123; return true &#125; if cur.Left == nil &amp;&amp; cur.Right == nil &#123; return false &#125; if cur.Left != nil &#123; count -= cur.Left.Val if traversal(cur.Left, count) &#123; return true &#125; count += cur.Left.Val &#125; if cur.Right != nil &#123; count -= cur.Right.Val if traversal(cur.Right, count) &#123; return true &#125; count += cur.Right.Val &#125; return false&#125; 从中序与后序遍历序列构造二叉树本题算是比较难的二叉树题目了，大家先看视频来理解。 106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树 一起做，思路一样的 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html 本题是构造二叉树。是一个比较不容考到的点。需要知道如何构造二叉树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445func buildTree(inorder []int, postorder []int) *TreeNode &#123; if len(postorder) == 0 &#123; return nil &#125; // 后序遍历数组最后一个元素，就是当前的中间节点 rootValue := postorder[len(postorder)-1] root := &amp;TreeNode&#123;Val:rootValue&#125; // 叶子结点 if len(postorder) == 1 &#123; return root &#125; // 找到中序遍历的切割点 var delimiterIndex int for delimiterIndex = 0; delimiterIndex &lt; len(inorder); delimiterIndex++ &#123; if inorder[delimiterIndex] == rootValue &#123; break; &#125; &#125; // 切割中序数组 // 左闭右开区间：[0, delimiterIndex) leftInorder := inorder[:delimiterIndex] // [delimiterIndex + 1, end) rightInorder := inorder[delimiterIndex+1:] // postorder 舍弃末尾元素 postorder = postorder[:len(postorder)-1] // 切割后序数组 // 依然左闭右开，注意这里使用了左中序数组大小作为切割点 // [0, len(leftInorder)) leftPostorder := postorder[:len(leftInorder)] // [len(leftInorder), end) rightPostorder := postorder[len(leftInorder):] root.Left = buildTree(leftInorder, leftPostorder) root.Right = buildTree(rightInorder, rightPostorder) return root&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day15 二叉树 part03","slug":"arl/代码随想录 day15 二叉树 part03","date":"2024-11-14T16:45:49.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-14-c1012dc0d4d1.html","link":"","permalink":"https://leiqi.top/2024-11-14-c1012dc0d4d1.html","excerpt":"","text":"第六章 二叉树part03迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。 110.平衡二叉树 （优先掌握递归）再一次涉及到，什么是高度，什么是深度，可以巩固一下。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html 1234567891011121314151617181920212223242526272829func isBalanced(root *TreeNode) bool &#123; h := getHeight(root) if h == -1 &#123; return false &#125; return true&#125;// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1func getHeight(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; l, r := getHeight(root.Left), getHeight(root.Right) if l == -1 || r == -1 &#123; return -1 &#125; if l - r &gt; 1 || r - l &gt; 1 &#123; return -1 &#125; return max(l, r) + 1&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 257. 二叉树的所有路径 （优先掌握递归）这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。 如果对回溯 似懂非懂，没关系， 可以先有个印象。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html 1234567891011121314151617181920func binaryTreePaths(root *TreeNode) []string &#123; res := make([]string, 0) var travel func(node *TreeNode, s string) travel = func(node *TreeNode, s string) &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; v := s + strconv.Itoa(node.Val) res = append(res, v) return &#125; s = s + strconv.Itoa(node.Val) + &quot;-&gt;&quot; if node.Left != nil &#123; travel(node.Left, s) &#125; if node.Right != nil &#123; travel(node.Right, s) &#125; &#125; travel(root, &quot;&quot;) return res&#125; 404.左叶子之和 （优先掌握递归）其实本题有点文字游戏，搞清楚什么是左叶子，剩下的就是二叉树的基本操作。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html 12345678910111213141516func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; leftValue := sumOfLeftLeaves(root.Left) // 左 if root.Left != nil &amp;&amp; root.Left.Left == nil &amp;&amp; root.Left.Right == nil &#123; leftValue = root.Left.Val // 中 &#125; rightValue := sumOfLeftLeaves(root.Right) // 右 return leftValue + rightValue&#125; 222.完全二叉树的节点个数（优先掌握递归）需要了解，普通二叉树 怎么求，完全二叉树又怎么求 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html 1234567891011121314151617181920var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 // 初始化 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) // 隐藏回溯 dfs(root.Right, d+1)&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day14 第六章 二叉树 part02","slug":"arl/代码随想录 day14 第六章 二叉树 part02","date":"2024-11-12T15:48:36.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-12-b89e2e660a4d.html","link":"","permalink":"https://leiqi.top/2024-11-12-b89e2e660a4d.html","excerpt":"","text":"第六章 二叉树 part02226.翻转二叉树 （优先掌握递归）这道题目 一些做过的同学 理解的也不够深入，建议大家先看我的视频讲解，无论做过没做过，都会有很大收获。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html 思路： 使用递归。分治，递归只要想好边界条件和需要重复执行的最小单元操作即可。 12345678910111213func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return nil &#125; root.Left, root.Right = root.Right, root.Left //交换 invertTree(root.Left) invertTree(root.Right) return root&#125; 101. 对称二叉树 （优先掌握递归）先看视频讲解，会更容易一些。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html 思路： 使用递归的方式。在二叉树的外边对比，在二叉树的里边对比。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSymmetric(root *TreeNode) bool &#123; return check(root, root)&#125;func check(p, q *TreeNode) bool &#123; // 边界场景判断，都为nil的时候为true if p == nil &amp;&amp; q == nil &#123; return true &#125; // 其中有一个为nil, 另一个不为nil, 返回false if p == nil || q == nil &#123; return false &#125; // 考虑值不相等，为false if p.Val != q.Val &#123; return false &#125; // 判断外部的节点是否对称 out := check(p.Left, q.Right) // 判断内部的边界是否对称 in := check(p.Right, q.Left) isSame := out &amp;&amp; in return isSame&#125; 104.二叉树的最大深度 （优先掌握递归）什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。 大家 要先看视频讲解，就知道以上我说的内容了，很多录友刷过这道题，但理解的还不够。 题目链接&#x2F;文章讲解&#x2F;视频讲解： https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html 思路：可以层序遍历或者使用递归到叶子节点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475func max (a, b int) int &#123; if a &gt; b &#123; return a; &#125; return b;&#125;// 递归func maxdepth(root *treenode) int &#123; if root == nil &#123; return 0; &#125; return max(maxdepth(root.left), maxdepth(root.right)) + 1;&#125;// 遍历1 直接使用queuefunc maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) deeps := 0 for len(queue) &gt; 0 &#123; size := len(queue) for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; deeps++ &#125; return deeps&#125;// 遍历2 使用中间slicefunc maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) deeps := 0 for len(queue) &gt; 0 &#123; size := len(queue) nextLevel := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] if top.Left != nil &#123; nextLevel = append(nextLevel, top.Left) &#125; if top.Right != nil &#123; nextLevel = append(nextLevel, top.Right) &#125; &#125; queue = nextLevel deeps++ &#125; return deeps&#125; 111.二叉树的最小深度 （优先掌握递归）先看视频讲解，和最大深度 看似差不多，其实 差距还挺大，有坑。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html 递归三步曲： 确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 12345678910111213141516171819202122232425262728293031323334func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) deeps := 0 for len(queue) &gt; 0 &#123; size := len(queue) for i := 0; i &lt; size; i++ &#123; top := queue[0] if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left == nil &amp;&amp; top.Right == nil &#123; return deeps + 1 &#125; queue = queue[1:] &#125; deeps++ &#125; return deeps&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"TODO  代码随想录 day 13 第六章 二叉树part01","slug":"arl/TODO  代码随想录 day 13 第六章 二叉树part01","date":"2024-11-10T13:44:35.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-11-10-98090d76025b.html","link":"","permalink":"https://leiqi.top/2024-11-10-98090d76025b.html","excerpt":"","text":"","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"TODO 代码随想录 day11 第五章 栈与队列part02","slug":"arl/代码随想录 day11 第五章 栈与队列part02","date":"2024-11-10T13:43:44.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-10-4d5a238c7e96.html","link":"","permalink":"https://leiqi.top/2024-11-10-4d5a238c7e96.html","excerpt":"","text":"150. 逆波兰表达式求值本题不难，但第一次做的话，会很难想到，所以先看视频，了解思路再去做题 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html 思路：不从后序表达式来考虑。从栈的角度，消消乐游戏的角度来考虑也是可以的。 123456789101112131415161718192021222324func evalRPN(tokens []string) int &#123; stack := []int&#123;&#125; for _, token := range tokens &#123; val, err := strconv.Atoi(token) if err == nil &#123; stack = append(stack, val) &#125; else &#123; // 如果err不为nil说明不是数字 num1, num2 := stack[len(stack)-2], stack[(len(stack))-1] stack = stack[:len(stack)-2] switch token &#123; case &quot;+&quot;: stack = append(stack, num1+num2) case &quot;-&quot;: stack = append(stack, num1-num2) case &quot;*&quot;: stack = append(stack, num1*num2) case &quot;/&quot;: stack = append(stack, num1/num2) &#125; &#125; &#125; return stack[0]&#125; 239. 滑动窗口最大值 （有点难度，可能代码写不出来，但一刷至少需要理解思路）之前讲的都是栈的应用，这次该是队列的应用了。 本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html 思路： 需要构造单调队列。比较难。 这这题想到需要如何使用大顶堆和小顶堆。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 封装单调队列的方式解题type MyQueue struct &#123; queue []int&#125;func NewMyQueue() *MyQueue &#123; return &amp;MyQueue&#123; queue: make([]int, 0), &#125;&#125;func (m *MyQueue) Front() int &#123; return m.queue[0]&#125;func (m *MyQueue) Back() int &#123; return m.queue[len(m.queue)-1]&#125;func (m *MyQueue) Empty() bool &#123; return len(m.queue) == 0&#125;func (m *MyQueue) Push(val int) &#123; for !m.Empty() &amp;&amp; val &gt; m.Back() &#123; m.queue = m.queue[:len(m.queue)-1] &#125; m.queue = append(m.queue, val)&#125;func (m *MyQueue) Pop(val int) &#123; if !m.Empty() &amp;&amp; val == m.Front() &#123; m.queue = m.queue[1:] &#125;&#125;func maxSlidingWindow(nums []int, k int) []int &#123; queue := NewMyQueue() length := len(nums) res := make([]int, 0) // 先将前k个元素放入队列 for i := 0; i &lt; k; i++ &#123; queue.Push(nums[i]) &#125; // 记录前k个元素的最大值 res = append(res, queue.Front()) for i := k; i &lt; length; i++ &#123; // 滑动窗口移除最前面的元素 queue.Pop(nums[i-k]) // 滑动窗口添加最后面的元素 queue.Push(nums[i]) // 记录最大值 res = append(res, queue.Front()) &#125; return res&#125; 347.前 K 个高频元素 （有点难度，可能代码写不出来，一刷至少需要理解思路）大&#x2F;小顶堆的应用， 在C++中就是优先级队列 本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：小顶堆func topKFrequent(nums []int, k int) []int &#123; map_num:=map[int]int&#123;&#125; //记录每个元素出现的次数 for _,item:=range nums&#123; map_num[item]++ &#125; h:=&amp;IHeap&#123;&#125; heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num&#123; heap.Push(h,[2]int&#123;key,value&#125;) if h.Len()&gt;k&#123; heap.Pop(h) &#125; &#125; res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i&lt;k;i++&#123; res[k-i-1]=heap.Pop(h).([2]int)[0] &#125; return res&#125;//构建小顶堆type IHeap [][2]int // 这里是什么意思？func (h IHeap) Len()int &#123; return len(h)&#125;func (h IHeap) Less (i,j int) bool &#123; return h[i][1]&lt;h[j][1]&#125;func (h IHeap) Swap(i,j int) &#123; h[i],h[j]=h[j],h[i]&#125;func (h *IHeap) Push(x interface&#123;&#125;)&#123; *h=append(*h,x.([2]int))&#125;func (h *IHeap) Pop() interface&#123;&#125;&#123; old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x&#125; 总结栈与队列做一个总结吧，加油 https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day8  字符串part 01","slug":"arl/代码随想录 day8  字符串part 01","date":"2024-11-07T16:26:03.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-11-07-5ae89b58eade.html","link":"","permalink":"https://leiqi.top/2024-11-07-5ae89b58eade.html","excerpt":"","text":"今日任务● 344.反转字符串 ● 541. 反转字符串II ● 卡码网：54.替换数字 详细布置344.反转字符串建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html 思路就是双指针，首尾调换 1234567891011// 一把过func reverseString(s []byte) &#123; left, right := 0, len(s)-1 for left &lt; right &#123; s[left],s[right] = s[right], s[left] left++ right-- &#125;&#125; 12345678// 正常简写方案func reverseString(s []byte) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125;&#125; 541. 反转字符串II建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html 从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 比较巧妙的是，直接按照2k 为step， 如果i+k &lt;&#x3D; length ，则反转前k(这个时候是直到i开始位置的，所以可以方便的反转前k个) 123456789101112131415161718192021222324func reverseStr(s string, k int) string &#123; ss := []byte(s) length := len(s) for i := 0; i &lt; length; i += 2 * k &#123; // 1. 每隔 2k 个字符的前 k 个字符进行反转 // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if i + k &lt;= length &#123; reverse(ss[i:i+k]) &#125; else &#123; reverse(ss[i:length]) &#125; &#125; return string(ss)&#125;func reverse(b []byte) &#123; left := 0 right := len(b) - 1 for left &lt; right &#123; b[left], b[right] = b[right], b[left] left++ right-- &#125;&#125; 卡码网：54.替换数字建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。 题目链接&#x2F;文章讲解：https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html 思路：很多数组填充类的问题，做法一般是预先给数组留好位置，然后再进行填充。go 语言的技巧，利用byte数组传入number byte, 12345678910111213141516171819import &quot;fmt&quot;func main()&#123; var strByte []byte fmt.Scanln(&amp;strByte) for i := 0; i &lt; len(strByte); i++&#123; if strByte[i] &lt;= &#x27;9&#x27; &amp;&amp; strByte[i] &gt;= &#x27;0&#x27; &#123; inserElement := []byte&#123;&#x27;n&#x27;,&#x27;u&#x27;,&#x27;m&#x27;,&#x27;b&#x27;,&#x27;e&#x27;,&#x27;r&#x27;&#125; strByte = append(strByte[:i], append(inserElement, strByte[i+1:]...)...) i = i + len(inserElement) -1 // 记得跟新i跳过number的位置 &#125; &#125; fmt.Printf(string(strByte))&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day10 第五章 栈与队列part01","slug":"arl/代码随想录 day10 第五章 栈与队列part01","date":"2024-11-07T16:25:14.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-07-8f0b910f6d30.html","link":"","permalink":"https://leiqi.top/2024-11-07-8f0b910f6d30.html","excerpt":"","text":"理论基础了解一下 栈与队列的内部实现机制，文中是以C++为例讲解的。 文章讲解：https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 232.用栈实现队列232. 用栈实现队列 - 力扣（LeetCode）大家可以先看视频，了解一下模拟的过程，然后写代码会轻松很多。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html 思路：使用两个辅助栈实现队列，一个作为in 栈，一个作为out 栈。in 先进后出，然后入out栈。 in: [1,2,3] -&gt; out: [3,2,1]。 队列先出，即等于out栈的后出了。其实通过两个栈的反转就可以实现原先的先进后出，变为先进先出。同时每次操作的时候都要判断out 是否有元素，必须out 为空的时候，才能将in中元素添加到out. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129type MyQueue struct &#123; inputStack []int outputStack []int&#125; func Constructor() MyQueue &#123; return MyQueue&#123; inputStack: make([]int, 0), outputStack: make([]int, 0), &#125;&#125; func (this *MyQueue) Push(x int) &#123; this.inputStack = append(this.inputStack, x)&#125; func (this *MyQueue) Pop() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return top&#125; func (this *MyQueue) Peek() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // return top&#125; func (this *MyQueue) Empty() bool &#123; if len(this.inputStack) == 0 &amp;&amp; len(this.outputStack) == 0 &#123; return true &#125; return false&#125; /** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈可能大家惯性思维，以为还要两个队列来模拟栈，其实只用一个队列就可以模拟栈了。 建议大家掌握一个队列的方法，更简单一些，可以先看视频讲解 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html思路: 思路：栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type MyStack struct &#123; inputQueue []int outputQueue []int&#125;func Constructor() MyStack &#123; return MyStack&#123; inputQueue: make([]int, 0), outputQueue: make([]int, 0), &#125;&#125;func (this *MyStack) Push(x int) &#123; this.inputQueue = append(this.inputQueue, x)&#125;func (this *MyStack) Pop() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = this.outputQueue this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Top() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] // 不删除元素，需要将inputqueue 添加上去。 this.inputQueue = append(this.outputQueue, this.inputQueue...) this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Empty() bool &#123; // 两个队列都为空才为空 if (len(this.inputQueue) == 0) &amp;&amp; (len(this.outputQueue) == 0) &#123; return true &#125; return false&#125; 20. 有效的括号讲完了栈实现队列，队列实现栈，接下来就是栈的经典应用了。 大家先自己思考一下 有哪些不匹配的场景，在看视频 我讲的都有哪些场景，落实到代码其实就容易很多了。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html 思路： 不要上来就写代码，这样容易越写越乱。需要分析好有多少种情况，然后开始写代码就比较清晰了。如果不在动手之前分析好，写出的代码会有很多问题。 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false 左括号直接入栈。 12345678910111213141516171819202122232425262728293031323334353637/ 思路： 使用栈来进行括号的匹配// 时间复杂度 O(n)// 空间复杂度 O(n)func isValid(s string) bool &#123; // 使用切片模拟栈的行为 stack := make([]rune, 0) // m 用于记录某个右括号对应的左括号 m := make(map[rune]rune) m[&#x27;)&#x27;] = &#x27;(&#x27; m[&#x27;]&#x27;] = &#x27;[&#x27; m[&#x27;&#125;&#x27;] = &#x27;&#123;&#x27; // 遍历字符串中的 rune for _, c := range s &#123; // 左括号直接入栈 if c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27; &#123; stack = append(stack, c) &#125; else &#123; // 如果是右括号，先判断栈内是否还有元素 if len(stack) == 0 &#123; return false &#125; // 再判断栈顶元素是否能够匹配 peek := stack[len(stack)-1] if peek != m[c] &#123; return false &#125; // 模拟栈顶弹出 stack = stack[:len(stack)-1] &#125; &#125; // 若栈中不再包含元素，则能完全匹配 return len(stack) == 0&#125; 1047. 删除字符串中的所有相邻重复项栈的经典应用。 要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html 思路：通过栈的先入后出，或者说后入先出的能力，可以韩浩的记录当前元素的前一个元素是什么。从而判断是否是相邻的重复项。最终将栈中的元素反转即可。 1234567891011121314151617181920212223242526func removeDuplicates(s string) string &#123; stack := make([]rune, 0) for _, val := range s &#123; if len(stack) == 0 || val != stack[len(stack)-1] &#123; stack = append(stack, val) &#125; else &#123; stack = stack[:len(stack)-1] &#125; &#125; // 这里是遵守stack 是个栈，所以需要弹出，并反转。如果不遵守实际可以直接返回 return string(stack) var res []rune for len(stack) != 0 &#123; // 将栈中元素放到result字符串汇总 res = append(res, stack[len(stack)-1]) stack = stack[:len(stack)-1] &#125; // 此时字符串需要反转一下 l, r := 0, len(res)-1 for l &lt; r &#123; res[l], res[r] = res[r], res[l] l++ r-- &#125; return string(res)&#125; 这里是遵守stack 是个栈，所以需要弹出，并反转。如果不遵守实际可以直接返回 return string(stack)可以修改为： 1234567891011121314func removeDuplicates(s string) string &#123; stack := make([]rune, 0) for _, val := range s &#123; if len(stack) == 0 || val != stack[len(stack)-1] &#123; stack = append(stack, val) &#125; else &#123; stack = stack[:len(stack)-1] &#125; &#125; return string(stack)&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day 9  字符串part 02","slug":"arl/代码随想录 day 9  字符串part 02","date":"2024-11-07T16:09:44.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-07-0b635f3f9997.html","link":"","permalink":"https://leiqi.top/2024-11-07-0b635f3f9997.html","excerpt":"","text":"● 151.翻转字符串里的单词 ● 卡码网：55.右旋转字符串 ● 28. 实现 strStr() ● 459.重复的子字符串 ● 字符串总结 ● 双指针回顾 详细布置151.翻转字符串里的单词建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import ( &quot;fmt&quot;)func reverseWords(s string) string &#123; //1.使用双指针删除冗余的空格 slowIndex, fastIndex := 0, 0 b := []byte(s) //删除头部冗余空格 for len(b) &gt; 0 &amp;&amp; fastIndex &lt; len(b) &amp;&amp; b[fastIndex] == &#x27; &#x27; &#123; fastIndex++ &#125; //删除单词间冗余空格 for ; fastIndex &lt; len(b); fastIndex++ &#123; if fastIndex-1 &gt; 0 &amp;&amp; b[fastIndex-1] == b[fastIndex] &amp;&amp; b[fastIndex] == &#x27; &#x27; &#123; continue &#125; b[slowIndex] = b[fastIndex] slowIndex++ &#125; //删除尾部冗余空格 if slowIndex-1 &gt; 0 &amp;&amp; b[slowIndex-1] == &#x27; &#x27; &#123; b = b[:slowIndex-1] &#125; else &#123; b = b[:slowIndex] &#125; //2.反转整个字符串 reverse(b) //3.反转单个单词 i单词开始位置，j单词结束位置 i := 0 for i &lt; len(b) &#123; j := i for ; j &lt; len(b) &amp;&amp; b[j] != &#x27; &#x27;; j++ &#123; &#125; reverse(b[i:j]) i = j i++ &#125; return string(b)&#125;func reverse(b []byte) &#123; left := 0 right := len(b) - 1 for left &lt; right &#123; b[left], b[right] = b[right], b[left] left++ right-- &#125;&#125; 卡码网：55.右旋转字符串建议：题解中的解法如果没接触过的话，应该会想不到 题目链接&#x2F;文章讲解： https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html 先反转整个字符串，再反转前部分和后部分。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func reverse (strByte []byte, l, r int)&#123; for l &lt; r &#123; strByte[l], strByte[r] = strByte[r], strByte[l] l++ r-- &#125;&#125;func main()&#123; var str string var target int fmt.Scanln(&amp;target) fmt.Scanln(&amp;str) strByte := []byte(str) reverse(strByte, 0, len(strByte) - 1) reverse(strByte, 0, target - 1) reverse(strByte, target, len(strByte) - 1) fmt.Printf(string(strByte))&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day3 第三章 哈希表part02","slug":"arl/代码随想录 day3 第三章 哈希表part02","date":"2024-11-04T16:35:08.000Z","updated":"2025-01-13T15:35:14.510Z","comments":true,"path":"2024-11-04-ee32a7ba0ecc.html","link":"","permalink":"https://leiqi.top/2024-11-04-ee32a7ba0ecc.html","excerpt":"","text":"","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day4 第三章 哈希表part02","slug":"arl/TODO 代码随想录 day4 第三章 哈希表part02","date":"2024-11-04T16:34:49.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-11-04-369839de35d3.html","link":"","permalink":"https://leiqi.top/2024-11-04-369839de35d3.html","excerpt":"","text":"","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"代码随想录 day6 第三章 哈希表part02","slug":"arl/代码随想录 day7 第三章 哈希表part02","date":"2024-11-04T15:04:17.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-11-04-b0ef262ffe3c.html","link":"","permalink":"https://leiqi.top/2024-11-04-b0ef262ffe3c.html","excerpt":"","text":"第三章 哈希表part02今日任务● 454.四数相加II ● 383. 赎金信 ● 15. 三数之和 ● 18. 四数之和 ● 总结 详细布置454.四数相加II建议：本题是 使用map 巧妙解决的问题，好好体会一下 哈希法 如何提高程序执行效率，降低时间复杂度，当然使用哈希法 会提高空间复杂度，但一般来说我们都是舍空间 换时间， 工业开发也是这样。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html 思路：题目条件中说明了不去重。 暴力做法：需要遍历四个数值。分治，先算两个数组中的和，然后在求对应两个列表的数值之和。 需要注意的点：去哈希表中招对应的-key 是否存在，存在需要加val, 而不是加一code 1234567891011121314151617181920func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int &#123; maps := make(map[int]int, len(nums1)) // 不去重， 暴力做法：需要遍历四个数值。分治，先算两个数组中的和，然后在求对应两个列表的数值之和。 for _, v := range nums1 &#123; for _, v2 := range nums2 &#123; maps[v+v2] += 1 &#125; &#125; count := 0 for _, v3 := range nums3 &#123; for _, v4 := range nums4 &#123; // 去哈希表中招对应的-key 是否存在，存在需要加val, 而不是加一 if val, ok := maps[-v3-v4]; ok &#123; count += val &#125; &#125; &#125; return count&#125; 383. 赎金信建议：本题 和 242.有效的字母异位词 是一个思路 ，算是拓展题 题目链接&#x2F;文章讲解：https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html 思路：抽象出来就是字符a， 看能否使用b来组成。 判断赎金中各个字符串出现的次数，是否小于等于杂志中出现的次数 只有小写字母 使用两个map 记录，然后遍历ransomNote 需要凑成的单词数量，判断对应杂志中是否有足够的数量字母出现。需要注意的是使用卫语句可以实现提前返回。 123456789101112131415161718192021func canConstruct(ransomNote string, magazine string) bool &#123; ransomNoteMap := make(map[rune]int, len(ransomNote)) magazineMap := make(map[rune]int, len(magazine)) for _, v1 := range magazine &#123; magazineMap[v1] += 1 &#125; for _, v := range ransomNote &#123; ransomNoteMap[v] += 1 &#125; for k, v := range ransomNoteMap &#123; if v &gt; magazineMap[k]&#123; return false &#125; &#125; return true&#125; 15. 三数之和建议：本题虽然和 两数之和 很像，也能用哈希法，但用哈希法会很麻烦，双指针法才是正解，可以先看视频理解一下 双指针法的思路，文章中讲解的，没问题 哈希法很麻烦。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html 思路: 先排序，然后使用双指针，然后分别对相邻数据进行排序。TODO:待二刷 12345678910111213141516171819202122232425262728293031323334353637func threeSum(nums []int) [][]int &#123; sort.Ints(nums) res := [][]int&#123;&#125; // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for i := 0; i &lt; len(nums)-2; i++ &#123; // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 n1 := nums[i] if n1 &gt; 0 &#123; break &#125; // 去重a if i &gt; 0 &amp;&amp; n1 == nums[i-1] &#123; continue &#125; l, r := i+1, len(nums)-1 for l &lt; r &#123; n2, n3 := nums[l], nums[r] if n1+n2+n3 == 0 &#123; res = append(res, []int&#123;n1, n2, n3&#125;) // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 for l &lt; r &amp;&amp; nums[l] == n2 &#123; l++ &#125; for l &lt; r &amp;&amp; nums[r] == n3 &#123; r-- &#125; &#125; else if n1+n2+n3 &lt; 0 &#123; l++ &#125; else &#123; r-- &#125; &#125; &#125; return res&#125; 18. 四数之和建议： 要比较一下，本题和 454.四数相加II 的区别，为什么 454.四数相加II 会简单很多，这个想明白了，对本题理解就深刻了。 本题 思路整体和 三数之和一样的，都是双指针，但写的时候 有很多小细节，需要注意，建议先看视频。 题目链接&#x2F;文章讲解&#x2F;视频讲解：https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html 要求也不能重复，需要去重，返回布尔值。 思路：将四数之和转化为三数之和需要注意的点，四数之和返回的是任意值。可能为附属 TODO: 待二刷 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func fourSum(nums []int, target int) [][]int &#123; if len(nums) &lt; 4 &#123; return nil &#125; sort.Ints(nums) var res [][]int for i := 0; i &lt; len(nums)-3; i++ &#123; n1 := nums[i] // if n1 &gt; target &#123; // 不能这样写,因为可能是负数 // break // &#125; if i &gt; 0 &amp;&amp; n1 == nums[i-1] &#123; // 对nums[i]去重 continue &#125; for j := i + 1; j &lt; len(nums)-2; j++ &#123; n2 := nums[j] if j &gt; i+1 &amp;&amp; n2 == nums[j-1] &#123; // 对nums[j]去重 continue &#125; l := j + 1 r := len(nums) - 1 for l &lt; r &#123; n3 := nums[l] n4 := nums[r] sum := n1 + n2 + n3 + n4 if sum &lt; target &#123; l++ &#125; else if sum &gt; target &#123; r-- &#125; else &#123; res = append(res, []int&#123;n1, n2, n3, n4&#125;) for l &lt; r &amp;&amp; n3 == nums[l+1] &#123; // 去重 l++ &#125; for l &lt; r &amp;&amp; n4 == nums[r-1] &#123; // 去重 r-- &#125; // 找到答案时,双指针同时靠近 r-- l++ &#125; &#125; &#125; &#125; return res&#125;","categories":[{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"}],"tags":[]},{"title":"申请域名绑定github pages","slug":"端/申请域名绑定github pages","date":"2024-09-01T02:17:17.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2024-09-01-ed1bf9078b39.html","link":"","permalink":"https://leiqi.top/2024-09-01-ed1bf9078b39.html","excerpt":"","text":"你是否想让自己的github 个人博客拥有自己的个性域名，而不是很长的github.io 域名呢？快来看看吧！ 前置需求 在Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo完成了域名的购买 完成了GitHub Pages的设置，有了可用的http://username.github.io库之后，可以访问 Github Pages 正文0. 进入我的账户 1. 无论是什么域名服务商，找到DNS Management页面如果是namesilo购买的域名，可以通过以下步骤：点击“domain manager”点击这个蓝色的小球（Manage DNS for this domain） 2. 写入 type A 的DNS记录 如果厂商提供了写入模板，这一步就很简单了。拿namesilo举例，在Manage DNS页面往下滑动可以看到namesilo支持的很多 DNS Templates。 找到GitHub的template，点击“Apply Template”，然后在弹出的窗口里直接点击“Accept”，你就会发现4条A记录已经自动写入了。 如果厂商不能自动添加，也可以手动添加，并不麻烦。打开下面的网址，滑动到第五个步骤，可以看到下图 [Managing a custom domain for your GitHub Pages site - GitHub Docs​docs.github.com&#x2F;en&#x2F;pages&#x2F;configuring-a-custom-domain-for-your-github-pages-site&#x2F;managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain! 上面圈起来的四个地址就是需要等会儿手动输入的。 不同厂商之间的手动添加方法不一样，但只要记住 type 后填“A”，address&#x2F;points to或其他同义表达后填这四个地址中的一个，其他默认就好了，一共需要添加四条，可以复制粘贴。 添加之后会多出四个### 3. 创建CNAME文件 这一步也有其他方法，比如直接通过上一步类似的方法来添加，只要选择CNAME type，把address写成http://username.github.io， 上面的方法 save 之后看到报错不要慌，让子弹飞一会儿就好了 最终有这些配置即可： github 填写域名地址在GitHub库的Settings–&gt;Pages–&gt;Custom Domain里填上自己的域名，把Enforce HTTPS打上勾即可。 即刻访问你自己的域名网站吧！ 参考：将自己的域名绑定在GitHub的个人网页库中（以namesilo为例） - 知乎 (zhihu.com)","categories":[{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"git stash","slug":"it/git stash","date":"2024-08-21T16:26:46.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-08-21-f4ccab39149e.html","link":"","permalink":"https://leiqi.top/2024-08-21-f4ccab39149e.html","excerpt":"","text":"当尝试使用 git pull -f 强制拉取远程仓库的更新时，Git 会警告你，因为本地有未提交的更改，这些更改可能会被覆盖。确定要取消对特定文件的保存，可以按照以下步骤操作： 放弃本地更改：使用 git checkout 命令来放弃对特定文件的更改。 bashgit checkout – .obsidian&#x2F;workspace.json再次尝试拉取：放弃更改后，可以再次尝试拉取远程仓库的更新。 bashgit pull如果不想放弃这些更改，而是想将它们保存起来，可以使用 git stash 命令： 保存更改：使用 git stash 将更改保存到一个临时区域。 git stash拉取远程更新： 1git pull 恢复更改：在拉取更新后，你可以使用 git stash apply 来恢复之前保存的更改。 1git stash apply 请注意，使用 git stash apply 可能不会总是成功，在这种情况下，可能需要手动解决冲突。","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"leetcode  1.两数之和","slug":"eetcode/leetcode  1.两数之和","date":"2024-08-21T15:53:21.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2024-08-21-64c0a1f316e6.html","link":"","permalink":"https://leiqi.top/2024-08-21-64c0a1f316e6.html","excerpt":"","text":"有两种思路： 使用暴力遍历， 复杂度的是 O(n ^2) 123456789101112func twoSum(nums []int, target int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; for j:= i+1; j &lt; len(nums); j++ &#123; if nums[i] + nums[j] == target &#123; return []int&#123;i, j&#125; &#125; &#125; &#125; return []int&#123;&#125;&#125; 使用哈希表，是O(n) 使用哈希表需要注意的是， 这里需要判断idx 和idx2 不相同，因为是要找两个位置，不能取同一个位置1234567891011121314151617func twoSum(nums []int, target int) []int &#123; maps := make(map[int]int, len(nums)) for idx, num := range nums &#123; maps[num] = idx &#125; for idx, num := range nums &#123; if idx2, ok := maps[target-num]; ok &amp;&amp; idx != idx2 &#123; // 00 : 04 : 10 使用哈希表，需要注意的是，有可能使用了同一个idx 这里需要注意 return []int&#123;idx, idx2&#125; &#125; &#125; return []int&#123;&#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"docker容器打包成本地压缩镜像并load","slug":"ocker/docker容器打包成本地压缩镜像并load","date":"2024-08-11T03:59:34.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-08-11-a8e2c27fed87.html","link":"","permalink":"https://leiqi.top/2024-08-11-a8e2c27fed87.html","excerpt":"","text":"docker容器打包成镜像和压缩（1）将容器保存成新的镜像相当于加了一层，使用docker commit 1sudo docker commit -a &#x27;run_code&#x27; b4293c3b9202 myimage:v2 （2）将镜像打包 1docker save -o mask_detection_v5.tar myimage:v5 (3) 将镜像包压缩 1sudo tar -zcvf myimage.tar.gz myimage.tar 还有一种容器的打包和压缩一步到位的方法： 1docker save myimage:v5 | gzip &gt; myimage.tar.gz docker镜像压缩包解压及镜像载入 一步加载压缩的镜像命令 12docker load &lt; myimage.tar.gz （1）压缩包解压 1tar -zxvf myimage.tar.gz 得到.tar格式的镜像包 （2）镜像载入 1sudo docker load -i myimage.tar 载入后查看已经加载的镜像 1sudo docker images 运行镜像123# 交互式运行docker run -it myimage:v1 bash 进入已经运行的容器12docker exec -it [imagesID] bash","categories":[{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"}],"tags":[]},{"title":"查询深度学习环境python torch cuda版本","slug":"具/查询深度学习环境python torch cuda版本","date":"2024-08-08T14:55:03.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2024-08-08-efa703ec12d7.html","link":"","permalink":"https://leiqi.top/2024-08-08-efa703ec12d7.html","excerpt":"","text":"1234567import sysimport torch#sys模块提供了一系列有关Python运行环境的变量和函数。print(sys.version)print(torch.__version__)print(torch.cuda.is_available())","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"开机自启WSL","slug":"具/开机自启WSL","date":"2024-08-07T14:09:47.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2024-08-07-117ef9b8f4c6.html","link":"","permalink":"https://leiqi.top/2024-08-07-117ef9b8f4c6.html","excerpt":"","text":"在C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 目录下，新建vbs文件 文件内容拷贝下边内容，注意bash.exe 要替换为你电脑中的地址 123456Set ws = WScript.CreateObject(&quot;WScript.Shell&quot;)cmd = &quot;C:\\Windows\\System32\\bash.exe -c &quot;&quot;bash /init.sh&quot;&quot;&quot;&#x27;运行命令不显示cmd窗口ws.Run cmd, 0, falseSet ws = NothingWScript.quit","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git更新仓库地址","slug":"it/git更新仓库地址","date":"2024-07-23T15:34:45.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-07-23-764a3cd05cde.html","link":"","permalink":"https://leiqi.top/2024-07-23-764a3cd05cde.html","excerpt":"","text":"使用如下命令 1git remote set-url origin https://gitee.com/xxxxx","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"设置github 同步到gitee","slug":"it/设置github 同步到gitee","date":"2024-07-21T14:15:47.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2024-07-21-3ee37da7ed1c.html","link":"","permalink":"https://leiqi.top/2024-07-21-3ee37da7ed1c.html","excerpt":"","text":"复制自己电脑的私钥到github 复制自己电脑的公钥到gitee 获取gitee 的私人令牌 创建.github&#x2F;workflows&#x2F;xxx.ymal 12345678910111213141516171819202122232425name: Pageson: push: branches: - master # default branchjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v2 - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125; with: # 注意替换为你的 GitHub 源仓库地址 source-repo: git@github.com:leiqichn/novelBigModel.git # 注意替换为你的 Gitee 目标仓库地址 destination-repo: git@gitee.com:leiqichn/novelBigModel.git","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Golang 使用new创建slice","slug":"olang/Golang 使用new创建slice","date":"2024-07-21T06:14:35.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-07-21-01f71b57e534.html","link":"","permalink":"https://leiqi.top/2024-07-21-01f71b57e534.html","excerpt":"","text":"在 Go 语言中，new 关键字用于分配类型为 T 的零值并返回其地址，即类型为 *T 的值。对于 slice 来说，可以使用 new 来分配一个指向 slice 的指针，但是通常我们不这样做，因为 slice 是引用类型，我们更倾向于直接使用 make 函数来创建 slice。 然而，如果确实需要使用 new 来创建一个 slice 的指针，可以这样做： 12var s *[]int // 声明一个指向int类型slice的指针s = new([]int) // 分配一个int类型的slice，并将其地址赋给s 但是，这样创建的 slice 是一个空的 slice，它没有任何底层数组（即 nil 的数组），并且长度和容量都是 0。如果需要一个具有特定长度和容量的 slice，应该使用 make 函数： 1s := make([]int, length, capacity) // 创建一个长度为 length，容量为 capacity 的int类型slice 如果使用 new 创建了一个 slice 指针，并且想要初始化它，可以这样做： 12s := new([]int)*s = make([]int, length, capacity) // 通过解引用指针并使用make来初始化slice 在大多数情况下，直接使用 make 函数来创建 slice 是更常见和更简单的方法。使用 new 创建 slice 指针通常不是必要的，除非你有特定的需求，比如在函数中返回一个 slice 的指针，或者你需要在多个地方共享同一个 slice 的引用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"依赖注入","slug":"olang/依赖注入","date":"2024-07-21T05:03:46.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-07-21-618c8c29b962.html","link":"","permalink":"https://leiqi.top/2024-07-21-618c8c29b962.html","excerpt":"","text":"依赖注入使用接口来实现依赖注入，降低模块间的耦合。概念： 依赖注入是一种设计模式，它允许你将组件的依赖关系（即其他组件或服务）从组件本身中分离出来，并在组件外部进行配置。这样做可以减少组件之间的耦合，使得代码更加模块化，易于测试和维护。 Go 语言实现： 在 Go 语言中，可以通过接口来实现依赖注入。接口定义了组件所需的行为，然后你可以在运行时注入任何实现了这些行为的具体类型。 优点： 降低耦合：组件不直接依赖于具体的实现类，而是依赖于接口，这降低了组件之间的耦合度。 提高灵活性：可以轻易地替换依赖的具体实现，而不需要修改组件的代码。 易于测试：可以为测试注入模拟对象（mocks），从而可以隔离测试组件，不依赖于外部服务或组件。 1234567891011121314151617181920212223242526272829303132333435package maintype Logger interface &#123; Log(message string)&#125;type ConsoleLogger struct&#123;&#125;func (l ConsoleLogger) Log(message string) &#123; println(&quot;Log-DEBUG:&quot;, message)&#125;type ConsoleLoggerINFO struct&#123;&#125;func (l ConsoleLoggerINFO) Log(message string) &#123; println(&quot;Log-INFO:&quot;, message)&#125;type Application struct &#123; logger Logger&#125;func (a *Application) SetLogger(logger Logger) &#123; a.logger = logger&#125;func main() &#123; app := Application&#123;&#125; consoleLogger := ConsoleLogger&#123;&#125; app.SetLogger(consoleLogger) app.logger.Log(&quot;Application started&quot;) consoleLoggerInfo := ConsoleLoggerINFO&#123;&#125; app.SetLogger(consoleLoggerInfo)&#125; 上边通过Go语言的Logger接口包含了Log方法, Application包含了Logger接口。 Application可以通过SetLogger来设置任何实现接口中Log 方法的就，可以方便切换日志类型。这就是依赖注入，每个部分都是个组件，可以随意方便的更换","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"回调函数和直接调用的区别","slug":"olang/回调函数和直接调用的区别","date":"2024-07-21T04:51:05.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-07-21-023e6a227482.html","link":"","permalink":"https://leiqi.top/2024-07-21-023e6a227482.html","excerpt":"","text":"回调函数与直接调用在表面上看起来可能相似，但它们在程序设计和执行上有本质的区别。以下是回调函数与直接调用之间的一些关键差异： 调用时机： 直接调用：函数A直接调用函数B，函数B的执行是立即的，并且是在函数A的控制下进行的。 回调函数：函数A接收函数B作为参数，但函数B的执行时机可能由外部事件或条件触发，不一定立即执行。 控制流： 直接调用：控制流是线性的，函数B执行完毕后，控制权返回给函数A。 回调函数：控制流可能会中断，函数A执行到某个点后，将控制权交给函数B，函数B执行完毕后，控制权可能不会直接返回给函数A，而是等待某个条件满足后才继续执行。 执行环境： 直接调用：函数B在函数A的上下文中执行，可以访问函数A的局部变量。 回调函数：函数B可能在不同的上下文中执行，例如在异步操作完成后，此时它可能无法访问函数A的局部变量。 目的和用途： 直接调用：通常用于直接执行某个操作或计算。 回调函数：通常用于响应事件、处理异步操作的结果或在特定条件下触发后续操作。 编程模式： 直接调用：更符合同步编程模式，代码执行顺序明确。 回调函数：常用于异步编程模式，代码的执行顺序可能不那么明确，需要更多的控制结构来管理。 函数定义： 直接调用：函数B在被调用时不需要特定的定义或约束。 回调函数：函数B可能需要符合特定的接口或签名，以便作为回调被其他函数使用。 错误处理： 直接调用：错误处理通常在调用者（函数A）中进行。 回调函数：错误处理可能需要在回调函数本身中进行，调用者可能不知道回调函数何时被调用。 代码组织： 直接调用：代码组织可能更直观，因为函数调用关系清晰。 回调函数：代码组织可能需要更多的设计考虑，以确保回调函数在适当的时机被调用，并且逻辑清晰。 使用回调函数而不是直接调用的原因通常与程序设计的复杂性、灵活性和可扩展性有关。例如，在处理异步事件、网络请求或用户界面操作时，回调函数提供了一种有效的方式来处理这些操作的结果，而不需要阻塞主程序流程。此外，回调函数还可以帮助实现更高层次的抽象，如事件监听器、中间件等","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"github同步gitee","slug":"it/github同步gitee","date":"2024-07-18T16:38:12.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-07-18-e17dac938cf8.html","link":"","permalink":"https://leiqi.top/2024-07-18-e17dac938cf8.html","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"vue3快速实践","slug":"端/vue3/vue3 入门/vue3快速实践","date":"2024-06-24T14:32:19.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2024-06-24-1130f46a1ad4.html","link":"","permalink":"https://leiqi.top/2024-06-24-1130f46a1ad4.html","excerpt":"","text":"教程 | Vue.js (vuejs.org) 声明式渲染你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。SFC 是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 .vue 后缀的文件中。 Vue 的核心功能是声明式渲染：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。能在改变时触发更新的状态被称作是响应式的。我们可以使用 Vue 的 reactive() API 来声明响应式状态。由 reactive() 创建的对象都是 JavaScript Proxy 123456789import &#123; reactive &#125; from &#x27;vue&#x27;const counter = reactive(&#123; count: 0&#125;)console.log(counter.count) // 0counter.count++ reactive() 只适用于对象 (包括数组和内置类型，如 Map 和 Set)。而另一个 API ref() 则可以接受任何值类型。ref 会返回一个包裹对象，并在 .value 属性下暴露内部值。 在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。 template 1&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt; 现在，试着自己创建一些响应式状态， Attribute 绑定 v-bind1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const titleClass = ref(&#x27;title&#x27;)&lt;/script&gt;&lt;template&gt; &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;&lt;/template&gt;&lt;style&gt;.title &#123; color: red;&#125;&lt;/style&gt; 时间监听 v-on : clickv-on: click &#x3D; “aaa” : 或者 @click&#x3D; “aaa” 123456789101112131415161718&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)function increment() &#123; // 更新组件状态 count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 使此按钮生效 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 表单绑定 v-modelv-model 会将被绑定的值与 &lt;input&gt; 的值自动同步，这样我们就不必再使用事件处理函数了。 v-model 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在指南 - 表单绑定中讨论了更多的细节。 1234567891011121314151617181920212223242526272829303132&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)function onInput(e) &#123; text.value = e.target.value&#125;&lt;/script&gt;&lt;template&gt; &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt;# 使用v-model 简化&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)&lt;/script&gt;&lt;template&gt; &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt; 条件渲染 12345678910111213141516&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const awesome = ref(true)function toggle() &#123; awesome.value = !awesome.value # 做取反&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle&lt;/button&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;&lt;/template&gt;","categories":[{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"jupyter","slug":"ython/Linux环境上jupyter 安装","date":"2024-06-21T14:26:04.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-06-21-02cd02e81f22.html","link":"","permalink":"https://leiqi.top/2024-06-21-02cd02e81f22.html","excerpt":"","text":"安装pip install notebook 用于启动 Jupyter Notebook 服务的一系列命令 12345jupyter-notebook stop 8888JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)echo $JUPYTER_TOKENnohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;jupyter-notebook list 这里是每条命令的简要说明： 12345jupyter-notebook stop 8888：停止端口为 8888 的 Jupyter Notebook 服务。JUPYTER_TOKEN=$(&lt; /dev/urandom tr -dc A-Za-z0-9 | head -c16; echo)：生成一个随机的 16 位的 token，用于 Jupyter Notebook 的安全认证。nohup jupyter-notebook --ip 0.0.0.0 --port 8888 --no-browser --allow-root --NotebookApp.token=$JUPYTER_TOKEN &amp;：在后台启动 Jupyter Notebook 服务，允许从任何 IP 地址访问，不打开浏览器，允许 root 用户运行，并设置之前生成的 token。jupyter-notebook list：列出当前运行的 Jupyter Notebook 服务。 conda 对应版本12345# 创建glm4-demo python 3.10的虚拟环境conda create --name glm4-demo python=3.10conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=11.0 -c pytorch PyTorch 12conda install python=3.10 pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia 指定python版本：conda install python&#x3D;3.10 pytorch&#x3D;2.3.0 torchvision torchaudio pytorch-cuda&#x3D;12.1 -c pytorch -c nvidia","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"leetcode 每日温度 单调栈","slug":"eetcode/leetcode 每日温度 单调栈","date":"2024-05-20T16:16:04.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-05-20-1fbf9ee2486f.html","link":"","permalink":"https://leiqi.top/2024-05-20-1fbf9ee2486f.html","excerpt":"","text":"739. 每日温度 - 力扣（LeetCode） 栈里边存放的是还没有找到后边更大值的元素 123456789101112131415func dailyTemperatures(temperatures []int) []int &#123; n := len(temperatures) ans := make([]int, n) st := []int&#123;&#125; for i, t := range temperatures &#123; for len(st) &gt; 0 &amp;&amp; t &gt; temperatures[st[len(st)-1]] &#123; j := st[len(st)-1] st = st[:len(st)-1] ans[j] = i - j &#125; st = append(st, i) &#125; return ans&#125; 这段代码是一个Go语言编写的函数，名为dailyTemperatures，它使用单调栈的数据结构来解决一个特定问题：给定一个每日温度列表temperatures，返回一个新列表，其中第i个元素是温度列表中第i天之后第一个比第i天温度更高的温度的天数。 代码思想解释： 问题定义：我们想要找到一个序列中每个元素之后的第一个更大元素，并记录它们之间的索引差。 单调栈的应用：单调栈是一种特殊的栈结构，它保证栈内的元素是单调递增或单调递减的。在这个场景中，我们使用单调栈来维护一个索引栈，栈内元素代表尚未找到更大温度的天的索引。 初始化： n：记录输入温度数组的长度。 ans：初始化一个长度为n的数组，用于存储结果，初始值设为0。 st：初始化一个空的切片，用作单调栈。 遍历温度数组： 通过range关键字遍历temperatures数组，同时获取索引i和对应的温度值t。 维护单调栈： 当前温度t大于栈顶元素对应的温度时，说明栈顶元素之后的第一个更高温度就是当前温度。此时，执行以下操作： 弹出栈顶元素j，即st[len(st)-1]。 计算索引差i - j，并将这个差值赋给ans[j]。 更新栈st，移除栈顶元素。 压栈操作： 将当前索引i压入栈st中。这表示当前索引的天还没有找到之后的第一个更高温度。 返回结果： 遍历结束后，返回ans数组，其中每个元素表示对应天之后第一个更高温度的天数。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"go语言实现优先队列","slug":"eetcode/go语言实现优先队列","date":"2024-05-18T16:39:54.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2024-05-18-dfe0612e31db.html","link":"","permalink":"https://leiqi.top/2024-05-18-dfe0612e31db.html","excerpt":"","text":"Go 语言中实现优先队列，最大堆和最小堆通常可以通过使用容器&#x2F;heap包来完成。Go 语言的heap包提供了一个堆操作的接口，它允许用户实现任意类型的堆，包括最大堆和最小堆。 1. 优先队列优先队列是一种特殊的队列，元素出队顺序是根据优先级来决定的，而不是按照元素入队顺序。在Go语言中，优先队列可以通过heap包来实现。 2. 最大堆最大堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于其子节点的值。在Go语言中，可以通过实现heap.Interface接口来创建最大堆。 3. 最小堆最小堆与最大堆相反，其中每个父节点的值都小于或等于其子节点的值。最小堆也可以通过实现heap.Interface接口来创建。 实现步骤定义堆的元素类型首先，你需要定义一个元素类型，这个类型将用于存储在堆中的元素。 1type IntHeap []int 实现heap.Interface接口要使用heap包的功能，你需要实现heap.Interface接口。这个接口包括三个方法：Push, Pop, 和 Less。 123456789101112131415func (h IntHeap) Len() int &#123; return len(h) &#125;func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125; // 对于最小堆func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125; 使用heap.Init初始化堆在使用堆之前，你需要调用heap.Init来初始化它。 123var h IntHeap // 先声明hheap.Init(&amp;h) // 再使用heap.Init(&amp;h) 初始化h指针 添加元素使用heap.Push来添加元素。 12heap.Push(&amp;h, 10)heap.Push(&amp;&amp;h, 20) 移除元素使用heap.Pop来移除并获取堆顶元素。 12top := heap.Pop(&amp;h)fmt.Printf(&quot;top element: %v\\n&quot;, top) 修改元素如果你需要修改堆中的元素，你需要自己处理，因为heap包不提供修改元素的接口。 转换为最大堆如果你需要实现最大堆，只需要修改Less方法，让它返回父节点大于子节点。 1func (h IntHeap) Less(i, j int) bool &#123; return h[i] &gt; h[j] &#125; // 对于最大堆 以上就是在Go语言中实现优先队列，最大堆和最小堆的基本步骤。通过实现heap.Interface接口，可以轻松地创建和管理各种类型的堆。 例题215. 数组中的第K个最大元素 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * Copyright (c) 2024 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2024/5/20 上午12:00 */package leetcode215import &quot;container/heap&quot;func findKthLargest(nums []int, k int) int &#123; h := heapify(nums) // 转化为heap 类型 var res any for i := 0; i &lt; k; i++ &#123; res = heap.Pop(&amp;h) &#125; return res.(int)&#125;type BigHeap []intfunc (h BigHeap) Len() int &#123; return len(h) &#125;func (h BigHeap) Less(i, j int) bool &#123; // 大根堆 return h[i] &gt; h[j]&#125;func (h BigHeap) Swap(i, j int) &#123; tmp := h[i] h[i] = h[j] h[j] = tmp&#125;func (h *BigHeap) Push(x any) &#123; // 使用any 或者interface *h = append(*h, x.(int))&#125;// 删除元素待定func (h *BigHeap) Pop() any &#123; x := (*h)[h.Len()-1] *h = (*h)[:h.Len()-1] return x&#125;// 将 nums 转换成 BigHeapfunc heapify(nums []int) BigHeap &#123; h := BigHeap(nums) // bigHeap 本身就是slice 的别名，所以可以转换 // 或者使用下边两行 h := make(BigHeap, len(nums)) // 新建BigHeap，长度为lenNums copy(h, nums) // 将num copy 到 BigHeap 中去 heap.Init(&amp;h) // 需要输入指针 return h&#125; 347. 前 K 个高频元素 涉及到两个元素，先构建一个长度为2的数组，然后对其value 进行优先队列的排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//方法一：小顶堆func topKFrequent(nums []int, k int) []int &#123; map_num:=map[int]int&#123;&#125; //记录每个元素出现的次数 for _,item:=range nums&#123; map_num[item]++ &#125; h:=&amp;IHeap&#123;&#125; heap.Init(h) //所有元素入堆，堆的长度为k for key,value:=range map_num&#123; heap.Push(h,[2]int&#123;key,value&#125;) if h.Len()&gt;k&#123; heap.Pop(h) &#125; &#125; res:=make([]int,k) //按顺序返回堆中的元素 for i:=0;i&lt;k;i++&#123; res[k-i-1]=heap.Pop(h).([2]int)[0] &#125; return res&#125;//构建小顶堆type IHeap [][2]intfunc (h IHeap) Len()int &#123; return len(h)&#125;func (h IHeap) Less (i,j int) bool &#123; return h[i][1]&lt;h[j][1]&#125;func (h IHeap) Swap(i,j int) &#123; h[i],h[j]=h[j],h[i]&#125;func (h *IHeap) Push(x interface&#123;&#125;)&#123; *h=append(*h,x.([2]int))&#125;func (h *IHeap) Pop() interface&#123;&#125;&#123; old:=*h n:=len(old) x:=old[n-1] *h=old[0:n-1] return x&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 355设计推特","slug":"eetcode/leetcode 355设计推特","date":"2024-05-10T15:26:56.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-05-10-b1491b9671d6.html","link":"","permalink":"https://leiqi.top/2024-05-10-b1491b9671d6.html","excerpt":"","text":"Problem: 355. 设计推特 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"设计题思考","slug":"eetcode/设计题思考","date":"2024-05-08T17:20:58.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-05-08-9a58f8b87168.html","link":"","permalink":"https://leiqi.top/2024-05-08-9a58f8b87168.html","excerpt":"","text":"设计数据结构和算法时，通常需要遵循以下步骤来解决问题： 理解问题：首先，彻底理解题目要求做什么，包括输入、输出、限制条件等。 确定需求：明确需要哪些数据结构来存储信息，以及如何使用这些数据结构来满足题目的需求。 设计数据结构： 确定实体类型：例如，用户（User）、推文（Tweet）等。 确定实体之间的关系：例如，用户可以发布推文，用户可以关注其他用户。 定义方法：根据题目要求，设计所需的方法或函数，如发布推文、关注用户、取消关注和获取信息流。 实现逻辑：为每个方法设计逻辑，考虑如何使用数据结构来实现题目要求的功能。 考虑边界条件和错误处理：确保你的代码可以处理各种边界情况和潜在的错误。 优化：在满足基本要求后，考虑是否可以优化代码，比如提高时间效率或空间效率。 对于LeetCode题目 设计推特，思考过程如下： 理解题目：题目要求模拟Twitter的功能，包括用户发布推文、关注和取消关注，以及获取个人的信息流。 确定需求： 需要存储用户信息，包括用户ID、关注列表和推文列表。 需要存储推文信息，包括推文ID和时间戳。 设计数据结构： Twitter：包含用户映射，用于快速访问用户信息。 User：包含用户ID、关注列表和推文列表。 Tweet：包含推文ID和时间戳。 定义方法： Constructor：初始化Twitter实例。 PostTweet：实现用户发布推文的逻辑。 Follow：实现用户关注其他用户的逻辑。 Unfollow：实现用户取消关注的逻辑。 GetNewsFeed：实现获取用户信息流的逻辑。 实现逻辑： 对于PostTweet，检查用户是否存在，如果不存在则创建用户，然后添加推文。 对于Follow和Unfollow，更新用户的followees映射。 对于GetNewsFeed，收集并排序推文，然后返回结果。 考虑边界条件： 确保在添加推文或关注用户时，处理用户不存在的情况。 在获取信息流时，处理用户没有推文或关注任何人的情况。 优化： 考虑是否可以使用更高效的数据结构或算法来提高性能。 在解决LeetCode题目时，通常需要具备一定的数据结构和算法知识，包括对数组、链表、树、图、哈希表等的熟悉，以及对排序、搜索、动态规划等算法的理解。此外，练习和分析不同的题目类型和解法也是提高解题能力的关键。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"如何使用递归","slug":"olang/如何使用递归","date":"2024-05-08T15:15:21.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-05-08-23291165e2d9.html","link":"","permalink":"https://leiqi.top/2024-05-08-23291165e2d9.html","excerpt":"","text":"123456789101112131415func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125; 解决递归问题的关键在于理解问题的本质并将其分解为更小的子问题。以下是一些帮助你思考递归解题思路的步骤： 识别重复模式： 确定问题是否存在重复的子问题。在许多递归问题中，整个问题可以分解为与其相似但规模更小的子问题。 定义递归函数： 根据问题定义一个或多个递归函数，这些函数将接受问题的子集作为输入，并返回解决子问题的答案。 确定基本情况： 找出问题的基本情况，也就是递归终止的条件。在基本情况下，问题可以直接解决，而不需要进一步递归。 分解问题： 将问题分解为更小的子问题。思考如何使用子问题的解来构建原问题的解。 递归工作： 描述递归如何工作，包括如何从子问题的解中构建出原问题的解。 合并结果： 确定如何将子问题的解合并为原问题的解。 编写伪代码： 在编写实际代码之前，先用伪代码描述递归逻辑。 考虑边界条件： 考虑所有可能的边界条件，确保递归能够在所有情况下正确终止。 优化性能： 如果可能，考虑使用记忆化（memoization）或动态规划来避免重复计算相同的子问题。 测试和调试： 编写测试用例来验证递归逻辑，并调试任何出现的问题。 以排序数组转换为二叉搜索树的问题为例，解题思路可以这样形成： 重复模式：注意到二叉搜索树的性质，即中间的元素可以作为根，左边的元素可以作为左子树的节点，右边的元素可以作为右子树的节点。 定义递归函数：traversal 函数接收一个数组和两个索引，表示当前考虑的子数组。 确定基本情况：如果左索引大于右索引，说明子数组为空，返回 nil。 分解问题：选择子数组的中间元素作为当前子树的根，然后对左右两部分分别递归调用 traversal 函数。 递归工作：递归地构建左子树和右子树，然后将它们连接到当前根节点。 合并结果：通过将子树赋值给根节点的左右指针，将子问题的解合并为原问题的解。 编写伪代码：在脑中或纸上概述递归调用的流程。 考虑边界条件：确保数组索引不会超出数组边界。 优化性能：此问题中没有明显的性能优化空间，因为每个元素恰好使用一次。 测试和调试：通过在不同的数组输入上测试函数来确保其正确性。 通过这些步骤，可以构建出解决递归问题的清晰思路，并将其转化为有效的代码实现。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"goland中debug 无法显示全局变量解决","slug":"olang/goland中debug 无法显示全局变量解决","date":"2024-05-07T16:22:44.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-05-07-c105be0dd846.html","link":"","permalink":"https://leiqi.top/2024-05-07-c105be0dd846.html","excerpt":"","text":"实际只会有局部变量，没有全局变量test 解决方法： 右键 选择+ New Watch ； 或者 按按键 Insert 添加变量 test 即可 添加成功之后每次单步执行都会显示变量结果：","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang 中格式化打印单个字符","slug":"olang/golang 中格式化打印单个字符Byte","date":"2024-05-03T08:58:56.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-05-03-ec16a5fd018e.html","link":"","permalink":"https://leiqi.top/2024-05-03-ec16a5fd018e.html","excerpt":"","text":"在Go语言中，fmt.Printf 函数是用来格式化输出的，它接受一个格式化字符串作为第一个参数，后面跟着相应的参数。格式化字符串中可以包含一些格式化动词（也称为转换说明符），它们定义了如何将相应的参数值转换为字符串并输出。 %c 是一个格式化动词，它指定了对应的参数应该被转换为一个单一的Unicode字符并输出。当你在 fmt.Printf 中使用 %c，并且传入一个整数（int 类型）时，它会将该整数值转换为该整数值对应的Unicode码点的字符。 例如： 12345678package mainimport &quot;fmt&quot;func main() &#123; var codePoint int = 65 // ASCII码中A的码点 fmt.Printf(&quot;%c\\n&quot;, codePoint) // 输出: A&#125; 在这个例子中，变量 codePoint 的值为 65，它是大写字母 “A” 在ASCII编码中的码点。fmt.Printf(&quot;%c\\n&quot;, codePoint) 将这个整数值格式化为字符 “A” 并输出。 在处理字节数组 []byte 并想要将每个字节转换为对应的字符时，%c 非常有用，因为Go的 string 类型是UTF-8编码的，每个字节可以是一个字符的一部分。例如： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; s := &quot;hello&quot; bytes := []byte(s) for i, b := range bytes &#123; fmt.Printf(&quot;Byte %d: %c\\n&quot;, i, b) &#125; // 输出: // Byte 0: h // Byte 1: e // Byte 2: l // Byte 3: l // Byte 4: o&#125; 在这个例子中，我们遍历字符串 &quot;hello&quot; 的字节表示，并使用 %c 格式化每个字节为字符。由于 “hello” 由纯ASCII字符组成，每个字节都是一个完整的字符。如果处理包含多字节UTF-8字符的字符串，单独的字节可能不会形成有效的字符。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"golang slice无法添加指针","slug":"olang/golang slice无法添加指针","date":"2024-05-02T13:37:36.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-05-02-247b79126fb5.html","link":"","permalink":"https://leiqi.top/2024-05-02-247b79126fb5.html","excerpt":"","text":"在Go语言中，指针是一种存储变量内存地址的数据类型。当你有一个指向int的指针，比如timePtr *int，你可以通过*timePtr来访问和修改指针指向的值。然而，指针本身是一个值类型，它存储的是变量的内存地址，而不是变量本身。 在你提供的add函数中： 1func add(timePtr *int) &#123; *timePtr += 1 &#125; // 增加一秒 timePtr是一个指向int的指针。虽然你可以通过*timePtr来间接修改它所指向的int值，但是你不能使用这个指针来创建一个关于*int的切片。原因如下： 指针的值是地址：timePtr变量存储的是currentTime变量的内存地址，而不是currentTime的值。切片是基于数组的，它们需要一个具体的数据集合来创建。 切片的元素类型：切片的元素类型是固定的，并且是在创建时确定的。你不能创建一个关于*int的切片，因为切片的元素类型是int，而不是*int（指向int的指针）。 切片创建语法：创建切片通常需要一个数组或另一个切片作为基础，或者使用make函数指定长度和容量。例如： 123var arr [5]intslice1 := arr[:] // 基于数组的切片slice2 := make([]int, 5, 10) // 使用make创建切片 如果你的目的是创建一个记录时间变化历史的切片，你需要一个独立的切片来存储这些时间值。你可以在main函数中声明这样一个切片，并在CRUD操作中更新它： 1234567891011121314151617var currentTime intvar history []int // 用于记录历史时间func add(timePtr *int, historyPtr *[]int) &#123; *timePtr++ historyPtr = append(*historyPtr, *timePtr)&#125;func main() &#123; currentTime = 0 history = make([]int, 0) // 初始化历史切片 add(&amp;currentTime, &amp;history) // 可以继续调用 add 并传入 &amp;currentTime 和 &amp;history 来记录更多时间点 fmt.Println(&quot;History of times:&quot;, history)&#125; 在这个例子中，history是一个切片，用于存储时间点的历史记录。每次调用add函数时，我们不仅更新currentTime，还将新的时间点添加到history切片中。注意，由于切片是引用类型，我们传递&amp;history来允许函数修改原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"计算机网络概览","slug":"络/计算机网络概览","date":"2024-05-02T07:27:45.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2024-05-02-82705503428a.html","link":"","permalink":"https://leiqi.top/2024-05-02-82705503428a.html","excerpt":"","text":"【计算机网络】常识 知识点：集线器Hub、交换机Switch、桥接、路由器Router、路由表、MAC地址、IP地址、默认网关IP；高低电平表示电信号，2.4-5.0v表示高电平，0-0.4表示低电平；两台计算机可以通过一条网线，但多条计算机需要指数级根网线；太费线【集线器Hub】转发消息的设备；Hub是物理层的设备；广播隐私性较差；数据链路层；【半双工】无法同时向上或向下传输（双向通讯，例如对讲机）Hub太费时间；【交换机Switch】交换机记录设备的唯一标识【MAC地址】是设备的物理地址且全球唯一；【物理地址MAC】交换机将每个设备的MAC地址与【对应端口】记录为一张地址表；（首先是群发，随后才是点对点）【点对点连接】【全双工通讯】提高了带宽利用率；【桥接】一根线连接两台交换机，实现两个交换机设备的相互访问；两台交换器有一个端口记录为桥接端口，交换两台交换机的MAC地址表；【交换机Switch】只能用在设备不多的内网，例如公司内网或学校教育网；【交换机Switch】虽然可以记录几千到几万个MAC地址，并且【桥接】只能增加新的MAC地址记录；交换机越多，通过桥接的传播路径也会越长【路由器Router】一种专门的网络设备，用于找到网络的最优路径（并非家里的WiFi路由器）；【IP地址】用于标识不同的网络和网络设备；【路由器Router】连接两个不同的交换机Switch组成的网络并分配【网段】（例如网络A分配192.168.1.0&#x2F;24，网络B分配192.168.2.0&#x2F;24，连接到路由器的192.168.1.1和192.168.2.1端口，设备A1和设备B1分配192.168.1.10和192.168.2.10）【默认网关IP】不同网段连接到路由器的IP；【IP地址】只是设备的临时标识，方便使用，最终的通信还是需要靠MAC地址完成；设备A1给设备B1发数据包，在网络A内找目标IP，找不到就会发送到路由器；【路由表】记录IP和端口映射关系的路由表（一说网关）；来决定如何将数据包转发到网络B，在网络B中找到对应设备B1的MAC地址；后续的通信还是通过路由器来转发；拓展：DHCP服务器【IPv4】2的32次方，43亿个网络设备，2019年11月耗尽；【IPv6】2的128次方；【海底光缆】","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"ssh 隧道 端口转发","slug":"具/ssh 隧道 端口转发","date":"2024-04-21T14:30:08.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2024-04-21-29ab33001840.html","link":"","permalink":"https://leiqi.top/2024-04-21-29ab33001840.html","excerpt":"","text":"使用SSH端口转发 如果物理机在远程，你需要使用SSH的端口转发功能来将远程物理机上的容器端口转发到你的PC上。这可以通过使用-L参数实现，如下所示： 1ssh -L 本地端口:localhost:13579 用户名@物理机IP 其中“本地端口”是你希望在PC上使用的端口号，而“物理机IP”是物理机的IP地址。 例如：我想直接登录110.43.203.19 上其中一个容器，而其没有放开对应容器的端口，我们就可以将端口映射到本地PC； 123ssh -L 13579:localhost:13579 root@110.43.203.19 -p 30005 // ssh -p 13579 root@localhost","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 208. 实现 Trie (前缀树)","slug":"eetcode/leetcode 208. 实现 Trie (前缀树)","date":"2024-04-16T16:34:47.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-04-16-1150f59f3df6.html","link":"","permalink":"https://leiqi.top/2024-04-16-1150f59f3df6.html","excerpt":"","text":"Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。 208. 实现 Trie (前缀树) - 力扣（LeetCode） Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。 为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的： 12345678type TrieNode struct &#123; Value int Next *TrieNode&#125; 而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)： 12345678type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package main import &quot;fmt&quot; // TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125; // Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125; // Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125; // Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125; // Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125; // StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125; /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Golang slice作为参数传递给函数需要使用指针","slug":"olang/Golang slice作为参数传递给函数需要使用指针","date":"2024-04-11T16:35:04.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2024-04-11-22166b2f52d0.html","link":"","permalink":"https://leiqi.top/2024-04-11-22166b2f52d0.html","excerpt":"","text":"123456789101112131415161718func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; dfs(1,n,k,&amp;res,&amp;[]int&#123;&#125;) return res&#125;func dfs(s, n, k int, res *[][]int, item *[]int) &#123; if len(*item) == k &#123; *res = append(*res, append([]int&#123;&#125;, *item...)) return &#125; for i := s; i &lt;= n-(k-len(*item))+1; i++&#123; *item = append(*item, i) dfs(i+1, n, k, res, item) *item = (*item)[:len(*item)-1] &#125;&#125; 在 Go 语言中，虽然 slice 是引用类型，但是当它作为参数传递给函数时，传递的实际上是 slice 的引用副本，而不是指向底层数组的指针。这意味着函数接收到的是一个指向原始 slice 的指针的副本。对于 slice 的修改操作，如果是改变 slice 内部的元素，那么在函数内外都是同步的，因为它们指向同一个底层数组。 然而，如果操作涉及到改变 slice 的长度或者容量，比如通过 append 函数或者直接索引赋值的方式，那么在函数内部对 slice 进行这样的操作不会影响到原始 slice，因为这些操作会创建一个新的底层数组来存储新的 slice 元素，而原始 slice 仍然指向原来的底层数组。 这就是为什么在需要修改 slice 的长度或容量的情况下，我们需要传递指向 slice 的指针（即指针的指针），因为只有这样，函数内部对 slice 的修改才能反映到原始 slice 上。 例如，在 combine 函数中，如果想要 dfs 函数能够修改 res slice 的长度（即添加新的组合到 res 中），那么需要传递 res 的指针的指针。这样，当 dfs 函数执行 *res = append(*res, newCombination...) 时，它会修改原始的 res slice 而不是它的副本。 传递指针的原因是为了： 避免不必要的副本创建：传递指针可以避免在每次函数调用时创建 slice 的副本，从而减少内存的使用和垃圾回收的压力。 确保函数内部的修改能够反映到原始数据上：当需要在函数内部修改 slice 的长度或容量时，传递指针是必要的，因为只有通过指针，函数才能访问并修改原始 slice 的底层数组。 提高代码的效率和性能：使用指针可以提高代码的执行效率，尤其是在处理大量数据或者递归算法时，可以显著减少内存分配和复制操作，从而提高程序的整体性能。 还可以转化为全局变量；需要注意的是go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化 123456789101112131415161718192021222324252627var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) // 需要进行初始化 path = make([]int, 0) // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return &#125; for i := startIdx;i&lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; tempPath :&#x3D; make([]int, k) &#x2F;&#x2F; tempPath :&#x3D; []int{},copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。copy(tempPath, path) 123456789101112131415161718192021222324252627282930var res [][]int // go 中引用类型（如切片、map、channel等会自动初始化为nil, 需要手动初始化var path []intfunc combine(n int, k int) [][]int &#123; res = make([][]int, 0) path = make([]int, 0) // 结束条件 var backtracking func(n int, k int, startIndex int) backtracking = func(n int, k int, startIndex int) &#123; if len(path) == k &#123; tempPath := make([]int, k) // tempPath := []int&#123;&#125;,copy(tempPath, path) 将会失败，因为 copy 函数需要目标切片有足够的容量来接收源切片的元素。 copy(tempPath, path) res = append(res, tempPath) &#125; for i:= startIndex; i &lt;= n; i++ &#123; if (n -i +1 ) &lt; (k -len(path)) &#123; return &#125; path = append(path, i) backtracking(n, k, i+1) path = path[:len(path)-1] &#125; &#125; backtracking(n,k,1) return res&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"设计题 总结","slug":"eetcode/设计题 总结","date":"2024-04-05T17:21:04.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-04-05-d9f9294c39ef.html","link":"","permalink":"https://leiqi.top/2024-04-05-d9f9294c39ef.html","excerpt":"","text":"举个简单的例子：设计题 - 实现浏览器历史记录1.初始化 homepage 和历史记录容量2.浏览网页 和当前页相同，则直接返回 和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。3.实现前进和后退功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: 浏览器实现 * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; if b.GetCurrentPage() == newPageURL &#123; return newPageURL &#125; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。 第一步：理解需求在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能： 记录当前页面。支持前进和后退操作。能够跳转到新页面。考虑历史记录的容量限制。 第二步：建模接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素： 当前页面：表示用户当前正在浏览的页面。历史记录：表示用户访问过的页面的顺序列表。最大容量：限制历史记录的长度，以防止无限增长。一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。 第三步：选择数据结构和函数接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数： NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。GetCurrentPage() string：获取当前页面的URL。GoBack() string：执行后退操作，并返回当前页面的URL。GoForward() string：执行前进操作，并返回当前页面的URL。NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。 第四步：编写示例代码现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。 第五步：测试和优化一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。 根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。 总结在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。 练习下面，我们来按照难度多练习几道题目 简单题 232. 用栈实现队列 - 力扣（LeetCode） 思路：input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667type MyQueue struct &#123; inputStack []int outputStack []int&#125;func Constructor() MyQueue &#123; return MyQueue&#123; inputStack: make([]int, 0), outputStack: make([]int, 0), &#125;&#125;func (this *MyQueue) Push(x int) &#123; this.inputStack = append(this.inputStack, x)&#125;func (this *MyQueue) Pop() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // this.outputStack = this.outputStack[:len(this.outputStack)-1] return top&#125;func (this *MyQueue) Peek() int &#123; if len(this.outputStack) != 0 &#123; topTmp := this.outputStack[len(this.outputStack)-1] // return topTmp &#125; else &#123; for len(this.inputStack) != 0 &#123; this.outputStack = append(this.outputStack, this.inputStack[len(this.inputStack)-1]) this.inputStack = this.inputStack[:len(this.inputStack)-1] &#125; &#125; top := this.outputStack[len(this.outputStack)-1] // return top&#125;func (this *MyQueue) Empty() bool &#123; if len(this.inputStack) == 0 &amp;&amp; len(this.outputStack) == 0 &#123; return true &#125; return false&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 225. 用队列实现栈 - 力扣（LeetCode） 思路：用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type MyStack struct &#123; inputQueue []int outputQueue []int&#125;func Constructor() MyStack &#123; return MyStack&#123; inputQueue: make([]int, 0), outputQueue: make([]int, 0), &#125;&#125;func (this *MyStack) Push(x int) &#123; this.inputQueue = append(this.inputQueue, x)&#125;func (this *MyStack) Pop() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = this.outputQueue this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Top() int &#123; for len(this.inputQueue) != 1 &#123; this.outputQueue = append(this.outputQueue, this.inputQueue[0]) this.inputQueue = this.inputQueue[1:] &#125; top := this.inputQueue[0] this.inputQueue = append(this.outputQueue, this.inputQueue...) this.outputQueue = []int&#123;&#125; return top&#125;func (this *MyStack) Empty() bool &#123; if (len(this.inputQueue) == 0) &amp;&amp; (len(this.outputQueue) == 0) &#123; return true &#125; return false&#125; 303. 区域和检索 - 数组不可变思路：简单题， 12345678910111213141516171819202122232425type NumArray struct &#123; nums []int&#125;func Constructor(nums []int) NumArray &#123; return NumArray&#123;nums: nums&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; sum := 0 for i:= left; i&lt;= right; i++ &#123; sum += this.nums[i] &#125; return sum&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用前缀和怎么求 preSum 数组利用前面提到的递推式: 遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，即preSum[0]为nums[0]（前提是nums有元素）。 预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。 需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。 后面会给出简化的写法。 123456789101112131415161718192021222324252627282930313233type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums)) preSum[0] = nums[0] for i:=1; i&lt;len(nums);i++ &#123; preSum[ i] = preSum[ i-1] + nums[i] &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; if left == 0 &#123; // 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j] if len(this.preSum) == 0 &#123; // 但如果nums根本没有长度，直接返回0 return 0 &#125; return this.preSum[right] &#125; return this.preSum[right] - this.preSum[left-1]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 使用多一位长度的前缀和之所以上面处理东西多，是因为preSum[i]的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index 要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]即： 1234567891011121314151617181920212223242526type NumArray struct &#123; preSum []int&#125;func Constructor(nums []int) NumArray &#123; preSum := make([]int, len(nums) + 1) for index, value := range nums &#123; preSum[index + 1] = preSum[index] + value &#125; return NumArray&#123;preSum&#125;&#125;func (this *NumArray) SumRange(left int, right int) int &#123; return this.preSum[right + 1] - this.preSum[left]&#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */ 703. 数据流中的第 K 大元素暴力解法 1234567891011121314151617181920212223242526272829303132type KthLargest struct &#123; // 排序后的nums index int sortedNums []int&#125;func Constructor(k int, nums []int) KthLargest &#123; return KthLargest&#123;k, nums&#125;&#125;func (this *KthLargest) Add(val int) int &#123; this.sortedNums = append(this.sortedNums, val) sort.Ints(this.sortedNums) revert(this.sortedNums) return this.sortedNums[this.index-1]&#125;func revert(nums []int) &#123; for i, j := 0, len(nums)-1; i &lt; j; i, j = i+1, j-1 &#123; nums[i], nums[j] = nums[j], nums[i] &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * obj := Constructor(k, nums); * param_1 := obj.Add(val); */ 优先队列我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。 在单次插入的操作中，我们首先将元素 val\\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。 123456789101112131415161718192021222324252627282930313233type KthLargest struct &#123; sort.IntSlice k int&#125;func Constructor(k int, nums []int) KthLargest &#123; kl := KthLargest&#123;k: k&#125; for _, val := range nums &#123; kl.Add(val) &#125; return kl&#125;func (kl *KthLargest) Push(v interface&#123;&#125;) &#123; kl.IntSlice = append(kl.IntSlice, v.(int))&#125;func (kl *KthLargest) Pop() interface&#123;&#125; &#123; a := kl.IntSlice v := a[len(a)-1] kl.IntSlice = a[:len(a)-1] return v&#125;func (kl *KthLargest) Add(val int) int &#123; heap.Push(kl, val) if kl.Len() &gt; kl.k &#123; heap.Pop(kl) &#125; return kl.IntSlice[0]&#125; 146 LRU缓存146. LRU 缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type LRUCache struct &#123; capacity int // 容量 keysList []int // 实现最新时间 存放key 每次update get put 等都要将对应key删除，然后追加到最新时间 keysMap map[int]int // 存放key value&#125;func Constructor(capacity int) LRUCache &#123; //return return LRUCache&#123;capacity, make([]int, 0), make(map[int]int, 0)&#125;&#125;// 如果key存在于缓存中，则返回关键字的值，否则返回-1func (this *LRUCache) Get(key int) int &#123; if ele, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) return ele &#125; return -1&#125;func (this *LRUCache) Put(key int, value int) &#123; // 关键字存在 则更新值为value // 不存在，则插入value // 如果插入超过数量capacity 则删除最久没有使用的关键字【list] if _, ok := this.keysMap[key]; ok &#123; this.updateListKey(key) this.keysMap[key] = value &#125; else &#123; this.updateListKey(key) this.keysMap[key] = value if len(this.keysList) &gt; this.capacity &#123; delete(this.keysMap, this.keysList[0]) // 这里删除key 从list队列中获取 this.keysList = this.keysList[1:] &#125; &#125;&#125;func (this *LRUCache) updateListKey(key int) &#123; for i := 0; i &lt; len(this.keysList); i++ &#123; if key == this.keysList[i] &#123; this.keysList = append(this.keysList[:i], this.keysList[i+1:]...) // 删除该key, 然后放在末尾 break &#125; &#125; this.keysList = append(this.keysList, key)&#125; 355 设计推特355. 设计推特 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596type Twitter struct &#123; userMap map[int]*User&#125;type User struct &#123; userId int followees map[int]bool tweets []*Tweet&#125;type Tweet struct &#123; tweetId int time int userId int&#125;// 推特数目，用于时间排序var tweetCount intfunc Constructor() Twitter &#123; return Twitter&#123;userMap: make(map[int]*User)&#125;&#125;func (t *Twitter) PostTweet(userId int, tweetId int) &#123; // 新建tweet 将自己设置为关注 // 如果map 中不存在需要新建，因为User 类中存在map 和 slice if _, ok := t.userMap[userId]; !ok &#123; t.userMap[userId] = &amp;User&#123;userId: userId, tweets: make([]*Tweet, 0), followees: make(map[int]bool)&#125; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) t.userMap[userId].followees[userId] = true &#125; else &#123; tweet := &amp;Tweet&#123;tweetId, tweetCount, userId&#125; t.userMap[userId].tweets = append(t.userMap[userId].tweets, tweet) &#125; // 将tweetId 和时间做一个新增 tweetCount++&#125;func (t *Twitter) Follow(followerId int, followeeId int) &#123; // 如果关注人不存在则新建 if _, ok := t.userMap[followerId]; !ok &#123; t.userMap[followerId] = &amp;User&#123; userId: followerId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followerId].followees[followerId] = true &#125; // 如果被关注人不存在则新建 if _, ok := t.userMap[followeeId]; !ok &#123; t.userMap[followeeId] = &amp;User&#123; userId: followeeId, followees: make(map[int]bool), &#125; // 每次新建user的时候 将自己加入自己关注 t.userMap[followeeId].followees[followeeId] = true &#125; t.userMap[followerId].followees[followeeId] = true&#125;// 形参上的Id 在使用数据结构的时候一般使用map查找func (t *Twitter) Unfollow(followerId int, followeeId int) &#123; if _, ok := t.userMap[followerId]; ok &#123; delete(t.userMap[followerId].followees, followeeId) &#125;&#125;func (t *Twitter) GetNewsFeed(userId int) []int &#123; resTop10 := []int&#123;&#125; tweeters := []*Tweet&#123;&#125; if _, ok := t.userMap[userId]; ok &#123; for followeeId, _ := range t.userMap[userId].followees &#123; tweeters = append(tweeters, t.userMap[followeeId].tweets...) &#125; &#125; sort.Slice(tweeters, func(i, j int) bool &#123; if tweeters[i].time &gt; tweeters[j].time &#123; return true &#125; return false &#125;) for i := 0; i &lt; len(tweeters) &amp;&amp; i &lt; 10 ; i++ &#123; resTop10 = append(resTop10, tweeters[i].tweetId) &#125; return resTop10&#125; 208. 实现 Trie (前缀树) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport &quot;fmt&quot;// TrieNode 代表Trie中的每个节点type TrieNode struct &#123; children [26]*TrieNode isEnd bool&#125;// Trie 代表整个前缀树type Trie struct &#123; root *TrieNode&#125;// Constructor 初始化一个Trie对象func Constructor() Trie &#123; return Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;&#125;// Insert 将word插入到trie中func (this *Trie) Insert(word string) &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; node.children[index] = &amp;TrieNode&#123;&#125; &#125; node = node.children[index] &#125; node.isEnd = true // 标记单词结束的节点&#125;// Search 在trie中搜索wordfunc (this *Trie) Search(word string) bool &#123; node := this.root for _, ch := range word &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明word不在trie中 &#125; node = node.children[index] &#125; return node.isEnd // 检查最后一个节点是否标记为单词结尾&#125;// StartsWith 返回trie中是否有任何单词以prefix为前缀func (this *Trie) StartsWith(prefix string) bool &#123; node := this.root for _, ch := range prefix &#123; index := ch - &#x27;a&#x27; if node.children[index] == nil &#123; return false // 如果路径中的节点不存在，说明没有以prefix为前缀的word &#125; node = node.children[index] &#125; return true // 所有的char都在路径中，说明trie有以prefix为前缀的word&#125;/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 211. 添加与搜索单词 - 数据结构设计 一次AC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &quot;strings&quot;type WordDictionary struct &#123; wordMap map[string]bool&#125;func Constructor() WordDictionary &#123; return WordDictionary&#123;make(map[string]bool, 0)&#125;&#125;func (this *WordDictionary) AddWord(word string) &#123; this.wordMap[word] = true&#125;func (this *WordDictionary) Search(word string) bool &#123; if _, ok := this.wordMap[word]; ok &#123; return true &#125; else if strings.Contains(word, &quot;.&quot;) &#123; for key, _ := range this.wordMap &#123; if len(key) == len(word) &#123; flag := true for i := 0; i &lt; len(word); i++ &#123; if key[i] == word[i] || word[i] == &#x27;.&#x27; &#123; &#125; else &#123; flag = false &#125; &#125; if flag == true &#123; return true &#125; &#125; &#125; return false &#125; return false&#125;/** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */ 284. 窥视迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142/* Below is the interface for Iterator, which is already defined for you. * * type Iterator struct &#123; * * &#125; * * func (this *Iterator) hasNext() bool &#123; * // Returns true if the iteration has more elements. * &#125; * * func (this *Iterator) next() int &#123; * // Returns the next element in the iteration. * &#125; */type PeekingIterator struct &#123; iter *Iterator _hasNext bool _next int&#125;func Constructor(iter *Iterator) *PeekingIterator &#123; return &amp;PeekingIterator&#123;iter, iter.hasNext(), iter.next()&#125;&#125;func (it *PeekingIterator) hasNext() bool &#123; return it._hasNext&#125;func (it *PeekingIterator) next() int &#123; ret := it._next it._hasNext = it.iter.hasNext() if it._hasNext &#123; it._next = it.iter.next() &#125; return ret&#125;func (it *PeekingIterator) peek() int &#123; return it._next&#125; 535. TinyURL 的加密与解密 12345678910111213141516171819202122232425262728293031323334// 通过自增id 的方式来实现encodetype Codec struct &#123; dataId map[int]string nums int&#125;func Constructor() Codec &#123; return Codec&#123;map[int]string&#123;&#125;, 0&#125;&#125;// Encodes a URL to a shortened URL.func (this *Codec) encode(longUrl string) string &#123; this.nums++ this.dataId[this.nums] = longUrl res := &quot;http://tinyurl.com/&quot; + strconv.Itoa(this.nums) return res&#125;// Decodes a shortened URL to its original URL.func (this *Codec) decode(shortUrl string) string &#123; index := strings.Split(shortUrl, &quot;/&quot;) tmp := index[len(index)-1] idx, _ := strconv.Atoi(tmp) long := this.dataId[idx] return long&#125;/** * Your Codec object will be instantiated and called as such: * obj := Constructor(); * url := obj.encode(longUrl); * ans := obj.decode(url); */ 707. 设计链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374type MyLinkedList struct &#123; // 如何确定结构体里应设置什么变量？ // 总的List 包含 有多少个节点，以及头节点是什么 Size int dummyHead *ListNode &#125;func Constructor() MyLinkedList &#123; // Constructor 该如何写？如何才能符合题目要求？ return MyLinkedList&#123;0, &amp;ListNode&#123;0,nil&#125;&#125; // 这个虚拟头节点不应该删掉吗？&#125;func (this *MyLinkedList) Get(index int) int &#123; if index &lt; 0 || index &gt;= this.Size &#123; return -1 &#125; //dummyHead := &amp;ListNode&#123;0, this.head&#125; cur := this.dummyHead.Next for index != 0 &amp;&amp; cur != nil &#123; cur = cur.Next index-- &#125; return cur.Val&#125;func (this *MyLinkedList) AddAtHead(val int) &#123; this.AddAtIndex(0, val)&#125;func (this *MyLinkedList) AddAtTail(val int) &#123; this.AddAtIndex(this.Size, val)&#125;func (this *MyLinkedList) AddAtIndex(index int, val int) &#123; if index &gt;= 0 &amp;&amp; index &lt;= this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; newNode := &amp;ListNode&#123;val, cur.Next&#125; cur.Next = newNode this.Size++ &#125; if index &lt; 0 &#123; this.AddAtIndex(0, val) this.Size++ &#125; if index &gt; this.Size &#123; return // 这个return 到哪里了？ 代表结束这个程序吗？ &#125;&#125;func (this *MyLinkedList) DeleteAtIndex(index int) &#123; if index &gt;= 0 &amp;&amp; index &lt; this.Size &#123; cur := this.dummyHead //cur 等于虚拟头节点，插入节点的前驱 for i := 0; i &lt; index; i++ &#123; cur = cur.Next &#125; cur.Next = cur.Next.Next this.Size-- &#125; return&#125;/** * Your MyLinkedList object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Get(index); * obj.AddAtHead(val); * obj.AddAtTail(val); * obj.AddAtIndex(index,val); * obj.DeleteAtIndex(index); */ 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 901. 股票价格跨度 12345678910111213141516171819202122232425type StockSpanner struct &#123; stack [][2]int idx int&#125;func Constructor() StockSpanner &#123; return StockSpanner&#123;[][2]int&#123;&#123;-1, math.MaxInt32&#125;&#125;, -1&#125;&#125;func (s *StockSpanner) Next(price int) int &#123; s.idx++ for price &gt;= s.stack[len(s.stack)-1][1] &#123; s.stack = s.stack[:len(s.stack)-1] &#125; s.stack = append(s.stack, [2]int&#123;s.idx, price&#125;) return s.idx - s.stack[len(s.stack)-2][0]&#125;/** * Your StockSpanner object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Next(price); */ 1396. 设计地铁系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */ 1476. 子矩形查询 1234567891011121314151617181920212223242526272829303132type SubrectangleQueries struct &#123; // 需要什么数据结构呢？ 1. 一个二维数组 rectangle [][]int&#125;func Constructor(rectangle [][]int) SubrectangleQueries &#123; return SubrectangleQueries&#123;rectangle: rectangle&#125;&#125;func (this *SubrectangleQueries) UpdateSubrectangle(row1 int, col1 int, row2 int, col2 int, newValue int) &#123; for i:=row1;i &lt;= row2;i++ &#123; for j:= col1; j &lt;= col2; j++ &#123; this.rectangle[i][j] = newValue &#125; &#125;&#125;func (this *SubrectangleQueries) GetValue(row int, col int) int &#123; return this.rectangle[row][col]&#125;/** * Your SubrectangleQueries object will be instantiated and called as such: * obj := Constructor(rectangle); * obj.UpdateSubrectangle(row1,col1,row2,col2,newValue); * param_2 := obj.GetValue(row,col); */ 1845. 座位预约管理系统 1234567891011121314151617181920212223242526272829303132333435type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125; 1993. 树上的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869type LockingTree struct &#123; parent []int lockNodeUser []int children [][]int&#125;func Constructor(parent []int) LockingTree &#123; n := len(parent) lockNodeUser := make([]int, n) children := make([][]int, n) for i := 0; i &lt; n; i++ &#123; lockNodeUser[i] = -1 p := parent[i] if p != -1 &#123; children[p] = append(children[p], i) &#125; &#125; return LockingTree&#123;parent, lockNodeUser, children&#125;&#125;func (this *LockingTree) Lock(num int, user int) bool &#123; if this.lockNodeUser[num] == -1 &#123; this.lockNodeUser[num] = user return true &#125; return false&#125;func (this *LockingTree) Unlock(num int, user int) bool &#123; if this.lockNodeUser[num] == user &#123; this.lockNodeUser[num] = -1 return true &#125; return false&#125;func (this *LockingTree) Upgrade(num int, user int) bool &#123; res := this.lockNodeUser[num] == -1 &amp;&amp; !this.hasLockedAncestor(num) &amp;&amp; this.checkAndUnlockDescendant(num) if res &#123; this.lockNodeUser[num] = user &#125; return res&#125;func (this *LockingTree) hasLockedAncestor(num int) bool &#123; num = this.parent[num] for num != -1 &#123; if this.lockNodeUser[num] != -1 &#123; return true &#125; num = this.parent[num] &#125; return false&#125;func (this *LockingTree) checkAndUnlockDescendant(num int) bool &#123; res := false if this.lockNodeUser[num] != -1 &#123; res = true &#125; this.lockNodeUser[num] = -1 for _, child := range this.children[num] &#123; if this.checkAndUnlockDescendant(child) &#123; res = true &#125; &#125; return res&#125; 2241. 设计一个 ATM 机器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type ATM struct &#123; orderList []int amountMap map[int]int // map 是多余的&#125;func Constructor() ATM &#123; return ATM&#123; make([]int, 5), make(map[int]int),// 初始化 使用make 多练习多学习，保持手感。 &#125;&#125;var price [5]int = [5]int&#123;20, 50, 100, 200, 500&#125;func (this *ATM) Deposit(banknotesCount []int) &#123; for i , count := range banknotesCount&#123; this.orderList[i] += count &#125;&#125;func (this *ATM) Withdraw(amount int) []int &#123; //使用整除法 ans := make([]int, 5) for i := 4; i &gt;= 0; i-- &#123; ans[i] = min(amount/price[i],this.orderList[i]) amount -= ans[i]*price[i] &#125; if amount &gt; 0 &#123; return []int&#123;-1&#125; &#125; for idx,v := range ans &#123; this.orderList[idx] -= v &#125; return ans // 注意试着返回是需要钞票的数量，不是钞票的剩余数量&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 2353. 设计食物评分系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394type FoodRatings struct &#123; Map map[string]*FoodHeap NameMap map[string]*Food&#125;type Food struct &#123; Name, C string Rating, Idx int&#125;// 实现堆type FoodHeap []*Foodfunc (h FoodHeap) String() string &#123; res := &quot;&quot; for _, f := range h &#123; res = fmt.Sprintf(&quot;%s -&gt; (%v, %v)&quot;, res, f.Name, f.Rating) &#125; return res&#125;func (h FoodHeap) Len() int &#123; return len(h) &#125;func (h FoodHeap) Swap(i, j int) &#123; h[i], h[i].Idx, h[j], h[j].Idx = h[j], h[j].Idx, h[i], h[i].Idx&#125;// 大顶堆 如果分数相同，Name 字典序小的更大func (h FoodHeap) Less(i, j int) bool &#123; if h[j].Rating == h[i].Rating &#123; return h[i].Name &lt; h[j].Name &#125; return h[j].Rating &lt; h[i].Rating&#125;func (h *FoodHeap) Push(f interface&#123;&#125;) &#123; // Push and Pop use pointer receivers because they modify the slice&#x27;s length, // not just its contents. food := f.(*Food) food.Idx = h.Len() *h = append(*h, food)&#125;func (h *FoodHeap) Pop() interface&#123;&#125; &#123; a := *h; v := a[len(a) - 1]; *h = a[:len(a) - 1]; return v &#125;// 以烹饪方式对评分归类func Constructor(foods []string, cuisines []string, ratings []int) FoodRatings &#123; f := FoodRatings&#123; Map: make(map[string]*FoodHeap), NameMap: make(map[string]*Food, len(foods)), &#125; var ( food *Food h *FoodHeap has bool ) for idx := range foods &#123; food = &amp;Food &#123; foods[idx], cuisines[idx], ratings[idx], 0, &#125; f.NameMap[foods[idx]] = food if h, has = f.Map[cuisines[idx]]; !has &#123; h = &amp;FoodHeap&#123;&#125; f.Map[cuisines[idx]] = h &#125; heap.Push(h, food) &#125; return f&#125;func (this *FoodRatings) ChangeRating(food string, newRating int) &#123; f := this.NameMap[food] h := this.Map[f.C] f.Rating = newRating heap.Fix(h, f.Idx) &#125;func (this *FoodRatings) HighestRated(cuisine string) string &#123; h := this.Map[cuisine] if h.Len() == 0 &#123; return cuisine + &quot;No exist&quot; &#125; return (*h)[0].Name&#125; LCR 184. 设计自助结算系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type MaxQueue struct &#123; q1 []int max []int&#125;func Constructor() MaxQueue &#123; return MaxQueue&#123; make([]int,0), make([]int,0), &#125;&#125;func (this *MaxQueue) Max_value() int &#123; if len(this.max) == 0&#123; return -1 &#125; return this.max[0]&#125;func (this *MaxQueue) Push_back(value int) &#123; this.q1 = append(this.q1,value) for len(this.max) != 0 &amp;&amp; value &gt; this.max[len(this.max)-1]&#123; this.max = this.max[:len(this.max)-1] &#125; this.max = append(this.max,value)&#125;func (this *MaxQueue) Pop_front() int &#123; n := -1 if len(this.q1) != 0&#123; n = this.q1[0] this.q1 = this.q1[1:] if this.max[0] == n&#123; this.max = this.max[1:] &#125; &#125; return n&#125;/** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Max_value(); * obj.Push_back(value); * param_3 := obj.Pop_front(); */作者：Sakura链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solutions/135149/golang-shuang-dui-lie-by-sakura-151/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows IE代理问题解决","slug":"络/windows IE代理问题解决","date":"2024-04-05T05:11:29.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2024-04-05-e1116cf34b00.html","link":"","permalink":"https://leiqi.top/2024-04-05-e1116cf34b00.html","excerpt":"","text":"CMD 检查系统代理配置： - 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。 - 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 双指针","slug":"eetcode/leetcode 双指针","date":"2024-03-23T14:51:46.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-03-23-84678021105b.html","link":"","permalink":"https://leiqi.top/2024-03-23-84678021105b.html","excerpt":"","text":"1234567891011121314// 删除有序数组中的重复元素func removeDuplicates(nums []int) int &#123; slow:=0 for fast:=1;fast &lt;len(nums);fast++ &#123; if nums[fast] != nums[slow] &#123; slow++// 跳到下个位置，保存slow nums[slow] = nums[fast] &#125; &#125; return slow +1&#125; slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。 12345678910func moveZeroes(nums []int) &#123; slow, n := 0, len(nums) for fast := 0; fast &lt; n; fast++ &#123; // 注意第一个是0的时候需要比较 if nums[fast] != 0 &#123; // 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 nums[slow], nums[fast] = nums[fast], nums[slow] slow++ &#125; &#125;&#125; 思路： 1234567891011121314func maxArea(height []int) int &#123; ans := 0 for i := 0; i &lt; len(height); i++ &#123; for j := i + 1; j &lt; len(height); j++ &#123; area := (j - i) * min(height[i], height[j]) ans = max(area,ans) &#125; &#125; return ans&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 123456789101112131415161718func maxArea(height []int) (ans int) &#123; left, right := 0, len(height)-1 // 初始化两边指针 for left &lt; right &#123; area := (right - left) * min(height[left], height[right]) // 计算面积 ans = max(ans, area) // 计算最大值 if height[left] &lt; height[right] &#123; left++ // 移动短的那个 &#125; else &#123; right-- &#125; &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 前缀和，后缀和木桶效应，当前能装的水，取决于两边最大值 的最小值。 1234567891011121314151617181920212223242526func trap(height []int) (ans int) &#123; n := len(height) preMax := make([]int, n) // preMax[i] 表示从 height[0] 到 height[i] 的最大值 preMax[0] = height[0] for i := 1; i &lt; n; i++ &#123; preMax[i] = max(preMax[i-1], height[i]) &#125; sufMax := make([]int, n) // sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值 sufMax[n-1] = height[n-1] for i := n - 2; i &gt;= 0; i-- &#123; sufMax[i] = max(sufMax[i+1], height[i]) &#125; for i, h := range height &#123; ans += min(preMax[i], sufMax[i]) - h // 累加每个水桶能接多少水 &#125; return&#125;func min(a, b int) int &#123; if a &gt; b &#123; return b &#125;; return a &#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125; 双指针 123456789101112131415161718func trap(height []int) (ans int) &#123; left, right, preMax, sufMax := 0, len(height)-1, 0, 0 for left &lt; right &#123; preMax = max(preMax, height[left]) sufMax = max(sufMax, height[right]) if preMax &lt; sufMax &#123; ans += preMax - height[left] left++ &#125; else &#123; ans += sufMax - height[right] right-- &#125; &#125; return&#125;func max(a, b int) int &#123; if a &lt; b &#123; return b &#125;; return a &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 单调栈","slug":"eetcode/leetcode 单调栈","date":"2024-02-24T15:57:54.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-02-24-dd95d981cb94.html","link":"","permalink":"https://leiqi.top/2024-02-24-dd95d981cb94.html","excerpt":"","text":"单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」 输入一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 1234567891011121314151617181920212223func nextGreaterElement(nums []int) []int &#123; n := len(nums) // 存放答案的数组 res := make([]int, n) // 倒着往栈里放 s := make([]int, 0) for i := n - 1; i &gt;= 0; i-- &#123; // 倒着入栈是为了后边正着出栈 // 判定个子高矮 for len(s) &gt; 0 &amp;&amp; s[len(s)-1] &lt;= nums[i] &#123; // 矮个起开，反正也被挡着了。。。 s = s[:len(s)-1] &#125; // nums[i] 身后的更大元素 if len(s) == 0 &#123; // 没有更大的元素 res[i] = -1 &#125; else &#123; res[i] = s[len(s)-1] // 正着出栈 &#125; s = append(s, nums[i]) // 当前元素 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"golang 修改函数传入参数切片需要指针","slug":"olang/golang 修改函数传入参数切片需要指针","date":"2024-02-24T14:50:06.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2024-02-24-4fbd7a88bf6f.html","link":"","permalink":"https://leiqi.top/2024-02-24-4fbd7a88bf6f.html","excerpt":"","text":"func dfs(root *TreeNode, res *[]int) { if root &#x3D;&#x3D; nil { return } *res = append(*res, root.Val) dfs(root.Left, res) dfs(root.Right, res) }在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。 在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。 但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。 这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"路由器设置桥接","slug":"络/路由器设置桥接","date":"2024-02-15T13:34:12.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2024-02-15-1f66da892e14.html","link":"","permalink":"https://leiqi.top/2024-02-15-1f66da892e14.html","excerpt":"","text":"设置密码类型和主路由一样 记得关闭DHCP服务器","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"leetcode 406. 根据身高重建队列【贪心】","slug":"eetcode/leetcode 406. 根据身高重建队列【贪心】","date":"2024-01-23T16:13:30.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-01-23-1cb0809a7893.html","link":"","permalink":"https://leiqi.top/2024-01-23-1cb0809a7893.html","excerpt":"","text":"406. 根据身高重建队列 - 力扣（LeetCode） 12345678910111213141516func reconstructQueue(people [][]int) [][]int &#123; sort.Slice(people, func(i, j int) bool &#123; if people[i][0] == people[j][0]&#123; return people[i][1] &lt; people[j][1] &#125; return people[i][0] &gt; people[j][0] // 身高由大到小排列 &#125;)i // 再按照K进行插入排序，优先插入K小的 for i, p := range people &#123; copy(people[p[1]+1 :i+1], people[p[1] :i=1]) // 腾空出一个位置 people[p[1]] = pi &#125; return people&#125; sort.Slice(people, func(i, j int) bool &#123; ... &#125;): 使用 sort.Slice 对 people 进行排序，按照身高从大到小排列，如果身高相同则按照 k 从小到大排列。 for i, p := range people &#123; ... &#125;: 遍历排序后的数组，按照每个人的 k 值进行插入排序。 copy(people[p[1]+1:i+1], people[p[1]:i+1]): 在插入位置 p[1] 之后的位置腾出一个空位，为新的元素插入做准备。 people[p[1]] = p: 将当前人物 p 插入到正确的位置。 最终，返回重新排列后的队列 people。 在 copy(people[p[1]+1:i+1], people[p[1]:i+1]) 中，使用 i+1 而不是 len(people) 的原因是为了确保只复制有效的元素范围。这里的目标是将 people[p[1]:i+1] 复制到 people[p[1]+1:i+1]，而不是复制整个切片。 让我们考虑一下为什么使用 i+1： i 表示当前元素的索引，而我们想要复制的范围是从 p[1] 到 i。 使用 i+1 作为结束索引可以确保包含 i 在内的元素，而不会超出有效的范围。 如果使用 len(people) 作为结束索引，那么将会复制从 p[1] 到 len(people)-1 的所有元素，这超出了实际有效的范围。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 77.组合【回溯】","slug":"eetcode/leetcode 77.组合【回溯】","date":"2024-01-23T15:17:11.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-01-23-183e0ff5f5ef.html","link":"","permalink":"https://leiqi.top/2024-01-23-183e0ff5f5ef.html","excerpt":"","text":"77. 组合 - 力扣（LeetCode） 使用回溯的模板 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125;&#125; 12345678910111213141516171819202122232425func combine(n int, k int) [][]int &#123; res := [][]int&#123;&#125; path := []int&#123;&#125; // 结束条件 var backtracking func(n, k ,startIdx int) backtracking = func(n, k ,startIdx int) &#123; // 提前返回需要return if len(path) == k &#123; pathTmp := make([]int,len(path)) copy(pathTmp, path) res = append(res, pathTmp) return // return &#125; for i := startIdx;i &lt;= n ;i++ &#123; path = append(path,i) backtracking(n,k,i+1) // i+1 进行下一轮 path = path[:(len(path) -1)] &#125; &#125; backtracking(n,k,1) return res&#125; 创建一个二维切片 res 用于存储最终结果，以及一个一维切片 path 用于存储当前路径。 定义回溯函数 backtracking，它接收三个参数：n 表示数字范围，k 表示组合长度，startIdx 表示当前起始数字的索引。 在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。 使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。 在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。 在主函数中初始调用回溯函数，然后返回最终结果。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【BFS DFS通用模板】","slug":"eetcode/【BFS DFS通用模板】","date":"2024-01-22T16:05:29.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-01-22-759654485d5d.html","link":"","permalink":"https://leiqi.top/2024-01-22-759654485d5d.html","excerpt":"","text":"深度优先搜索（DFS）通用模板123456789101112131415161718192021222324252627282930313233343536// 通用的深度优先搜索函数func dfs(node int, visited []bool, graph [][]int) &#123; // 边界终止条件 if m n &#123; &#125; // 终止条件 if visited[node] &#123; return &#125; // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 递归处理相邻节点 for _, neighbor := range graph[node] &#123; dfs(neighbor, visited, graph) &#125;&#125;// 在主函数中调用func main() &#123; // 初始化节点、访问数组等 // ... // 遍历所有节点 for node := 0; node &lt; len(graph); node++ &#123; if !visited[node] &#123; dfs(node, visited, graph) &#125; &#125;&#125; 广度优先搜索（BFS）通用模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 通用的广度优先搜索函数func bfs(start int, graph [][]int) &#123; queue := []int&#123;start&#125; visited := make([]bool, len(graph)) for len(queue) &gt; 0 &#123; // 出队列 node := queue[0] queue = queue[1:] // 处理当前节点 // ... // 标记当前节点为已访问 visited[node] = true // 将相邻节点入队列 for _, neighbor := range graph[node] &#123; if !visited[neighbor] &#123; queue = append(queue, neighbor) &#125; &#125; &#125;&#125;// 在主函数中调用func main() &#123; // 初始化起始节点、图等 // ... // 调用BFS函数 bfs(start, graph)&#125;// 计算从起点 start 到终点 target 的最近距离func BFS(start Node, target Node) int &#123; // 核心数据结构 q := make([]Node, 0) // 避免走回头路 visited := make(map[Node]bool) // 将起点加入队列 q = append(q, start) visited[start] = true for len(q) &gt; 0 &#123; sz := len(q) // 将当前队列中的所有节点向四周扩散 for i := 0; i &lt; sz; i++ &#123; cur := q[0] q = q[1:] // 划重点：这里判断是否到达终点 if cur == target &#123; return step &#125; // 将 cur 的相邻节点加入队列 for _, x := range cur.adj() &#123; if _, ok := visited[x]; !ok &#123; q = append(q, x) visited[x] = true &#125; &#125; &#125; &#125; // 如果走到这里，说明在图中没有找到目标节点&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 94.二叉树的中序遍历","slug":"eetcode/leetcode 94.二叉树的中序遍历","date":"2024-01-22T15:01:59.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2024-01-22-f8790b7ced8e.html","link":"","permalink":"https://leiqi.top/2024-01-22-f8790b7ced8e.html","excerpt":"","text":"递归方法123456789101112131415func inorderTraversal(root *TreeNode) (res []int) &#123; var traversal func(node *TreeNode) traversal = func(node *TreeNode) &#123; if node == nil &#123; return &#125; traversal(node.Left) res = append(res,node.Val) traversal(node.Right) &#125; traversal(root) return res&#125; 非递归方法1234567891011121314151617181920212223func inorderTraversal(root *TreeNode) []int &#123; ans := []int&#123;&#125; if root == nil &#123; return ans &#125; st := list.New() cur := root for cur != nil || st.Len() &gt; 0 &#123; if cur != nil &#123; st.PushBack(cur) cur = cur.Left &#125; else &#123; cur = st.Remove(st.Back()).(*TreeNode) ans = append(ans, cur.Val) cur = cur.Right &#125; &#125; return ans&#125; 下面是对代码的解释： ans := []int&#123;&#125;: 创建一个空的整数切片，用于存储最终的中序遍历结果。 if root == nil &#123; return ans &#125;: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。 st := list.New(): 创建一个新的链表（list），用作栈。这里使用标准库中的list包，实现了一个双向链表作为栈。 cur := root: 初始化当前节点为根节点。 for cur != nil || st.Len() &gt; 0 &#123;: 进入循环，只要当前节点不为空或栈不为空就继续遍历。 if cur != nil &#123;: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。 st.PushBack(cur): 将当前节点入栈。 cur = cur.Left: 移动到左子树。 &#125; else &#123;: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。 cur = st.Remove(st.Back()).(*TreeNode): 弹出栈顶节点，即当前待处理的节点。 ans = append(ans, cur.Val): 将当前节点的值加入结果切片。 cur = cur.Right: 移动到右子树。 循环回到第5步，直到栈为空。 这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。 其中 进入循环的条件 for cur != nil || st.Len() &gt; 0 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件： cur != nil: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。 st.Len() &gt; 0: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。 这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。 在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【go】初始化双向列表List","slug":"eetcode/【go】初始化双向列表List","date":"2024-01-22T14:39:01.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-01-22-93119ce81a1c.html","link":"","permalink":"https://leiqi.top/2024-01-22-93119ce81a1c.html","excerpt":"","text":"在Go语言中，两种方法都可以用于初始化一个list.List。 queue := &amp;list.List&#123;&#125;: 这是使用结构体字面量的方式，创建一个 list.List 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。 queue := list.New(): 这是使用 list 包中的 New 函数来创建一个新的 list.List。New 函数返回一个指向新创建的 list.List 实例的指针。同样，这种方式也创建了一个空的链表。 两种方式都是有效的","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【20240114】LeetCode 83. 删除排序链表中的重复元素","slug":"eetcode/【20240114】LeetCode 83. 删除排序链表中的重复元素","date":"2024-01-14T10:10:30.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-01-14-e61755fec3db.html","link":"","permalink":"https://leiqi.top/2024-01-14-e61755fec3db.html","excerpt":"","text":"Problem: 83. 删除排序链表中的重复元素 [TOC] 思路 遍历 解题方法 描述你的解题方法 复杂度时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123; for i := head; i != nil &amp;&amp; i.Next != nil ; &#123; if i.Next.Val == i.Val &#123; i.Next = i.Next.Next // 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123; i = i.Next不需要 &#125; else &#123; i = i.Next &#125; &#125; return head&#125;2func deleteDuplicates(head *ListNode) *ListNode &#123; current := head for current != nil &amp;&amp; current.Next != nil &#123; if current.Next.Val == current.Val &#123; // 保存下一个节点的引用 nextNode := current.Next // 删除当前节点 current.Next = nextNode.Next // 释放内存 nextNode = nil &#125; else &#123; // 非重复元素，继续遍历 current = current.Next &#125; &#125; return head&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"【Win】键盘下键坏了，使用组合键模拟下方向键","slug":"具/【Win】键盘下键坏了，使用组合键模拟下方向键","date":"2024-01-14T09:05:02.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2024-01-14-2aaa71f8e7be.html","link":"","permalink":"https://leiqi.top/2024-01-14-2aaa71f8e7be.html","excerpt":"","text":"使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤： 下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中： 1!s::Send &#123;Down&#125; 这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。 运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。 现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"【20240106】leetcode 2807. 在链表中插入最大公约数","slug":"eetcode/【20240106】leetcode 2807. 在链表中插入最大公约数","date":"2024-01-06T15:27:26.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2024-01-06-2b3ad028343c.html","link":"","permalink":"https://leiqi.top/2024-01-06-2b3ad028343c.html","excerpt":"","text":"2807. 在链表中插入最大公约数 - 力扣（LeetCode） 最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。 计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下： 用较大的数除以较小的数，得到余数。 将较小的数作为新的被除数，余数作为新的除数。 重复步骤 1 和 2，直到余数为零。 最后的非零余数即为最大公约数。 这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。 以下是一个用 Go 语言实现的最大公约数的辗转相除法示例： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;// 辗转相除法求最大公约数func gcd(a, b int) int &#123; for b != 0 &#123; temp := b b = a % b a = temp &#125; return a&#125;func main() &#123; num1 := 48 num2 := 18 result := gcd(num1, num2) fmt.Println(&quot;最大公约数为:&quot;, result)&#125; 在这个例子中，gcd 函数使用了辗转相除法来计算两个整数的最大公约数。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LeetCode 1071. 字符串的最大公因子","slug":"eetcode/LeetCode 1071. 字符串的最大公因子","date":"2024-01-03T15:12:16.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2024-01-03-58e186a9065e.html","link":"","permalink":"https://leiqi.top/2024-01-03-58e186a9065e.html","excerpt":"","text":"1071. 字符串的最大公因子 解题思路： 暴力解法123456789101112131415161718192021222324252627282930313233343536373839404142func gcdOfStrings(str1 string, str2 string) string &#123; n1, n2 := len(str1), len(str2) // 从最长的可能的子串长度开始尝试 for i := min(n1, n2); i &gt; 0; i-- &#123; if n1%i == 0 &amp;&amp; n2%i == 0 &#123; commonSubstring := str1[:i] // 检查是否满足条件 if checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123; return commonSubstring &#125; &#125; &#125; return &quot;&quot;&#125;// 检查字符串是否能够整除func checkDivisible(s string, sub string) bool &#123; repeats := len(s) / len(sub) concatenated := repeatString(sub, repeats) return s == concatenated&#125;// 重复字符串func repeatString(s string, count int) string &#123; result := &quot;&quot; for i := 0; i &lt; count; i++ &#123; result += s &#125; return result&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 数学方法辗转相除法 1234567891011121314151617func gcdOfStrings(str1 string, str2 string) string &#123; if str1 + str2 != str2 + str1 &#123; return &quot;&quot; &#125; gcd := gcd(len(str1), len(str2)) return str1[0:gcd]&#125; func gcd(a, b int) int &#123; for b != 0 &#123; a, b = b, a % b &#125; return a&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"windows新增wsl bash here键快捷方式","slug":"具/windows新增wsl bash here键快捷方式","date":"2024-01-01T10:23:10.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2024-01-01-38178c63ba17.html","link":"","permalink":"https://leiqi.top/2024-01-01-38178c63ba17.html","excerpt":"","text":"win + R 输入regedit输入到 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 新建wsl_bash_here目录, 设置如下默认值 新建command新建项，输入wsl.exe 的地址 成功可以看到右侧是有wsl bash here的选项的在当面目录打开wsl 成功原理和添加git bash here 类似, 参考:手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git 设置免密配置-全局免密-单仓库免密-SSH免密","slug":"it/git 设置免密配置-全局免密-单仓库免密-SSH免密","date":"2024-01-01T06:56:28.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2024-01-01-91517aa963bc.html","link":"","permalink":"https://leiqi.top/2024-01-01-91517aa963bc.html","excerpt":"","text":"介绍之前我们要首先知道一个简单的概念:https通过记住账号密码免登，ssh通过校验生成的密钥免登。 通常都用ssh校验。 查看通信方式 在项目目录中运行命令： 1git remote -v 如果出现提示是： 12origin https://gitee.com/xxx/xxx.git (fetch)origin https://gitee.com/xxx/xxx.git (push) 则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址 一、https 方式及免密码配置0. 项目中 git 基本配置全局用户名密码配置 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@qq.com&quot; 项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。 1234567# 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令git init# 关联远程仓库git remote add origin https://gitee.com/xxx/xxx.gitgit add -Agit commit -m &quot;初始化&quot;git push -u origin master 需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。 这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。 1.全局免密码配置配置存储模式 1git config --global credential.helper store 执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store Linux 下查看： 1vim ~/.gitconfig windows10 下当前用户路径：%USERPROFILE%内容如下： 12345[user] name = lenovo email = xxxx@outlook.com[credential] helper = store 然后在项目目录，执行git pull&#x2F;git push命令，会提示输入账号密码。这次输入账号密码之后，就会记住账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。 2、单项目免密码配置编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项： 12[remote &quot;origin&quot;]url = https://gitee.com/xxx/xxx.git 修改为： 12[remote &quot;origin&quot;] url = https://yourusername:password@gitee.com/xxx/xxxx.git 也就是在 https:// 之后，增加 用户名:密码@ 二. SSH免密登录如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式, 1git remote rm origin 前提github 网页增加本机SSH key git ssh 方式免密提交方式需要将 ssh-keygen 生成的公钥放到服务器上 全局用户名密码配置 12git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx@qq.com&quot; 项目初始化，生成 .git 目录，配置 ssh 远程项目地址。 123# 如果是新仓库需要git init ;否则不需要git init; git init# git 关联远程仓库git remote add origin git@gitee.com:xxx/xxx.git 生成公钥和私钥1、首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，检查本机的ssh密钥。 12$ cd ~/.ssh $ ls 如果提示：No such file or directory ，说明是第一次使用 git。 如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。 123$ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 2、执行生成公钥和私钥的命令，生成新的密钥： 1ssh-keygen -t rsa -C &quot;xxx&quot; 代码参数： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。 按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 执行查看公钥信息： 1cat ~/.ssh/id_rsa.pub Windows 系统，位置在用户目录下 .ssh文件夹中。%USERPROFILE% 复制公钥信息到远端仓库gitee打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。 githubSettings -SSH and GPG keys - New SSH key然后，提交时就不再需要用户名和密码了 123git add -Agit commit -m &quot;ssh免密提交&quot;git push -u origin master 参考:https://zhuanlan.zhihu.com/p/358721423","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"Windows设置Clion 下方Terminal为WSL linux 子系统","slug":"具/Windows设置Clion 下方Terminal为WSL linux 子系统","date":"2023-12-30T15:49:39.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-12-30-397a0b919639.html","link":"","permalink":"https://leiqi.top/2023-12-30-397a0b919639.html","excerpt":"","text":"终端上的小箭头下的设置 找到WSL的地址 粘贴到对应地址中 设置成功这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"免费使用Jetbrain 全家桶-服务器激活码激活软件","slug":"具/免费使用Jetbrain 全家桶-服务器激活码激活软件","date":"2023-12-30T15:08:29.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-12-30-6a1e804ab992.html","link":"","permalink":"https://leiqi.top/2023-12-30-6a1e804ab992.html","excerpt":"","text":"众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品. Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。 https://search.censys.io/ 搜索：services.http.response.headers.location: account.jetbrains.com/fls-auth https://www.shodan.io 搜索：Location: https://account.jetbrains.com/fls-auth https://fofa.info/ 搜索：fls-auth 随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是https://search.censys.io/ 网站, 搜索 1services.http.response.headers.location: account.jetbrains.com/fls-auth 例如上边就是 http://111.231.22.61:1024 激活成功激活成功，请开始愉快的编码吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"WPS设置打开文件自动同步云文档","slug":"具/WPS设置打开文件自动同步云文档","date":"2023-12-30T14:08:47.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-12-30-3a73bdfdd568.html","link":"","permalink":"https://leiqi.top/2023-12-30-3a73bdfdd568.html","excerpt":"","text":"不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作： 打开首页，设置中心 打开新文件会自动上传更新","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git强制拉取远端","slug":"it/git强制拉取远端","date":"2023-10-22T09:53:57.000Z","updated":"2025-01-13T15:35:14.511Z","comments":true,"path":"2023-10-22-9bf76366f18c.html","link":"","permalink":"https://leiqi.top/2023-10-22-9bf76366f18c.html","excerpt":"","text":"12git fetch origingit reset --hard origin/&lt;branch_name&gt; 这里的 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下： git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。 git reset –hard origin&#x2F;：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。 这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。","categories":[{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"}],"tags":[]},{"title":"leetcode 1726.同积元组","slug":"eetcode/leetcode 1726.同积元组","date":"2023-10-20T15:21:57.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-10-20-9599b5db4d91.html","link":"","permalink":"https://leiqi.top/2023-10-20-9599b5db4d91.html","excerpt":"","text":"Problem: 1726. 同积元组 思路 使用排列组合的方法，开始使用三种语言同时写leetcode. 解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213func tupleSameProduct(nums []int) int &#123; n := len(nums) cnt := make(map[int]int) for i := 0; i &lt; n; i++ &#123; for j := i + 1; j &lt; n; j++ &#123;// j +1 不要重复 cnt[nums[i] * nums[j]]++ // 使用map 遍历每次乘积对应次数 &#125; &#125; ans := 0 for _, v := range cnt &#123; ans += v * (v - 1) * 4 &#125; []1234567891011121314151617class Solution &#123;public: int tupleSameProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = 0; unordered_map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; cnt[nums[i] * nums[j]]++; &#125; &#125; for (auto &amp;[k, v] : cnt) &#123; ans += v * (v - 1) * 4; &#125; return ans; &#125;&#125;; []12345678910111213141516class Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = dict() for i in range(n): for j in range(i+1,n): if nums[i]*nums[j] in maps: maps[nums[i] * nums[j]] += 1 else: maps[nums[i] * nums[j]] = 1 ans = 0 for _, v in maps.items(): ans += v*(v-1) *4 return ans","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"本地运行LeetCode的Python代码 调试","slug":"ython/本地运行LeetCode的Python代码 调试","date":"2023-10-19T16:57:22.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-10-19-6057db0e071e.html","link":"","permalink":"https://leiqi.top/2023-10-19-6057db0e071e.html","excerpt":"","text":"最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦 要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类： 创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。 导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。 1from typing import List 创建Solution类并在其中定义问题的解决方案。例如： 1234567891011class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: # 实现你的解决方案 # 例如，找到两个数的和等于目标，并返回它们的索引 num_to_index = &#123;&#125; for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] 创建一个main函数来测试你的解决方案。 12345def main(): solution = Solution() # 调用Solution类的方法进行测试 result = solution.twoSum([2, 7, 11, 15], 9) print(result) 12if __name__ == &quot;__main__&quot;: main() 执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行： 1python leetcode_solution.py 这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"三种Python3 判断字典中是否存在对应key的方法","slug":"ython/三种Python3 判断字典中是否存在对应key的方法","date":"2023-10-19T16:41:07.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-10-19-8f51ae9ef5a1.html","link":"","permalink":"https://leiqi.top/2023-10-19-8f51ae9ef5a1.html","excerpt":"","text":"第一种：使用get()方法 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; 打印返回值 12print(dict.get(&#x27;name&#x27;)) # 结果返回对应valprint(dict.get(&#x27;id&#x27;)) # 结果返回None 第二种：使用keys()方法 生成一个字典dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’} 判断是否存在，其中dict.keys()是列出字典所有的key 12print(&#x27;name&#x27; in dict.keys()) # 结果返回Trueprint(&#x27;id&#x27; in dict.keys()) # 结果返回False 除了使用in也可以使用not in，用于判定这个key不存在 第三种：使用 in 关键字 生成一个字典 1dict = &#123;&#x27;name&#x27;: &#x27;&#x27;,&#x27;age&#x27;: &#x27;&#x27;,&#x27;sex&#x27;: &#x27;&#x27;&#125; # 判断key是否存在于dict中 12print(&#x27;name&#x27; in dict) # 结果返回Trueprint(&#x27;id&#x27; in dict) # 结果返回False 补充：生成默认字典（collections.defaultdict）使用defaultdict(int)来创建maps，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。 123456789101112131415from collections import defaultdictclass Solution: def tupleSameProduct(self, nums: List[int]) -&gt; int: n = len(nums) maps = defaultdict(int) ans = 0 for i in range(n): for j in range(i+1, n): product = nums[i] * nums[j] ans += maps[product] * 4 maps[product] += 1 return ans","categories":[{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"}],"tags":[]},{"title":"数据结构和操作的对比：Python vs. Go vs. C++","slug":"eetcode/数据结构和操作的对比：Python vs. Go vs. C++","date":"2023-10-19T16:25:56.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2023-10-19-86483682723b.html","link":"","permalink":"https://leiqi.top/2023-10-19-86483682723b.html","excerpt":"","text":"Python示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 数组my_list = [1, 2, 3, 4]# 切片sub_list = my_list[1:3]reversed_list = my_list[::-1python]# 字典my_dict = &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;# 双向链表（使用collections.deque）from collections import dequemy_linked_list = deque()my_linked_list.append(1)my_linked_list.append(2)my_linked_list.append(3)# 最大堆和最小堆（需要使用第三方库heapq）import heapqmax_heap = []min_heap = []# 二叉树（使用类或结构体）# 字符串操作my_string = &quot;Hello, World!&quot;substring = my_string[7:12]my_int = 42my_str = str(my_int)# 深度拷贝和浅拷贝（使用copy模块）import copyoriginal_list = [1, [2, 3], 4]shallow_copy = copy.copy(original_list)deep_copy = copy.deepcopy(original_list)# 删除元素my_list.pop(1) # 删除第二个元素# 查找小写字母if my_string.islower(): print(&quot;String contains only lowercase letters&quot;)# 遍历数组for item in my_list: print(item)# 使用循环遍历字典for key, value in my_dict.items(): print(key, value)# 判断字典是否包含键if &#x27;name&#x27; in my_dict: print(&quot;Dictionary contains &#x27;name&#x27;&quot;) Go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Go示例// 数组和切片mySlice := []int&#123;1, 2, 3, 4&#125;subSlice := mySlice[1:3]reversedSlice := reverseSlice(mySlice)// 字典myMap := map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30,&#125;// 双向链表（使用container/list）import &quot;container/list&quot;myList := list.New()myList.PushBack(1)myList.PushBack(2)myList.PushBack(3)// 最大堆和最小堆（需要使用heap包）import &quot;container/heap&quot;maxHeap := &amp;MaxHeap&#123;&#125;minHeap := &amp;MinHeap&#123;&#125;// 二叉树（使用结构体或指针）// 字符串操作myString := &quot;Hello, World!&quot;substring := myString[7:12]myInt := 42myStr := fmt.Sprintf(&quot;%d&quot;, myInt)// 深度拷贝和浅拷贝（使用复制切片或递归）originalSlice := []int&#123;1, 2, 3, 4&#125;shallowCopy := make([]int, len(originalSlice))copy(shallowCopy, originalSlice)deepCopy := append([]int(nil), originalSlice...)// 删除元素index := 1mySlice = append(mySlice[:index], mySlice[index+1:]...)// 查找小写字母containsLowercase := falsefor _, char := range myString &#123; if unicode.IsLower(char) &#123; containsLowercase = true break &#125;&#125;// 遍历切片for _, item := range mySlice &#123; fmt.Println(item)&#125;// 使用循环遍历字典for key, value := range myMap &#123; fmt.Println(key, value)&#125;// 判断字典是否包含键if _, exists := myMap[&quot;name&quot;]; exists &#123; fmt.Println(&quot;Map contains &#x27;name&#x27;&quot;)&#125; C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// C++示例// 数组和向量#include &lt;vector&gt;std::vector&lt;int&gt; myVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; subVector(myVector.begin() + 1, myVector.begin() + 3);std::vector&lt;int&gt; reversedVector(myVector.rbegin(), myVector.rend());// 字典（使用std::map）#include &lt;map&gt;std::map&lt;std::string, int&gt; myMap;myMap[&quot;name&quot;] = &quot;Alice&quot;;myMap[&quot;age&quot;] = 30;// 双向链表（使用std::list）#include &lt;list&gt;std::list&lt;int&gt; myList;myList.push_back(1);myList.push_back(2);myList.push_back(3);// 最大堆和最小堆（使用std::priority_queue）#include &lt;queue&gt;std::priority_queue&lt;int&gt; maxHeap;std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;// 二叉树（使用结构体或指针）// 字符串操作std::string myString = &quot;Hello, World!&quot;;std::string substring = myString.substr(7, 5);int myInt = 42;std::string myStr = std::to_string(myInt);// 深度拷贝和浅拷贝std::vector&lt;int&gt; originalVector = &#123;1, 2, 3, 4&#125;;std::vector&lt;int&gt; shallowCopy = originalVector;std::vector&lt;int&gt; deepCopy(originalVector);// 删除元素int index = 1;myVector.erase(myVector.begin() + index);// 查找小写字母bool containsLowercase = false;for (char c : myString) &#123; if (std::islower(c)) &#123; containsLowercase = true; break; &#125;&#125;// 遍历向量for (int item : myVector) &#123; std::cout &lt;&lt; item &lt;&lt; std::endl;&#125;// 使用循环遍历字典for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;// 判断字典是否包含键if (myMap.find(&quot;name&quot;) != myMap.end()) &#123; std::cout &lt;&lt; &quot;Map contains &#x27;name&#x27;&quot; &lt;&lt; std::endl;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 136.只出现一次的数字","slug":"eetcode/Leetcode 136.只出现一次的数字","date":"2023-10-16T15:23:24.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-10-16-66afbe22520d.html","link":"","permalink":"https://leiqi.top/2023-10-16-66afbe22520d.html","excerpt":"","text":"Problem: 136. 只出现一次的数字[TOC] 思路 如何才能做到线性时间复杂度和常数空间复杂度呢？ 答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。 任何数和 0做异或运算，结果仍然是原来的数任何数和其自身做异或运算，结果是 0 解题方法 描述你的解题方法 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code hash []1234567891011121314func singleNumber(nums []int) int &#123; numsMap := make(map[int]int) for _, val := range nums &#123; numsMap[val] += 1 &#125; for key, val := range numsMap &#123; if val == 1 &#123; return key &#125; &#125; return 0&#125; 位运算 []123456789func singleNumber(nums []int) int &#123; single := 0 for _, num := range nums &#123; single ^= num &#125; return single&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 155.最小栈","slug":"eetcode/leetcode 155.最小栈","date":"2023-10-12T16:07:58.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-10-12-cfa4d16bfad5.html","link":"","permalink":"https://leiqi.top/2023-10-12-cfa4d16bfad5.html","excerpt":"","text":"Problem: 155. 最小栈 思路 栈 解题方法 描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code[]12345678910111213141516171819202122232425262728293031323334353637383940// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好type MinStack struct &#123; stack []int // 主栈 minStack []int // 辅助栈&#125;func Constructor() MinStack &#123; minStacks := MinStack&#123;[]int&#123;&#125;, []int&#123;math.MaxInt&#125;&#125; return minStacks&#125;func (this *MinStack) Push(x int) &#123; // 同时比较辅助站的的top元素，如果更小 则添加到辅助站 this.stack = append(this.stack, x) minTmp := min(x, this.minStack[len(this.minStack)-1]) this.minStack = append(this.minStack, minTmp)&#125;func (this *MinStack) Pop() &#123; this.stack = this.stack[:len(this.stack)-1] this.minStack = this.minStack[:len(this.minStack)-1]&#125;func (this *MinStack) Top() int &#123; return (this.stack[len(this.stack)-1])&#125;func (this *MinStack) GetMin() int &#123; return (this.minStack[len(this.minStack)-1])&#125;func min(x, y int) int &#123; if x &lt; y &#123; return x &#125; return y&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"使用 Go 的 container list 包：双向链表的便捷工具","slug":"eetcode/使用 Go 的 container list 包：双向链表的便捷工具","date":"2023-10-09T16:44:33.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2023-10-09-5ecfb18fa495.html","link":"","permalink":"https://leiqi.top/2023-10-09-5ecfb18fa495.html","excerpt":"","text":"Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。 基本概念在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。 导入 container&#x2F;list 包要使用 container&#x2F;list 包，首先需要导入它： 1import &quot;container/list&quot; 创建链表创建一个新的链表非常简单： 1myList := list.New() 这将创建一个名为 myList 的新链表。 插入元素你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头： 12myList.PushBack(42)myList.PushFront(23) 访问元素要访问链表中的元素，你可以使用 Front 和 Back 方法： 12firstElement := myList.Front().ValuelastElement := myList.Back().Value 遍历链表遍历链表可以使用 for 循环来实现： 123for element := myList.Front(); element != nil; element = element.Next() &#123; // 处理 element.Value&#125; 删除元素要删除链表中的元素，可以使用 Remove 方法： 12elementToRemove := myList.Front()myList.Remove(elementToRemove) 容易混淆的地方1. 类型断言链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如： 1value := element.Value.(int) 如果断言失败，会导致运行时错误。 2. InsertAfter 和 InsertBefore这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。 示例：浏览器历史记录下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/* * Copyright (c) 2023 Lei Qi. All rights reserved. * Author: Lei Qi * Description: * Date: 2023/10/10 上午12:33 */package mainimport ( &quot;container/list&quot; &quot;fmt&quot;)type Browser struct &#123; history *list.List current *list.Element maxLen int homepage string&#125;func NewBrowser(maxLen int, homepage string) *Browser &#123; history := list.New() current := history.PushBack(homepage) return &amp;Browser&#123; history: history, current: current, maxLen: maxLen, homepage: homepage, &#125;&#125;func (b *Browser) GetCurrentPage() string &#123; return b.current.Value.(string)&#125;func (b *Browser) GoBack() string &#123; if b.current.Prev() != nil &#123; b.current = b.current.Prev() &#125; return b.GetCurrentPage()&#125;func (b *Browser) GoForward() string &#123; if b.current.Next() != nil &#123; b.current = b.current.Next() &#125; return b.GetCurrentPage()&#125;func (b *Browser) NavigateToNewPage(newPageURL string) string &#123; // 清除当前页面之后的历史记录 for e := b.current.Next(); e != nil; e = e.Next() &#123; b.history.Remove(e) &#125; // 将新页面添加到历史记录中 b.current = b.history.InsertAfter(newPageURL, b.current) // 限制浏览器历史记录的最大长度 for b.history.Len() &gt; b.maxLen &#123; front := b.history.Front() if front != nil &#123; b.history.Remove(front) &#125; &#125; return b.GetCurrentPage()&#125;func main() &#123; browser := NewBrowser(5, &quot;初始页面&quot;) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面1&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 浏览更多新页面 fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面2&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面3&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面4&quot;)) fmt.Println(&quot;浏览新页面:&quot;, browser.NavigateToNewPage(&quot;新页面5&quot;)) fmt.Println(&quot;当前页面:&quot;, browser.GetCurrentPage()) // 后退和前进 fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;后退:&quot;, browser.GoBack()) fmt.Println(&quot;前进:&quot;, browser.GoForward())&#125; 这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。 结论container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845. 座位预约管理系统","slug":"eetcode/leetcode 1845. 座位预约管理系统","date":"2023-10-06T04:09:42.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-10-06-c2afb6383992.html","link":"","permalink":"https://leiqi.top/2023-10-06-c2afb6383992.html","excerpt":"","text":"Problem: 1845. 座位预约管理系统 个人博客,记录学习: https://leiqicn.gitee.io/ [TOC] 思路 座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存. 解题方法 使用slice 的index来表示座位号,1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n; 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code使用slice []12345678910111213141516171819202122232425262728293031323334 type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber] = 0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125;&#125;使用mapmap 有个用例会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type SeatManager struct &#123; seatMap map[int]int minSeat int&#125;func Constructor(n int) SeatManager &#123; seatMap := make(map[int]int, n+1) for i := 0; i &lt;= n; i++ &#123; // 注意从0 开始初始化 seatMap[i] = 0 &#125; seatMan := SeatManager&#123; seatMap, 1, &#125; return seatMan&#125;func (this *SeatManager) Reserve() int &#123; value := this.minSeat this.seatMap[value] = 1 for i:= value; i &lt;= len(this.seatMap);i++ &#123; if this.seatMap[i] == 1 &#123; continue &#125; this.minSeat = i break &#125; return value&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seatMap[seatNumber] = 0 if seatNumber &lt; this.minSeat &#123; this.minSeat = seatNumber &#125;&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go 中是否使用make创建slice的区别","slug":"olang/Go 中是否使用make创建slice的区别","date":"2023-10-05T09:01:37.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-10-05-9d3185fd2258.html","link":"","permalink":"https://leiqi.top/2023-10-05-9d3185fd2258.html","excerpt":"","text":"go slice 的make 会创建默认长度 且值为0 的slice 在 Go 语言中，可以使用 make 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 make 和不使用 make 创建切片的主要区别： 使用 make 创建切片： 12// 使用 make 创建切片，指定长度和容量 slice := make([]int, 5, 10) 指定长度和容量： 使用 make 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。 底层数组初始化： 使用 make 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，slice 是一个包含5个零值整数的切片。 不使用 make 创建切片： 12// 不使用 make 创建切片，长度为 5 slice := []int&#123;1, 2, 3, 4, 5&#125; &#96; 自动确定长度： 不使用 make 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，slice 的长度是5，因为提供了5个整数。 容量与长度相同： 如果不使用 make 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。 总结： 使用 make 创建切片时，您可以明确控制切片的容量，并按长度初始化为0值，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。 不使用 make 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。 无论使用哪种方式创建切片，都可以使用 append 函数来动态增长切片的长度。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"JetBrians 全家桶设置文件header","slug":"具/JetBrians 全家桶设置文件header","date":"2023-10-05T08:41:46.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-10-05-7527c8e47a8b.html","link":"","permalink":"https://leiqi.top/2023-10-05-7527c8e47a8b.html","excerpt":"","text":"前言我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。 先看下效果图 操作步骤1. file- settings 找到Copyright - CopyrightProfiles点击+ 号，新建一个name 为“copyRight” 的profile profile 的内容粘贴下面的问文本, 替换自己的名字 1234Copyright (c) $originalComment.match(&quot;Copyright \\(c\\) (\\d+)&quot;, 1, &quot;-&quot;, &quot;$today.year&quot;)$today.year YOUR NAME. All rights reserved. Author: YOUR NAME Description: Date: $today 点击Copyright 添加刚才的profile 点击应用即可 右键-generate-Copyright 插入","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Leetcode1603. 设计停车系统","slug":"eetcode/Leetcode 1603. 设计停车系统","date":"2023-09-26T17:09:22.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-09-26-aeddfdb3bdac.html","link":"","permalink":"https://leiqi.top/2023-09-26-aeddfdb3bdac.html","excerpt":"","text":"Problem: 1603. 设计停车系统 [TOC] 思路 首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。 虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。 解题方法 lastCar [3]int 添加上边的数组 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(1)$ Code []12345678910111213141516171819202122232425262728293031 type ParkingSystem struct &#123; lastCar [3]int&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; var parkingSystem ParkingSystem parkingSystem.lastCar[0] = big parkingSystem.lastCar[1] = medium parkingSystem.lastCar[2] = small return parkingSystem&#125;func (this *ParkingSystem) AddCar(carType int) bool &#123; carIdx := carType - 1 if this.lastCar[carIdx] &gt; 0 &#123; this.lastCar[carIdx]-- return true &#125; return false&#125;/** * Your ParkingSystem object will be instantiated and called as such: * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver） * param_1 := obj.AddCar(carType); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Linux非root用户通过X11运行图形界面程序-以Rstudio为例","slug":"具/Linux非root用户通过X11运行图形界面程序-以Rstudio为例","date":"2023-09-24T12:36:53.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-09-24-4fe5badbd053.html","link":"","permalink":"https://leiqi.top/2023-09-24-4fe5badbd053.html","excerpt":"","text":"问题由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！ X11是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。 操作步骤 使用mobaxTerm 登录对应服务器，需要显示X11 打开 创建虚拟环境1234567# 创建虚拟环境 conda create -n rstudio# 安装Ｒconda activate rstudio # 进入创建好的环境变量conda install r-base# 安装Rstudioconda install rstudio-desktop 成功 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面 画个图试试，顺利出图！开始愉快的coding吧！ 已知问题： 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。 总结我们可以通过X11来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 将用户追加到对应用户组","slug":"inux/Linux 将用户追加到对应用户组,新建文件默认同组读写权限","date":"2023-09-17T06:02:54.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-09-17-5141f57450ab.html","link":"","permalink":"https://leiqi.top/2023-09-17-5141f57450ab.html","excerpt":"","text":"前言本文目的是为了将多个用户设置同组用户，并且同组内用户新建文件的默认权限是同组内用户可读写。 解决方案 将test 添加到GroupA 1234usermod -a -G GroupName UserName# 例如将test 追加到GroupAusermod -a -G GroupA test 修改新建文件的默认权限 在.bashrc 里添加 1umask 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--) 1source ~/.bashrc","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[]},{"title":"C++ 结构化设计","slug":"++/C++ 结构化设计","date":"2023-09-13T15:21:57.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-09-13-476441b87811.html","link":"","permalink":"https://leiqi.top/2023-09-13-476441b87811.html","excerpt":"","text":"结构化程序设计自顶向下的设计 是自顶向下的分解 -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题 实现阶段自顶向上的实现，实现一个一个子问题 程序由三种基本结构组成，顺序-分支-循环 例子","categories":[{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"}],"tags":[]},{"title":"clash在终端设置代理","slug":"具/clash在终端设置代理","date":"2023-09-12T15:38:32.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-09-12-b926f621cf15.html","link":"","permalink":"https://leiqi.top/2023-09-12-b926f621cf15.html","excerpt":"","text":"前言github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！ 开启代理前置条件：手动开打 clash 等VPN软件 12export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890 对应的网址是在settings- static-Host; 对应port 为General-Prot 取消代理12unset http_proxyunset http_proxy git 里设置开启代理 alias 命令别名新建 .bashrc123456789101112131415161718cd ~vi .bashrc# 将以下内容复制进去# .bashrc# Source global definitionsif [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrcfi# Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:# export SYSTEMD_PAGER=# User specific aliases and functions// 别名设置，其他别名设置也是类似alias proxyon=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;alias proxyoff=&quot;unset http_proxy;unset https_proxy&quot; 测试是否成功可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 2594修车的最少时间","slug":"eetcode/leetcode 2594修车的最少时间","date":"2023-09-07T15:59:00.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-09-07-b8c038c07b41.html","link":"","permalink":"https://leiqi.top/2023-09-07-b8c038c07b41.html","excerpt":"","text":"2594. 修车的最少时间 - 力扣（LeetCode） 思路能力值为 r 的机械工可以在 t&#x3D; r * n2 分钟内修好 n 辆车。可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。 12345678910111213141516171819202122func repairCars(ranks []int, cars int) int64 &#123; l , r := 1, ranks[0] * cars * cars var check = func(m int) bool &#123; cnt := 0 for _, x := range ranks &#123; cnt += int(math.Sqrt(float64(m / x))) &#125; return cnt &gt;= cars &#125; for l &lt; r &#123; m := (l + r) &gt;&gt; 1 if check(m) &#123; r = m &#125; else &#123; l = m + 1 &#125; &#125; return int64(l)&#125; l 和 r 的初始化： l 初始化为1，表示最小可能的修理时间。 r 初始化为 ranks[0] * cars * cars，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。 check 函数定义： 这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 m 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 m 时间内能修理多少辆车，然后累加到 cnt 变量中。 如果 cnt 大于或等于需要修理的汽车数量 cars，则返回 true，否则返回 false。 二分查找循环： 使用一个二分查找循环来查找最小的修理时间。循环条件是 l &lt; r，即当最小时间小于最大时间时，继续循环。 在每次循环中，计算中间值 m，并调用 check(m) 检查是否满足修理所有汽车的条件。 如果满足条件，则将 r 更新为 m，因为我们希望找到更小的修理时间。 如果不满足条件，则将 l 更新为 m + 1，因为我们需要增加修理时间。 这样，不断地缩小时间范围，直到找到最小的修理时间。 最终返回结果： 一旦 l 不再小于 r，循环结束，说明已经找到了最小的修理时间，将其转换为 int64 类型并返回。 我们总结一下二分查找适用的场景 二分查找算法适用场景递增或递减规律：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。 有序数据集合：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。 快速查找：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。 确定性问题：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。 时间复杂度要求较高：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。 可比较性数据：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。 搜索范围可确定：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。 内存连续性：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。 一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"设计模式-抽象工厂","slug":"计模式/设计模式-抽象工厂","date":"2023-09-03T12:39:19.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2023-09-03-c6ab66461699.html","link":"","permalink":"https://leiqi.top/2023-09-03-c6ab66461699.html","excerpt":"","text":"抽象工厂模式结构多个工厂模式; 有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"设计模式-工厂方法模式","slug":"计模式/设计模式-工厂方法模式","date":"2023-09-03T05:09:25.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2023-09-03-c58ee0dac51b.html","link":"","permalink":"https://leiqi.top/2023-09-03-c58ee0dac51b.html","excerpt":"","text":"网站链接：工厂方法设计模式 (refactoringguru.cn) 简介工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。 简单工厂‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间. 工厂方法模式结构不同的类实现相同的动作,例如运输等 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 具体产品 （Concrete Products） 是产品接口的不同实现。 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。 注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 伪代码基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。 如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。 如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。 你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 简单工厂和工厂模式的区别1. 简单工厂设计模式（Simple Factory Design Pattern）： 定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。2. 工厂方法设计模式（Factory Method Design Pattern）： 定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。结构： 工厂方法模式包括抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。主要区别： 复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。 责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。 扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。 灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。 选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。 UML类图如何看看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。” 接口: ‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口. 类和类之间的关系: 继承的关系，继承关系用空心三角形+实线来表示 聚合: 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。 合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。 依赖","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"leetcode 2511 最多可以摧毁的敌人城堡数目","slug":"eetcode/leetcode 2511 最多可以摧毁的敌人城堡数目","date":"2023-09-02T12:51:41.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-09-02-72954cc13c19.html","link":"","permalink":"https://leiqi.top/2023-09-02-72954cc13c19.html","excerpt":"","text":"2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode） 思路抽象出来就是求1和-1间最大连续0 的数量。 有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？ 1.当然可以分类讨论，代码会很复杂，判断很多，容易出错 使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res 12345678910111213141516171819202122232425262728293031323334353637383940func captureForts(forts []int) int &#123; ans, pre := 0, -1 //pre 记录的是 1 或 -1 的位置 for i, fort := range forts &#123; if fort == -1 || fort == 1 &#123; if pre &gt;= 0 &amp;&amp; forts[pre] != fort &#123; ans = max(ans, i - pre - 1) &#125; pre = i &#125; &#125; return ans&#125; func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"LRU","slug":"eetcode/LRU","date":"2023-08-07T15:29:00.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-08-07-e74632bdccbf.html","link":"","permalink":"https://leiqi.top/2023-08-07-e74632bdccbf.html","excerpt":"","text":"146. LRU 缓存 - 力扣（LeetCode） list Elemet 双向列表； 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &quot;container/list&quot;type LRUCache struct &#123; cap int // 缓存容量 cache map[int]*list.Element//!!! 双向链表 使用Element // 双向链表节点 指向的map list *list.List // 双向链表&#125;type keyVal struct &#123; key, val int // 节点的Key和Value&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cap: capacity, // 初始化缓存容量 cache: make(map[int]*list.Element), // 初始化map映射 list: list.New(), // 初始化双向链表 &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 return elem.Value.(*keyVal).val // 返回节点的value值 &#125; return -1 // 没有找到的情况下，返回-1&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.cache[key]; ok &#123; // 如果map里有key对应的双向链表节点 this.list.MoveToFront(elem) // 把节点移动到链表头 //!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值； elem.Value.(*keyVal).val = value // 更新节点的value值 return &#125; if this.list.Len() &gt;= this.cap &#123; // 如果超过了缓存容量 tail := this.list.Back() // 获取链表的尾节点 k := tail.Value.(*keyVal).key // 获取节点的key this.list.Remove(tail) // 从链表中删除尾节点 delete(this.cache, k) // 从map中删除尾节点 &#125; elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) // 将节点添加到链表头 this.cache[key] = elem // 将节点映射到map中&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 最大深度和最小深度","slug":"eetcode/leetcode 最大深度和最小深度","date":"2023-07-29T15:46:22.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-07-29-4df215f63090.html","link":"","permalink":"https://leiqi.top/2023-07-29-4df215f63090.html","excerpt":"","text":"题目104. 二叉树的最大深度 - 力扣（LeetCode） 111. 二叉树的最小深度 - 力扣（LeetCode） 思路深度 是指从根节点到该节点的距离（节点数量）高度 是指从该节点到叶子节点的角力（节点数量） 最大深度 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)最小子树 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现： 最大深度递归分治后序遍历 需要调用自生函数，需要严格按照定义调用递归。 1234567891011121314151617// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := maxDepth(root.Right) leftMaxDepth := maxDepth(root.Left) return 1 + max(rightMaxDepth,leftMaxDepth)&#125;func max(a,b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 迭代 层序遍历1234567891011121314151617181920212223242526// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 最小深度递归后序遍历 12345678910111213141516171819202122232425262728293031// 定义：输入根节点，返回这棵二叉树的最小深度func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; rightMaxDepth := minDepth(root.Right) leftMaxDepth := minDepth(root.Left) // 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论 if root.Right == nil &amp;&amp; root.Left !=nil &#123; return 1 + leftMaxDepth // 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。 &#125; if root.Left == nil &amp;&amp; root.Right !=nil &#123; return 1 + rightMaxDepth &#125; return 1 + min(rightMaxDepth,leftMaxDepth)&#125; func min(a,b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125; 迭代 层序遍历123456789101112131415161718192021222324252627282930func minDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; if top.Right == nil &amp;&amp; top.Left == nil &#123; return depth + 1 // 当前节点也算哦 &#125; &#125; depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Go语言中的byte类型与Unicode码点与整数的转换","slug":"eetcode/Go语言中的byte类型与Unicode码点与整数的转换","date":"2023-07-09T14:22:16.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-07-09-dda1c4b9508f.html","link":"","permalink":"https://leiqi.top/2023-07-09-dda1c4b9508f.html","excerpt":"","text":"byte类型与Unicode码点的转换在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。 当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; b := byte(&#x27;A&#x27;) i := int(b) fmt.Printf(&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\\n&quot;, b, b, i)&#125; 在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下： 1Byte: A, Unicode码点: 65, 转换后的整数: 65 可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。 byte类型与整数的转换之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。 123456789101112package main import ( &quot;fmt&quot; ) func main() &#123; ch := &#x27;0&#x27; num := int(ch - &#x27;0&#x27;) fmt.Printf(&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\\n&quot;, ch, ch, num) &#125; 在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下： 1字符: 0, unicode码点或者byte对应的数值: 48, 转换后的整数: 0 可以看到，字符 ‘0’ 成功转换为整数 0。其中需要注意的是：在Go语言中，格式化输出时 %c 是一个占位符，用于表示要输出的值是一个Unicode字符。具体来说，%c 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48 这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。 总结byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Mesh组网：家庭路由和无线连接新方式","slug":"络/Mesh组网：家庭路由和无线连接新方式","date":"2023-06-25T14:24:32.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2023-06-25-a45e5f4edabc.html","link":"","permalink":"https://leiqi.top/2023-06-25-a45e5f4edabc.html","excerpt":"","text":"在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。 what Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。 how Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释： 设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。 路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。 中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。 自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。 why 为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择： 扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。 提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。 可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。 鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。 应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。 与桥接路由对比 Mesh组网： 概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。 特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。 优点： 扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。 鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。 简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。 缺点： 延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。 多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。 网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。 桥接路由： 概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。 特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。 优点： 低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。 单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。 集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。 缺点： 单点故障：中央路由器的故障可能导致整个网络失去连接。 限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。 扩展性：增加节点时，可能需要重新配置和调整网络结构。 结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。","categories":[{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"链表总结","slug":"eetcode/链表总结","date":"2023-06-24T16:15:32.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-06-24-42b41b131ba0.html","link":"","permalink":"https://leiqi.top/2023-06-24-42b41b131ba0.html","excerpt":"","text":"链表的合并 虚拟头节点 拉拉链 1234567891011121314151617181920212223242526272829303132func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy p1 := l1 p2 := l2 for p1 != nil &amp;&amp; p2 != nil &#123; // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if p1.Val &gt; p2.Val &#123; p.Next = p2 p2 = p2.Next &#125; else &#123; p.Next = p1 p1 = p1.Next &#125; // p 指针不断前进 p = p.Next &#125; if p1 != nil &#123; p.Next = p1 &#125; if p2 != nil &#123; p.Next = p2 &#125; return dummy.Next&#125; 链表的拆分 初始化两个链表，分别添加 合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next 合并 12345678910111213141516171819202122232425262728293031func partition(head *ListNode, x int) *ListNode &#123; // 存放小于 x 的链表的虚拟头结点 dummy1 := &amp;ListNode&#123;-1, nil&#125; // 存放大于等于 x 的链表的虚拟头结点 dummy2 := &amp;ListNode&#123;-1, nil&#125; // p1, p2 指针负责生成结果链表 p1, p2 := dummy1, dummy2 // p 负责遍历原链表，类似合并两个有序链表的逻辑 // 这里是将一个链表分解成两个链表 p := head for p != nil &#123; if p.Val &gt;= x &#123; p2.Next = p p2 = p2.Next &#125; else &#123; p1.Next = p p1 = p1.Next &#125; // 断开原链表中的每个节点的 next 指针 temp := p.Next p.Next = nil p = temp &#125; // 连接两个链表 p1.Next = dummy2.Next return dummy1.Next&#125; k 链表合并 最小堆 go语言的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162type ListNode struct &#123; Val int Next *ListNode&#125;func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) == 0 &#123; return nil &#125; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, nil&#125; p := dummy // 优先级队列，最小堆 pq := make(PriorityQueue, 0) heap.Init(&amp;pq) // 将 k 个链表的头结点加入最小堆 for _, head := range lists &#123; if head != nil &#123; heap.Push(&amp;pq, head) &#125; &#125; for pq.Len() &gt; 0 &#123; // 获取最小节点，接到结果链表中 node := heap.Pop(&amp;pq).(*ListNode) p.Next = node if node.Next != nil &#123; heap.Push(&amp;pq, node.Next) &#125; // p 指针不断前进 p = p.Next &#125; return dummy.Next&#125;type PriorityQueue []*ListNodefunc (pq PriorityQueue) Len() int &#123; return len(pq)&#125;func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].Val &lt; pq[j].Val&#125;func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i]&#125;func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; node := x.(*ListNode) *pq = append(*pq, node)&#125;func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) node := old[n-1] *pq = old[0 : n-1] return node&#125; 倒数K链表 n 是包含nil 的 一个fast 去探路，先走k步 slow 和fast 一起走 当fast为nil 时，到达k ,赋值为next.next 即可 1234567891011121314151617181920212223242526272829// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.Next = x.Next.Next return dummy.Next&#125; // 返回链表的倒数第 k 个节点func findFromEnd(head *ListNode, k int) *ListNode &#123; p1 := head // p1 先走 k 步 for i := 0; i &lt; k; i++ &#123; p1 = p1.Next &#125; p2 := head // p1 和 p2 同时走 n - k 步 for p1 != nil &#123; p1 = p1.Next p2 = p2.Next &#125; // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2&#125; 倒数K链表移除复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可 1234567891011121314// 主函数func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; // 虚拟头结点 dummy := &amp;ListNode&#123;-1, head&#125; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 x := findFromEnd(dummy, n + 1) // 删掉倒数第 n 个节点 x.next = x.next.next return dummy.next&#125; func findFromEnd(head *ListNode, k int) *ListNode &#123; // 代码见上文&#125; 移除中间链表876. 链表的中间结点 - 力扣（LeetCode） slow 走一步，fast走两步 fast nil，slow 为中间每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 1234567891011121314func middleNode(head *ListNode) *ListNode &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 // for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步 for fast!= nil &amp;&amp; fast.Next != nil&#123; // 应该修改为这个，slow 会停在中点右边第二个部分 // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next &#125; // 慢指针指向中点 return slow&#125; 判断链表是否成环 slow 走一步，fast走两步 fast 和slow 相遇则成环，fast 遇到nil 则不成环。 1234567891011121314151617func hasCycle(head *ListNode) bool &#123; // 快慢指针初始化指向 head slow, fast := head, head // 快指针走到末尾时停止 for fast != nil &amp;&amp; fast.Next != nil &#123; // 慢指针走一步，快指针走两步 slow = slow.Next fast = fast.Next.Next // 快慢指针相遇，说明含有环 if slow == fast &#123; return true &#125; &#125; // 不包含环 return false&#125; labuladong","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"数组双指针刷题总结","slug":"eetcode/数组双指针刷题总结","date":"2023-06-22T14:01:13.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2023-06-22-079d0af75447.html","link":"","permalink":"https://leiqi.top/2023-06-22-079d0af75447.html","excerpt":"","text":"双指针技巧分为快慢指针和左右指针 快慢指针 原地修改数组 遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++ 去除有序数组&#x2F;链表中去重 和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast] 左右指针1.二分查找 * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界2.N sum 之和 * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大3.反转字符串 * 终止条件是i&gt;j4.回文串判断 * 判断条件s[i] &#x3D;&#x3D; s[j]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1170. 比较字符串最小字母出现频次","slug":"eetcode/leetcode 1170. 比较字符串最小字母出现频次","date":"2023-06-14T15:28:09.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-06-14-88f65f0a1bb7.html","link":"","permalink":"https://leiqi.top/2023-06-14-88f65f0a1bb7.html","excerpt":"","text":"1170. 比较字符串最小字母出现频次 - 力扣（Leetcode） 后缀和（Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。 具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。 在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。 不使用后缀和1234567891011121314151617181920212223242526272829303132func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量 for _, s := range words &#123; count[f(s)] += 1 &#125; res := make([]int, len(queries)) for i, s := range queries &#123; for idx, c := range count &#123; // 遍历count if c&gt;0 &amp;&amp; f(s) &lt; idx &#123;// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c res[i]+=c &#125; &#125; &#125; return res&#125; 使用后缀和12345678910111213141516171819202122232425262728293031func f(s string) int &#123; cnt := 0 ch := &#x27;z&#x27; for _, c := range s &#123; if c &lt; ch &#123; ch = c cnt = 1 &#125; else if c == ch &#123; cnt++ &#125; &#125; return cnt&#125;func numSmallerByFrequency(queries []string, words []string) []int &#123; count := make([]int, 12) // 先计算word 里的每个数 for _, s := range words &#123; count[f(s)] += 1 &#125; // 计算后缀和,i+1 就是大于i位置的所有个数 for i := 9; i &gt;= 1; i-- &#123; count[i] += count[i + 1] &#125; res := make([]int, len(queries)) for i, s := range queries &#123; res[i] = count[f(s) + 1] &#125; return res&#125; 为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？ 在numSmallerByFrequency函数中， count数组记录的是各个不同频次出现的次数，因此 count[i]代表所有最小字母出现频次不于 i 的字符串的数量。 如果对于 queries 中的某个字符串 s ，它的最小字母出现频次为 f(s)，那么可以依据 count 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 f(s)+1 开始的所有频次出现次数即可： res[i] = count[f(s) + 1] 这里使用的是 f(s)+1 而不是 f(s) 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"什么是二进制的按位或和按位异或","slug":"olang/什么是二进制的按位或和按位异或","date":"2023-06-08T15:59:19.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-06-08-3d1c210a715f.html","link":"","permalink":"https://leiqi.top/2023-06-08-3d1c210a715f.html","excerpt":"","text":"按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！ 按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下 123456input bit a | input bit b | output ------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 1 例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111): 12345 110| 011----- 111 按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下： 1234567input bit a | input bit b | output------------------------------- 0 | 0 | 0 0 | 1 | 1 1 | 0 | 1 1 | 1 | 0 12345 110^ 011----- 101 总结按位或，就是只要有1 就为1 (包含了1 1 ；0 1；1 0；三种)按位异或，必须一个0一个1，才为1 （包含0 1；1 0；两种）大家记住了吗？","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 2460.对数组执行操作 2023.05.06每日一题","slug":"eetcode/leetcode 2460.对数组执行操作 2023.05.06每日一题","date":"2023-06-05T14:46:05.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-06-05-869070f8049d.html","link":"","permalink":"https://leiqi.top/2023-06-05-869070f8049d.html","excerpt":"","text":"2460. 对数组执行操作 - 力扣（Leetcode） 思路直接模拟 Code第一版时间复杂度：O(n)空间复杂度：O(n) 123456789101112131415161718192021func applyOperations(nums []int) []int &#123; var res []int res = make([]int, len(nums)) index := 0 // 第一次遍历 进行赋值操作 for i := 0; i &lt; len(nums)-1; i++ &#123; if nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i+1] = 0 &#125; &#125; // 第二次遍历 将非0移动到前边 for i := 0; i &lt; len(nums); i++ &#123; if nums[i] != 0 &#123; res[index] = nums[i] index++ &#125; &#125; return res&#125; 第二版时间复杂度：O(n)空间复杂度：O(1) 12345678910111213141516func applyOperations(nums []int) []int &#123; n := len(nums) j := 0 for i := 0; i &lt; n; i++ &#123; if i+1 &lt; n &amp;&amp; nums[i] == nums[i+1] &#123; nums[i] *= 2 nums[i + 1] = 0 &#125; if nums[i] != 0 &#123; nums[i], nums[j] = nums[j], nums[i] j++ &#125; &#125; return nums&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 28.找出字符串中第一个匹配项的下标","slug":"eetcode/leetcode 28.找出字符串中第一个匹配项的下标","date":"2023-05-31T14:27:00.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-31-396a1cd3c61e.html","link":"","permalink":"https://leiqi.top/2023-05-31-396a1cd3c61e.html","excerpt":"","text":"28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode） 简单解法利用split 函数，判断是否能够拆分，如果 12345678910111213func strStr(haystack string, needle string) int &#123; // 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片 splitList := strings.Split(haystack, needle) // 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1 if len(splitList)== 1 &amp;&amp; needle!=haystack &#123; return -1 &#125; if len(splitList) &gt; 1 &#123; return len(splitList[0]) &#125; // needle 在haystack的最开头，返回0 return 0&#125; 123456789101112 func main() &#123; haystack := &quot;good&quot; needle := &quot;go&quot; splitList := strings.Split(haystack, needle) // 如果在首位相同，前边会有个空字符串。 fmt.Println(splitList, len(splitList)) fmt.Println(&quot;tmp:&quot;, splitList[0]) &#125;// [&quot;&quot; &quot;od&quot;] 2 双指针解法朴素解法直观的解法的是：枚举原串 ss 中的每个字符作为「发起点」，每次从原串的「发起点」和匹配串的「首位」开始尝试匹配： 匹配成功：返回本次匹配的原串「发起点」。匹配失败：枚举原串的下一个「发起点」，重新尝试匹配。 12345678910111213141516171819202122func strStr(haystack string, needle string) int &#123; cur := 0 for cur &lt; len(haystack) &#123; p1 := cur p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return cur &#125; cur++ &#125; return -1&#125; 可以修改为for 循环 1234567891011121314151617181920212223func strStr(haystack string, needle string) int &#123; if len(haystack) &lt; len(needle) &#123; return -1 &#125; for i:= 0; i &lt; len(haystack); i++ &#123; p1 := i p2 := 0 for p1 &lt; len(haystack) &amp;&amp; p2 &lt; len(needle) &amp;&amp; needle[p2] == haystack[p1] &#123; p1++ p2++ &#125; if p2 == len(needle) &#123; return i &#125; &#125; return -1&#125; TODO KMP 算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 104.二叉树的深度","slug":"eetcode/leetcode 104.二叉树的深度","date":"2023-05-30T15:33:48.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-30-b1879d2b65d1.html","link":"","permalink":"https://leiqi.top/2023-05-30-b1879d2b65d1.html","excerpt":"","text":"个人网站：https://leiqicn.gitee.io/categories/leetcode/104. 二叉树的最大深度 - 力扣（Leetcode） 二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。 所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。 递归123456789101112131415func max (a, b int) int &#123; if a &gt; b &#123; return a; &#125; return b;&#125;// 递归func maxdepth(root *treenode) int &#123; if root == nil &#123; return 0; &#125; return max(maxdepth(root.left), maxdepth(root.right)) + 1;&#125; 迭代法可以使用模板层序遍历 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */import &quot;container/list&quot;func maxDepth(root *TreeNode) int &#123; depth := 0 if root == nil &#123; return 0 &#125; queue := list.New() queue.PushBack(root) for queue.Len() &gt; 0 &#123; size := queue.Len() for i := 0; i &lt; size; i++ &#123; // 切掉第一个元素 first := queue.Remove(queue.Front()).(*TreeNode) //注意层序遍历是切掉前边一个 if first.Left != nil &#123; queue.PushBack(first.Left) &#125; if first.Right != nil &#123; queue.PushBack(first.Right) &#125; &#125; depth++ &#125; return depth&#125; 切片实现12345678910111213141516171819202122232425262728// 定义：输入根节点，返回这棵二叉树的最大深度func maxDepth(root *TreeNode) int &#123; depth := 0; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue,root) for len(queue) &gt; 0 &#123; // queue 不为空的时候 size := len(queue) for i:=0;i &lt;size ;i++ &#123;// 遍历一层 top := queue[0] queue = queue[1:] // 取最上层元素，并切掉该元素 if top.Right != nil &#123; queue = append(queue,top.Right) &#125; if top.Left != nil &#123; queue = append(queue,top.Left) &#125; &#125; depth++ &#125; return depth&#125; 使用一个临时切片来存储当前层所有节点的子节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; // 使用切片实现队列 var queue []*TreeNode queue = append(queue, root) depth := 0 for len(queue) &gt; 0 &#123; // 当前层的节点数量 size := len(queue) // 使用一个临时切片来存储当前层所有节点的子节点 var nextLevel []*TreeNode for i := 0; i &lt; size; i++ &#123; // 从队列头部移除节点 node := queue[0] queue = queue[1:] // 移除队列的第一个元素 // 将左子树和右子树添加到下一层的队列 if node.Left != nil &#123; nextLevel = append(nextLevel, node.Left) &#125; if node.Right != nil &#123; nextLevel = append(nextLevel, node.Right) &#125; &#125; // 将下一层的节点赋值给当前层的队列 queue = nextLevel // 每次循环处理一层的节点 depth++ &#125; return depth&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}]},{"title":"leetcode 122买动态股票的最佳时机II","slug":"eetcode/leetcode 122买动态股票的最佳时机II","date":"2023-05-27T15:51:57.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-27-5cebfed1675b.html","link":"","permalink":"https://leiqi.top/2023-05-27-5cebfed1675b.html","excerpt":"","text":"122. 买卖股票的最佳时机 II - 力扣（Leetcode） 每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。 相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。 下面是代码解释： 首先定义变量 sum 记录当前总利润。然后从第二个价格开始遍历，计算当日价格与前一天价格之差。如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。最后返回累计的总利润。这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。 12345678910func maxProfit(prices []int) int &#123; var sum int for i := 1; i &lt; len(prices); i++ &#123; // 累加每次大于0的交易 if prices[i] - prices[i-1] &gt; 0 &#123; sum += prices[i] - prices[i-1] &#125; &#125; return sum&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1091.二进制矩阵中的最短路径","slug":"eetcode/leetcode 1091.二进制矩阵中的最短路径","date":"2023-05-26T15:35:54.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-26-5abcbf266873.html","link":"","permalink":"https://leiqi.top/2023-05-26-5abcbf266873.html","excerpt":"","text":"1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）DFS 超时版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type point struct &#123; x int y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; n := len(grid) if grid[0][0] == 1 || grid[n-1][n-1] == 1 &#123; return -1 &#125; res := 0 dirs := [][]int&#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125; var help func(i, j, tmp int) help = func(i, j, tmp int) &#123; // 判断是否越界或已经访问过当前节点 if i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n || grid[i][j] == 1 &#123; return &#125; if i == n-1 &amp;&amp; j == n-1 &#123; // 当到达终点时，更新res if tmp+1 &lt; res || res == 0 &#123; res = tmp + 1 &#125; return &#125; // 将当前点标记为已访问 grid[i][j] = 1 tmp++ for _, item := range dirs &#123; x := i + item[0] y := j + item[1] help(x, y, tmp) &#125; // 回溯操作，将当前点复原为未访问状态 grid[i][j] = 0 &#125; help(0, 0, 0) if res == 0 &#123; return -1 &#125; return res&#125; BFS，最短路径使用BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type point struct &#123; x,y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; // queue 维护 m,n := len(grid),len(grid[0]) visited := make(map[point]int) queue := make([]point,0) step := 1 start := point&#123;0,0&#125; end := point&#123;m-1,n-1&#125; dirs := []point&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125; // 起点为1 则直接返回 if grid[0][0] == 1 &#123; return -1 &#125; queue = append(queue,start) visited[start] = 1 for len(queue) &gt; 0 &#123; size := len(queue) // 将当前队列中的所有节点向四周扩散 for i:=0; i &lt; size; i++&#123; cur := queue[0] // 当前cur queue = queue[1:] // 切掉当前点 // 判断是否是终点 if cur == end &#123; return step &#125; // 遍历八个方向 判断是否符合边界条件 for _, dir :=range dirs&#123; newX := cur.x + dir.x newY := cur.y + dir.y newPoint := point&#123;newX,newY&#125; if newX &gt;=0 &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=0 &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==0 &amp;&amp; grid[newX][newY]==0 &#123; visited[point&#123;newX,newY&#125;] = 1 queue =append(queue,newPoint) &#125; &#125; &#125; step++ &#125; // 只能为0 的路径才可以更新到queue 边界控制 return -1&#125; &gt; 1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）### 解题思路 典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。 &gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？ 1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。 &gt; ### BFS解法中的visited为什么可以全局使用？ BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"leetcode 53.最大子数和","slug":"eetcode/leetcode 53.最大子数和","date":"2023-05-25T15:08:24.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-25-8fc7b96cd054.html","link":"","permalink":"https://leiqi.top/2023-05-25-8fc7b96cd054.html","excerpt":"","text":"Problem: 53. 最大子数组和 个人网站： https://leiqicn.gitee.io/categories/leetcode/[TOC] 思路 这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。 解题方法 方法1 算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。 方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums0; 遍历顺序，从idx &#x3D; 1 开始遍历。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code[]123456789101112131415161718192021222324252627282930313233// 方法1 func maxSubArray(nums []int) int &#123; count := 0 res := math.MinInt32 for i := 0; i &lt; len(nums); i++ &#123; count += nums[i] if count &gt; res &#123; res = count &#125; if count &lt; 0 &#123; count = 0 &#125; &#125; return res&#125;// 方法2 使用了类似动态规划的思想// 定义 nums[i] 当前元素，nums[i-1] 前序列之和func maxSubArray(nums []int) int &#123; max := nums[0] //初始化最大值为前边一个元素 // 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。 for i:= 0 ;i &lt;len(nums)-1; i++ &#123; if nums[i+1] + nums[i] &gt; nums[i+1] &#123; nums[i+1] = nums[i+1] + nums[i] &#125; // 超过最大值，则更新 if nums[i+1] &gt; max &#123; max = nums[i+1] &#125; &#125; return max&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"go语言-回调函数（钩子）","slug":"olang/go语言-回调函数（钩子）","date":"2023-05-25T13:56:41.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-05-25-2cbe3a05ec00.html","link":"","permalink":"https://leiqi.top/2023-05-25-2cbe3a05ec00.html","excerpt":"","text":"在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。 以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数： 123456789101112131415161718package mainimport ( &quot;fmt&quot;)func printWithCallback(callback func(string)) &#123; text := &quot;Hello, world!&quot; fmt.Println(text) callback(text)&#125;func main() &#123; callback := func(text string) &#123; fmt.Printf(&quot;Printed: %s\\n&quot;, text) &#125; printWithCallback(callback)&#125; 以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。 当程序运行起来后，会输出如下内容： 12Hello, world!Printed: Hello, world! 这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。 对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;time&quot;)func TimeElapsedCallback(start time.Time) &#123; elapsed := time.Now().Sub(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func heavyCalculation(callback func(time.Time)) &#123; start := time.Now() // 这里进行任何需要测量时间的操作 callback(start)&#125;func main() &#123; heavyCalculation(TimeElapsedCallback)&#125; 在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。 在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容： Time elapsed: 1.001201ms以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。 回调函数的不同以下是不使用回调函数的方式实现计算程序执行时间的示例代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func heavyCalculation() &#123; start := time.Now() // 这里进行任何需要测量时间的操作 elapsed := time.Since(start) fmt.Printf(&quot;Time elapsed: %v\\n&quot;, elapsed)&#125;func main() &#123; heavyCalculation()&#125; 和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。 在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。 当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。 使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。 而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。 钩子函数的使用场景非常广泛，在几乎所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。 以下是使用回调函数的优点：灵活性：可以轻松地将自定义代码插入到已有的代码流程中。可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"leetcode 376.摆动序列","slug":"eetcode/leetcode 376.摆动序列","date":"2023-05-23T17:05:07.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-23-7b5e53100757.html","link":"","permalink":"https://leiqi.top/2023-05-23-7b5e53100757.html","excerpt":"","text":"376. 摆动序列 - 力扣（Leetcode） 12345678910111213141516171819func wiggleMaxLength(nums []int) int &#123; var count, preDiff, curDiff int count = 1 // 初始化计数为1，至少有一个数字是有效的 if len(nums) &lt; 2 &#123; return count // 如果数组长度小于2，直接返回计数值 &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; curDiff = nums[i+1] - nums[i] // 计算当前数字之间的差值 // 根据差值的正负和前一个差值的正负进行判断 // 如果满足摆动序列的条件，更新前一个差值和计数值 if (curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) &#123; preDiff = curDiff count++ &#125; &#125; return count // 返回最终的计数值&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 226. 翻转二叉树","slug":"eetcode/leetcode 226. 翻转二叉树","date":"2023-05-23T15:06:25.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-23-d59f64e0619b.html","link":"","permalink":"https://leiqi.top/2023-05-23-d59f64e0619b.html","excerpt":"","text":"226. 翻转二叉树 - 力扣（Leetcode） 1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ // 定义将二叉树翻转func invertTree(root *TreeNode) *TreeNode &#123; // 递归终止条件 if root == nil &#123; return nil &#125; // 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点 root.Right,root.Left = root.Left,root.Right // 将右子树翻转 invertTree(root.Right) // 将左子树翻转 invertTree(root.Left) return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 144. 二叉树的前序遍历","slug":"eetcode/leetcode 144. 二叉树的前序遍历","date":"2023-05-23T14:49:08.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-23-62bd8ef029a5.html","link":"","permalink":"https://leiqi.top/2023-05-23-62bd8ef029a5.html","excerpt":"","text":"144. 二叉树的前序遍历 - 力扣（Leetcode） 记得提前判断是否为空，否则会报找不到内存指针的错误 注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。leetcode 102. 二叉树的层序遍历 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; stack := list.New() res := []int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; stack.PushBack(root) for stack.Len() &gt; 0 &#123; top := stack.Remove(stack.Back()).(*TreeNode) res = append(res,top.Val) if top.Right !=nil &#123; stack.PushBack(top.Right) &#125; if top.Left !=nil &#123; stack.PushBack(top.Left) &#125; &#125; return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 102. 二叉树的层序遍历","slug":"eetcode/leetcode 102. 二叉树的层序遍历","date":"2023-05-23T14:46:19.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-23-a419f5d1c6af.html","link":"","permalink":"https://leiqi.top/2023-05-23-a419f5d1c6af.html","excerpt":"","text":"102. 二叉树的层序遍历 - 力扣（Leetcode） 使用slice123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; // 层序遍历 使用size 记录每层数组 queue node 队列 res := make([][]int, 0) queue := make([]*TreeNode, 0) if root != nil &#123; queue = append(queue, root) &#125; else &#123; return res &#125; for len(queue) != 0 &#123; size := len(queue) levels := make([]int, 0) for i:= 0; i &lt; size; i++ &#123; node := queue[0] queue = queue[1:len(queue)] //切掉元素0 levels = append(levels, node.Val) // 添加元素 if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; res = append(res, levels) &#125; return res&#125; 使用list123456789101112131415161718192021222324252627func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; if root == nil&#123;//防止为空 return res &#125; queue := &amp;list.List&#123;&#125; queue.PushBack(root) for queue.Len() &gt; 0 &#123; length := queue.Len() //保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数） var levelQueue []int fmt.Println(length) for i := 0; i &lt; length; i++ &#123; node := queue.Remove(queue.Front()).(*TreeNode) //出队列 if node.Left != nil &#123; queue.PushBack(node.Left) &#125; if node.Right != nil &#123; queue.PushBack(node.Right) &#125; levelQueue = append(levelQueue, node.Val) //将值加入本层切片中 &#125; res = append(res, levelQueue) //放入结果集 &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1845.座位预约管理系统","slug":"eetcode/leetcode 1845.座位预约管理系统","date":"2023-05-22T16:06:33.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-22-97adde03f66a.html","link":"","permalink":"https://leiqi.top/2023-05-22-97adde03f66a.html","excerpt":"","text":"1845. 座位预约管理系统 - 力扣（Leetcode） 超时版本123456789101112131415161718192021222324252627282930313233type seat struct &#123; seatId int isFree int // 空&#125;type SeatManager struct &#123; seats map[int]*seat isFrees []int // 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加&#125;func Constructor(n int) SeatManager &#123; var a = SeatManager&#123;make(map[int]*seat, n), make([]int, n)&#125; for i := 0; i &lt; n; i++ &#123; id := i + 1 a.seats[id] = &amp;seat&#123;id, 1&#125; a.isFrees[i] = id // 初始化 &#125; return a&#125;func (this *SeatManager) Reserve() int &#123; sort.Ints(this.isFrees) top := this.isFrees[0] this.seats[top].isFree = 0 this.isFrees = this.isFrees[1:] return top&#125;// 遍历 或者使用mapfunc (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber].isFree = 1 this.isFrees = append(this.isFrees,seatNumber)&#125; 通过版本123456789101112131415161718192021222324252627282930313233343536type SeatManager struct &#123; seats []int min int&#125;func Constructor(n int) SeatManager &#123; set:=make([]int,n+2) return SeatManager&#123;seats:set,min:1&#125;&#125;func (this *SeatManager) Reserve() int &#123; value := this.min this.seats[value]=1 length := len (this.seats) fmt.Println(length) i:=value for ;i&lt;length+1;i++&#123; if this.seats[i]==1&#123; continue &#125; this.min=i // 中间变量，更新下次的最小座位号 break &#125; return value // 最小的座位号&#125;func (this *SeatManager) Unreserve(seatNumber int) &#123; this.seats[seatNumber]=0 if seatNumber &lt; this.min&#123; this.min=seatNumber &#125; return&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 455.分发饼干","slug":"eetcode/leetcode 455.分发饼干","date":"2023-05-21T15:10:15.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-21-c1aa51f444e0.html","link":"","permalink":"https://leiqi.top/2023-05-21-c1aa51f444e0.html","excerpt":"","text":"455. 分发饼干 - 力扣（Leetcode） https://leiqicn.gitee.io/ 欢迎关注我的博客，定时更新golang 刷题笔记 贪心的策略： 贪心算法一般分为如下四步： 将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;如果没有越界并且饼干大于等于胃口，则childIdx ++；res++ 12345678910111213141516171819func findContentChildren(g []int, s []int) int &#123; // g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值 sort.Ints(g) sort.Ints(s) j := 0 res := 0 // 用小饼干 来满足最小的胃口 for i := 0; i &lt; len(s); i++ &#123; // 判断越界 饼干大于胃口 if j &lt; len(g) &amp;&amp; s[i] &gt;= g[j] &#123; // len不越界的条件需要在前边 res++ j++ &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"网站无法访问categories？","slug":"具/网站无法访问categories？","date":"2023-05-21T13:45:30.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2023-05-21-a827bdd2d159.html","link":"","permalink":"https://leiqi.top/2023-05-21-a827bdd2d159.html","excerpt":"","text":"在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。 可以显示啦","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"leetcode 706. 设计哈希映射 Golang","slug":"eetcode/leetcode 706. 设计哈希映射 Golang","date":"2023-05-20T14:58:30.000Z","updated":"2025-01-13T15:35:14.513Z","comments":true,"path":"2023-05-20-e3f31d125f9b.html","link":"","permalink":"https://leiqi.top/2023-05-20-e3f31d125f9b.html","excerpt":"","text":"706. 设计哈希映射 - 力扣（Leetcode）使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List 使用结构体（非指针）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;// func (this *MyHashMap) hash(key int, value int)&#123;// &#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(entry); et.k == key &#123; e.Value = entry&#123;key, value&#125; // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝 return &#125; &#125; this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123; return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */ 使用结构体指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 链地址法var base = 769// base := 769type entry struct &#123; k int v int&#125;type MyHashMap struct &#123; hashMaps []list.List&#125;// hash集合可以使用数组链表；func Constructor() MyHashMap &#123; return MyHashMap&#123;make([]list.List, base)&#125;&#125;func (this *MyHashMap) Put(key int, value int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et := e.Value.(*entry); et.k == key &#123; // 注意list 的元素类型是空接口，需要断言类型 et.v = value // 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针 return &#125; &#125; this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)&#125;func (this *MyHashMap) Get(key int) int &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; // 可以缩写为if et := e.Value.(entry); et.k == key 用于断言，并找key return et.v &#125; &#125; return -1&#125;func (this *MyHashMap) Remove(key int) &#123; hash := key % base for e := this.hashMaps[hash].Front(); e != nil; e = e.Next() &#123; if et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123; this.hashMaps[hash].Remove(e) return &#125; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode　705. 设计哈希集合","slug":"eetcode/leetcode　705. 设计哈希集合","date":"2023-05-19T15:06:26.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2023-05-19-2fa443568cc1.html","link":"","permalink":"https://leiqi.top/2023-05-19-2fa443568cc1.html","excerpt":"","text":"705. 设计哈希集合 - 力扣（Leetcode） 1234567891011121314151617181920212223242526272829303132333435363738394041const base = 769 // 哈希表的长度 质数type MyHashSet struct &#123; data []list.List // 使用链表储存冲突元素&#125;func Constructor() MyHashSet &#123; // 构造函数，返回一个空的哈希集合 return MyHashSet&#123;make([]list.List, base)&#125;&#125;// 哈希函数：对键值取模得到哈希值func (s *MyHashSet) hash(key int) int &#123; return key % base&#125;func (s *MyHashSet) Add(key int) &#123; // 向哈希集合中添加元素 if !s.Contains(key) &#123; // 如果元素不在集合中 h := s.hash(key) // 计算哈希值 s.data[h].PushBack(key) // 将元素加入到链表中 &#125;&#125;func (s *MyHashSet) Remove(key int) &#123; // 从哈希集合中删除元素 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要删除的元素 s.data[h].Remove(e) // 从链表中删除元素 &#125; &#125;&#125;func (s *MyHashSet) Contains(key int) bool &#123; // 判断某个元素是否在哈希集合中 h := s.hash(key) // 计算哈希值 for e := s.data[h].Front(); e != nil; e = e.Next() &#123; // 遍历链表 if e.Value.(int) == key &#123; // 如果元素等于要查找的元素 return true // 返回 true &#125; &#125; return false // 没有找到元素，返回 false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"leetcode 1396.设计地铁系统","slug":"eetcode/leetcode 1396.设计地铁系统","date":"2023-05-18T15:31:58.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-18-0a0f1bd6a4a5.html","link":"","permalink":"https://leiqi.top/2023-05-18-0a0f1bd6a4a5.html","excerpt":"","text":"1396. 设计地铁系统 - 力扣（Leetcode） 设计题： 设计数据结构 user startTime int endTime int startStationName string endStatationName string UndergroundSystem userMap map[int]*user pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间 注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type user struct &#123; id int startTime int endTime int startStationName string endStatationName string&#125;type UndergroundSystem struct &#123; userMap map[int]*user pathMap map[string][]int // 存放对应路程的用时，用于计算平均时间&#125;func Constructor() UndergroundSystem &#123; // 初始化 return UndergroundSystem&#123;make(map[int]*user),make(map[string][]int)&#125;&#125;func (this *UndergroundSystem) CheckIn(id int, stationName string, t int) &#123; //userMap 添加 this.userMap[id] = &amp;user&#123;id:id&#125; // 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址 this.userMap[id].startTime = t this.userMap[id].startStationName = stationName &#125;func (this *UndergroundSystem) CheckOut(id int, stationName string, t int) &#123; //出站时，更新user.end* ;append pathmap useTime := 0 if _,ok := this.userMap[id] ;ok &#123; this.userMap[id].endTime = t this.userMap[id].endStatationName = stationName &#125; mapKey := this.userMap[id].startStationName +&quot;-&gt;&quot; + this.userMap[id].endStatationName useTime = this.userMap[id].endTime - this.userMap[id].startTime this.pathMap[mapKey] = append(this.pathMap[mapKey],useTime)&#125; func (this *UndergroundSystem) GetAverageTime(startStation string, endStation string) float64 &#123; mapKey := startStation +&quot;-&gt;&quot; + endStation return average(this.pathMap[mapKey])&#125;func average(s []int) float64 &#123; sum := 0 for _,v := range s &#123; sum +=v &#125; return float64(sum)/float64(len(s))&#125;/** * Your UndergroundSystem object will be instantiated and called as such: * obj := Constructor(); * obj.CheckIn(id,stationName,t); * obj.CheckOut(id,stationName,t); * param_3 := obj.GetAverageTime(startStation,endStation); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"leetcode 设计题 Constructor构建","slug":"eetcode/leetcode 设计题 Constructor构建","date":"2023-05-14T14:13:21.000Z","updated":"2025-01-13T15:35:14.514Z","comments":true,"path":"2023-05-14-776ea61b62a5.html","link":"","permalink":"https://leiqi.top/2023-05-14-776ea61b62a5.html","excerpt":"","text":"在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法： 123456789type ParkingSystem struct &#123; carNums map[int]int // 记录每种停车位的数量&#125;func Constructor(big int, medium int, small int) ParkingSystem &#123; return ParkingSystem&#123; carNums: map[int]int&#123;1: big, 2: medium, 3: small&#125;, // 初始化 carNums 映射 &#125;&#125; 在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。 请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。 具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现： 1234567891011121314151617type B struct &#123; m map[int]int&#125;type A struct &#123; m map[int]B&#125;func main() &#123; a := &amp;A&#123; m: make(map[int]B), &#125; b := &amp;B&#123; m: make(map[int]int), &#125; a.m[1] = *b // 给 A 中的第一个元素分配一个新的 B 结构体实例&#125; 在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 nil 引用错误，我们还在代码中使用了 make 函数创建了一个空映射。 例如, 下边结构体中map 嵌套了另外一个结构体的map,可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例： 12345678910111213141516type Res struct &#123; big map[int]int&#125;type ParkingSystem struct &#123;map carNums map[int]*Res // map 嵌套map&#125;func NewParkingSystem() *ParkingSystem &#123; return &amp;ParkingSystem&#123;carNums: make(map[int]*Res)&#125; // 只用先make 一个空map,指向Res&#125;func main() &#123; ps := NewParkingSystem() ps.carNums[1] = &amp;Res&#123;big: make(map[int]int)&#125;&#125; 在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。 然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。 总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"}]},{"title":"Go语言-copy","slug":"olang/Go语言-copy","date":"2023-05-11T16:27:16.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-05-11-27c67ecef2a3.html","link":"","permalink":"https://leiqi.top/2023-05-11-27c67ecef2a3.html","excerpt":"","text":"在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下： 1func copy(dst, src []Type) int 其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。 使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下： 123456789// 定义一个包含元素的数组a := [5]int&#123;1, 2, 3, 4, 5&#125;// 定义要删除的元素下标index := 2// 利用 append 函数和 copy 函数删除指定下标的元素copy(a[index:], a[index+1:])a = a[:len(a)-1]// 打印删除后的数组fmt.Println(a) // 输出 [1 2 4 5] 上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。 在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。 在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片： 1b := a[1:4] 这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。 在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作： 1copy(a[index:], a[index+1:]) 这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-byte和rune 有什么区别 byte rune 转为int","slug":"olang/Go语言-byte和rune 有什么区别 byte rune 转为int","date":"2023-05-11T16:06:34.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-05-11-257639a12a8e.html","link":"","permalink":"https://leiqi.top/2023-05-11-257639a12a8e.html","excerpt":"","text":"在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。 byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。 将 byte 或 rune 转换为 int 可以使用类型转换操作符： 123456b := byte(&#x27;0&#x27;)i := int(b) - int(&#x27;0&#x27;) // 将 byte &#x27;0&#x27; 转换为 int 0// 上边可以简写为i := b - &#x27;0&#x27;r := rune(&#x27;中&#x27;)i := int(r) // 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点） 将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如： 123456i := 10b := byte(i) // 溢出！编译器会忽略高位部分，直接取低位部分的字节r := rune(i)if r &lt; 0xFFFF &#123; r = rune(b) // 类型断言&#125; 可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Leetcode 200.岛屿数量","slug":"eetcode/Leetcode 200.岛屿数量【BFS DFS】","date":"2023-05-10T17:02:51.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-10-da8c57fb590a.html","link":"","permalink":"https://leiqi.top/2023-05-10-da8c57fb590a.html","excerpt":"","text":"200. 岛屿数量 - 力扣（Leetcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++func numIslands(grid [][]byte) int &#123; res := 0 r := len(grid) c := len(grid[0]) visited := make([][]byte, r) for i := 0; i &lt; r; i++ &#123; visited[i] = make([]byte, c) &#125; // 遍历二维slice for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; // 每个位置 if grid[i][j] == &#x27;1&#x27; &#123; dfs(grid, i, j, visited) res++ &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; //单层递归逻辑，四面八方递归 dfs(grid, i+1, j, visited) dfs(grid, i, j+1, visited) dfs(grid, i-1, j, visited) dfs(grid, i, j-1, visited)&#125; 也可以使用方向二维数组来遍历 可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下： 1234567891011121314151617181920212223242526272829303132func dfs(grid [][]byte, i int, j int, visited [][]byte) &#123; r := len(grid) c := len(grid[0]) // 定义方向变化值dirs dirs := [][]int&#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125; // 边界判断 if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; // 判断值，是海水直接返回 if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 判断是否走过 if visited[i][j] == &#x27;1&#x27; &#123; return &#125; // 改变状态为海水,并修改为走过 grid[i][j] = &#x27;0&#x27; visited[i][j] = &#x27;1&#x27; // 循环遍历dirs，对四个方向进行递归 for _, d := range dirs &#123; new_i, new_j := i + d[0], j + d[1] dfs(grid, new_i, new_j, visited) &#125;&#125; 在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。 使用额外的visited 的时候，一定要作为dfs 的入参，让其拷贝一份在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化（leetcode 的测试环境会造成影响）。 为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： 需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。 对应BFS实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ bfs(grid, i, j) &#125; &#125; &#125; return res&#125;func bfs(grid [][]byte, i, j int) &#123; r := len(grid) c := len(grid[0]) queue := []point&#123;&#123;i, j&#125;&#125; grid[i][j] = &#x27;0&#x27; // 标记为已访问 for len(queue) &gt; 0 &#123; current := queue[0] queue = queue[1:] for _, item := range dirct &#123; myRow := current.x + item[0] myCol := current.y + item[1] if myRow &gt;= 0 &amp;&amp; myRow &lt; r &amp;&amp; myCol &gt;= 0 &amp;&amp; myCol &lt; c &amp;&amp; grid[myRow][myCol] == &#x27;1&#x27; &#123; grid[myRow][myCol] = &#x27;0&#x27; // 标记为已访问 queue = append(queue, point&#123;myRow, myCol&#125;) &#125; &#125; &#125;&#125;// DFS type point struct &#123; x int y int&#125;var dirct = [][]int&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;func numIslands(grid [][]byte) int &#123; if len(grid) == 0 &#123; return 0 &#125; res := 0 r := len(grid) c := len(grid[0]) visited := make(map[point]int) // 使用局部变量，每次调用都重新初始化 for i := 0; i &lt; r; i++ &#123; for j := 0; j &lt; c; j++ &#123; if grid[i][j] == &#x27;1&#x27; &#123; res++ dfs(grid, i, j, visited) &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i, j int, visited map[point]int) &#123; r := len(grid) c := len(grid[0]) if i &lt; 0 || j &lt; 0 || i &gt;= r || j &gt;= c &#123; return &#125; if grid[i][j] == &#x27;0&#x27; &#123; return &#125; // 和visited 等价 if _, ok := visited[point&#123;i, j&#125;]; ok &#123; return &#125; grid[i][j] = &#x27;0&#x27; // 和visited 等价 visited[point&#123;i, j&#125;] = 1 for _, item := range dirct &#123; myRow := i + item[0] myCol := j + item[1] if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok &#123; // 这里和前边 if _, ok := visited[point&#123;i, j&#125;]; ok 二选一 dfs(grid, myRow, myCol, visited) &#125; &#125;&#125;// 需要注意的是岛屿数量的 Go 语言代码中，有一点需要注意。在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化。//为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码： https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/ 岛屿问题一文搞定","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"}]},{"title":"结构体指针作为map key 结构体值改变对map有影响吗","slug":"olang/结构体指针作为map key 结构体值改变对map有影响吗","date":"2023-05-10T16:37:20.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-05-10-7dfabb45bbc2.html","link":"","permalink":"https://leiqi.top/2023-05-10-7dfabb45bbc2.html","excerpt":"","text":"最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？接下来让我们一起看看： 当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据 例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据： 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; m := make(map[*int]string) x := 1 p := &amp;x m[p] = &quot;A&quot; // 添加数据 fmt.Println(m) // map[0xc000016088:A] *p = 2 // 修改变量x的值 fmt.Println(m) // map[0xc000016088:A]&#125; 在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。 接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。 总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言删除指定索引元素","slug":"olang/Go语言删除指定索引元素","date":"2023-05-10T15:47:04.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-05-10-741623f2e4fb.html","link":"","permalink":"https://leiqi.top/2023-05-10-741623f2e4fb.html","excerpt":"","text":"在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。 以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素： 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; i := 2 // 要删除的索引 // 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片 b := append(a[:i], a[i+1:]...) fmt.Println(b) // 输出 [1 2 4 5]&#125; 在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。 接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。 最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"Go语言指定索引插入元素","slug":"olang/Go语言指定索引插入元素","date":"2023-05-10T15:42:50.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-05-10-5e3b5c8e7446.html","link":"","permalink":"https://leiqi.top/2023-05-10-5e3b5c8e7446.html","excerpt":"","text":"在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。 下面是一个示例代码，它插入一个元素到切片的第二个位置： 12345678910package mainimport &quot;fmt&quot;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; i := 1 // 要插入的位置 b := append(a[:i], append([]int&#123;5&#125;, a[i:]...)...) // 在切片的第二个位置插入数字5 fmt.Println(b) // 输出 [1 5 2 3 4]&#125; 在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。 接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。 最后，我们将结果赋值给变量 b 并打印输出它。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"}]},{"title":"leetcode 108.将有序数组转换为二叉搜索树","slug":"eetcode/leetcode 108.将有序数组转换为二叉搜索树","date":"2023-05-04T15:23:48.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-05-04-ce9a22434c37.html","link":"","permalink":"https://leiqi.top/2023-05-04-ce9a22434c37.html","excerpt":"","text":"108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode） 递归解法注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑注意递归函数定义，严格按照定义调用递归使用前序遍历 中左右 123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123; return traversal(nums,0,len(nums)-1)&#125;// 定义：返回nums root 节点func traversal(nums []int,left int , right int) *TreeNode&#123; if left &gt; right &#123; return nil &#125; mid := (left + right)/2 root := &amp;TreeNode&#123;nums[mid],nil,nil&#125; root.Left = traversal(nums,left,mid-1) // 把后边 root 节点添加到当前root left 左节点上 root.Right = traversal(nums,mid+1,right) // 把后边 root 节点添加到当前root right 左节点上 return root&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"删除ppt所有批注和备注","slug":"具/删除ppt所有批注和备注","date":"2023-04-24T14:25:04.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-04-24-4faf63eb321c.html","link":"","permalink":"https://leiqi.top/2023-04-24-4faf63eb321c.html","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Go语言-接口","slug":"olang/Go语言-接口","date":"2023-04-20T16:42:26.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-04-20-89710477a7ed.html","link":"","permalink":"https://leiqi.top/2023-04-20-89710477a7ed.html","excerpt":"","text":"在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。 以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()： 123456789101112131415161718192021222324type Printer interface &#123; Print()&#125;type User struct &#123; name string&#125;func (u User) Print() &#123; fmt.Println(u.name,&quot;我爱加班&quot;)&#125; func printAll(ps []Printer) &#123; for _, p := range ps &#123; p.Print() &#125;&#125;func main() &#123; var ps []Printer ps = append(ps, User&#123;&quot;Alice&quot;&#125;) ps = append(ps, User&#123;&quot;Bob&quot;&#125;) printAll(ps)&#125; 在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为： 12Alice 我爱加班Bob 我爱加班 在这段代码中，我们通过接口将User类型与PrintAll() 函数解耦，这样当我们需要添加新的类型时，只需要实现Print()方法即可，而不需要修改PrintAll()函数实现。 比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改PrintAll()函数实现。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，有相同的特征，我们将其抽象出来，降低代码耦合性。 1234567type Boss struct &#123; name string&#125;func (b Boss) Print() &#123; fmt.Println(&quot;你明天不用来了&quot;)&#125; 其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照合同的规定进行处理。 同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"Go语言-多态","slug":"olang/Go语言-多态","date":"2023-04-20T16:32:20.000Z","updated":"2025-01-13T15:35:14.508Z","comments":true,"path":"2023-04-20-af074e588287.html","link":"","permalink":"https://leiqi.top/2023-04-20-af074e588287.html","excerpt":"","text":"Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。 我们来实现这样一个例子： 实现猫和狗两个对象，并且他们都有动作：叫，但叫声不同。再实现一个对象鸟，他除了叫，还会飞。 下面是基于Go语言，实现题目要求的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;type Animal interface &#123; Cry()&#125;type Cat struct&#123;&#125;func (c Cat) Cry() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;type Dog struct&#123;&#125;func (d Dog) Cry() &#123; fmt.Println(&quot;汪汪汪&quot;)&#125;type Bird struct&#123;&#125;func (b Bird) Cry() &#123; fmt.Println(&quot;叽叽喳喳&quot;)&#125;func (b Bird) Fly() &#123; fmt.Println(&quot;我会飞&quot;)&#125;func main() &#123; var animal Animal // 创建一只猫 animal = Cat&#123;&#125; animal.Cry() // 创建一只狗 animal = Dog&#123;&#125; animal.Cry() // 创建一只鸟 bird := Bird&#123;&#125; animal = bird animal.Cry() bird.Fly()&#125; 在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。 运行上述代码，输出如下： 1234喵喵喵汪汪汪叽叽喳喳我会飞 在这段代码中，我们使用了接口的多态特性，通过定义Animal接口，实现了不同类型的对象之间的通用性，并且在Bird中新增了Fly() 方法，符合面向对象的开放封闭原则。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"}],"tags":[]},{"title":"波纹","slug":"影/波纹","date":"2023-04-08T05:41:33.000Z","updated":"2025-01-13T15:35:14.516Z","comments":true,"path":"2023-04-08-722322c4ddc3.html","link":"","permalink":"https://leiqi.top/2023-04-08-722322c4ddc3.html","excerpt":"","text":"波光粼粼","categories":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"}]},{"title":"Leetcode 513.找树左下角的值","slug":"eetcode/Leetcode 513.找树左下角的值","date":"2023-04-03T14:44:37.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-04-03-03cca064ab00.html","link":"","permalink":"https://leiqi.top/2023-04-03-03cca064ab00.html","excerpt":"","text":"513. 找树左下角的值 - 力扣（Leetcode） 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root &#x3D; [2,1,3]输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -2^31 &lt;= Node.val &lt;= 2^31 - 1 思考本题可以转化为什么呢？ 1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。 代码实现1.递归 12345678910111213141516171819202122var depth int // 全局变量 最大深度var res int // 记录最终结果func findBottomLeftValue(root *TreeNode) int &#123; depth, res = 0, 0 dfs(root, 1) return res&#125;func dfs(root *TreeNode, d int) &#123; //这里判断nil ,后边左右节点就不用判断了 if root == nil &#123; return &#125; // 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果 if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; depth &lt; d &#123; depth = d res = root.Val &#125; dfs(root.Left, d+1) dfs(root.Right, d+1)&#125; 2.迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; &#125; &#125; return res&#125;// 迭代2 每层用一个切片func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; // 通过另外一个切片来添加的解法也要尝试学习一下 queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 使用nextqueue 保存每一层，然后追加到queue nextqueue := []*TreeNode&#123;&#125; for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] res = nextqueue[0] if top.Left != nil &#123; nextqueue = append(nextqueue, top.Left) &#125; if top.Right != nil &#123; nextqueue = append(nextqueue, top.Right) &#125; &#125; queue = append(queue,nextqueue...) &#125; return res&#125; 拓展思考如果要求最右边的值呢？这里该怎么求呢？ 只需要将 遍历左右的顺序颠倒一下即可 123456789101112131415161718192021222324252627282930313233343536func findBottomLeftValue(root *TreeNode) int &#123; res := -1 queue := []*TreeNode&#123;&#125; if root == nil &#123; return -1 &#125; queue = append(queue, root) //res 在哪里更新呢？ for len(queue) &gt; 0 &#123; size := len(queue) // 遍历每一层 for i := 0; i &lt; size; i++ &#123; top := queue[0] queue = queue[1:] // 获取每一层的最左边的位置，更新res if i == 0 &#123; res = top.Val &#125; if top.Right != nil &#123; queue = append(queue, top.Right) &#125; if top.Left != nil &#123; queue = append(queue, top.Left) &#125; &#125; &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 404.左叶子之和","slug":"eetcode/Leetcode 404.左叶子之和","date":"2023-03-29T14:44:37.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-03-29-c131676dd7b1.html","link":"","permalink":"https://leiqi.top/2023-03-29-c131676dd7b1.html","excerpt":"","text":"123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; // 递归 res := 0 // 终止条件 if root == nil &#123; return 0 &#125; leftNode := root.Left leftNodeVal := sumOfLeftLeaves(root.Left) // 左 rightNodeVal := sumOfLeftLeaves(root.Right)// 右 if leftNode != nil &amp;&amp; leftNode.Left == nil &amp;&amp; leftNode.Right == nil &#123; // 中 leftNodeVal = leftNode.Val &#125; // 单次循环 res = leftNodeVal + rightNodeVal // 中，左边+右边 return res &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 257.二叉树的所有路径","slug":"eetcode/Leetcode 257.二叉树的所有路径","date":"2023-03-28T15:47:29.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-03-28-53b6b0695943.html","link":"","permalink":"https://leiqi.top/2023-03-28-53b6b0695943.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res []stringvar path []stringfunc binaryTreePaths(root *TreeNode) []string &#123; res = make([]string,0) path = make([]string,0) if (root == nil) &#123; return res &#125; backTracking(root) return res&#125;func backTracking(root *TreeNode)&#123; // 终点 左右子节点都为nil if isLeafNode(root) &#123; NodeValStr := strconv.Itoa(root.Val) path = append(path, NodeValStr) pathStr := strings.Join(path, &quot;-&gt;&quot;) res = append(res, pathStr) return &#125; // 前序遍历 中左右 // 遍历 每次递归的操作 NodeVal:= strconv.Itoa(root.Val)// 中 path = append(path, NodeVal) if root.Left != nil &#123; // 左 backTracking(root.Left) path = path[:len(path)-1] &#125; if root.Right != nil &#123; // 右 backTracking(root.Right) path = path[:len(path)-1] &#125;&#125;func isLeafNode(node *TreeNode) bool&#123; if node.Right==nil &amp;&amp; node.Left== nil &amp;&amp; node!= nil&#123; return true &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"Leetcode 110.平衡二叉树","slug":"eetcode/Leetcode 110.平衡二叉树","date":"2023-03-28T03:18:47.000Z","updated":"2025-01-13T15:35:14.512Z","comments":true,"path":"2023-03-28-c58b9cf85e3e.html","link":"","permalink":"https://leiqi.top/2023-03-28-c58b9cf85e3e.html","excerpt":"","text":"110. 平衡二叉树 - 力扣（Leetcode） 简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 示例 2： 输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 输入：root &#x3D; []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 思路这里是求高度： 节点到叶子节点的最长距离，使用后序遍历深度是root 到该节点的最长距离（距离☞节点数），使用前序遍历 因此只要分别计算左右子树的高度，并且做差不大于1就行 代码实现使用-1 记录 res 不是平衡二叉树每次执行，都需要判断是不是等于-1，直接返回-1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"}],"tags":[]},{"title":"快来压缩你的博客图片","slug":"具/【TODO】快来压缩你的博客图片","date":"2023-03-23T16:00:00.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-03-23-4868b6a1c39c.html","link":"","permalink":"https://leiqi.top/2023-03-23-4868b6a1c39c.html","excerpt":"","text":"虽然没多大变化 哈哈哈再试试 更大更高清的图片 实测,效果不太行….但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下待更新…","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"给你的博客 安装上PWA吧","slug":"具/【TODO】给你的博客 安装上PWA吧","date":"2023-03-23T16:00:00.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-03-23-49ace33ca004.html","link":"","permalink":"https://leiqi.top/2023-03-23-49ace33ca004.html","excerpt":"","text":"TODO: 什么是PWA，可以提示添加到主屏幕渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站 安装 hexo-pwa 由于hexo-pwa停止维护，需要解决报错 设置全局_config.yml 文件(非主题)","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Linux 命令 将前台任务挂到后台运行","slug":"inux/Linux 命令 将前台任务挂到后台运行","date":"2023-03-18T16:00:00.000Z","updated":"2025-01-13T15:35:14.509Z","comments":true,"path":"2023-03-18-87649bcaf9cc.html","link":"","permalink":"https://leiqi.top/2023-03-18-87649bcaf9cc.html","excerpt":"","text":"背景 很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用bg 挂后台的命令。 第一步：ctrl + z 第二步：jobs 查看任务id 第三步： bg %任务id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"博客设置 obsidian 上传图片","slug":"具/博客设置 obsidian 上传图片","date":"2023-03-18T16:00:00.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-03-18-4e4b648f656d.html","link":"","permalink":"https://leiqi.top/2023-03-18-4e4b648f656d.html","excerpt":"","text":"背景本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的相对路径就可以读取并显示图片。 而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。 操作1. 打开obsidian - 文件与链接2. 按照下图配置 * 将内部链接类型 设置为 “基于当前笔记的相对路径” &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用相对路径 取消wiki 链接 指定图片的默认路径为 source/imgs&gt; 如果没有该文件夹，则需要先新建一下。 成功网页可以成功显示图片","categories":[{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"关于我","slug":"于我/关于我","date":"2023-03-13T16:00:00.000Z","updated":"2025-01-13T15:35:14.515Z","comments":true,"path":"2023-03-13-519b5e93f019.html","link":"","permalink":"https://leiqi.top/2023-03-13-519b5e93f019.html","excerpt":"","text":"博客链接链接 关于我大家好，我是Lei Qi, 毕业于复旦大学，任职于华为，主要做Golang、Python软件开发。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~","categories":[{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}],"categories":[{"name":"c","slug":"c","permalink":"https://leiqi.top/categories/c/"},{"name":"工具","slug":"工具","permalink":"https://leiqi.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"carl","slug":"carl","permalink":"https://leiqi.top/categories/carl/"},{"name":"leetcode","slug":"leetcode","permalink":"https://leiqi.top/categories/leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://leiqi.top/categories/Golang/"},{"name":"前端","slug":"前端","permalink":"https://leiqi.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"git","slug":"git","permalink":"https://leiqi.top/categories/git/"},{"name":"Docker","slug":"Docker","permalink":"https://leiqi.top/categories/Docker/"},{"name":"vue3 入门","slug":"vue3-入门","permalink":"https://leiqi.top/categories/vue3-%E5%85%A5%E9%97%A8/"},{"name":"Python","slug":"Python","permalink":"https://leiqi.top/categories/Python/"},{"name":"网络","slug":"网络","permalink":"https://leiqi.top/categories/%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","permalink":"https://leiqi.top/categories/C/"},{"name":"Linux","slug":"Linux","permalink":"https://leiqi.top/categories/Linux/"},{"name":"设计模式","slug":"设计模式","permalink":"https://leiqi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/categories/%E6%91%84%E5%BD%B1/"},{"name":"关于我","slug":"关于我","permalink":"https://leiqi.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"}],"tags":[{"name":"刨根问底","slug":"刨根问底","permalink":"https://leiqi.top/tags/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"},{"name":"DFS","slug":"DFS","permalink":"https://leiqi.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://leiqi.top/tags/BFS/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://leiqi.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二维数组最短路径","slug":"二维数组最短路径","permalink":"https://leiqi.top/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"贪心","slug":"贪心","permalink":"https://leiqi.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://leiqi.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"设计题","slug":"设计题","permalink":"https://leiqi.top/tags/%E8%AE%BE%E8%AE%A1%E9%A2%98/"},{"name":"图遍历，岛屿问题","slug":"图遍历，岛屿问题","permalink":"https://leiqi.top/tags/%E5%9B%BE%E9%81%8D%E5%8E%86%EF%BC%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"},{"name":"golang","slug":"golang","permalink":"https://leiqi.top/tags/golang/"},{"name":"摄影","slug":"摄影","permalink":"https://leiqi.top/tags/%E6%91%84%E5%BD%B1/"},{"name":"水","slug":"水","permalink":"https://leiqi.top/tags/%E6%B0%B4/"},{"name":"linux命令","slug":"linux命令","permalink":"https://leiqi.top/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"about","slug":"about","permalink":"https://leiqi.top/tags/about/"}]}