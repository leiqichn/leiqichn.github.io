---
doc_type: weread-highlights-reviews
bookId: "621792"
author: Mark Lutz 著
cover: https://cdn.weread.qq.com/weread/cover/71/YueWen_621792/t7_YueWen_621792.jpg
reviewCount: 1
noteCount: 42
isbn: 9787111326533
category: 计算机-编程设计
lastReadDate: 2020-02-24
---
# 元数据
> [!abstract] Python学习手册（原书第4版）
> - ![ Python学习手册（原书第4版）|200](https://cdn.weread.qq.com/weread/cover/71/YueWen_621792/t7_YueWen_621792.jpg)
> - 书名： Python学习手册（原书第4版）
> - 作者： Mark Lutz 著
> - 简介： 
> - 出版时间 2015-01-01 00:00:00
> - ISBN： 9787111326533
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社

# 高亮划线

## 第二部分 类型和运算


- 📌 加号（+）代表加法，星号（*）表示乘法，双星号（**）表示乘方。 ^621792-9-4627-4659
    - ⏱ 2019-12-25 00:51:29 

- 📌 在核心类型中，数字、字符串和元组是不可变的； ^621792-9-11768-11790
    - ⏱ 2019-12-25 01:00:23 

- 📌 列表和字典不是这样（它们可以完全自由地改变） ^621792-9-11790-11812
    - ⏱ 2019-12-25 01:00:30 

- 📌 因为字符串具有不可变性，我们必须这样做。 ^621792-9-12633-12653
    - ⏱ 2019-12-25 01:03:30 

- 📌 对于更多细节，你可以调用内置的dir函数，将会返回一个列表，其中包含了对象的所有属性。 ^621792-9-14442-14485
    - ⏱ 2019-12-25 01:10:10 

- 📌 ，以双下划线开头并结尾的变量名是用来表示Python实现细节的命名模式 ^621792-9-15588-15623
    - ⏱ 2019-12-25 01:10:28 

- 📌 ord（'\n'）  # ^621792-9-16914-16956
    - ⏱ 2019-12-25 01:13:46 

- 📌 L + [4,5,6] ^621792-9-19893-19907
    - ⏱ 2019-12-25 01:27:06 

- 📌 大多数列表的方法都会就地改变列表对象，而不是创建一个新的列表： ^621792-9-21039-21070
    - ⏱ 2019-12-25 01:29:45 

- 📌 这里的列表sort方法，默认按照升序对列表进行排序，而reverse对列表进行翻转。 ^621792-9-21401-21443
    - ⏱ 2019-12-25 01:29:56 
## 第5章 数字


- 📌 还有一个is_integer方法可以测试数字是否是一个整数。 ^621792-10-4487-4517
    - ⏱ 2020-01-23 18:38:29 

- 📌 lambda创建匿名函数 ^621792-10-5118-5130
    - ⏱ 2020-01-23 18:38:14 

- 📌 比较sorted（dict.items（）） ^621792-10-6749-6771
    - ⏱ 2020-01-23 18:40:23 

- 📌 要计数器初始化为0，在列表后添加元素前，要首先初始化列表为一个空列表。 ^621792-10-12142-12206
    - ⏱ 2020-01-23 18:45:30 

- 📌 //执行Floor除法，它截除掉余数并且针对整数操作数返回一个整数， ^621792-10-18597-18631
    - ⏱ 2020-01-23 18:47:33 

- 📌 //的结果的数据类型总是依赖于操作数的类型：如果操作数中有一个是浮点数，结果就是浮点数； ^621792-10-19782-19826
    - ⏱ 2020-01-23 18:47:52 

- 📌 学习在这样的环境中使用//。查看第13章中的一个简单的素数while循环的示例，以及 ^621792-10-24939-24981
    - ⏱ 2020-01-23 18:52:32 

- 📌 >>> X￼ 5192296858534827628530496329220095L￼ >>> oct（X）￼ '017777777777777777777777777777777777777L'￼ >>> bin（X）￼ '0b1111111111111111111111111111111111111111111111111111111111 ...and so on...关于二进制数字，下一小节将介绍处理单独的位的工具。位操作除了一般的数学运算（加法、减法等），Python也支持C语言中的大多数数学表达式。这包括那些把整数当作二进制位串对待的操作。例如，还可以实现位移及布尔操作：￼ >>> x = 1  # 0001￼ >>> x << 2 # Shift left 2 bits: 0100￼ 4￼ >>> x | 2  # Bitwise OR: 0011￼ 3￼ >>> x & 1  # Bitwise AND: 0001￼ 1 ^621792-10-29551
    - ⏱ 2020-01-23 18:54:32 

- 📌 例如，内置函数pow和abs，分别计算幂和绝对值 ^621792-10-32820-32844
    - ⏱ 2020-01-23 19:34:45 

- 📌 例如，由于项在集合中只能存储一次，集合（set）可以用来把重复项从其他集合（collection）中过滤掉 ^621792-10-58785-58838
    - ⏱ 2020-01-23 19:39:57 
## 第6章 动态类型简介


- 📌 尽管这样，因为这并不是必须的，你将会发现Python代码比你通常惯用的代码更加灵活：如果正确的使用Python，代码能够自动以多种类型进行工作。本书提到的这个代码有两个头部信息，一个是类型标志符，另一个是引用计数器。为了了解后者，我们需要继续学习下面内容，并简要地介绍对象生命结束时发生了什么变化。对象的垃圾收集在上一节的例子中，我们把变量a赋值给了不同类型的对象。但是当重新给变量a赋值时，它前一个引用值发生了什么变化？例如，在下边的语句中，对象3发生了什么变化？>>> a = 3>>> a = 'spam'答案是，在Python中，每当一个变量名被赋予了一个新的对象，之前的那个对象占用的空间就会被回收（如果它没有被其他的变量名或对象所引用的话）。 ^621792-11-4822
    - ⏱ 2020-01-23 01:03:00 
## 第7章 字符串


- 📌 注意：内容提示：从技术上讲，本章介绍的只是Python中的字符串内容的一部分，即大多数程序员需要知道的内容。它介绍了基本的str字符串类型，该类型用来处理ASCII文本并且不管使用何种Python版本都能同样地工作。也就是说，本章有意把讨论范围限制在大多数Python脚本中会用到的字符串处理基础知识。从更为正式的角度讲，ASCII是Unicode文本的一种简单形式。Python通过包含各种不同的对象类型，解决了文本和二进制数据之间的区别：•Python 3.0中，有3种字符串类型：str用于Unicode文本（ASCII或其他），bytes用于二进制数据（包括编码的文本），bytearray是bytes的一种可变的变体。•在Python 2.6中，unicode字符串表示宽Unicode文本，str字符串处理8位文本和二进制数据。bytearray类型在Python 2.6及其以后的版本中可用，但在更早的版本就不可用了，并且它在其他版本中并不像在Python 3.0中那样与二进制数据紧密相连。由于大多数程序员不需要深入了解Unicode编码或二进制数据格式的细节，我们将这些细节放到本书的高级话题部分的第36章中介绍。如果你需要了解替代字符集或打包的二进制数据和文件这样更高级的字符串概念，在阅读完本章内容后继续阅读第36章。现在，我们将关注基本的字符串类型及其操作。你将会发现，我们这里所学习的基础知识也直接应用于Python的工具集中更高级的字符串类型。除了核心系列的字符串工具以外，Python通过标准库re模块（正则表达式）还支持更高级的基于模式的字符串处理，这在第4章介绍过；甚至还有更高级的文本处理工具，如XML解析器，我们将在第36章简单介绍。然而，本书主要关注表7-1介绍的基本表示。本章将会以字符串常量的形式以及基本的字符串操作作为开始，之后将会学习字符串方法和格式等更高级的工具。Python带有很多字符串工具，我们不会在这里介绍所有这些工具；完整的介绍可以在Python的库手册中找到。这里，我们的目标是介绍很常用的工具以给出一个有代表性的例子，我们在这里没有介绍的那些方法，和我们见到的方法在很大程度上是类似的。字符串常量从整体上来讲，Python中的字符串用起来还是相当的简单的。也许最复杂的事情就是在代码中有如此多的方法去编写它们： ^621792-12-1592
    - ⏱ 2020-01-21 22:51:57 

- 📌 }添加一个6字符宽度的字段并且在左边补充 ^621792-12-48940-48960
    - ⏱ 2020-01-23 00:37:01 
## 第8章 列表与字典


- 📌 让我们快速地看一下它们的主要属性，Python列表是：任意对象的有序集合从功能上看，列表就是收集其他对象的地方，你可以把它们看做组。同时列表所包含的每一项都保持了从左到右的位置顺序（也就是说，它们是序列）。通过偏移读取就像字符串一样，你可以通过列表对象的偏移对其进行索引，从而读取对象的某一部分内容。由于列表的每一项都是有序的，那么你也可以执行诸如分片和合并之类的任务。可变长度、异构以及任意嵌套与字符串不同的是，列表可以实地的增长或者缩短（长度可变），并且可以包含任何类型的对象而不仅仅是包含有单个字符的字符串（异构）。因为列表能够包含其他复杂的对象，又能够支持任意的嵌套，所以可以创建列表的子列表的子列表等。属于可变序列的分类就类型分类而言，列表支持在原处的修改（它们是可变的），也可以响应所有针对字符串序列的操作，例如,索引、分片以及合并。实际上，序列操作在列表与字符串中的工作方式相同。 ^621792-13-904
    - ⏱ 2020-01-23 20:01:57 

- 📌 del语句在这里也适用。 ^621792-13-21020-21032
    - ⏱ 2020-01-24 13:05:29 
 

- 📌 这类似于列表的pop方法，只不过删除的是一个键而不是一个可选的位置： ^621792-13-23374-23408
    - ⏱ 2020-01-24 13:09:56 

- 📌 最后一种形式通常也会与zip函数一起使用 ^621792-13-32935-32955
    - ⏱ 2020-01-24 13:19:54 

- 📌 对于D.key、D.values和D.items方法， ^621792-13-33773-33800
    - ⏱ 2020-01-24 13:21:18 

- 📌 正如我们将在本书第13章学习到的，zip函数是在一个单个调用中从键和值的列表来构建一个字典的方式之一。 ^621792-13-34423-34474
    - ⏱ 2020-01-24 13:21:57 

- 📌 字典解析对于从键列表来初始化字典也很有用，这和我们在前一小节末尾遇到的fromkeys方法很相似： ^621792-13-36081-36143
    - ⏱ 2020-01-24 13:24:01 
## 第9章 元组、文件及其他


- 📌 int和一些其他转换方法会忽略数字旁边的空白。 ^621792-14-17676-17728
    - ⏱ 2020-01-24 13:36:11 

- 📌 使用eval可以把字符串转换成对象 ^621792-14-18715-18732
    - ⏱ 2020-01-24 13:37:54 

- 📌 pickle模块 ^621792-14-18903-18911
    - ⏱ 2020-01-24 13:38:23 

- 📌 struct模块能够构造并解析打包的二进制数据。 ^621792-14-21110-21134
    - ⏱ 2020-01-24 13:40:04 
## 第六部分 类和OOP


- 📌 就是一些函数的包 ^621792-30-969-977
    - ⏱ 2019-11-20 23:37:03 

- 📌 内置对象类型 ^621792-30-989-995
    - ⏱ 2019-11-20 23:37:25 

- 📌 使用这个表达式读取模块的属性，调用对象的方法等 ^621792-30-3417-3440
    - ⏱ 2020-02-24 22:02:04 

- 📌 我们通常把树中位置较高的类称为超类（superclass）（就像C2和C3）。树中位置较低的类则称为子类（ ^621792-30-4908-4961
    - ⏱ 2020-01-26 16:23:09 

- 📌 在类头部的括号内 ^621792-30-7798-7806
    - ⏱ 2019-11-21 10:01:01 

- 📌 可能会先写个通用的超类，来定义组织中所有员工的默认的通用行 ^621792-30-12167-12196
    - ⏱ 2020-01-27 01:31:31 
## 第26章 类代码编写基础


- 📌 支持多个对象的产生、命名空间继承以及运算符重载 ^621792-31-744-767
    - ⏱ 2020-01-27 01:41:34 

- 📌 类对象和实例对象 ^621792-31-912-920
    - ⏱ 2020-01-27 01:41:45 

- 📌 在其所在文件导入时执行的。 ^621792-31-1562-1575
    - ⏱ 2020-01-27 01:43:24 

- 📌 类通过继承进行定制除了作为工厂来生成多个实例对象之外，类也可引入新组件（子类）来进行修改，而不对现有组件进行原地的修改。由类产生的实例对象会继承该类的属性。Python也可让类继承其他类，因而开启了编写类层次结构的大门，在阶层较低的地方覆盖现有的属性，让行为特定化。实际上，向层次的下端越深入，软件就会变得越特定。在这里和模块并不一致：模块的属性存在于一个单一、平坦的命名空间之内（这个命名空间不接受定制化）。在Python中，实例从类中继承，而类继承于超类。以下是属性继承机制的核心观点。•超类列在了类开头的括号中。要继承另一个类的属性，把该类列在class语句开头的括号中就可以了。含有继承的类称为子类，而子类所继承的类就是其超类。 ^621792-31-6425
    - ⏱ 2020-01-27 01:54:25 
## 第28章 类代码编写细节


- 📌 第28章类代码编写细节如果你还没有完全搞懂所有的Python OOP的内容，请别担心，我们已经很快浏览了这些内容，现在将会更深入地研究之前介绍过的概念。在这一章及以后的各章中，我们要从另一个角度看待类机制。这里，我们将继续学习类、方法和继承，正式讲解第26章介绍的一些编写类概念，并进行扩展。因为类是最后一个命名空间工具，所以我们也要在这里总结Python中命名空间的概念。下一章将继续深入回顾类机制，介绍一个更为特殊的方面：运算符重载。除了介绍详细细节，本章和下一章还会介绍一些比以前所见规模更大的类。class语句虽然Python class语句表面上看起来与其他OOP语言的工具类似，但仔细观察时，和一些程序员习惯的东西其实有着很大的不同。例如，class语句是Python主要的OOP工具，但与C++不同的是，Python的class并不是声明式的。就像def一样，class语句是对象的创建者并且是一个隐含的赋值运算——执行时，它会产生类对象，并把其引用值存储在前面所使用的变量名。此外，像def一样，class语句也是真正的可执行代码。直到Python抵达并运行定义的class语句前，你的类都不存在（一般都是在其所在模块被导入时，在这之前都不会存在）。一般形式class是复合语句，其缩进语句的主体一般都出现在头一行下边。在头一行中，超类列在类名称之后的括号内，由逗号相隔。列出一个以上的超类会引起多重继承（第30章会进一步讨论）。以下是class语句的一般形式。￼ class <name>（superclass,...）:            # Assign to name￼     data = value                         # Shared class data￼     def method（self,...）:                # Methods￼ ^621792-33-385
    - ⏱ 2020-01-31 22:45:16 
## 第八部分 高级话题


- 📌 search方法向前查找一个匹配 ^621792-41-82222-82238
    - ⏱ 2020-01-21 23:10:05 

- 📌 findall ^621792-41-82244-82251
    - ⏱ 2020-01-21 23:09:53 
# 读书笔记

## 第8章 列表与字典

### 划线评论
- 📌 update方法有点类似于合并  ^11897562-7eC0TT4he
    - 💭 合并
    - ⏱ 2020-01-24 13:09:38
   
# 本书评论
