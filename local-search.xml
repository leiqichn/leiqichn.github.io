<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计题 总结</title>
    <link href="/2024-04-05-d9f9294c39ef.html"/>
    <url>/2024-04-05-d9f9294c39ef.html</url>
    
    <content type="html"><![CDATA[<p><strong>设计题 - 实现浏览器历史记录</strong><br>1.初始化 homepage 和历史记录容量<br>2.浏览网页 </p><ul><li>和当前页相同，则直接返回</li><li>和当前页不同，如果容量满了，则删除最早的记录；清楚之前当前页的后边的历史记录，并把最新的当前页添加到最后。<br>3.实现前进和后退功能<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description: 浏览器实现</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.GetCurrentPage() == newPageURL &#123;<br><span class="hljs-keyword">return</span> newPageURL<br>&#125;<br><br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当面临一个设计题，如实现一个浏览器历史记录，需要考虑许多方面的因素。在这篇博客中，我们将探讨如何思考、建模和解决这个设计题，以及如何在考试场景下应对这类问题。</p><h1 id="第一步：理解需求"><a href="#第一步：理解需求" class="headerlink" title="第一步：理解需求"></a>第一步：理解需求</h1><p>在着手解决设计题之前，首先要明确需求。在这个例子中，我们需要实现一个浏览器历史记录，包括以下功能：</p><p>记录当前页面。<br>支持前进和后退操作。<br>能够跳转到新页面。<br>考虑历史记录的容量限制。</p><h1 id="第二步：建模"><a href="#第二步：建模" class="headerlink" title="第二步：建模"></a>第二步：建模</h1><p>接下来，我们需要建立一个合适的模型来表示浏览器历史记录。在这个模型中，需要考虑以下要素：</p><p>当前页面：表示用户当前正在浏览的页面。<br>历史记录：表示用户访问过的页面的顺序列表。<br>最大容量：限制历史记录的长度，以防止无限增长。<br>一个合适的数据结构来表示这个模型是双向链表。双向链表允许我们轻松插入、删除和遍历元素，非常适合表示浏览历史记录。</p><h1 id="第三步：选择数据结构和函数"><a href="#第三步：选择数据结构和函数" class="headerlink" title="第三步：选择数据结构和函数"></a>第三步：选择数据结构和函数</h1><p>接下来，我们需要选择适当的数据结构来表示模型，并确定哪些函数将用于实现各种操作。在这个例子中，我们选择了container&#x2F;list包中的双向链表作为数据结构，并定义以下函数：</p><p>NewBrowser(maxLen int, homepage string) *Browser：创建一个浏览器对象，并指定最大历史记录容量和首页。<br>GetCurrentPage() string：获取当前页面的URL。<br>GoBack() string：执行后退操作，并返回当前页面的URL。<br>GoForward() string：执行前进操作，并返回当前页面的URL。<br>NavigateToNewPage(newPageURL string) string：导航到新页面，并返回当前页面的URL。</p><h1 id="第四步：编写示例代码"><a href="#第四步：编写示例代码" class="headerlink" title="第四步：编写示例代码"></a>第四步：编写示例代码</h1><p>现在，我们可以编写示例代码来展示如何使用这个设计。在示例中，我们模拟了用户浏览不同页面的情况，并展示了如何使用上述函数来管理浏览历史记录。</p><h1 id="第五步：测试和优化"><a href="#第五步：测试和优化" class="headerlink" title="第五步：测试和优化"></a>第五步：测试和优化</h1><p>一旦实现了设计，就需要进行测试以确保它能按预期工作。在测试过程中，需要考虑各种情况，包括正常操作、边界情况和错误情况。</p><p>根据测试的结果，可以对设计进行优化和改进。这可能包括性能优化、边界情况的处理、错误处理和异常情况的处理等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在解决一个设计题时，需要从需求出发，建立合适的模型，选择适当的数据结构和函数，编写示例代码，进行测试和优化。设计题通常涉及多个方面的考虑，需要综合考虑各种情况以确保设计的正确性和鲁棒性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面，我们来按照难度多练习几道题目</p><h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ol><li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></li></ol><p><img src="/../../imgs/Pasted%20image%2020240405184827.png"></p><p> <strong>思路：</strong>input 作为输入，output 最为反转后的；如果output存在则直接取结果；否则从input里边反转；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>inputStack  []<span class="hljs-type">int</span><br>outputStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br><span class="hljs-keyword">return</span> MyQueue&#123;<br>inputStack:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputStack: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputStack = <span class="hljs-built_in">append</span>(this.inputStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br>this.outputStack = this.outputStack[:<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.outputStack) != <span class="hljs-number">0</span> &#123;<br><br>topTmp := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> topTmp<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputStack) != <span class="hljs-number">0</span> &#123;<br>this.outputStack = <span class="hljs-built_in">append</span>(this.outputStack, this.inputStack[<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>])<br>this.inputStack = this.inputStack[:<span class="hljs-built_in">len</span>(this.inputStack)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br>top := this.outputStack[<span class="hljs-built_in">len</span>(this.outputStack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.inputStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(this.outputStack) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Peek();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a><img src="/../../imgs/Pasted%20image%2020240405184932.png"></li></ol><p><strong>思路：</strong>用队列实现栈；栈是最后一元素出来；所以input 需要遍历到添加元素到output, 到剩余最后一个元素。这个元素就是要出栈的。出完栈再将output 重新赋值给input;output 重置为空；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>inputQueue  []<span class="hljs-type">int</span><br>outputQueue []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br><span class="hljs-keyword">return</span> MyStack&#123;<br>inputQueue:  <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>outputQueue: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>),<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.inputQueue, x)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = this.outputQueue<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.inputQueue) != <span class="hljs-number">1</span> &#123;<br>this.outputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue[<span class="hljs-number">0</span>])<br>this.inputQueue = this.inputQueue[<span class="hljs-number">1</span>:]<br>&#125;<br>top := this.inputQueue[<span class="hljs-number">0</span>]<br>this.inputQueue = <span class="hljs-built_in">append</span>(this.outputQueue, this.inputQueue...)<br>    this.outputQueue = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(this.inputQueue) == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">len</span>(this.outputQueue) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406201421.png"><br>思路：简单题，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    nums  []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    <span class="hljs-keyword">return</span> NumArray&#123;nums: nums&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i:= left; i&lt;= right; i++ &#123;<br>        sum += this.nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用前缀和<br><img src="/../../imgs/Pasted%20image%2020240406201959.png"><br>怎么求 preSum 数组<br>利用前面提到的递推式:<br><img src="/../../imgs/Pasted%20image%2020240406201929.png"></p><p>遍历求出每一个preSum[i]，别忘了预置preSum[-1]为0，<strong>即preSum[0]为nums[0]（前提是nums有元素）</strong>。</p><p>预置preSum[-1]这种荒谬的情况，只是为了边界情况也能套用通式。</p><p>需要针对len(nums) &#x3D;&#x3D; 0的情况进行特判，i &#x3D; 0 的情况，也需单独讨论。</p><p>后面会给出简化的写法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(nums);i++ &#123;<br>        preSum[ i] = preSum[ i<span class="hljs-number">-1</span>] + nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 此时preSum[i-1]应该为0，从0到j的求和，应该返回preSum[j]</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.preSum) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 但如果nums根本没有长度，直接返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> this.preSum[right]<br>&#125;<br>    <span class="hljs-keyword">return</span> this.preSum[right] - this.preSum[left<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p>使用多一位长度的前缀和<br>之所以上面处理东西多，是因为<code>preSum[i]</code>的定义导致的。例如如果上边left &#x3D;&#x3D; 0 ; 则不再适用于通用公式；那是因为left -1 &#x3D; -1了，而数组中没有-1 index</p><p>要解决这问题。我们只要改革preSum[i]的定义就行;我们期望最后是preSum[left] 而不是preSum[left-1]<br>即：</p><p><img src="/../../imgs/Pasted%20image%2020240406202142.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    preSum []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    preSum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> nums &#123;<br>        preSum[index + <span class="hljs-number">1</span>] = preSum[index] + value<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NumArray&#123;preSum&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span></span> SumRange(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.preSum[right + <span class="hljs-number">1</span>] - this.preSum[left]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(nums);</span><br><span class="hljs-comment"> * param_1 := obj.SumRange(left,right);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h1><p><img src="/../../imgs/Pasted%20image%2020240406204841.png"><br><strong>暴力解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 排序后的nums</span><br>index      <span class="hljs-type">int</span><br>sortedNums []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br><span class="hljs-keyword">return</span> KthLargest&#123;k, nums&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>this.sortedNums = <span class="hljs-built_in">append</span>(this.sortedNums, val)<br>sort.Ints(this.sortedNums)<br>revert(this.sortedNums)<br><span class="hljs-keyword">return</span> this.sortedNums[this.index<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">revert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(k, nums);</span><br><span class="hljs-comment"> * param_1 := obj.Add(val);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><p><strong>优先队列</strong><br>我们可以使用一个大小为 kkk 的优先队列来存储前 kkk 大的元素，其中优先队列的队头为队列中最小的元素，也就是第 kkk 大的元素。</p><p>在单次插入的操作中，我们首先将元素 val\textit{val}val 加入到优先队列中。如果此时优先队列的大小大于 kkk，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 kkk。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KthLargest <span class="hljs-keyword">struct</span> &#123;<br>    sort.IntSlice<br>    k <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(k <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> KthLargest &#123;<br>    kl := KthLargest&#123;k: k&#125;<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>        kl.Add(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    kl.IntSlice = <span class="hljs-built_in">append</span>(kl.IntSlice, v.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    a := kl.IntSlice<br>    v := a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    kl.IntSlice = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *KthLargest)</span></span> Add(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    heap.Push(kl, val)<br>    <span class="hljs-keyword">if</span> kl.Len() &gt; kl.k &#123;<br>        heap.Pop(kl)<br>    &#125;<br>    <span class="hljs-keyword">return</span> kl.IntSlice[<span class="hljs-number">0</span>]<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>windows IE代理问题解决</title>
    <link href="/2024-04-05-e1116cf34b00.html"/>
    <url>/2024-04-05-e1116cf34b00.html</url>
    
    <content type="html"><![CDATA[<p>CMD <strong>检查系统代理配置</strong>：</p><pre><code class="hljs">- 通过命令提示符运行`netsh winhttp show proxy`来查看当前的系统代理设置。- 如果需要更改系统代理，可以使用`netsh winhttp set proxy`命令进行设置。</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 双指针</title>
    <link href="/2024-03-23-84678021105b.html"/>
    <url>/2024-03-23-84678021105b.html</url>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020240323225412.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 删除有序数组中的重复元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    slow:=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast:=<span class="hljs-number">1</span>;fast &lt;<span class="hljs-built_in">len</span>(nums);fast++ &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<span class="hljs-comment">// 跳到下个位置，保存slow</span><br><br>            nums[slow] = nums[fast]<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow +<span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240323225326.png"></p><p>slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p><strong>注意到以下性质：</strong></p><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。<br>因此每次交换，都是将slow指针的零与fast指针的非零数交换，且非零数的相对顺序并未改变。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>slow, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> fast := <span class="hljs-number">0</span>; fast &lt; n; fast++ &#123; <span class="hljs-comment">// 注意第一个是0的时候需要比较</span><br><span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 不是零的时候，才会交换，如果第一个是0，则fast 是会向后移动的，这样就会交换数值，保证的是slow是指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span><br>nums[slow], nums[fast] = nums[fast], nums[slow]<br>slow++<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324224049.png"><br><strong>思路：</strong><br><img src="/../../imgs/Pasted%20image%2020240324224214.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(height); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(height); j++ &#123;<br>area := (j - i) * min(height[i], height[j])<br>ans = max(area,ans)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240324223922.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span> <span class="hljs-comment">// 初始化两边指针</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        area := (right - left) * min(height[left], height[right]) <span class="hljs-comment">// 计算面积</span><br>        ans = max(ans, area) <span class="hljs-comment">// 计算最大值</span><br>        <span class="hljs-keyword">if</span> height[left] &lt; height[right] &#123; <br>            left++ <span class="hljs-comment">// 移动短的那个</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020240326011627.png"></p><p>前缀和，后缀和<br>木桶效应，当前能装的水，取决于两边最大值 的最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    preMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// preMax[i] 表示从 height[0] 到 height[i] 的最大值</span><br>    preMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        preMax[i] = max(preMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    sufMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">// sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值</span><br>    sufMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        sufMax[i] = max(sufMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        ans += min(preMax[i], sufMax[i]) - h <span class="hljs-comment">// 累加每个水桶能接多少水</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    left, right, preMax, sufMax := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        preMax = max(preMax, height[left])<br>        sufMax = max(sufMax, height[right])<br>        <span class="hljs-keyword">if</span> preMax &lt; sufMax &#123;<br>            ans += preMax - height[left]<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += sufMax - height[right]<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &lt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 单调栈</title>
    <link href="/2024-02-24-dd95d981cb94.html"/>
    <url>/2024-02-24-dd95d981cb94.html</url>
    
    <content type="html"><![CDATA[<p>单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」</p><p>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// 存放答案的数组</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123; <span class="hljs-comment">// 倒着入栈是为了后边正着出栈</span><br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &lt;= nums[i] &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的更大元素</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 没有更大的元素</span><br>            res[i] = <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] <span class="hljs-comment">// 正着出栈</span><br>        &#125;<br>        s = <span class="hljs-built_in">append</span>(s, nums[i]) <span class="hljs-comment">// 当前元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang 修改函数传入参数切片需要指针</title>
    <link href="/2024-02-24-4fbd7a88bf6f.html"/>
    <url>/2024-02-24-4fbd7a88bf6f.html</url>
    
    <content type="html"><![CDATA[<p>func dfs(root *TreeNode, res *[]int) {<br>    if root &#x3D;&#x3D; nil {<br>        return<br>    }</p><pre><code class="hljs">*res = append(*res, root.Val)dfs(root.Left, res)dfs(root.Right, res)</code></pre><p>}<br>在这个修正后的版本中，res参数是一个指向切片的指针。这样，我们在函数内部通过*res来访问和修改原始切片的内容，确保递归调用可以正确地将结果收集到原始切片中。</p><p>在 Go 语言中，切片是引用类型。这意味着当你将切片传递给函数时，你实际上传递的是切片的引用（底层数组的地址），而不是切片的副本。因此，对切片的修改会影响到原始切片。</p><p>但是需要注意的是，虽然切片是引用类型，但当你在函数内部对切片进行重新分配（比如使用 append 函数时），你实际上是创建了一个新的切片，而原始切片并没有被修改。这是因为切片是对底层数组的一个视图，对切片的修改可能会导致底层数组的重新分配和复制。</p><p>这就是为什么在你的原始 DFS 函数中，尽管你传递了切片 res 给递归函数，但在递归调用中对 res 进行 append 操作并不会修改原始切片的内容。为了避免这个问题，可以通过传递切片的指针来确保在函数内部对切片的修改可以影响到原始切片。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 406. 根据身高重建队列【贪心】</title>
    <link href="/2024-01-23-1cb0809a7893.html"/>
    <url>/2024-01-23-1cb0809a7893.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406. 根据身高重建队列 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240124001349.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(people [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> people[i][<span class="hljs-number">0</span>] == people[j][<span class="hljs-number">0</span>]&#123;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">1</span>] &lt; people[j][<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> people[i][<span class="hljs-number">0</span>] &gt; people[j][<span class="hljs-number">0</span>] <span class="hljs-comment">// 身高由大到小排列</span><br><br>&#125;)i<br><span class="hljs-comment">// 再按照K进行插入排序，优先插入K小的</span><br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-built_in">copy</span>(people[p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span> :i+<span class="hljs-number">1</span>], people[p[<span class="hljs-number">1</span>] :i=<span class="hljs-number">1</span>])  <span class="hljs-comment">// 腾空出一个位置</span><br>        people[p[<span class="hljs-number">1</span>]] = pi<br>&#125;<br><span class="hljs-keyword">return</span> people<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>sort.Slice(people, func(i, j int) bool &#123; ... &#125;)</code>: 使用 <code>sort.Slice</code> 对 <code>people</code> 进行排序，按照身高从大到小排列，如果身高相同则按照 <code>k</code> 从小到大排列。</p></li><li><p><code>for i, p := range people &#123; ... &#125;</code>: 遍历排序后的数组，按照每个人的 <code>k</code> 值进行插入排序。</p></li><li><p><code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code>: 在插入位置 <code>p[1]</code> 之后的位置腾出一个空位，为新的元素插入做准备。</p></li><li><p><code>people[p[1]] = p</code>: 将当前人物 <code>p</code> 插入到正确的位置。</p></li></ol><p>最终，返回重新排列后的队列 <code>people</code>。</p><p>在 <code>copy(people[p[1]+1:i+1], people[p[1]:i+1])</code> 中，使用 <code>i+1</code> 而不是 <code>len(people)</code> 的原因是为了确保只复制有效的元素范围。这里的目标是将 <code>people[p[1]:i+1]</code> 复制到 <code>people[p[1]+1:i+1]</code>，而不是复制整个切片。</p><p>让我们考虑一下为什么使用 <code>i+1</code>：</p><ol><li><code>i</code> 表示当前元素的索引，而我们想要复制的范围是从 <code>p[1]</code> 到 <code>i</code>。</li><li>使用 <code>i+1</code> 作为结束索引可以确保包含 <code>i</code> 在内的元素，而不会超出有效的范围。</li><li>如果使用 <code>len(people)</code> 作为结束索引，那么将会复制从 <code>p[1]</code> 到 <code>len(people)-1</code> 的所有元素，这超出了实际有效的范围。</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 77.组合【回溯】</title>
    <link href="/2024-01-23-183e0ff5f5ef.html"/>
    <url>/2024-01-23-183e0ff5f5ef.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020240123231742.png"></p><p>使用回溯的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>path := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">// 结束条件</span><br><span class="hljs-keyword">var</span> backtracking <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span><br>backtracking = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k ,startIdx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 提前返回需要return</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k &#123;<br>            pathTmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(path))<br><span class="hljs-built_in">copy</span>(pathTmp, path)<br>res = <span class="hljs-built_in">append</span>(res, pathTmp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// return </span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := startIdx;i &lt;= n ;i++ &#123;<br>path = <span class="hljs-built_in">append</span>(path,i)<br>backtracking(n,k,i+<span class="hljs-number">1</span>) <span class="hljs-comment">// i+1 进行下一轮</span><br>path = path[:(<span class="hljs-built_in">len</span>(path) <span class="hljs-number">-1</span>)]<br>&#125;<br>&#125;<br>backtracking(n,k,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>创建一个二维切片 <code>res</code> 用于存储最终结果，以及一个一维切片 <code>path</code> 用于存储当前路径。</p></li><li><p>定义回溯函数 <code>backtracking</code>，它接收三个参数：<code>n</code> 表示数字范围，<code>k</code> 表示组合长度，<code>startIdx</code> 表示当前起始数字的索引。</p></li><li><p>在回溯函数中，如果当前路径的长度等于 k，将当前路径添加到结果中。</p></li><li><p>使用循环遍历数字范围，将当前数字加入路径，并递归调用回溯函数。</p></li><li><p>在递归结束后，进行回溯，将当前数字从路径中移除，继续遍历下一个数字。</p></li><li><p>在主函数中初始调用回溯函数，然后返回最终结果。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【BFS DFS通用模板】</title>
    <link href="/2024-01-22-759654485d5d.html"/>
    <url>/2024-01-22-759654485d5d.html</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索（DFS）通用模板"><a href="#深度优先搜索（DFS）通用模板" class="headerlink" title="深度优先搜索（DFS）通用模板"></a>深度优先搜索（DFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 通用的深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node <span class="hljs-type">int</span>, visited []<span class="hljs-type">bool</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> visited[node] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理当前节点</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 标记当前节点为已访问</span><br>    visited[node] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 递归处理相邻节点</span><br>    <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>        dfs(neighbor, visited, graph)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化节点、访问数组等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 遍历所有节点</span><br>    <span class="hljs-keyword">for</span> node := <span class="hljs-number">0</span>; node &lt; <span class="hljs-built_in">len</span>(graph); node++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[node] &#123;<br>            dfs(node, visited, graph)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）通用模板"><a href="#广度优先搜索（BFS）通用模板" class="headerlink" title="广度优先搜索（BFS）通用模板"></a>广度优先搜索（BFS）通用模板</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通用的广度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(start <span class="hljs-type">int</span>, graph [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(graph))<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 出队列</span><br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment">// 处理当前节点</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 标记当前节点为已访问</span><br>        visited[node] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 将相邻节点入队列</span><br>        <span class="hljs-keyword">for</span> _, neighbor := <span class="hljs-keyword">range</span> graph[node] &#123;<br>            <span class="hljs-keyword">if</span> !visited[neighbor] &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, neighbor)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在主函数中调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化起始节点、图等</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用BFS函数</span><br>    bfs(start, graph)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 94.二叉树的中序遍历</title>
    <link href="/2024-01-22-f8790b7ced8e.html"/>
    <url>/2024-01-22-f8790b7ced8e.html</url>
    
    <content type="html"><![CDATA[<h1 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">var</span> traversal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traversal = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br>traversal(node.Left)<br>res = <span class="hljs-built_in">append</span>(res,node.Val)<br>traversal(node.Right)<br>    &#125;<br>    traversal(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br><br>    st := list.New()<br>    cur := root<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> || st.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> cur != <span class="hljs-literal">nil</span> &#123;<br>            st.PushBack(cur)<br>            cur = cur.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = st.Remove(st.Back()).(*TreeNode)<br>            ans = <span class="hljs-built_in">append</span>(ans, cur.Val)<br>            cur = cur.Right<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是对代码的解释：</p><ol><li><p><code>ans := []int&#123;&#125;</code>: 创建一个空的整数切片，用于存储最终的中序遍历结果。</p></li><li><p><code>if root == nil &#123; return ans &#125;</code>: 检查树的根节点是否为空，如果为空则返回空切片，避免对空树进行遍历。</p></li><li><p><code>st := list.New()</code>: 创建一个新的链表（list），用作栈。这里使用标准库中的<code>list</code>包，实现了一个双向链表作为栈。</p></li><li><p><code>cur := root</code>: 初始化当前节点为根节点。</p></li><li><p><code>for cur != nil || st.Len() &gt; 0 &#123;</code>: 进入循环，只要当前节点不为空或栈不为空就继续遍历。</p></li><li><p><code>if cur != nil &#123;</code>: 如果当前节点不为空，将当前节点入栈，并将当前节点移动到左子树。</p><ul><li><p><code>st.PushBack(cur)</code>: 将当前节点入栈。</p></li><li><p><code>cur = cur.Left</code>: 移动到左子树。</p></li></ul></li><li><p><code>&#125; else &#123;</code>: 如果当前节点为空，表示左子树已经遍历完毕，需要处理栈顶节点。</p><ul><li><p><code>cur = st.Remove(st.Back()).(*TreeNode)</code>: 弹出栈顶节点，即当前待处理的节点。</p></li><li><p><code>ans = append(ans, cur.Val)</code>: 将当前节点的值加入结果切片。</p></li><li><p><code>cur = cur.Right</code>: 移动到右子树。</p></li></ul></li><li><p>循环回到第5步，直到栈为空。</p></li></ol><p>这种非递归中序遍历的实现使用了栈来辅助遍历，通过不断地将左子树的节点入栈，并在处理栈顶节点时将其值加入结果切片，最后移动到右子树，以达到中序遍历的顺序。</p><p>其中 进入循环的条件 <code>for cur != nil || st.Len() &gt; 0</code> 是为了确保在树的所有节点都被遍历到之前，循环能够继续执行。让我们逐步解释这个条件：</p><ul><li><p><code>cur != nil</code>: 如果当前节点不为空，表示还有左子树可以遍历，因此继续循环。</p></li><li><p><code>st.Len() &gt; 0</code>: 如果当前节点为空，但栈不为空，说明还有节点需要处理（回溯到上一层的右子树），也继续循环。</p></li></ul><p>这个条件的目的是确保在左子树和右子树都被遍历完之前，循环一直执行。当所有节点都被遍历过，且栈为空时，循环条件不再满足，退出循环，完成中序遍历。</p><p>在这个中序遍历的非递归实现中，通过栈来模拟递归调用的过程，确保每个节点都按照中序遍历的顺序被访问。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【go】初始化双向列表List</title>
    <link href="/2024-01-22-93119ce81a1c.html"/>
    <url>/2024-01-22-93119ce81a1c.html</url>
    
    <content type="html"><![CDATA[<p>在Go语言中，两种方法都可以用于初始化一个<code>list.List</code>。</p><ol><li><p><code>queue := &amp;list.List&#123;&#125;</code>: 这是使用结构体字面量的方式，创建一个 <code>list.List</code> 类型的结构体变量，并返回该结构体的指针。这种方式创建了一个空的链表。</p></li><li><p><code>queue := list.New()</code>: 这是使用 <code>list</code> 包中的 <code>New</code> 函数来创建一个新的 <code>list.List</code>。<code>New</code> 函数返回一个指向新创建的 <code>list.List</code> 实例的指针。同样，这种方式也创建了一个空的链表。</p></li></ol><p>两种方式都是有效的</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【20240114】LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="/2024-01-14-e61755fec3db.html"/>
    <url>/2024-01-14-e61755fec3db.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>遍历</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">for</span> i := head; i != <span class="hljs-literal">nil</span> &amp;&amp; i.Next != <span class="hljs-literal">nil</span> ; &#123;<br>        <span class="hljs-keyword">if</span> i.Next.Val == i.Val &#123;<br>            i.Next = i.Next.Next <span class="hljs-comment">// 这里不用移动下个元素，只用删除重复元素 for i := head; i != nil &amp;&amp; i.Next != nil ;i = i.Next &#123;  i = i.Next不需要</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i = i.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    current := head<br><br>    <span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &amp;&amp; current.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> current.Next.Val == current.Val &#123;<br>            <span class="hljs-comment">// 保存下一个节点的引用</span><br>            nextNode := current.Next<br>            <span class="hljs-comment">// 删除当前节点</span><br>            current.Next = nextNode.Next<br>            <span class="hljs-comment">// 释放内存</span><br>            nextNode = <span class="hljs-literal">nil</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 非重复元素，继续遍历</span><br>            current = current.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Win】键盘下键坏了，使用组合键模拟下方向键</title>
    <link href="/2024-01-14-2aaa71f8e7be.html"/>
    <url>/2024-01-14-2aaa71f8e7be.html</url>
    
    <content type="html"><![CDATA[<p>使用 AutoHotKey 来创建一个脚本，使得按下 Alt + S 时模拟按下下方向键。以下是创建这样一个脚本的步骤：</p><p>下载并安装 AutoHotKey： 访问 AutoHotKey 官网，下载并安装 AutoHotKey v1.0。<br><img src="/../../imgs/Pasted%20image%2020240114170655.png"><br>创建脚本文件： 打开文本编辑器（如记事本）并创建一个新的脚本文件，将以下内容复制粘贴到文件中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">!s::<span class="hljs-built_in">Send</span> &#123;Down&#125;<br></code></pre></td></tr></table></figure><p>这个脚本表示当你按下 Alt + S 组合键时，将模拟按下下方向键。<br><img src="/../../imgs/Pasted%20image%2020240114170729.png"><br>保存文件： 将文件保存为 .ahk 扩展名（例如，AltSRemap.ahk）。</p><p>运行脚本： 双击保存的 .ahk 文件，它将在系统托盘中运行。</p><p>现在，按下 Alt + S 组合键会模拟按下下方向键的效果。你可以根据需要修改脚本中的组合键，确保不会与其他快捷键冲突。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【20240106】leetcode 2807. 在链表中插入最大公约数</title>
    <link href="/2024-01-06-2b3ad028343c.html"/>
    <url>/2024-01-06-2b3ad028343c.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/?envType=daily-question&envId=2024-01-06">2807. 在链表中插入最大公约数 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020240106233021.png"></p><p>最大公约数（GCD，Greatest Common Divisor）是两个或多个整数的共有因数中的最大值。也叫作最大公因数、最大公因子或最大公量。如果两个整数的最大公约数是 1，那么它们被称为互质。</p><p>计算两个整数的最大公约数有多种方法，其中最著名的方法之一是辗转相除法（Euclidean Algorithm）。辗转相除法的基本思想是通过反复应用两个整数的除法余数关系，直到余数为零为止。具体步骤如下：</p><ol><li>用较大的数除以较小的数，得到余数。</li><li>将较小的数作为新的被除数，余数作为新的除数。</li><li>重复步骤 1 和 2，直到余数为零。</li><li>最后的非零余数即为最大公约数。</li></ol><p>这个算法的效率很高，时间复杂度为 �(log⁡(min⁡(�,�)))O(log(min(a,b)))。</p><p>以下是一个用 Go 语言实现的最大公约数的辗转相除法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 辗转相除法求最大公约数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        temp := b<br>        b = a % b<br>        a = temp<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num1 := <span class="hljs-number">48</span><br>    num2 := <span class="hljs-number">18</span><br><br>    result := gcd(num1, num2)<br><br>    fmt.Println(<span class="hljs-string">&quot;最大公约数为:&quot;</span>, result)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>gcd</code> 函数使用了辗转相除法来计算两个整数的最大公约数。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1071. 字符串的最大公因子</title>
    <link href="/2024-01-03-58e186a9065e.html"/>
    <url>/2024-01-03-58e186a9065e.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子</a></p><p><img src="/../../imgs/Pasted%20image%2020240103231323.png"></p><p><strong>解题思路：</strong></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n1, n2 := <span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2)<br><br>    <span class="hljs-comment">// 从最长的可能的子串长度开始尝试</span><br>    <span class="hljs-keyword">for</span> i := min(n1, n2); i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> n1%i == <span class="hljs-number">0</span> &amp;&amp; n2%i == <span class="hljs-number">0</span> &#123;<br>            commonSubstring := str1[:i]<br><br>            <span class="hljs-comment">// 检查是否满足条件</span><br>            <span class="hljs-keyword">if</span> checkDivisible(str1, commonSubstring) &amp;&amp; checkDivisible(str2, commonSubstring) &#123;<br>                <span class="hljs-keyword">return</span> commonSubstring<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 检查字符串是否能够整除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDivisible</span><span class="hljs-params">(s <span class="hljs-type">string</span>, sub <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    repeats := <span class="hljs-built_in">len</span>(s) / <span class="hljs-built_in">len</span>(sub)<br>    concatenated := repeatString(sub, repeats)<br>    <span class="hljs-keyword">return</span> s == concatenated<br>&#125;<br><br><span class="hljs-comment">// 重复字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatString</span><span class="hljs-params">(s <span class="hljs-type">string</span>, count <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    result := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>        result += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>辗转相除法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> str1 + str2 != str2 + str1 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    gcd := gcd(<span class="hljs-built_in">len</span>(str1), <span class="hljs-built_in">len</span>(str2))<br>    <span class="hljs-keyword">return</span> str1[<span class="hljs-number">0</span>:gcd]<br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> b != <span class="hljs-number">0</span> &#123;<br>        a, b = b, a % b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>windows新增wsl bash here键快捷方式</title>
    <link href="/2024-01-01-38178c63ba17.html"/>
    <url>/2024-01-01-38178c63ba17.html</url>
    
    <content type="html"><![CDATA[<p>win + R 输入regedit<br><img src="/../../imgs/Pasted%20image%2020240101182355.png"><br>输入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p><h1 id="新建wsl-bash-here目录-设置如下默认值"><a href="#新建wsl-bash-here目录-设置如下默认值" class="headerlink" title="新建wsl_bash_here目录, 设置如下默认值"></a>新建wsl_bash_here目录, 设置如下默认值</h1><p><img src="/../../imgs/Pasted%20image%2020240101183252.png"></p><h1 id="新建command新建项，输入wsl-exe-的地址"><a href="#新建command新建项，输入wsl-exe-的地址" class="headerlink" title="新建command新建项，输入wsl.exe 的地址"></a>新建command新建项，输入wsl.exe 的地址</h1><p><img src="/../../imgs/Pasted%20image%2020240101183246.png"></p><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>可以看到右侧是有wsl bash here的选项的<br><img src="/../../imgs/Pasted%20image%2020240101183634.png"><br><strong>在当面目录打开wsl 成功</strong><br><img src="/../../imgs/Pasted%20image%2020240101183645.png"><br>原理和添加git bash here 类似, 参考:<br><a href="https://blog.csdn.net/Passerby_Wang/article/details/120881670">手动添加Git Bash Here到右键菜单（超详细）_gitbash添加到右键-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git 设置免密配置-全局免密-单仓库免密-SSH免密</title>
    <link href="/2024-01-01-91517aa963bc.html"/>
    <url>/2024-01-01-91517aa963bc.html</url>
    
    <content type="html"><![CDATA[<h1 id="介绍之前"><a href="#介绍之前" class="headerlink" title="介绍之前"></a>介绍之前</h1><p>我们要首先知道一个简单的概念:<br>https通过<strong>记住账号密码免登</strong>，ssh通过<strong>校验生成的密钥免登</strong>。 通常都用ssh校验。</p><p>查看通信方式</p><p>在项目目录中运行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote -v<br></code></pre></td></tr></table></figure><p>如果出现提示是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">origin  https://gitee.com/xxx/xxx.git (fetch)<br>origin  https://gitee.com/xxx/xxx.git (push)<br></code></pre></td></tr></table></figure><p>则证明是https 通信，这样每次都会提示输入用户名和密码，如果我们还是使用https则看下文，全局https免密 和单个仓库免密<br>如果我们git远端配置了ssh 配置; 我们将其修改为ssh的地址<br><img src="/../../imgs/Pasted%20image%2020240101151457.png"></p><h1 id="一、https-方式及免密码配置"><a href="#一、https-方式及免密码配置" class="headerlink" title="一、https 方式及免密码配置"></a>一、https 方式及免密码配置</h1><h3 id="0-项目中-git-基本配置"><a href="#0-项目中-git-基本配置" class="headerlink" title="0. 项目中 git 基本配置"></a>0. 项目中 git 基本配置</h3><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置远程项目地址(前提已经在网页上新建了仓库)，完成首次提交。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text"># 初始化仓库 适用于新库,如果你之前已经有文件并且使用git管理过,请勿使用该命令<br>git init<br># 关联远程仓库<br>git remote add origin https://gitee.com/xxx/xxx.git<br>git add -A<br>git commit -m &quot;初始化&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>需要输入用户名，再输入密码，才能完成提交。以后每次都要输入用户名和密码。</p><p>这种方式如果要以后提交时免密码，只能将用户名和密码明文保存在本地，由 git 保管。因为本地没有加密，这种方式是不太安全的。</p><h3 id="1-全局免密码配置"><a href="#1-全局免密码配置" class="headerlink" title="1.全局免密码配置"></a>1.全局免密码配置</h3><p>配置存储模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>执行之后会在用户主目录下的.gitconfig文件中多加 helper &#x3D; store</p><p>Linux 下查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.gitconfig<br></code></pre></td></tr></table></figure><p>windows10 下当前用户路径：<code>%USERPROFILE%</code><br>内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[user]<br>        name = lenovo<br>        email = xxxx@outlook.com<br>[credential]<br>        helper = store<br></code></pre></td></tr></table></figure><p>然后在项目目录，执行git pull&#x2F;git push命令，会提示输入<strong>账号密码</strong>。这次输入账号密码之后，就会<strong>记住</strong>账号密码，并且会在当前用户根目录下生成一个.git-credentials文件，下一次就不用再输入账号密码了。<br><img src="/../../imgs/Pasted%20image%2020240101145902.png"></p><h3 id="2、单项目免密码配置"><a href="#2、单项目免密码配置" class="headerlink" title="2、单项目免密码配置"></a>2、单项目免密码配置</h3><p>编辑项目目录中.git 文件夹下的配置文件 config，修改其中 url 项：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]<br>url = https://gitee.com/xxx/xxx.git<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[remote &quot;origin&quot;]   <br>url = https://yourusername:password@gitee.com/xxx/xxxx.git<br></code></pre></td></tr></table></figure><p>也就是在 <code>https://</code> 之后，增加 <code>用户名:密码@</code></p><h1 id="二-SSH免密登录"><a href="#二-SSH免密登录" class="headerlink" title="二. SSH免密登录"></a>二. SSH免密登录</h1><p>如果之前是https 关联的,现在想使用ssh 方式关联,请先命令删除原有 origin 的通信方式,</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote rm origin<br></code></pre></td></tr></table></figure><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>github 网页增加本机SSH key</p><p>git ssh 方式免密提交方式需要将 <code>ssh-keygen</code> 生成的公钥放到服务器上</p><p>全局用户名密码配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;xxx&quot; <br>git config --global user.email &quot;xxx@qq.com&quot;<br></code></pre></td></tr></table></figure><p>项目初始化，生成 .git 目录，配置 ssh 远程项目地址。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 如果是新仓库需要git init ;否则不需要git init; git init<br># git 关联远程仓库<br>git remote add origin git@gitee.com:xxx/xxx.git<br></code></pre></td></tr></table></figure><h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><p>1、首先需要检查你电脑是否已经有 SSH key</p><p>运行 git Bash 客户端，检查本机的ssh密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">$ cd ~/.ssh <br>$ ls<br></code></pre></td></tr></table></figure><p>如果提示：No such file or directory ，说明是第一次使用 git。</p><p>如果不是第一次使用，已经存在 id_rsa.pub 或 id_dsa.pub 文件, 则不用重新生成,直接跳到步骤3。如果没有生成过 id_rsa.pub ,请执行下面的操作，生成ssh 密钥。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ mkdir key_backup   <br>$ cp id_rsa* key_backup   <br>$ rm id_rsa*<br></code></pre></td></tr></table></figure><p>2、执行生成公钥和私钥的命令，生成新的密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;xxx&quot;<br></code></pre></td></tr></table></figure><p>代码参数：</p><p>-t 指定密钥类型，默认是 rsa ，可以省略。</p><p>-C 设置注释文字，比如邮箱。</p><p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p><p>按默认为空，直接按回车3下，生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p><p>执行查看公钥信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>Windows 系统，位置在用户目录下 .ssh文件夹中。<code>%USERPROFILE%</code></p><h2 id="复制公钥信息到远端仓库"><a href="#复制公钥信息到远端仓库" class="headerlink" title="复制公钥信息到远端仓库"></a>复制公钥信息到远端仓库</h2><p><strong>gitee</strong><br>打开 gitee，我的账户-设置-SSH 公钥，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p><p><img src="https://pic3.zhimg.com/80/v2-8c26fae5769cb56da5e20c884a33c702_720w.webp"></p><p><strong>github</strong><br>Settings -SSH and GPG keys - New SSH key<br><img src="app://db738d3bb1089e4d04f6eb022a68209f31bf/D:/obsidian_note/LeiQi_Blog/source/imgs/Pasted%20image%2020240101151324.png?1704093204312"><br>然后，提交时就不再需要用户名和密码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">git add -A<br>git commit -m &quot;ssh免密提交&quot;<br>git push -u origin master<br></code></pre></td></tr></table></figure><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/358721423">https://zhuanlan.zhihu.com/p/358721423</a></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows设置Clion 下方Terminal为WSL linux 子系统</title>
    <link href="/2023-12-30-397a0b919639.html"/>
    <url>/2023-12-30-397a0b919639.html</url>
    
    <content type="html"><![CDATA[<h1 id="终端上的小箭头下的设置"><a href="#终端上的小箭头下的设置" class="headerlink" title="终端上的小箭头下的设置"></a>终端上的小箭头下的设置</h1><p><img src="/../../imgs/Pasted%20image%2020231230235906.png"><br><img src="/../../imgs/Pasted%20image%2020231230234942.png"></p><h1 id="找到WSL的地址"><a href="#找到WSL的地址" class="headerlink" title="找到WSL的地址"></a>找到WSL的地址</h1><p><img src="/../../imgs/Pasted%20image%2020231231000039.png"></p><p>粘贴到对应地址中<br><img src="/../../imgs/Pasted%20image%2020231231000121.png"></p><h1 id="设置成功"><a href="#设置成功" class="headerlink" title="设置成功"></a>设置成功</h1><p>这个时候,就可以和在linux 中一样的操作啦! 主要是win 的cmd 太难用了!</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>免费使用Jetbrain 全家桶-服务器激活码激活软件</title>
    <link href="/2023-12-30-6a1e804ab992.html"/>
    <url>/2023-12-30-6a1e804ab992.html</url>
    
    <content type="html"><![CDATA[<p>众所周知，PyCharm和IDEA Goland CLion 都是Jetbrain 公司的产品,非常适合开发项目.但是这个软件确是收费的,而且还不低. 本文就是介绍一种方法可以免费使用的方法,如果大家有余力的,还是希望购买正版产品.</p><p>Jetbrain 是针对公司这种大客户是有对应的License Server的，这样方便很多用户使用。而我们可以通过输入这些License 从而免费使用。</p><ul><li><a href="https://search.censys.io/">https://search.censys.io/</a>     搜索：<code>services.http.response.headers.location: account.jetbrains.com/fls-auth</code></li><li><a href="https://www.shodan.io/">https://www.shodan.io</a>  搜索：<br><code>Location: https://account.jetbrains.com/fls-auth</code></li><li><a href="https://fofa.info/">https://fofa.info/</a>     搜索：<code>fls-auth</code></li></ul><p>随便点进去一个搜索结果，找到状态为302的网址和端口，复制到对应的JetBrains 软件的License Server里. 我下边使用的是<a href="https://search.censys.io/">https://search.censys.io/</a> 网站, 搜索 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">services<span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.location</span>: account<span class="hljs-selector-class">.jetbrains</span>.com/fls-auth<br></code></pre></td></tr></table></figure><p><img src="/../../imgs/Pasted%20image%2020231230231034.png"><br>例如上边就是 <a href="http://111.231.22.61:1024/">http://111.231.22.61:1024</a></p><p><img src="/../../imgs/Pasted%20image%2020231230231326.png"></p><h1 id="激活成功"><a href="#激活成功" class="headerlink" title="激活成功"></a>激活成功</h1><p>激活成功，请开始愉快的编码吧！<br><img src="/../../imgs/Pasted%20image%2020231230231349.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WPS设置打开文件自动同步云文档</title>
    <link href="/2023-12-30-3a73bdfdd568.html"/>
    <url>/2023-12-30-3a73bdfdd568.html</url>
    
    <content type="html"><![CDATA[<p>不知道我们会不会有远程办公的场景，有时候在公司写了一般文档，回到家后还想着继续写。<br>WPS 的自动同步功能能够很方便的满足这需求。接下来介绍一下具体操作：</p><h1 id="打开首页，设置中心"><a href="#打开首页，设置中心" class="headerlink" title="打开首页，设置中心"></a>打开首页，设置中心</h1><p><img src="/../../imgs/Pasted%20image%2020231230221037.png"></p><p><img src="/../../imgs/Pasted%20image%2020231230220856.png"></p><h1 id="打开新文件会自动上传更新"><a href="#打开新文件会自动上传更新" class="headerlink" title="打开新文件会自动上传更新"></a>打开新文件会自动上传更新</h1><p><img src="/../../imgs/Pasted%20image%2020231230221311.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git强制拉取远端</title>
    <link href="/2023-10-22-9bf76366f18c.html"/>
    <url>/2023-10-22-9bf76366f18c.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/&lt;branch_name&gt;<br></code></pre></td></tr></table></figure><p>这里的 <branch_name> 应该替换为你想要拉取的远程分支的名称。这两个命令的作用如下：</p><p>git fetch origin：这个命令会从远程仓库（通常是”origin”，可以根据你的实际情况替换）获取最新的分支信息，但不会合并或应用任何更改到你的本地分支。</p><p>git reset –hard origin&#x2F;<branch_name>：这个命令会将你的本地分支重置为与指定远程分支相同的状态，并且会放弃本地的任何更改。–hard 标志会强制应用这个重置，因此请小心使用，确保你不需要本地的更改。</p><p>这些命令将强制拉取远程分支的最新版本，并且会覆盖本地的任何更改。确保在执行这些命令之前，你没有重要的未提交更改，因为它们将永久丢失。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1726.同积元组</title>
    <link href="/2023-10-20-9599b5db4d91.html"/>
    <url>/2023-10-20-9599b5db4d91.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/tuple-with-same-product/description/">1726. 同积元组</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>使用排列组合的方法，开始使用三种语言同时写leetcode.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p><img src="/../../imgs/Pasted%20image%2020231020003943.png"></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    cnt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<span class="hljs-comment">// j +1 不要重复</span><br>            cnt[nums[i] * nums[j]]++ <span class="hljs-comment">// 使用map 遍历每次乘积对应次数</span><br>        &#125;<br>    &#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cnt &#123;<br>        ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span><br>    &#125;<br>   <br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                cnt[nums[i] * nums[j]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[k, v] : cnt) &#123;<br>            ans += v * (v - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python3">class Solution:<br>    def tupleSameProduct(self, nums: List[int]) -&gt; int:<br>        n = len(nums)<br>        maps = dict()<br>        <br>        for i in range(n):<br>            for j in range(i+1,n):<br>                if nums[i]*nums[j] in maps:<br>                    maps[nums[i] * nums[j]] += 1<br>                else:<br>                    maps[nums[i] * nums[j]] = 1<br><br>        ans = 0<br>        for _, v in maps.items():<br>            ans += v*(v-1) *4<br>        return ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本地运行LeetCode的Python代码 调试</title>
    <link href="/2023-10-19-6057db0e071e.html"/>
    <url>/2023-10-19-6057db0e071e.html</url>
    
    <content type="html"><![CDATA[<p>最近打算开始捡起来python, 同时使用多种语言进行leetcode 训练，需要本地的调试环境，恰巧之前记录过如何在本地运行leetcode python。 大家一起来看看吧！看完就可以愉快的在本地coding啦</p><p>要在本地运行LeetCode的Python代码，你可以按照以下步骤创建一个Solution类：</p><p>创建一个Python文件（例如，leetcode_solution.py）来存放你的解决方案。</p><p>导入必要的模块。通常，你需要导入typing中的List，以及可能的其他模块，具体取决于问题的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br></code></pre></td></tr></table></figure><p>创建Solution类并在其中定义问题的解决方案。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-comment"># 实现你的解决方案</span><br>        <span class="hljs-comment"># 例如，找到两个数的和等于目标，并返回它们的索引</span><br>        num_to_index = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> num_to_index:<br>                <span class="hljs-keyword">return</span> [num_to_index[complement], i]<br>            num_to_index[num] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>创建一个main函数来测试你的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    solution = Solution()<br>    <span class="hljs-comment"># 调用Solution类的方法进行测试</span><br>    result = solution.twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>执行你的Python脚本，可以使用命令行或你喜欢的Python集成开发环境（IDE）来运行。例如，使用命令行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python leetcode_solution.py<br></code></pre></td></tr></table></figure><p>这将运行你的解决方案并输出结果。你可以根据具体问题的要求来定义Solution类中的方法和逻辑，然后在main函数中进行测试。确保将问题的输入参数和返回值类型与LeetCode上的问题描述匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三种Python3 判断字典中是否存在对应key的方法</title>
    <link href="/2023-10-19-8f51ae9ef5a1.html"/>
    <url>/2023-10-19-8f51ae9ef5a1.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一种：使用get-方法"><a href="#第一种：使用get-方法" class="headerlink" title="第一种：使用get()方法"></a>第一种：使用get()方法</h1><p> <strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p> <strong>打印返回值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>))  # 结果返回对应val<br><span class="hljs-built_in">print</span>(dict.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;id&#x27;</span>))  # 结果返回None<br></code></pre></td></tr></table></figure><p>第二种：使用keys()方法</p><p> <strong>生成一个字典</strong><br>dict &#x3D; {‘name’: ‘’,’age’: ‘’,’sex’: ‘’}<br> <strong>判断是否存在，其中dict.keys()是列出字典所有的key</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>.keys())  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><p>除了使用in也可以使用not in，用于判定这个key不存在</p><p>第三种：使用 in 关键字</p><p><strong>生成一个字典</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong># 判断key是否存在于dict中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>)  <span class="hljs-comment"># 结果返回False</span><br></code></pre></td></tr></table></figure><h1 id="补充：生成默认字典（collections-defaultdict）"><a href="#补充：生成默认字典（collections-defaultdict）" class="headerlink" title="补充：生成默认字典（collections.defaultdict）"></a>补充：生成默认字典（<code>collections.defaultdict</code>）</h1><p>使用<code>defaultdict(int)</code>来创建<code>maps</code>，它会自动初始化未存在的键为0，这样你无需手动检查键是否存在。普通的dict() 要判断key 不存在要赋初值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tupleSameProduct</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        maps = defaultdict(<span class="hljs-built_in">int</span>)<br>        <br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>                product = nums[i] * nums[j]<br>                ans += maps[product] * <span class="hljs-number">4</span><br>                maps[product] += <span class="hljs-number">1</span><br>                <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和操作的对比：Python vs. Go vs. C++</title>
    <link href="/2023-10-19-86483682723b.html"/>
    <url>/2023-10-19-86483682723b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Python示例"><a href="#Python示例" class="headerlink" title="Python示例"></a>Python示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 切片</span><br>sub_list = my_list[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversed_list = my_list[::-1python]<br><br><span class="hljs-comment"># 字典</span><br>my_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;<br><br><span class="hljs-comment"># 双向链表（使用collections.deque）</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>my_linked_list = deque()<br>my_linked_list.append(<span class="hljs-number">1</span>)<br>my_linked_list.append(<span class="hljs-number">2</span>)<br>my_linked_list.append(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 最大堆和最小堆（需要使用第三方库heapq）</span><br><span class="hljs-keyword">import</span> heapq<br>max_heap = []<br>min_heap = []<br><br><span class="hljs-comment"># 二叉树（使用类或结构体）</span><br><br><span class="hljs-comment"># 字符串操作</span><br>my_string = <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring = my_string[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>my_int = <span class="hljs-number">42</span><br>my_str = <span class="hljs-built_in">str</span>(my_int)<br><br><span class="hljs-comment"># 深度拷贝和浅拷贝（使用copy模块）</span><br><span class="hljs-keyword">import</span> copy<br>original_list = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>]<br>shallow_copy = copy.copy(original_list)<br>deep_copy = copy.deepcopy(original_list)<br><br><span class="hljs-comment"># 删除元素</span><br>my_list.pop(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 删除第二个元素</span><br><br><span class="hljs-comment"># 查找小写字母</span><br><span class="hljs-keyword">if</span> my_string.islower():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;String contains only lowercase letters&quot;</span>)<br><br><span class="hljs-comment"># 遍历数组</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)<br><br><span class="hljs-comment"># 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br><br><span class="hljs-comment"># 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dictionary contains &#x27;name&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go示例</span><br><br><span class="hljs-comment">// 数组和切片</span><br>mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>subSlice := mySlice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>reversedSlice := reverseSlice(mySlice)<br><br><span class="hljs-comment">// 字典</span><br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>&#125;<br><br><span class="hljs-comment">// 双向链表（使用container/list）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br>myList := list.New()<br>myList.PushBack(<span class="hljs-number">1</span>)<br>myList.PushBack(<span class="hljs-number">2</span>)<br>myList.PushBack(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 最大堆和最小堆（需要使用heap包）</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/heap&quot;</span><br>maxHeap := &amp;MaxHeap&#123;&#125;<br>minHeap := &amp;MinHeap&#123;&#125;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>myString := <span class="hljs-string">&quot;Hello, World!&quot;</span><br>substring := myString[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>]<br>myInt := <span class="hljs-number">42</span><br>myStr := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, myInt)<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝（使用复制切片或递归）</span><br>originalSlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>shallowCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(originalSlice))<br><span class="hljs-built_in">copy</span>(shallowCopy, originalSlice)<br>deepCopy := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), originalSlice...)<br><br><span class="hljs-comment">// 删除元素</span><br>index := <span class="hljs-number">1</span><br>mySlice = <span class="hljs-built_in">append</span>(mySlice[:index], mySlice[index+<span class="hljs-number">1</span>:]...)<br><br><span class="hljs-comment">// 查找小写字母</span><br>containsLowercase := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-keyword">if</span> unicode.IsLower(char) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历切片</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> mySlice &#123;<br>    fmt.Println(item)<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    fmt.Println(key, value)<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> _, exists := myMap[<span class="hljs-string">&quot;name&quot;</span>]; exists &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++示例</span><br><br><span class="hljs-comment">// 数组和向量</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subVector</span><span class="hljs-params">(myVector.begin() + <span class="hljs-number">1</span>, myVector.begin() + <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversedVector</span><span class="hljs-params">(myVector.rbegin(), myVector.rend())</span></span>;<br><br><span class="hljs-comment">// 字典（使用std::map）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br>myMap[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;Alice&quot;</span>;<br>myMap[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 双向链表（使用std::list）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br>std::list&lt;<span class="hljs-type">int</span>&gt; myList;<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 最大堆和最小堆（使用std::priority_queue）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br><span class="hljs-comment">// 二叉树（使用结构体或指针）</span><br><br><span class="hljs-comment">// 字符串操作</span><br>std::string myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string substring = myString.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> myInt = <span class="hljs-number">42</span>;<br>std::string myStr = std::<span class="hljs-built_in">to_string</span>(myInt);<br><br><span class="hljs-comment">// 深度拷贝和浅拷贝</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; originalVector = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; shallowCopy = originalVector;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deepCopy</span><span class="hljs-params">(originalVector)</span></span>;<br><br><span class="hljs-comment">// 删除元素</span><br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + index);<br><br><span class="hljs-comment">// 查找小写字母</span><br><span class="hljs-type">bool</span> containsLowercase = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : myString) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">islower</span>(c)) &#123;<br>        containsLowercase = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历向量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : myVector) &#123;<br>    std::cout &lt;&lt; item &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 使用循环遍历字典</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 判断字典是否包含键</span><br><span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;name&quot;</span>) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Map contains &#x27;name&#x27;&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 136.只出现一次的数字</title>
    <link href="/2023-10-16-66afbe22520d.html"/>
    <url>/2023-10-16-66afbe22520d.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/single-number/description/">136. 只出现一次的数字</a><br><img src="/../../imgs/Pasted%20image%2020231016232403.png"><br>[TOC]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p></blockquote><p>答案是使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。</p><p>任何数和 0做异或运算，结果仍然是原来的数<br>任何数和其自身做异或运算，结果是 0<br><img src="https://pic.leetcode.cn/1697469725-QtsjoA-image.png" alt="image.png"></p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描述你的解题方法</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ol><li><p>hash</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>numsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> nums &#123;<br>numsMap[val] += <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> numsMap &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> key<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>位运算</p><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    single := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        single ^= num<br>    &#125;<br>    <span class="hljs-keyword">return</span> single<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 155.最小栈</title>
    <link href="/2023-10-12-cfa4d16bfad5.html"/>
    <url>/2023-10-12-cfa4d16bfad5.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈</a></p></blockquote><p><img src="/../../imgs/Pasted%20image%2020231013000854.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>栈</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>描使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-comment">// 使用额外栈辅助， a b c d 入栈，如果d 在那么abc 必然在，所以每次入栈比较一个最小值，放入另一个栈就好</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>stack    []<span class="hljs-type">int</span> <span class="hljs-comment">// 主栈</span><br>minStack []<span class="hljs-type">int</span> <span class="hljs-comment">// 辅助栈</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>minStacks := MinStack&#123;[]<span class="hljs-type">int</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;math.MaxInt&#125;&#125;<br><span class="hljs-keyword">return</span> minStacks<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 同时比较辅助站的的top元素，如果更小 则添加到辅助站</span><br>this.stack = <span class="hljs-built_in">append</span>(this.stack, x)<br>minTmp := min(x, this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>])<br>this.minStack = <span class="hljs-built_in">append</span>(this.minStack, minTmp)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop() &#123;<br>this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> (this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> (this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> x &lt; y &#123;<br><span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">return</span> y<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Go 的 container list 包：双向链表的便捷工具</title>
    <link href="/2023-10-09-5ecfb18fa495.html"/>
    <url>/2023-10-09-5ecfb18fa495.html</url>
    
    <content type="html"><![CDATA[<p>Go 语言中的 container&#x2F;list 包提供了一种便捷的方式来操作双向链表（doubly linked list）。这个包是标准库的一部分，旨在提供一种通用的方式来创建、操作和遍历链表。在这篇博客中，我们将介绍如何使用 container&#x2F;list 包，探讨一些可能容易混淆的地方，并提供主要函数的使用示例。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在开始之前，让我们先了解一下双向链表的基本概念。双向链表是一种数据结构，其中每个节点都有两个指针，一个指向前一个节点，另一个指向后一个节点。这种结构允许我们在链表中轻松插入、删除和遍历元素。</p><h2 id="导入-container-x2F-list-包"><a href="#导入-container-x2F-list-包" class="headerlink" title="导入 container&#x2F;list 包"></a>导入 container&#x2F;list 包</h2><p>要使用 container&#x2F;list 包，首先需要导入它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br></code></pre></td></tr></table></figure><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><p>创建一个新的链表非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myList := list.New()<br></code></pre></td></tr></table></figure><p>这将创建一个名为 myList 的新链表。</p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>你可以使用 PushBack 和 PushFront 方法将元素插入链表的末尾和开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">myList.PushBack(<span class="hljs-number">42</span>)<br>myList.PushFront(<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>要访问链表中的元素，你可以使用 Front 和 Back 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">firstElement := myList.Front().Value<br>lastElement := myList.Back().Value<br></code></pre></td></tr></table></figure><h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><p>遍历链表可以使用 for 循环来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> element := myList.Front(); element != <span class="hljs-literal">nil</span>; element = element.Next() &#123;<br>    <span class="hljs-comment">// 处理 element.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>要删除链表中的元素，可以使用 Remove 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">elementToRemove := myList.Front()<br>myList.Remove(elementToRemove)<br></code></pre></td></tr></table></figure><h1 id="容易混淆的地方"><a href="#容易混淆的地方" class="headerlink" title="容易混淆的地方"></a>容易混淆的地方</h1><h2 id="1-类型断言"><a href="#1-类型断言" class="headerlink" title="1. 类型断言"></a>1. 类型断言</h2><p>链表中的元素是空接口类型 interface{}，因此在访问元素的值之前，你需要进行类型断言。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value := element.Value.(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>如果断言失败，会导致运行时错误。</p><h2 id="2-InsertAfter-和-InsertBefore"><a href="#2-InsertAfter-和-InsertBefore" class="headerlink" title="2. InsertAfter 和 InsertBefore"></a>2. InsertAfter 和 InsertBefore</h2><p>这两个方法用于在某个元素之后或之前插入新元素，并返回新插入元素的引用。这些方法在实际应用中非常有用。</p><h1 id="示例：浏览器历史记录"><a href="#示例：浏览器历史记录" class="headerlink" title="示例：浏览器历史记录"></a>示例：浏览器历史记录</h1><p>下面是一个示例，展示了如何使用 container&#x2F;list 包来实现浏览器历史记录功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2023 Lei Qi. All rights reserved.</span><br><span class="hljs-comment"> * Author: Lei Qi</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * Date: 2023/10/10 上午12:33</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/list&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Browser <span class="hljs-keyword">struct</span> &#123;<br>history  *list.List<br>current  *list.Element<br>maxLen   <span class="hljs-type">int</span><br>homepage <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBrowser</span><span class="hljs-params">(maxLen <span class="hljs-type">int</span>, homepage <span class="hljs-type">string</span>)</span></span> *Browser &#123;<br>history := list.New()<br>current := history.PushBack(homepage)<br><span class="hljs-keyword">return</span> &amp;Browser&#123;<br>history:  history,<br>current:  current,<br>maxLen:   maxLen,<br>homepage: homepage,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GetCurrentPage() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> b.current.Value.(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoBack() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Prev() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Prev()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> GoForward() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> b.current.Next() != <span class="hljs-literal">nil</span> &#123;<br>b.current = b.current.Next()<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Browser)</span></span> NavigateToNewPage(newPageURL <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 清除当前页面之后的历史记录</span><br><span class="hljs-keyword">for</span> e := b.current.Next(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br>b.history.Remove(e)<br>&#125;<br><span class="hljs-comment">// 将新页面添加到历史记录中</span><br>b.current = b.history.InsertAfter(newPageURL, b.current)<br><span class="hljs-comment">// 限制浏览器历史记录的最大长度</span><br><span class="hljs-keyword">for</span> b.history.Len() &gt; b.maxLen &#123;<br>front := b.history.Front()<br><span class="hljs-keyword">if</span> front != <span class="hljs-literal">nil</span> &#123;<br>b.history.Remove(front)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> b.GetCurrentPage()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>browser := NewBrowser(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;初始页面&quot;</span>)<br><br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面1&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 浏览更多新页面</span><br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面2&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面3&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面4&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;浏览新页面:&quot;</span>, browser.NavigateToNewPage(<span class="hljs-string">&quot;新页面5&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;当前页面:&quot;</span>, browser.GetCurrentPage())<br><br><span class="hljs-comment">// 后退和前进</span><br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;后退:&quot;</span>, browser.GoBack())<br>fmt.Println(<span class="hljs-string">&quot;前进:&quot;</span>, browser.GoForward())<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这个示例创建了一个浏览器历史记录，并通过插入新页面来模拟浏览历史。使用 container&#x2F;list 包，我们可以轻松地插入、遍历和操作历史记录。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>container&#x2F;list 包提供了一个便捷的方式来操作双向链表，它在某些情况下非常有用，例如实现浏览器历史记录或其他需要动态插入和删除元素的场景。希望这篇博客能够帮助大家。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1845. 座位预约管理系统</title>
    <link href="/2023-10-06-c2afb6383992.html"/>
    <url>/2023-10-06-c2afb6383992.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统</a></p></blockquote><p>个人博客,记录学习: <a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a><br>  [TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>座位 使用n+2 长度的map或者slice. 最小值可以使用一个结构体变量来保存.</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>使用slice 的index来表示座位号,<br>1.在每次操作Unreserve的时候,记得更新seat 为可用(将对应值置为0),且要比较更新最小座位号,因为Unreserve会释放该seat.<br>2.在每次reserve的时候, 使用中间变量返回最小座位号,因为this.min 要用来更新下一次的最小座位号.更新下一次的最小座位号,这里需要注意 i&lt;length+1 ,slice make的时候长度要为n+2, 保证遍历到n;</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><strong>使用slice</strong><br>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br>  <br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats []<span class="hljs-type">int</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>set:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> SeatManager&#123;seats:set,min:<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>value := this.min<br>this.seats[value]=<span class="hljs-number">1</span><br>length := <span class="hljs-built_in">len</span> (this.seats)<br>fmt.Println(length)<br>i:=value<br><span class="hljs-keyword">for</span> ;i&lt;length+<span class="hljs-number">1</span>;i++&#123;<br><span class="hljs-keyword">if</span> this.seats[i]==<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>this.min=i <span class="hljs-comment">// 中间变量，更新下次的最小座位号</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> value <span class="hljs-comment">// 最小的座位号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>)  &#123;<br>this.seats[seatNumber] = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> seatNumber &lt; this.min&#123;<br>this.min=seatNumber<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong>使用map</strong><br>map 有个用例会超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seatMap   <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>minSeat   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>seatMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123; <span class="hljs-comment">// 注意从0 开始初始化</span><br>seatMap[i] = <span class="hljs-number">0</span><br>&#125;<br>seatMan := SeatManager&#123;<br>seatMap,<br><span class="hljs-number">1</span>,<br>&#125;<br><span class="hljs-keyword">return</span> seatMan<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>  value := this.minSeat<br>this.seatMap[value] = <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">for</span> i:= value; i &lt;= <span class="hljs-built_in">len</span>(this.seatMap);i++ &#123;<br>    <span class="hljs-keyword">if</span> this.seatMap[i] == <span class="hljs-number">1</span> &#123;<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br>    this.minSeat = i<br>    <span class="hljs-keyword">break</span><br>  &#125;<br><span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>) &#123;<br>  this.seatMap[seatNumber] = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">if</span> seatNumber &lt; this.minSeat &#123;<br>    this.minSeat = seatNumber<br>  &#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> a &lt; b &#123;<br>    <span class="hljs-keyword">return</span> a<br>  &#125;<br>  <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go 中是否使用make创建slice的区别</title>
    <link href="/2023-10-05-9d3185fd2258.html"/>
    <url>/2023-10-05-9d3185fd2258.html</url>
    
    <content type="html"><![CDATA[<p>go slice 的make 会创建默认长度 且值为0 的slice </p><p>在 Go 语言中，可以使用 <code>make</code> 函数来创建切片（slice）。切片是一种动态数组，它可以在运行时动态增长或缩小。以下是使用 <code>make</code> 和不使用 <code>make</code> 创建切片的主要区别：</p><p><strong>使用 <code>make</code> 创建切片：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用 make 创建切片，指定长度和容量 </span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ol><li><p><strong>指定长度和容量：</strong> 使用 <code>make</code> 创建切片时，您需要明确指定切片的长度和容量。长度是切片当前包含的元素数量，容量是底层数组的大小，通常大于或等于切片的长度。指定容量可以提高性能，因为它可以减少重新分配内存的次数。</p></li><li><p><strong>底层数组初始化：</strong> 使用 <code>make</code> 创建切片时，它会自动初始化底层数组，将切片的元素都设置为其类型的零值。在上面的示例中，<code>slice</code> 是一个包含5个零值整数的切片。</p></li></ol><p><strong>不使用 <code>make</code> 创建切片：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 不使用 make 创建切片，长度为 5 </span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>&#96;</p><ol><li><p><strong>自动确定长度：</strong> 不使用 <code>make</code> 创建切片时，切片的长度会根据提供的元素数量自动确定。在上面的示例中，<code>slice</code> 的长度是5，因为提供了5个整数。</p></li><li><p><strong>容量与长度相同：</strong> 如果不使用 <code>make</code> 创建切片，切片的容量将与长度相同，因为底层数组的大小会与切片的长度相匹配。</p></li></ol><p>总结：</p><ul><li>使用 <code>make</code> 创建切片时，您可以明确控制切片的容量，并<strong>按长度初始化为0值</strong>，适用于需要精确控制内存分配的情况，或者在预先知道切片的最大长度时。</li><li>不使用 <code>make</code> 创建切片时，适用于快速创建切片并根据提供的元素自动确定长度的情况。这种方式更简洁，适合大多数情况。</li></ul><p>无论使用哪种方式创建切片，都可以使用 <code>append</code> 函数来动态增长切片的长度。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JetBrians 全家桶设置文件header</title>
    <link href="/2023-10-05-7527c8e47a8b.html"/>
    <url>/2023-10-05-7527c8e47a8b.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在写代码的时候一般会在文件的头部添加header，包括copyright 时间，和作者和描述等信息。接下来我们就来看看怎么添加。</p><p>先看下效果图<br><img src="/../../imgs/Pasted%20image%2020231005164404.png"></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-file-settings"><a href="#1-file-settings" class="headerlink" title="1. file- settings"></a>1. file- settings</h2><p><img src="/../../imgs/Pasted%20image%2020231005164508.png"></p><h1 id="找到Copyright-CopyrightProfiles"><a href="#找到Copyright-CopyrightProfiles" class="headerlink" title="找到Copyright - CopyrightProfiles"></a>找到Copyright - CopyrightProfiles</h1><p>点击+ 号，新建一个name 为“copyRight” 的profile</p><p><img src="/../../imgs/Pasted%20image%2020231005164618.png"></p><p>profile 的内容粘贴下面的问文本, 替换自己的名字</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Copyright (c) <span class="hljs-symbol">$origi</span>nalComment.match(<span class="hljs-string">&quot;Copyright \(c\) (\d+)&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;$today.year&quot;</span>)<span class="hljs-symbol">$today</span>.<span class="hljs-built_in">year</span> YOUR NAME. <span class="hljs-built_in">All</span> rights reserved.  <br>Author: YOUR NAME  <br>Description:  <br><span class="hljs-built_in">Date</span>: <span class="hljs-symbol">$today</span><br></code></pre></td></tr></table></figure><h1 id="点击Copyright-添加刚才的profile"><a href="#点击Copyright-添加刚才的profile" class="headerlink" title="点击Copyright 添加刚才的profile"></a>点击Copyright 添加刚才的profile</h1><p><img src="/../../imgs/Pasted%20image%2020231005165129.png"></p><h2 id="点击应用即可-右键-generate-Copyright-插入"><a href="#点击应用即可-右键-generate-Copyright-插入" class="headerlink" title="点击应用即可 右键-generate-Copyright 插入"></a>点击应用即可 右键-generate-Copyright 插入</h2><p><img src="/../../imgs/Pasted%20image%2020231005164944.png"></p><p><img src="/../../imgs/Pasted%20image%2020231005165025.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode1603. 设计停车系统</title>
    <link href="/2023-09-26-aeddfdb3bdac.html"/>
    <url>/2023-09-26-aeddfdb3bdac.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/design-parking-system/description/">1603. 设计停车系统</a></p></blockquote><p>  [TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>首先，读清楚题目，需要分别记录3个车的剩余车位数量，并且要在addCar的时候进行判空，这就需要用到查找，在车类型中查找，这里我们可以使用map或数组。因为车的类型是连续的，不是稀疏的。我们更建议使用数组。</p></blockquote><p>虽然这是一道简单的设计题，但是我们需要以小见大，认真思考。设计题就是理解题目意思——&gt;建模-&gt;选择合适的数据结构-&gt; 优化算法。一定要认真读题，先规划和设计好，再动收，一定要多练习，保持手感。需要注意的是：在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver），保证可以修改new 出来的结构体。</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>lastCar [3]int 添加上边的数组</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>添加空间复杂度, 示例： $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1>  <figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Go">  <br>  <span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<br>    lastCar [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(big <span class="hljs-type">int</span>, medium <span class="hljs-type">int</span>, small <span class="hljs-type">int</span>)</span></span> ParkingSystem &#123;<br>    <span class="hljs-keyword">var</span> parkingSystem  ParkingSystem<br>    parkingSystem.lastCar[<span class="hljs-number">0</span>] = big<br>    parkingSystem.lastCar[<span class="hljs-number">1</span>] = medium<br>    parkingSystem.lastCar[<span class="hljs-number">2</span>] = small<br>    <span class="hljs-keyword">return</span> parkingSystem<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *ParkingSystem)</span></span> AddCar(carType <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    carIdx := carType - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> this.lastCar[carIdx] &gt; <span class="hljs-number">0</span> &#123;<br>        this.lastCar[carIdx]--<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your ParkingSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(big, medium, small); // 在 Go 语言 中，new 是一种创建变量的方式。通过 new(T) 可以创建类型为 T 的变量，初始值为 T 类型的零值，返回值为其地址（地址类型是 *T），这样在Constructor 只用返回值，而不是指针，但是在 AddCar 函数中，我们使用了指向 ParkingSystem 的指针接收器（receiver）</span><br><span class="hljs-comment"> * param_1 := obj.AddCar(carType);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux非root用户通过X11运行图形界面程序-以Rstudio为例</title>
    <link href="/2023-09-24-4fe5badbd053.html"/>
    <url>/2023-09-24-4fe5badbd053.html</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于使用单位或者学校的服务器，我们一般都没有root权限，导致一些Server版本的软件不能安装（例如数据分析领域的Rstudio-Server，需要root权限，新增端口给Rstudio-Server的web服务）。<br>但大家有没有发现，我们自己在本地的PC上安装桌面版本的Rstudio是并不要管理员权限的，是因为我们不需要开放端口，Rstudio直接在显示在图形界面上了。<br>那么理论上，我们可以在服务器上，通过模拟服务器的图形界面来直接运行桌面版的Rstudio。而这个模拟服务器的图形界面就可以使用X11！</p><blockquote><p><strong>X11</strong>是一个用于在Unix和类Unix系统上实现图形用户界面的标准协议和窗口系统。它通过分布式性质允许在远程服务器上运行图形应用程序，并将图形数据传输到本地计算机上显示，从而实现了图形界面的远程访问和显示。</p></blockquote><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><ol><li>使用mobaxTerm 登录对应服务器，需要显示X11 打开<img src="/../../imgs/Pasted%20image%2020230924203748.png"></li><li>创建虚拟环境<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建虚拟环境</span><br> conda create -n rstudio<br><span class="hljs-comment"># 安装Ｒ</span><br>conda activate rstudio <span class="hljs-comment"># 进入创建好的环境变量</span><br>conda install r-base<br><span class="hljs-comment"># 安装Rstudio</span><br>conda install rstudio-desktop<br></code></pre></td></tr></table></figure></li></ol><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p> 经过漫长的等待，直接运行rstudio 就会进入x11转发的图形界面<br> <img src="/../../imgs/Pasted%20image%2020230924205521.png"><br><strong>画个图试试，顺利出图！开始愉快的coding吧！</strong><br><img src="/../../imgs/Pasted%20image%2020230924205559.png"></p><p><strong>已知问题：</strong> 操作延迟较高，没有本地反应快，但是还可以接受，大家可以试试。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以通过<strong>X11</strong>来在服务器上运行图形化的程序，这个图形化的程序一般不需要很高的权限，不涉及外部端口新增。因此我们可以在服务器上运行很多图形化程序，例如Rstudio。甚至是我们的Pycharm、Goland、CLion 等Jetbrains的全家桶。大家快来试试吧！</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 将用户追加到对应用户组</title>
    <link href="/2023-09-17-5141f57450ab.html"/>
    <url>/2023-09-17-5141f57450ab.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文目的是为了将多个用户设置同组用户，并且同组内用户<strong>新建文件的默认权限</strong>是同组内用户可读写。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>将test 添加到GroupA</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">usermod -a -G GroupName UserName<br><span class="hljs-comment"># 例如将test 追加到GroupA</span><br>usermod -a -G GroupA <span class="hljs-built_in">test</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>修改新建文件的默认权限</li></ol><p>在.bashrc 里添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">umask</span> 003 // 文件夹具体权限 则为 777 - 003 = 774 （rwxrwxr--） 文件默认权限为 666 - 003 = 663(rw-rw-r--)<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 结构化设计</title>
    <link href="/2023-09-13-476441b87811.html"/>
    <url>/2023-09-13-476441b87811.html</url>
    
    <content type="html"><![CDATA[<h1 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h1><p><strong>自顶向下的设计 是自顶向下的分解</strong> -&gt; 找子问题 -&gt;公共的问题-&gt;抽出来子问题<br><img src="/../../imgs/Pasted%20image%2020230913232308.png"></p><h1 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h1><p>自顶向上的实现，实现一个一个子问题</p><p>程序由三种基本结构组成，<strong>顺序-分支-循环</strong><img src="/../../imgs/Pasted%20image%2020230913232249.png"></p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="/../../imgs/Pasted%20image%2020230913232729.png"><br><img src="/../../imgs/Pasted%20image%2020230913232746.png"></p><p><img src="/../../imgs/Pasted%20image%2020230913232825.png"><br><img src="/../../imgs/Pasted%20image%2020230913232951.png"><br><img src="/../../imgs/Pasted%20image%2020230913232936.png"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clash在终端设置代理</title>
    <link href="/2023-09-12-b926f621cf15.html"/>
    <url>/2023-09-12-b926f621cf15.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>github 提交代码总是失败，还是老老实实使用VPN吧。但是VPN打开了，git终端命令还是不行，原来是要进行终端代理设置。一起来看看吧！</p><h1 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h1><p>前置条件：手动开打 clash 等VPN软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:7890<br><span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p>对应的网址是在settings- static-Host; 对应port 为General-Prot<br><img src="/../../imgs/Pasted%20image%2020230913000142.png"><br><img src="/../../imgs/Pasted%20image%2020230913000136.png"></p><h1 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">unset</span> http_proxy<br><span class="hljs-built_in">unset</span> http_proxy<br></code></pre></td></tr></table></figure><h1 id="git-里设置开启代理-alias-命令别名"><a href="#git-里设置开启代理-alias-命令别名" class="headerlink" title="git 里设置开启代理 alias 命令别名"></a>git 里设置开启代理 alias 命令别名</h1><h2 id="新建-bashrc"><a href="#新建-bashrc" class="headerlink" title="新建 .bashrc"></a>新建 .bashrc</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br>vi .bashrc<br><br><span class="hljs-comment"># 将以下内容复制进去</span><br><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="hljs-keyword">then</span><br>        . /etc/bash.bashrc<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature:</span><br><span class="hljs-comment"># export SYSTEMD_PAGER=</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br>// 别名设置，其他别名设置也是类似<br><span class="hljs-built_in">alias</span> proxyon=<span class="hljs-string">&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;</span><br><span class="hljs-built_in">alias</span> proxyoff=<span class="hljs-string">&quot;unset http_proxy;unset https_proxy&quot;</span><br></code></pre></td></tr></table></figure><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p>可以在终端直接使用proxyon 打开代理，proxyoff关闭代理。<br><img src="/../../imgs/Pasted%20image%2020230912235632.png"><br><img src="/../../imgs/Pasted%20image%2020230912235612.png"><br>可以看到环境变量里边，有了我们设置的环境变量。通过代理设置，我们可以轻松解决github 代码推送的问题，方便生产开发。<br><img src="/../../imgs/Pasted%20image%2020230913000956.png" alt="图 push成功"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2594修车的最少时间</title>
    <link href="/2023-09-07-b8c038c07b41.html"/>
    <url>/2023-09-07-b8c038c07b41.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230908000057.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>能力值为 <code>r</code> 的机械工可以在 t&#x3D; <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。<br>可以看到 n &#x3D; 根号(t&#x2F;r), t 对于car 的数量是单调增的，所以可以适用二分法来不断逼近car 的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repairCars</span><span class="hljs-params">(ranks []<span class="hljs-type">int</span>, cars <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    l , r := <span class="hljs-number">1</span>, ranks[<span class="hljs-number">0</span>] * cars * cars<br>    <span class="hljs-keyword">var</span> check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(m <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        cnt := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ranks &#123;<br>            cnt += <span class="hljs-type">int</span>(math.Sqrt(<span class="hljs-type">float64</span>(m / x)))<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt;= cars<br>    &#125;<br>        <br>    <span class="hljs-keyword">for</span> l &lt; r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> check(m) &#123;<br>            r = m<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int64</span>(l)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li><p><code>l</code> 和 <code>r</code> 的初始化：</p><ul><li><code>l</code> 初始化为1，表示最小可能的修理时间。</li><li><code>r</code> 初始化为 <code>ranks[0] * cars * cars</code>，表示最大可能的修理时间。这里假设第一个机械工的能力值最高，所以最大时间是他修理所有汽车所需的时间。</li></ul></li><li><p><code>check</code> 函数定义：</p><ul><li>这个函数用于检查给定的修理时间是否足够，以修理所有汽车。它接受一个整数 <code>m</code> 作为参数，表示修理时间。然后，它遍历每个机械工的能力值，计算每个机械工在 <code>m</code> 时间内能修理多少辆车，然后累加到 <code>cnt</code> 变量中。</li><li>如果 <code>cnt</code> 大于或等于需要修理的汽车数量 <code>cars</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><p>二分查找循环：</p><ul><li>使用一个二分查找循环来查找最小的修理时间。循环条件是 <code>l &lt; r</code>，即当最小时间小于最大时间时，继续循环。</li><li>在每次循环中，计算中间值 <code>m</code>，并调用 <code>check(m)</code> 检查是否满足修理所有汽车的条件。</li><li>如果满足条件，则将 <code>r</code> 更新为 <code>m</code>，因为我们希望找到更小的修理时间。</li><li>如果不满足条件，则将 <code>l</code> 更新为 <code>m + 1</code>，因为我们需要增加修理时间。</li><li>这样，不断地缩小时间范围，直到找到最小的修理时间。</li></ul></li><li><p>最终返回结果：</p><ul><li>一旦 <code>l</code> 不再小于 <code>r</code>，循环结束，说明已经找到了最小的修理时间，将其转换为 <code>int64</code> 类型并返回。</li></ul></li></ol><p>我们总结一下二分查找适用的场景</p><h1 id="二分查找算法适用场景"><a href="#二分查找算法适用场景" class="headerlink" title="二分查找算法适用场景"></a>二分查找算法适用场景</h1><p><strong>递增或递减规律</strong>：数据集合必须遵循某种递增或递减的规律，以确保二分查找的有效性。二分查找前提就是单调的。</p><p><strong>有序数据集合</strong>：二分查找要求数据集合必须是有序的，无论是升序还是降序都可以。</p><p><strong>快速查找</strong>：对于大型数据集，二分查找是一种高效的查找算法，因为它每次都将数据集合减半。</p><p><strong>确定性问题</strong>：二分查找通常用于解决确定性问题，即要么找到目标，要么确定目标不存在。它不适用于涉及模糊匹配或多个匹配项的情况。</p><p><strong>时间复杂度要求较高</strong>：在需要快速找到目标的情况下，二分查找的时间复杂度为O(log n)，对于大规模数据集非常高效。</p><p><strong>可比较性数据</strong>：二分查找要求能够比较数据元素的大小，因此适用于数字、字符等可比较的数据类型。</p><p><strong>搜索范围可确定</strong>：二分查找适用于可以确定搜索范围的问题，通常通过定义一个左边界和右边界来实现。</p><p><strong>内存连续性</strong>：在一些需要高效的内存访问场景中，二分查找比线性搜索更有效，因为它充分利用了内存的连续性。</p><p>一些具体的应用场景包括在有序数组中查找元素、查找某个值的边界、查找某个值的插入位置、查找满足某个条件的最大或最小值等。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-抽象工厂</title>
    <link href="/2023-09-03-c6ab66461699.html"/>
    <url>/2023-09-03-c6ab66461699.html</url>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230903231353.png"></p><h1 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h1><p><img src="/../../imgs/Pasted%20image%2020230903231449.png"><br>多个工厂模式;</p><p>有抽象工厂(现代工厂,和古代工厂),具体工厂(现代工程和古代风格工厂实现),抽象产品(接口 ,椅子和桌子) 和具体产品(实现具体的桌子和椅子)</p><p><img src="/../../imgs/Pasted%20image%2020230903231857.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="/2023-09-03-c58ee0dac51b.html"/>
    <url>/2023-09-03-c58ee0dac51b.html</url>
    
    <content type="html"><![CDATA[<p>网站链接：<br><a href="https://refactoringguru.cn/design-patterns/factory-method">工厂方法设计模式 (refactoringguru.cn)</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>工厂方法模式 她是一种创建型设计模式，其在父类中提供一种船舰对象的方法，允许子类决定实例化对象的类型。</p><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>‘简单工厂模式’，也就是说，到底要实例化谁，将来会不会增加实例化的对象，比如增加开根运算，这是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂<br><img src="/../../imgs/Pasted%20image%2020230903131943.png"><br><img src="/../../imgs/Pasted%20image%2020230903134040.png"><br><img src="/../../imgs/Pasted%20image%2020230903133944.png"><br>简单工厂就是在需要的时候, 创建对应的类. 每个类都相互独立,互不影响, 如果增加代码,不会编译之前的类, 减少编译时间.</p><h1 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h1><p><strong>不同的类实现相同的动作,例如运输等</strong><br><img src="/../../imgs/Pasted%20image%2020230903140955.png"></p><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p> 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p><p> 注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会<strong>重写基础工厂</strong>方法， 使其<strong>返回不同类型的产品</strong>。</p><p> 注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的<strong>已有对象</strong>。</p></li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/../../imgs/Pasted%20image%2020230903142906.png"><br>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。</p><p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。</p><p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p><p>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离<a href="https://refactoringguru.cn/design-patterns/abstract-factory">抽象工厂</a>模式更近一步。</p><h1 id="简单工厂和工厂模式的区别"><a href="#简单工厂和工厂模式的区别" class="headerlink" title="简单工厂和工厂模式的区别"></a>简单工厂和工厂模式的区别</h1><p><strong>1. 简单工厂设计模式（Simple Factory Design Pattern）：</strong></p><p>定义： 简单工厂模式是一种创建型设计模式，它提供了一个工厂类，该工厂类根据传入的参数或条件来实例化并返回不同类型的对象。<br>结构： 简单工厂模式通常由三个主要部分组成：工厂类（Factory Class）、产品类（Product Class）和客户端（Client）。客户端通过工厂类来创建产品对象，而不直接实例化产品类。<br>示例： 一个简单工厂模式的示例是创建不同类型的汽车对象，工厂根据传入的参数（如汽车型号）来创建相应类型的汽车对象。<br><strong>2. 工厂方法设计模式（Factory Method Design Pattern）：</strong></p><p>定义： 工厂方法模式是一种创建型设计模式，它将对象的创建委托给具体的工厂类，每个具体工厂类负责创建特定类型的对象。<br>结构： 工厂方法模式包括<strong>抽象工厂接口（Abstract Factory Interface）、具体工厂类（Concrete Factory Class）、抽象产品接口（Abstract Product Interface）和具体产品类（Concrete Product Class）。</strong><br>示例： 一个工厂方法模式的示例是创建不同类型的文件读取器对象。抽象工厂接口定义了创建文件读取器的方法，具体工厂类实现了这个接口并负责创建特定类型的文件读取器。<br>主要区别：</p><p>复杂性： 简单工厂模式更简单，通常只有一个工厂类，而工厂方法模式更灵活，可以有多个具体工厂类。</p><p>责任分配： 在简单工厂模式中，工厂类负责创建对象的具体类型，而在工厂方法模式中，具体工厂类负责创建特定类型的对象。</p><p>扩展性： 工厂方法模式更容易扩展，因为可以轻松地添加新的具体工厂类来创建新类型的对象，而不需要修改现有的代码。在简单工厂模式中，要添加新类型的对象通常需要修改工厂类的代码，这违反了开放-封闭原则。</p><p>灵活性： 工厂方法模式提供了更大的灵活性，因为它允许每个具体工厂类自行决定如何创建对象，而简单工厂模式通常在一个工厂类中硬编码了创建对象的逻辑。</p><p>选择简单工厂模式还是工厂方法模式取决于项目的需求和设计目标。简单工厂模式通常用于创建一组相关对象，而工厂方法模式更适用于创建不同种类的对象，且需要更高的扩展性。</p><h2 id="UML类图如何看"><a href="#UML类图如何看" class="headerlink" title="UML类图如何看"></a>UML类图如何看</h2><h2 id="看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"><a href="#看懂UML类图和时序图-—-Graphic-Design-Patterns-design-patterns-readthedocs-io-车的类图结构为abstract，表示车是一个抽象类；-它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；-小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；-小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；-学生与班级之间是聚合关系，使用带空心箭头的实线表示；-学生与身份证之间为关联关系，使用一根实线表示；-学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；" class="headerlink" title="看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)- 车的类图结构为abstract，表示车是一个抽象类；- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；- 学生与身份证之间为关联关系，使用一根实线表示；- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；"></a><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图 — Graphic Design Patterns (design-patterns.readthedocs.io)</a><br><img src="/../../imgs/Pasted%20image%2020230903222357.png"><br>- 车的类图结构为abstract，表示车是一个抽象类；<br>- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；<br>- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；<br>- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；<br>- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；<br>- 学生与身份证之间为关联关系，使用一根实线表示；<br>- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</h2><p><img src="/../../imgs/Pasted%20image%2020230903132154.png"></p><p>首先你看那个‘动物’矩形框，它就代表一个类（Class）。类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”</p><p><img src="/../../imgs/Pasted%20image%2020230903134233.png"></p><p><strong>接口:</strong> </p><p><img src="https://res.weread.qq.com/wrepub/CB_85fDPzDPICld6ht6gW5IeD0Q_Image00017.jpg"></p><p>‘飞翔’，它表示一个接口图，与类图的区别主要是顶端有interface显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口.</p><p><strong>类和类之间的关系:</strong> 继承的关系，继承关系用空心三角形+实线来表示<br><img src="/../../imgs/Pasted%20image%2020230903134840.png"></p><p><strong>聚合:</strong> 我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分 [DPE]（DPE表示此句摘自《设计模式》（第2版），详细摘要说明见附录二）。聚合关系用空心的菱形+实线箭头来表示。</p><p><img src="/../../imgs/Pasted%20image%2020230903140037.png"><br><strong>合成</strong>（Composition，也有翻译成‘<strong>组合</strong>’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 [DPE]。在这里鸟和其翅膀就是合成（组合）关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线箭头来表示。另外，你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。<br><img src="/../../imgs/Pasted%20image%2020230903140113.png"></p><p><strong>依赖</strong><br><img src="/../../imgs/Pasted%20image%2020230903140305.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2511 最多可以摧毁的敌人城堡数目</title>
    <link href="/2023-09-02-72954cc13c19.html"/>
    <url>/2023-09-02-72954cc13c19.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/description/?envType=daily-question&envId=2023-09-02">2511. 最多可以摧毁的敌人城堡数目 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230902205220.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>抽象出来就是求1和-1间最大连续0 的数量。</p><p>有两种情况，开始是1 结尾是-1，中间都是0；第二种情况开始是-1结尾是1，中间都是0；上边怎么保证终点和起点不一样呢？</p><p>1.当然可以分类讨论，代码会很复杂，判断很多，容易出错</p><ol start="2"><li>使用 一个变量pre记录开始节点，变更当1或者-1 进来的时候，pre 更新为index，判断当前节点是否和pre 不相等,符合条件则更新res</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">captureForts</span><span class="hljs-params">(forts []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    ans, pre := <span class="hljs-number">0</span>, <span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">//pre 记录的是 1 或 -1 的位置 </span><br><br>    <span class="hljs-keyword">for</span> i, fort := <span class="hljs-keyword">range</span> forts &#123;<br><br>        <span class="hljs-keyword">if</span> fort == <span class="hljs-number">-1</span> || fort == <span class="hljs-number">1</span> &#123;<br><br>            <span class="hljs-keyword">if</span> pre &gt;= <span class="hljs-number">0</span> &amp;&amp; forts[pre] != fort &#123;<br><br>                ans = max(ans, i - pre - <span class="hljs-number">1</span>)<br><br>            &#125;<br><br>            pre = i<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br><br>&#125;<br><br>  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br><br>        <span class="hljs-keyword">return</span> a<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LRU</title>
    <link href="/2023-08-07-e74632bdccbf.html"/>
    <url>/2023-08-07-e74632bdccbf.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230807233035.png"></p><p>list Elemet 双向列表；<br><img src="/../../imgs/Pasted%20image%2020230807233013.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">cap</span>  <span class="hljs-type">int</span>                    <span class="hljs-comment">// 缓存容量</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<span class="hljs-comment">//!!! 双向链表 使用Element // 双向链表节点 指向的map</span><br>    list *list.List             <span class="hljs-comment">// 双向链表</span><br>&#125;<br><br><span class="hljs-keyword">type</span> keyVal <span class="hljs-keyword">struct</span> &#123;<br>    key, val <span class="hljs-type">int</span> <span class="hljs-comment">// 节点的Key和Value</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    <span class="hljs-keyword">return</span> LRUCache&#123;<br>        <span class="hljs-built_in">cap</span>:   capacity,                            <span class="hljs-comment">// 初始化缓存容量</span><br>        cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),          <span class="hljs-comment">// 初始化map映射</span><br>        list:  list.New(),                           <span class="hljs-comment">// 初始化双向链表</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="hljs-comment">// 如果map里有key对应的双向链表节点</span><br>        this.list.MoveToFront(elem)                  <span class="hljs-comment">// 把节点移动到链表头</span><br>        <span class="hljs-keyword">return</span> elem.Value.(*keyVal).val              <span class="hljs-comment">// 返回节点的value值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>                                        <span class="hljs-comment">// 没有找到的情况下，返回-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">if</span> elem, ok := this.cache[key]; ok &#123;             <span class="hljs-comment">// 如果map里有key对应的双向链表节点</span><br>        this.list.MoveToFront(elem)                  <span class="hljs-comment">// 把节点移动到链表头</span><br>        <span class="hljs-comment">//!!! elem.Value 是接口，需要将其转为对应结构体，然后再取值；</span><br>        elem.Value.(*keyVal).val = value             <span class="hljs-comment">// 更新节点的value值 </span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.list.Len() &gt;= this.<span class="hljs-built_in">cap</span> &#123;                 <span class="hljs-comment">// 如果超过了缓存容量</span><br>        tail := this.list.Back()                     <span class="hljs-comment">// 获取链表的尾节点</span><br>        k := tail.Value.(*keyVal).key                <span class="hljs-comment">// 获取节点的key</span><br>        this.list.Remove(tail)                       <span class="hljs-comment">// 从链表中删除尾节点</span><br>        <span class="hljs-built_in">delete</span>(this.cache, k)                        <span class="hljs-comment">// 从map中删除尾节点</span><br>    &#125;<br>    elem := this.list.PushFront(&amp;keyVal&#123;key, value&#125;) <span class="hljs-comment">// 将节点添加到链表头</span><br>    this.cache[key] = elem                           <span class="hljs-comment">// 将节点映射到map中</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 最大深度和最小深度</title>
    <link href="/2023-07-29-4df215f63090.html"/>
    <url>/2023-07-29-4df215f63090.html</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230729235323.png"><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a><br><img src="/../../imgs/Pasted%20image%2020230729235305.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>深度 是指从根节点到该节点的距离（节点数量）<br>高度 是指从该节点到叶子节点的角力（节点数量）</p><p><strong>最大深度</strong> 可以通过迭代法，计算总共有多少层。 可以使用递归分治的思想，1 + maxDepth(左子树) + maxDepth(右子树)<br><strong>最小子树</strong> 其实和最大深度类似，但是这里要注意的是，不能直接套用最大深度的代码。最小子树的要求是，到叶子节点的距离。而上边最大深度没有这个要求。所以要对一侧子树为空的情况需要单独讨论。以下是代码实现：</p><h1 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h1><h2 id="递归分治"><a href="#递归分治" class="headerlink" title="递归分治"></a>递归分治</h2><p>后序遍历 需要调用自生函数，需要严格按照定义调用递归。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rightMaxDepth := maxDepth(root.Right)<br>    leftMaxDepth := maxDepth(root.Left)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(rightMaxDepth,leftMaxDepth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>queue := []*TreeNode&#123;&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue,root)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// queue 不为空的时候</span><br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt;size ;i++ &#123;<span class="hljs-comment">// 遍历一层</span><br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 取最上层元素，并切掉该元素</span><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Left)<br>&#125;<br>&#125;<br>        depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>后序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义：输入根节点，返回这棵二叉树的最小深度</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rightMaxDepth := minDepth(root.Right)<br><br>    leftMaxDepth := minDepth(root.Left)<br><br>    <span class="hljs-comment">// 注意 最小深度是要到叶子节点的距离，对于一侧子树为空的情况需要单独讨论</span><br><br>    <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &amp;&amp; root.Left !=<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftMaxDepth <span class="hljs-comment">// 注意前面已经计算了rightMin 后边就直接调用这个函数， 不要再写个递归函数，否则会超时。</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right !=<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightMaxDepth<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + min(rightMaxDepth,leftMaxDepth)<br><br>&#125;<br><br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="迭代-层序遍历-1"><a href="#迭代-层序遍历-1" class="headerlink" title="迭代 层序遍历"></a>迭代 层序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>queue := []*TreeNode&#123;&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue,root)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// queue 不为空的时候</span><br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i &lt;size ;i++ &#123;<span class="hljs-comment">// 遍历一层</span><br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 取最上层元素，并切掉该元素</span><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue,top.Left)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right == <span class="hljs-literal">nil</span> &amp;&amp; top.Left == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span> <span class="hljs-comment">// 当前节点也算哦</span><br>&#125;<br>&#125;<br>        depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型与Unicode码点与整数的转换</title>
    <link href="/2023-07-09-dda1c4b9508f.html"/>
    <url>/2023-07-09-dda1c4b9508f.html</url>
    
    <content type="html"><![CDATA[<h1 id="byte类型与Unicode码点的转换"><a href="#byte类型与Unicode码点的转换" class="headerlink" title="byte类型与Unicode码点的转换"></a>byte类型与Unicode码点的转换</h1><p>在Go语言中，byte 类型是无符号的8位整数类型，而字符类型 rune 则用于表示Unicode码点。</p><p>当我们将一个 byte 类型的值转换为对应的 int 类型时，它实际上是将字节的数值直接转换为 int。这种转换通常用于将ASCII字符转换为对应的整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b := <span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br>i := <span class="hljs-type">int</span>(b)<br><br>fmt.Printf(<span class="hljs-string">&quot;Byte: %c, Unicode码点: %d, 转换后的整数: %d\n&quot;</span>, b, b, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们将字符 ‘A’ 转换为 byte 类型并赋值给变量 b，然后再将 b 转换为 int 类型并赋值给变量 i。输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Byte: A, Unicode码点: <span class="hljs-number">65</span>, 转换后的整数: <span class="hljs-number">65</span><br></code></pre></td></tr></table></figure><p>可以看到，转换后的整数值与字符 ‘A’ 的ASCII码值相同。</p><h1 id="byte类型与整数的转换"><a href="#byte类型与整数的转换" class="headerlink" title="byte类型与整数的转换"></a>byte类型与整数的转换</h1><p>之前一直容易搞混byte类型与整数的转换和之前unicode 码点转换。整数的转换意思是a &#x3D; byte(‘0’); var b int &#x3D;0; 将a 转换为b的整数0；<br>在Go语言中，我们可以将字符 ‘0’ 转换为对应的整数 0。这种转换可以通过 byte(‘0’) - ‘0’ 的方式实现，利用了字符的ASCII码值之间的差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br>   <span class="hljs-string">&quot;fmt&quot;</span>  <br>)  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   ch := <span class="hljs-string">&#x27;0&#x27;</span>  <br>   num := <span class="hljs-type">int</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)  <br>  <br>   fmt.Printf(<span class="hljs-string">&quot;字符: %c, unicode码点或者byte对应的数值: %d, 转换后的整数: %d\n&quot;</span>, ch, ch, num)  <br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例代码中，我们将字符 ‘0’ 赋值给变量 ch，然后通过 ch - ‘0’ 的操作将其转换为整数并赋值给变量 num。输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">字符: <span class="hljs-number">0</span>, unicode码点或者<span class="hljs-type">byte</span>对应的数值: <span class="hljs-number">48</span>, 转换后的整数: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到，字符 ‘0’ 成功转换为整数 0。<br>其中需要注意的是：在Go语言中，格式化输出时 <code>%c</code> 是一个占位符，用于表示要输出的值是一个Unicode字符。<br>具体来说，<code>%c</code> 会将相应参数作为一个Unicode码点（或称为rune类型）来解释，并将其格式化为相应的字符表示。这允许你将一个整数值或字符类型的变量作为参数，并将其打印为对应的字符。例如上边就是直接打印编码后的字符0,而不是byte&#x2F;rune 对应的值 48</p><p>这种转换方式可以用于将字符 ‘0’ 到 ‘9’ 范围内的数字字符转换为对应的整数值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>byte&#x2F;rune 转对应unicode 码点的话，直接使用int() 进行强转；<br>如果是要转成0-9 对应的整数，则需要使用 int(byte(‘XX’) - ‘0’ )进行转换 。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mesh组网：家庭路由和无线连接新方式</title>
    <link href="/2023-06-25-a45e5f4edabc.html"/>
    <url>/2023-06-25-a45e5f4edabc.html</url>
    
    <content type="html"><![CDATA[<p>在当今互联的世界中，传统的网络常常面临覆盖范围、可靠性和可扩展性方面的限制。Mesh组网作为一种解决方案应运而生，通过创建一个动态网络，使设备能够直接相互通信，形成一个弹性和高效的网络基础设施。本文将从what、how和why的角度探讨Mesh组网。</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><ol><li>Mesh组网是什么？ Mesh组网是一种分散式无线通信系统，允许设备直接相互连接，形成交织在一起的节点网状结构。与传统的网络不同，依赖于中心接入点，Mesh网络使得设备能够同时充当客户端和路由器的角色。Mesh中的每个设备可以将数据中继到其他节点，扩大网络的覆盖范围并增强其鲁棒性。</li></ol><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><ol start="2"><li><p>Mesh组网如何实现？ Mesh组网采用对等网络（P2P）模型运行，其中每个参与的设备都作为网络中的一个节点。以下是Mesh组网工作原理的简化解释：</p><ul><li>设备连接性：Mesh中的每个设备通过无线电频率（如Wi-Fi或蓝牙）进行无线通信。在范围内的设备可以直接相互建立连接。</li><li>路由：当设备想要向其他设备发送数据时，它会根据信号强度、接近度或其他路由算法选择最优路径通过Mesh网络传输数据。</li><li>中继：如果目标设备超出范围，中间的节点可以充当中继，将数据包转发到达预定的接收方。这种动态中继过程确保数据在整个网络中的传递。</li><li>自我修复：如果一个节点失败或新设备加入网络，Mesh网络会自动适应并通过备用路径重新路由数据，使其具有高度的鲁棒性。</li></ul><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1></li><li><p>为什么使用Mesh组网？ Mesh组网提供了一些关键的优势，使其成为各种应用领域的理想选择：</p><ul><li>扩展覆盖范围：Mesh网络超越传统网络的限制，设备可以直接相互通信，而不仅仅依赖于集中式接入点，从而扩大了覆盖范围。</li><li>提高可靠性：Mesh网络的自我修复能力确保即使一个节点故障或被移除，网络也能迅速通过备用路径重新路由数据，保持连接的可靠性和连续性。</li><li>可扩展性：Mesh网络具有高度的可扩展性，新节点可以轻松加入网络，而无需进行重大的配置更改。这种灵活性允许根据需要扩展网络覆盖范围。</li><li>鲁棒性：通过在多个节点之间分配工作负载和数据流量，Mesh网络对单点故障具有鲁棒性。即使某些设备故障，网络仍然可用。</li><li>应用广泛：Mesh组网在智居、物联网（IoT）、智慧城市、灾害响应和农村互联等众多领域都有着重要的应用，其中可靠而广阔的网络覆盖非常关键。</li></ul></li></ol><h1 id="与桥接路由对比"><a href="#与桥接路由对比" class="headerlink" title="与桥接路由对比"></a>与桥接路由对比</h1><ol><li><p>Mesh组网：</p><ul><li>概念：Mesh组网是一种分散式无线通信系统，其中设备通过直接连接形成一个交织的节点网状结构。</li><li>特点：每个设备在Mesh组网中充当节点，可以接收、转发或发送数据。当设备之间的直接连接不可行时，数据通过其他节点进行多级中继。</li><li>优点：<ul><li>扩展性：新增节点可以无缝地加入Mesh组网中，扩大覆盖范围并提高网络容量。</li><li>鲁棒性：Mesh组网具有自修复能力，即使节点出现故障或被移除，数据可以通过备用路径传输，保持网络的连通性。</li><li>简单安装：Mesh组网中的节点相对独立，不需要复杂的配置过程，而且可以灵活地移动和重新布置。</li></ul></li><li>缺点：<ul><li>延迟增加：数据包经过多级中继可能会增加传输延迟，尤其是在网络负载较重或节点密度较大时。</li><li>多跳损耗：每次数据包中继都会引入一定的信号衰减和功耗，可能会降低数据传输速度和能效。</li><li>网络复杂性：Mesh组网中的节点互相通信，网络拓扑动态变化，管理和排除故障可能需要更多的复杂措施。</li></ul></li></ul></li><li><p>桥接路由：</p><ul><li>概念：桥接路由是一种集中式网络架构，其中设备通过连接到一个中央路由器或交换机来实现互联。</li><li>特点：所有数据流量经过中央路由器，该路由器负责处理路由和数据包转发。</li><li>优点：<ul><li>低延迟：由于数据流量直接通过中央路由器处理，传输延迟较低且稳定。</li><li>单跳连接：所有设备与中央路由器之间的连接通常是单跳连接，减少了信号衰减和能源消耗。</li><li>集中管理：由于所有设备都连接到中央路由器，网络管理和故障排除相对简单。</li></ul></li><li>缺点：<ul><li>单点故障：中央路由器的故障可能导致整个网络失去连接。</li><li>限制范围：由于基于单个中央设备，覆盖范围受到物理位置和信号强度的限制。</li><li>扩展性：增加节点时，可能需要重新配置和调整网络结构。</li></ul></li></ul></li></ol><p>结论： Mesh组网通过提供去中心化、自动配置和高度鲁棒的通信基础设施，彻底改变了设备相互连接的方式。Mesh网络能够扩大覆盖范围、提高可靠性并轻松扩展，为各种应用提供了有前途的解决方案。随着技术的不断发，利用Mesh组网的潜力将在塑造无线通信未来方面发挥重要作用。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表总结</title>
    <link href="/2023-06-24-42b41b131ba0.html"/>
    <url>/2023-06-24-42b41b131ba0.html</url>
    
    <content type="html"><![CDATA[<h1 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h1><ul><li>虚拟头节点</li><li>拉拉链 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    p := dummy<br>    p1 := l1<br>    p2 := l2<br>    <br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 比较 p1 和 p2 两个指针</span><br>        <span class="hljs-comment">// 将值较小的的节点接到 p 指针</span><br>        <span class="hljs-keyword">if</span> p1.Val &gt; p2.Val &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.Next<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="链表的拆分"><a href="#链表的拆分" class="headerlink" title="链表的拆分"></a>链表的拆分</h1><ul><li>初始化两个链表，分别添加</li><li>合并前 记得 将p.next 置为空，防止后边p1.next 还挂着p.next</li><li>合并</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(head *ListNode, x <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 存放小于 x 的链表的虚拟头结点</span><br>    dummy1 := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-comment">// 存放大于等于 x 的链表的虚拟头结点</span><br>    dummy2 := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-comment">// p1, p2 指针负责生成结果链表</span><br>    p1, p2 := dummy1, dummy2<br>    <span class="hljs-comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span><br>    <span class="hljs-comment">// 这里是将一个链表分解成两个链表</span><br>    p := head<br>    <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p.Val &gt;= x &#123;<br>            p2.Next = p<br>            p2 = p2.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p1.Next = p<br>            p1 = p1.Next<br>        &#125;<br>        <span class="hljs-comment">// 断开原链表中的每个节点的 next 指针</span><br>        temp := p.Next<br>        p.Next = <span class="hljs-literal">nil</span><br>        p = temp<br>    &#125;<br>    <span class="hljs-comment">// 连接两个链表</span><br>    p1.Next = dummy2.Next<br><br>    <span class="hljs-keyword">return</span> dummy1.Next<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="k-链表合并"><a href="#k-链表合并" class="headerlink" title="k 链表合并"></a>k 链表合并</h1><ul><li>最小堆 go语言的实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;<br>    Val <span class="hljs-type">int</span><br>    Next *ListNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nil</span>&#125;<br>    p := dummy<br>    <span class="hljs-comment">// 优先级队列，最小堆</span><br>    pq := <span class="hljs-built_in">make</span>(PriorityQueue, <span class="hljs-number">0</span>)<br>    heap.Init(&amp;pq)<br>    <span class="hljs-comment">// 将 k 个链表的头结点加入最小堆</span><br>    <span class="hljs-keyword">for</span> _, head := <span class="hljs-keyword">range</span> lists &#123;<br>        <span class="hljs-keyword">if</span> head != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(&amp;pq, head)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> pq.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 获取最小节点，接到结果链表中</span><br>        node := heap.Pop(&amp;pq).(*ListNode)<br>        p.Next = node<br>        <span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(&amp;pq, node.Next)<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-keyword">type</span> PriorityQueue []*ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> pq[i].Val &lt; pq[j].Val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    node := x.(*ListNode)<br>    *pq = <span class="hljs-built_in">append</span>(*pq, node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *pq<br>    n := <span class="hljs-built_in">len</span>(old)<br>    node := old[n<span class="hljs-number">-1</span>]<br>    *pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="倒数K链表"><a href="#倒数K链表" class="headerlink" title="倒数K链表"></a>倒数K链表</h1><ul><li>n 是包含nil 的</li><li>一个fast 去探路，先走k步</li><li>slow 和fast 一起走</li><li>当fast为nil 时，到达k ,赋值为next.next 即可<br><img src="/../../imgs/Pasted%20image%2020230625002218.png"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, head&#125;<br>    <span class="hljs-comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span><br>    x := findFromEnd(dummy, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 删掉倒数第 n 个节点</span><br>    x.Next = x.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br>    <br><span class="hljs-comment">// 返回链表的倒数第 k 个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    p1 := head<br>    <span class="hljs-comment">// p1 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        p1 = p1.Next<br>    &#125;<br>    p2 := head<br>    <span class="hljs-comment">// p1 和 p2 同时走 n - k 步</span><br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br>    <span class="hljs-keyword">return</span> p2<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="倒数K链表移除"><a href="#倒数K链表移除" class="headerlink" title="倒数K链表移除"></a>倒数K链表移除</h1><p>复用上边的代码，找到倒数x&#x3D;k+1, 然后赋值x.next &#x3D; x.next.next 即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">-1</span>, head&#125;<br>    <span class="hljs-comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span><br>    x := findFromEnd(dummy, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 删掉倒数第 n 个节点</span><br>    x.next = x.next.next<br>    <span class="hljs-keyword">return</span> dummy.next<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 代码见上文</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移除中间链表"><a href="#移除中间链表" class="headerlink" title="移除中间链表"></a>移除中间链表</h1><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode）</a></p><ul><li>slow 走一步，fast走两步</li><li>fast nil，slow 为中间<br><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    slow, fast := head, head<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-comment">// for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;// 这样奇数的时候会在中点的前一步</span><br>    <span class="hljs-keyword">for</span> fast!= <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span>&#123; <span class="hljs-comment">// 应该修改为这个，slow 会停在中点右边第二个部分</span><br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="判断链表是否成环"><a href="#判断链表是否成环" class="headerlink" title="判断链表是否成环"></a>判断链表是否成环</h1><ul><li>slow 走一步，fast走两步</li><li>fast 和slow 相遇则成环，fast 遇到nil 则不成环。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    slow, fast := head, head<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>        <span class="hljs-comment">// 快慢指针相遇，说明含有环</span><br>        <span class="hljs-keyword">if</span> slow == fast &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不包含环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>labuladong</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组双指针刷题总结</title>
    <link href="/2023-06-22-079d0af75447.html"/>
    <url>/2023-06-22-079d0af75447.html</url>
    
    <content type="html"><![CDATA[<p>双指针技巧分为<strong>快慢指针</strong>和<strong>左右指针</strong></p><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><ul><li>原地修改数组<ul><li>遍历fast 去探路，探到符合条件的将其赋值给slow,并slow++</li></ul></li><li>去除有序数组&#x2F;链表中去重<ul><li>和上边类似，例如删除指定元素v: 遍历fast ,判断不符合该条件的(!&#x3D;v),slow++; num[slow] &#x3D;&#x3D; num[fast]</li></ul></li></ul><h1 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h1><p>1.二分查找<br>    * 有序，直接找中间的点，判断中间是否符合对应的题目逻辑，将中间点赋值为左边界或者右边界<br>2.<strong>N sum 之和</strong><br>    * 一般是有序数组，然后左右相加，利用右边向内部移动数值减小和左边向内部移动数组变大<br>3.反转字符串<br>    * 终止条件是i&gt;j<br>4.回文串判断<br>     * 判断条件s[i] &#x3D;&#x3D; s[j]</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1170. 比较字符串最小字母出现频次</title>
    <link href="/2023-06-14-88f65f0a1bb7.html"/>
    <url>/2023-06-14-88f65f0a1bb7.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/">1170. 比较字符串最小字母出现频次 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230614235423.png"></p><p><strong>后缀和（</strong>Prefix Sum）是一种常用于区间和计算的技巧。它通过预处理把一个数组的前缀和先计算出来，然后在查询某个区间的和时，只需要构造两个前缀和相减即可得到所求的区间和。</p><p>具体而言，假设有一个长度为 n 的整数数组 A，记 S[i] 为 A[0]+A[1]+…+A[i-1] 的前缀和，其中 0≤i&lt;n。那么对于任何 0≤l≤r&lt;n，A[l]+A[l+1]+…+A[r] &#x3D; S[r+1]-S[l]。</p><p>在实际的应用中，如果需要进行多次区间和查询，可以利用后缀和技巧预处理出 A 数组的前缀和，并存储在一个新的数组 S 中。这样，对于任意区间 [l,] 查询，只需要计算 S[r+1]-S[l] 即可，时间复杂度为 O(1)。</p><h2 id="不使用后缀和"><a href="#不使用后缀和" class="headerlink" title="不使用后缀和"></a>不使用后缀和</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-number">0</span><br>    ch := <span class="hljs-string">&#x27;z&#x27;</span><br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> c &lt; ch &#123;<br>        ch = c<br>        cnt = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == ch &#123;<br>        cnt++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSmallerByFrequency</span><span class="hljs-params">(queries []<span class="hljs-type">string</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">12</span>)<br>    <span class="hljs-comment">// 先计算word 里的每个数 f(s)是s字符串中最小字符串的数量</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> words &#123;<br>        count[f(s)] += <span class="hljs-number">1</span><br>    &#125;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br>    <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> queries &#123;<br>        <span class="hljs-keyword">for</span> idx, c := <span class="hljs-keyword">range</span> count &#123; <span class="hljs-comment">// 遍历count</span><br>            <span class="hljs-keyword">if</span> c&gt;<span class="hljs-number">0</span> &amp;&amp; f(s) &lt; idx &#123;<span class="hljs-comment">// 如果count&gt;0,则说明该最小字符串数量(idx) 的个数为c。需要将res 加上这个数量c</span><br>                res[i]+=c<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="使用后缀和"><a href="#使用后缀和" class="headerlink" title="使用后缀和"></a>使用后缀和</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-number">0</span><br>    ch := <span class="hljs-string">&#x27;z&#x27;</span><br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> c &lt; ch &#123;<br>        ch = c<br>        cnt = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == ch &#123;<br>        cnt++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSmallerByFrequency</span><span class="hljs-params">(queries []<span class="hljs-type">string</span>, words []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">12</span>)<br>    <span class="hljs-comment">// 先计算word 里的每个数</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> words &#123;<br>        count[f(s)] += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// 计算后缀和,i+1 就是大于i位置的所有个数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">1</span>; i-- &#123;<br>        count[i] += count[i + <span class="hljs-number">1</span>]<br>    &#125;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br>    <span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> queries &#123;<br>        res[i] = count[f(s) + <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>为什么是res[i] &#x3D; count[f(s) + 1] ，而不是res[i] &#x3D; count[f(s)]？</strong></p><p>在<code>numSmallerByFrequency</code>函数中， <code>count</code>数组记录的是各个不同频次出现的次数，因此 <code>count[i]</code>代表所有最小字母出现频次不于 i 的字符串的数量。</p><p>如果对于 <code>queries</code> 中的某个字符串 <code>s</code> ，它的最小字母出现频次为 <code>f(s)</code>，那么可以依据 <code>count</code> 数组计算比该字符串要小的字符串的数量。由于 count数组是累加的，所以要计算比这个字符串严格小的字符串数量，只需要累加从 <code>f(s)+1</code> 开始的所有频次出现次数即可：</p><p><code>res[i] = count[f(s) + 1]</code></p><p>这里使用的是 <code>f(s)+1</code> 而不是 <code>f(s)</code> 是因为对于频次相同时应该被视为相同大小，否则我们会算入一些等于当前获得的最小频率的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是二进制的按位或和按位异或</title>
    <link href="/2023-06-08-3d1c210a715f.html"/>
    <url>/2023-06-08-3d1c210a715f.html</url>
    
    <content type="html"><![CDATA[<p>按位或（bitwise OR）和按位异或（bitwise XOR）是两种二进制位运算。但是这两个概念很容易忘记或者混淆，今天我们就来加深一下印象吧！</p><p>按位或运算符（|）对两个二进制数的每一位都执行逻辑或操作，返回一个新的二进制数。其真值表如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">input bit a | <span class="hljs-type">input</span> bit b | <span class="hljs-type">output</span> <br>------------------------------- <br><span class="hljs-number">0</span>        |     <span class="hljs-type">0</span>      | <span class="hljs-type">0</span> <br><span class="hljs-number">0</span>        |     <span class="hljs-type">1</span>      | <span class="hljs-type">1</span> <br><span class="hljs-number">1</span>        |     <span class="hljs-type">0</span>      | <span class="hljs-type">1</span> <br><span class="hljs-number">1</span>        |     <span class="hljs-type">1</span>      | <span class="hljs-type">1</span><br></code></pre></td></tr></table></figure><p>例如，执行 6 (二进制位 110) 和 3 (二进制位 011) 的按位或运算 会得到 7 (二进制位 111):</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  110</span><br><span class="hljs-section">| 011</span><br><span class="hljs-section">-----</span><br><span class="hljs-code">  111</span><br><br></code></pre></td></tr></table></figure><p>按位异或运算符（^）对两个二进制数的每一位都执行逻辑异或操作，返回一个新的二进制数。其真值表如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">input bit a | input bit b | output</span><br><span class="hljs-section">-------------------------------</span><br><span class="hljs-code">        0    |    0      |   0</span><br><span class="hljs-code">        0    |    1      |   1</span><br><span class="hljs-code">        1    |    0      |   1</span><br><span class="hljs-code">        1    |    1      |   0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  110</span><br><span class="hljs-section">^ 011</span><br><span class="hljs-section">-----</span><br><span class="hljs-code">  101</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按位或，就是只要有1 就为1 (包含了1  1 ；0 1；1  0；三种)<br>按位异或，必须一个0一个1，才为1 （包含0 1；1  0；两种）<br>大家记住了吗？</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2460.对数组执行操作 2023.05.06每日一题</title>
    <link href="/2023-06-05-869070f8049d.html"/>
    <url>/2023-06-05-869070f8049d.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/apply-operations-to-an-array/description/">2460. 对数组执行操作 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230605224628.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接模拟</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>第一版<br>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyOperations</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br>res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>index := <span class="hljs-number">0</span><br><span class="hljs-comment">// 第一次遍历 进行赋值操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>nums[i] *= <span class="hljs-number">2</span><br>nums[i+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 第二次遍历 将非0移动到前边</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>res[index] = nums[i]<br>index++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二版<br>时间复杂度：O(n)<br>空间复杂度：O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyOperations</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    j := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>            nums[i] *= <span class="hljs-number">2</span><br>            nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">0</span> &#123;<br>            nums[i], nums[j] = nums[j], nums[i]<br>            j++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 28.找出字符串中第一个匹配项的下标</title>
    <link href="/2023-05-31-396a1cd3c61e.html"/>
    <url>/2023-05-31-396a1cd3c61e.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531222721.png"></p><p>简单解法<br>利用split 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 使用split 函数，如果存在needle,则会把其切分为至少两个元素的切片</span><br>splitList := strings.Split(haystack, needle)<br><span class="hljs-comment">// 如果长度为1，且needle!=haystack 说明没找到匹配项，返回-1</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(splitList)== <span class="hljs-number">1</span> &amp;&amp; needle!=haystack &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(splitList) &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(splitList[<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-comment">// needle 在haystack的最开头，返回0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 104.二叉树的深度</title>
    <link href="/2023-05-30-b1879d2b65d1.html"/>
    <url>/2023-05-30-b1879d2b65d1.html</url>
    
    <content type="html"><![CDATA[<p>个人网站：<a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230531000419.png"></p><p>二叉树节点的深度指的是该节点到根节点的距离，也就是从根节点到该节点的路径长度。而二叉树节点的高度指的是该节点到其子树中最远叶子节点的距离，也就是该节点为根的子树的高度。</p><p>所以，可以将整个二叉树的高度定义为根节点的高度，也就是从根节点到最远叶子节点的距离。而整个二叉树的深度则没有固定的定义，通常是指二叉树中节点深度的最大值。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(root *treenode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxdepth(root.left), maxdepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>可以使用模板层序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>depth := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>queue := list.New()<br>queue.PushBack(root)<br><br><span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>size := queue.Len()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br><span class="hljs-comment">// 切掉第一个元素</span><br>first := queue.Remove(queue.Front()).(*TreeNode) <span class="hljs-comment">//注意层序遍历是切掉前边一个</span><br><span class="hljs-keyword">if</span> first.Left != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Left)<br>&#125;<br><span class="hljs-keyword">if</span> first.Right != <span class="hljs-literal">nil</span> &#123;<br>queue.PushBack(first.Right)<br>&#125;<br>&#125;<br>depth++<br>&#125;<br><span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>层序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 122买动态股票的最佳时机II</title>
    <link href="/2023-05-27-5cebfed1675b.html"/>
    <url>/2023-05-27-5cebfed1675b.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230527235217.png"></p><p>每次只允许在一天买入一支股票，在之后某个时间卖出它。同时，你也可以选择不进行任何交易。</p><p>相比于第一题买卖股票的最佳时机（只能进行一次交易），这道题没有限制交易次数，因此我们应该从一个更灵活的角度去考虑如何进行交易。</p><p>下面是代码解释：</p><p>首先定义变量 sum 记录当前总利润。<br>然后从第二个价格开始遍历，计算当日价格与前一天价格之差。<br>如果价格上涨了，则将当前利润加上买卖差价，否则不进行操作。<br>最后返回累计的总利润。<br>这样做的原理在于，如果在 i 天买入，在 j 天卖出（j &gt; i），我们可以等价于在 i+1、i+2……j-1、j 这些连续的日子里都进行了购入和卖出，而我们所需获得的利润即为这些差价的总和。因此，代码中只统计了所有价格差大于 0 的部分，而将其他价格差为负值的日子抛弃掉了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        <span class="hljs-comment">// 累加每次大于0的交易</span><br>        <span class="hljs-keyword">if</span> prices[i] - prices[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            sum += prices[i] - prices[i<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1091.二进制矩阵中的最短路径</title>
    <link href="/2023-05-26-5abcbf266873.html"/>
    <url>/2023-05-26-5abcbf266873.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230526235236.png"><br>DFS 超时版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">int</span><br>y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(grid)<br><span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>res := <span class="hljs-number">0</span><br>dirs := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-keyword">var</span> help <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span><br><br>help = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, tmp <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 判断是否越界或已经访问过当前节点</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= n || grid[i][j] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> i == n<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span> &#123;<br><span class="hljs-comment">// 当到达终点时，更新res</span><br><span class="hljs-keyword">if</span> tmp+<span class="hljs-number">1</span> &lt; res || res == <span class="hljs-number">0</span> &#123;<br>res = tmp + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 将当前点标记为已访问</span><br>grid[i][j] = <span class="hljs-number">1</span><br>tmp++<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dirs &#123;<br>x := i + item[<span class="hljs-number">0</span>]<br>y := j + item[<span class="hljs-number">1</span>]<br>help(x, y, tmp)<br>&#125;<br><span class="hljs-comment">// 回溯操作，将当前点复原为未访问状态</span><br>grid[i][j] = <span class="hljs-number">0</span><br>&#125;<br><br>help(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BFS，最短路径使用BFS </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x,y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// queue 维护</span><br>m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[point]<span class="hljs-type">int</span>)<br>queue := <span class="hljs-built_in">make</span>([]point,<span class="hljs-number">0</span>)<br>step := <span class="hljs-number">1</span><br>start := point&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;<br>end := point&#123;m<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>&#125;<br>dirs := []point&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;&#125;<br><span class="hljs-comment">// 起点为1 则直接返回</span><br>    <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>queue = <span class="hljs-built_in">append</span>(queue,start)<br>visited[start] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 将当前队列中的所有节点向四周扩散</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; size; i++&#123;<br>cur := queue[<span class="hljs-number">0</span>] <span class="hljs-comment">// 当前cur</span><br>queue = queue[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 切掉当前点</span><br><span class="hljs-comment">// 判断是否是终点</span><br><span class="hljs-keyword">if</span> cur == end &#123;<br><span class="hljs-keyword">return</span> step<br>&#125;<br><span class="hljs-comment">// 遍历八个方向 判断是否符合边界条件</span><br><span class="hljs-keyword">for</span> _, dir :=<span class="hljs-keyword">range</span> dirs&#123;<br>newX := cur.x + dir.x<br>newY := cur.y + dir.y<br>newPoint := point&#123;newX,newY&#125;<br><span class="hljs-keyword">if</span> newX &gt;=<span class="hljs-number">0</span> &amp;&amp; newX &lt; n&amp;&amp; newY &gt;=<span class="hljs-number">0</span> &amp;&amp; newY &lt; m &amp;&amp; visited[newPoint]==<span class="hljs-number">0</span> &amp;&amp; grid[newX][newY]==<span class="hljs-number">0</span> &#123;<br>visited[point&#123;newX,newY&#125;] = <span class="hljs-number">1</span><br>queue =<span class="hljs-built_in">append</span>(queue,newPoint)<br>&#125;<br>&#125;<br><br>&#125;<br>step++<br>&#125;<br><span class="hljs-comment">// 只能为0 的路径才可以更新到queue  边界控制</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>&gt; <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solutions/1076268/bfszui-duan-lu-jing-wen-ti-bfsdfsde-si-k-ngc5/">1091. 二进制矩阵中的最短路径 - 力扣（Leetcode）</a>### 解题思路</strong></p><blockquote><p>典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。</p></blockquote><p><strong>&gt; ### 在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？</strong></p><blockquote><p>1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径； 2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</p></blockquote><p><strong>&gt; ### BFS解法中的visited为什么可以全局使用？</strong></p><blockquote><p>BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？ 因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维数组最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 53.最大子数和</title>
    <link href="/2023-05-25-8fc7b96cd054.html"/>
    <url>/2023-05-25-8fc7b96cd054.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p><strong>个人网站：</strong> <a href="https://leiqicn.gitee.io/categories/leetcode/">https://leiqicn.gitee.io/categories/leetcode/</a><br><img src="https://pic.leetcode.cn/1685028457-IOzjjG-image.png" alt="image.png"><br>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>这里是经典的最大子序和的问题。我们可以很容易想到贪心的思想。就是如果前边的子序和是正数，则我们会把当前的数添加到前面的子序和上。否则，重新从当前位置开始子序和，丢弃前边的子序和。</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>方法1  算法通过遍历整个数组nums，维护一个当前连续子序列的和count，同时记录一个最大值res。每遍历一个元素，就将其加入到count中，并比较它与之前计算过的最大子序和res的大小关系，如果大于res，则更新res。并且当count变成负数时，就说明需要重新寻找连续子序列，因此将count重置为0。</p></blockquote><blockquote><p>方法2 使用了类似动态规划的思想，用nums 数组代表dp数组; dp[i]含义：dp 表示最大子序列，i 代表当前位置的最大子序列的值；dp[i+1] &#x3D; dp[i] +dp[i+1] ;max 初始化为第一个元素nums<a href="dp%5B0%5D">0</a>; 遍历顺序，从idx &#x3D; 1 开始遍历。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(n)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 方法1 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br>res := math.MinInt32<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>count += nums[i]<br><span class="hljs-keyword">if</span> count &gt; res &#123;<br>res = count<br>&#125;<br><br><span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span> &#123;<br>count = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-comment">// 方法2 使用了类似动态规划的思想</span><br><span class="hljs-comment">// 定义 nums[i] 当前元素，nums[i-1] 前序列之和</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>max := nums[<span class="hljs-number">0</span>] <span class="hljs-comment">//初始化最大值为前边一个元素</span><br><span class="hljs-comment">// 是判断当前连续子序列能否对后面的数字产生增益的条件，在算法中起到非常重要的作用。</span><br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span> ;i &lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] + nums[i] &gt; nums[i+<span class="hljs-number">1</span>] &#123;<br>nums[i+<span class="hljs-number">1</span>] = nums[i+<span class="hljs-number">1</span>] + nums[i]<br>&#125;<br><span class="hljs-comment">// 超过最大值，则更新</span><br><span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] &gt;  max &#123;<br>max = nums[i+<span class="hljs-number">1</span>]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言-回调函数（钩子）</title>
    <link href="/2023-05-25-2cbe3a05ec00.html"/>
    <url>/2023-05-25-2cbe3a05ec00.html</url>
    
    <content type="html"><![CDATA[<p>在Go语言中，回调函数和钩子函数通常是使用函数类型作为参数传递给函数或方法，以便在特定事件发生时被调用。这种机制非常灵活，可以让你编写出高效的、可复用的代码。</p><p>以下是一个简单的例子，展示了如何使用回调函数来实现一个函数，当输出文本时会同时调用传入的回调函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printWithCallback</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span>) &#123;<br>    text := <span class="hljs-string">&quot;Hello, world!&quot;</span><br>    fmt.Println(text)<br>    callback(text)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    callback := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Printed: %s\n&quot;</span>, text)<br>    &#125;<br>    printWithCallback(callback)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码定义了一个名为 printWithCallback 的函数，该函数接受一个函数类型参数 callback，其中这个 callback 会在输出文本后被调用。然后在主函数中定义了一个回调函数并将其作为参数传递给 printWithCallback 函数。</p><p>当程序运行起来后，会输出如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Hello, world!<br>Printed: Hello, world!<br></code></pre></td></tr></table></figure><p>这表示 printWithCallback 函数被成功调用，并且在输出文本之后 callback 被调用了一次。</p><p>对于钩子函数的例子，假设我们正在编写一段需要进行时间测量的代码。我们可以先定义一个钩子函数 TimeElapsedCallback，然后将它作为参数传递给要测量的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeElapsedCallback</span><span class="hljs-params">(start time.Time)</span></span> &#123;<br>    elapsed := time.Now().Sub(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">(callback <span class="hljs-keyword">func</span>(time.Time)</span></span>) &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    callback(start)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation(TimeElapsedCallback)<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，当我们调用 heavyCalculation 函数时，会传入一个名为 TimeElapsedCallback 的钩子函数。这个钩子函数被定义为一个打印程序执行时长的简单函数，它接受一个 time.Time 类型参数来计算程序耗时。</p><p>在执行完 heavyCalculation 函数后，TimeElapsedCallback 钩子函数就会被自动调用，然后打印程序运行时长，输出如下内容：</p><p>Time elapsed: 1.001201ms<br>以上演示了如何使用回调函数和钩子函数来处理事件。在Go语言中，这种技术经常用于实现异步操作、协程等方面。</p><h2 id="回调函数的不同"><a href="#回调函数的不同" class="headerlink" title="回调函数的不同"></a>回调函数的不同</h2><p>以下是不使用回调函数的方式实现计算程序执行时间的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heavyCalculation</span><span class="hljs-params">()</span></span> &#123;<br>    start := time.Now()<br>    <span class="hljs-comment">// 这里进行任何需要测量时间的操作</span><br>    elapsed := time.Since(start)<br>    fmt.Printf(<span class="hljs-string">&quot;Time elapsed: %v\n&quot;</span>, elapsed)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    heavyCalculation()<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前使用回调函数的示例代码相比，主要区别在于重构了 heavyCalculation 函数代码。</p><p>在这个更改后的函数中，我们将钩子函数的功能直接集成到代码流程中，通过调用 time.Since(start) 来得到程序的执行时间。这样做的缺点在于，在需要使用程序执行时间的其他场合还需要重新编写和复制此段逻辑, 这样就会限制程序的可重用性和可扩展性。</p><p>当然，在一些简单的场合下该方法也能够正常工作，不过如果需要在多处使用计算执行时间的逻辑或者需要更加细致的精度控制，建议使用钩子函数来实现。</p><p>使用钩子函数和不使用钩子函数的主要区别在于代码结构和灵活性。</p><p>而使用钩子函数，可以将打印程序执行时间的功能单独提出来作为一个函数。这使得我们可以像 heavyCalculation 函数那样封装其他计算逻辑并复用 TimeElapsedCallback 钩子函数。</p><p>钩子函数的使用场景非常广泛，在几乎<strong>所有需要在特定事件发生时自动执行一些附加逻辑的场景中都可以使用。</strong></p><h2 id="以下是使用回调函数的优点："><a href="#以下是使用回调函数的优点：" class="headerlink" title="以下是使用回调函数的优点："></a>以下是使用回调函数的优点：</h2><p>灵活性：可以轻松地将自定义代码插入到已有的代码流程中。<br>可重用性：可以将钩子函数单独进行封装，以供不同的代码文件或项目中使用。<br>易于维护：通过修改单个钩子函数即可更改所有使用该钩子函数的代码的行为。<br>总之，使用钩子函数可以帮助我们让代码变得更加简洁、灵活、模块化和可重用。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 376.摆动序列</title>
    <link href="/2023-05-23-7b5e53100757.html"/>
    <url>/2023-05-23-7b5e53100757.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376. 摆动序列 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230524010708.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> count, preDiff, curDiff <span class="hljs-type">int</span><br>    count = <span class="hljs-number">1</span> <span class="hljs-comment">// 初始化计数为1，至少有一个数字是有效的</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 如果数组长度小于2，直接返回计数值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>; i++ &#123;<br>        curDiff = nums[i+<span class="hljs-number">1</span>] - nums[i] <span class="hljs-comment">// 计算当前数字之间的差值</span><br><br>        <span class="hljs-comment">// 根据差值的正负和前一个差值的正负进行判断</span><br>        <span class="hljs-comment">// 如果满足摆动序列的条件，更新前一个差值和计数值</span><br>        <span class="hljs-keyword">if</span> (curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>) &#123;<br>            preDiff = curDiff<br>            count++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count <span class="hljs-comment">// 返回最终的计数值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 226. 翻转二叉树</title>
    <link href="/2023-05-23-d59f64e0619b.html"/>
    <url>/2023-05-23-d59f64e0619b.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523230644.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 定义将二叉树翻转</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 单个任务逻辑 交换root 下的两个节点，然后在严格按照定义递归调用左右节点</span><br>    root.Right,root.Left = root.Left,root.Right <br>    <span class="hljs-comment">// 将右子树翻转</span><br>    invertTree(root.Right)<br>    <span class="hljs-comment">// 将左子树翻转</span><br>    invertTree(root.Left)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 144. 二叉树的前序遍历</title>
    <link href="/2023-05-23-62bd8ef029a5.html"/>
    <url>/2023-05-23-62bd8ef029a5.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230523224940.png"></p><p>记得提前判断是否为空，否则会报找不到内存指针的错误<br><img src="/../../imgs/Pasted%20image%2020230523225147.png"></p><p>注意：这里和层序遍历不一样，这里不用使用中间变量lens :&#x3D; stack.len() 来遍历每层，虽然增加了每层遍历依然可以通过，但是没有必要。只有在层序遍历的时候才需要记录每层的信息。<a href="leetcode%20102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">leetcode 102. 二叉树的层序遍历</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := list.New()<br>res :=  []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<span class="hljs-comment">//防止为空</span><br><span class="hljs-keyword">return</span> res<br>&#125;<br>stack.PushBack(root)<br><span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &#123;<br>top := stack.Remove(stack.Back()).(*TreeNode)<br>res = <span class="hljs-built_in">append</span>(res,top.Val)<br><span class="hljs-keyword">if</span> top.Right !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Right)<br>&#125;<br><span class="hljs-keyword">if</span> top.Left !=<span class="hljs-literal">nil</span> &#123;<br>stack.PushBack(top.Left)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  res <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 102. 二叉树的层序遍历</title>
    <link href="/2023-05-23-a419f5d1c6af.html"/>
    <url>/2023-05-23-a419f5d1c6af.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523224632.png"></p><h1 id="使用slice"><a href="#使用slice" class="headerlink" title="使用slice"></a>使用slice</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 层序遍历 使用size 记录每层数组 queue node 队列</span><br><br>    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    queue := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        queue = <span class="hljs-built_in">append</span>(queue, root)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        size := <span class="hljs-built_in">len</span>(queue)<br>        levels := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <br><br>        <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(queue)] <span class="hljs-comment">//切掉元素0</span><br><br>            levels = <span class="hljs-built_in">append</span>(levels, node.Val) <span class="hljs-comment">// 添加元素</span><br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>  &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, levels)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用list"><a href="#使用list" class="headerlink" title="使用list"></a>使用list</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<span class="hljs-comment">//防止为空</span><br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    queue := &amp;list.List&#123;&#125;<br>    queue.PushBack(root)<br><br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        length := queue.Len()               <span class="hljs-comment">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）     </span><br>        <span class="hljs-keyword">var</span> levelQueue []<span class="hljs-type">int</span><br>        fmt.Println(length)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i++ &#123;<br>            node := queue.Remove(queue.Front()).(*TreeNode)    <span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue.PushBack(node.Right)<br>            &#125;<br>            levelQueue = <span class="hljs-built_in">append</span>(levelQueue, node.Val)    <span class="hljs-comment">//将值加入本层切片中</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, levelQueue)          <span class="hljs-comment">//放入结果集</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1845.座位预约管理系统</title>
    <link href="/2023-05-22-97adde03f66a.html"/>
    <url>/2023-05-22-97adde03f66a.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230523000703.png"></p><h3 id="超时版本"><a href="#超时版本" class="headerlink" title="超时版本"></a>超时版本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> seat <span class="hljs-keyword">struct</span> &#123;<br>seatId <span class="hljs-type">int</span><br>isFree <span class="hljs-type">int</span> <span class="hljs-comment">// 空</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats   <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*seat<br>isFrees []<span class="hljs-type">int</span> <span class="hljs-comment">// 可预约的使用list 保存一份,记得被占用的时候，删除该座位，空缺则添加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br><span class="hljs-keyword">var</span> a = SeatManager&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*seat, n), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>id := i + <span class="hljs-number">1</span><br>a.seats[id] = &amp;seat&#123;id, <span class="hljs-number">1</span>&#125;<br>a.isFrees[i] = id <span class="hljs-comment">// 初始化</span><br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>sort.Ints(this.isFrees)<br>top := this.isFrees[<span class="hljs-number">0</span>]<br>this.seats[top].isFree = <span class="hljs-number">0</span><br>this.isFrees = this.isFrees[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> top<br>&#125;<br><br><span class="hljs-comment">// 遍历 或者使用map</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>) &#123;<br>this.seats[seatNumber].isFree = <span class="hljs-number">1</span><br>this.isFrees = <span class="hljs-built_in">append</span>(this.isFrees,seatNumber)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过版本"><a href="#通过版本" class="headerlink" title="通过版本"></a>通过版本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> SeatManager <span class="hljs-keyword">struct</span> &#123;<br>seats []<span class="hljs-type">int</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> SeatManager &#123;<br>set:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> SeatManager&#123;seats:set,min:<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Reserve() <span class="hljs-type">int</span> &#123;<br>value := this.min<br>this.seats[value]=<span class="hljs-number">1</span><br>length := <span class="hljs-built_in">len</span> (this.seats)<br>fmt.Println(length)<br>i:=value<br><span class="hljs-keyword">for</span> ;i&lt;length+<span class="hljs-number">1</span>;i++&#123;<br><span class="hljs-keyword">if</span> this.seats[i]==<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>this.min=i <span class="hljs-comment">// 中间变量，更新下次的最小座位号</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> value <span class="hljs-comment">// 最小的座位号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SeatManager)</span></span> Unreserve(seatNumber <span class="hljs-type">int</span>)  &#123;<br>this.seats[seatNumber]=<span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> seatNumber &lt; this.min&#123;<br>this.min=seatNumber<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 455.分发饼干</title>
    <link href="/2023-05-21-c1aa51f444e0.html"/>
    <url>/2023-05-21-c1aa51f444e0.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/assign-cookies/description/">455. 分发饼干 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230521231054.png"></p><p><a href="https://leiqicn.gitee.io/">https://leiqicn.gitee.io/</a> 欢迎关注我的博客，定时更新golang 刷题笔记</p><p>贪心的策略：</p><blockquote><p>贪心算法一般分为如下四步：<br> 将问题分解为若干个子问题<br>找出适合的贪心策略<br>求解每一个子问题的最优解<br>将局部最优解堆叠成全局最优解</p></blockquote><p>排序，遍历饼干，child胃口初始化idx&#x3D;0 ,res &#x3D;0 ;<br>如果没有越界并且饼干大于等于胃口，则childIdx ++；res++</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(g []<span class="hljs-type">int</span>, s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// g 小孩胃口 s 饼干 从大到小排序 排序,并给胃口初始化赋值</span><br>    sort.Ints(g)<br>    sort.Ints(s)<br>    j := <span class="hljs-number">0</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 用小饼干 来满足最小的胃口</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 判断越界 饼干大于胃口</span><br>        <span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(g) &amp;&amp; s[i] &gt;= g[j]  &#123; <span class="hljs-comment">// len不越界的条件需要在前边</span><br><br>            res++<br>            j++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网站无法访问categories？</title>
    <link href="/2023-05-21-a827bdd2d159.html"/>
    <url>/2023-05-21-a827bdd2d159.html</url>
    
    <content type="html"><![CDATA[<p>在package.json中没有放 下边的hexo-generator-category，导致无法生成对应的文件。</p><p><img src="/../../imgs/Pasted%20image%2020230521214536.png"></p><p>可以显示啦<br><img src="/../../imgs/Pasted%20image%2020230521214912.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 706. 设计哈希映射 Golang</title>
    <link href="/2023-05-20-e3f31d125f9b.html"/>
    <url>/2023-05-20-e3f31d125f9b.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashmap/description/">706. 设计哈希映射 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230520230121.png"><br>使用了go 语言的list.List (双向列表)，具体如何使用请看文章：Go语言-list.List</p><h2 id="使用结构体（非指针）"><a href="#使用结构体（非指针）" class="headerlink" title="使用结构体（非指针）"></a>使用结构体（非指针）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 链地址法</span><br><span class="hljs-keyword">var</span> base = <span class="hljs-number">769</span><br><br><span class="hljs-comment">// base := 769</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-type">int</span><br>v <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyHashMap <span class="hljs-keyword">struct</span> &#123;<br>hashMaps []list.List<br>&#125;<br><br><span class="hljs-comment">// hash集合可以使用数组链表；</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashMap &#123;<br><span class="hljs-keyword">return</span> MyHashMap&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-comment">// func　(this *MyHashMap) hash(key int, value int)&#123;</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et := e.Value.(entry); et.k == key &#123;<br>e.Value = entry&#123;key, value&#125; <span class="hljs-comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>this.hashMaps[hash].PushBack(entry&#123;key, value&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(entry); ok&amp;&amp; et.k == key&#123;<br><span class="hljs-keyword">return</span> et.v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Remove(key <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(entry); ok &amp;&amp; et.k == key &#123;<br>this.hashMaps[hash].Remove(e)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> * param_2 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="使用结构体指针"><a href="#使用结构体指针" class="headerlink" title="使用结构体指针"></a>使用结构体指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 链地址法</span><br><span class="hljs-keyword">var</span> base = <span class="hljs-number">769</span><br><br><span class="hljs-comment">// base := 769</span><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-type">int</span><br>v <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyHashMap <span class="hljs-keyword">struct</span> &#123;<br>hashMaps []list.List<br>&#125;<br><br><span class="hljs-comment">// hash集合可以使用数组链表；</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashMap &#123;<br><span class="hljs-keyword">return</span> MyHashMap&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et := e.Value.(*entry); et.k == key &#123; <span class="hljs-comment">// 注意list 的元素类型是空接口，需要断言类型</span><br>et.v = value  <span class="hljs-comment">// 注意这里et 是拷贝，需要是使用e.Value 而不是其拷贝,可以使用其指针</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>this.hashMaps[hash].PushBack(&amp;entry&#123;key, value&#125;)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(*entry); ok&amp;&amp; et.k == key&#123; <span class="hljs-comment">// 可以缩写为if et := e.Value.(entry); et.k == key  用于断言，并找key</span><br><span class="hljs-keyword">return</span> et.v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyHashMap)</span></span> Remove(key <span class="hljs-type">int</span>) &#123;<br>hash := key % base<br><span class="hljs-keyword">for</span> e := this.hashMaps[hash].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123;<br><span class="hljs-keyword">if</span> et, ok := e.Value.(*entry); ok &amp;&amp; et.k == key &#123;<br>this.hashMaps[hash].Remove(e)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> * param_2 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Remove(key);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode　705. 设计哈希集合</title>
    <link href="/2023-05-19-2fa443568cc1.html"/>
    <url>/2023-05-19-2fa443568cc1.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-hashset/description/">705. 设计哈希集合 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230520225749.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> base = <span class="hljs-number">769</span> <span class="hljs-comment">// 哈希表的长度 质数</span><br><br><span class="hljs-keyword">type</span> MyHashSet <span class="hljs-keyword">struct</span> &#123;<br>    data []list.List <span class="hljs-comment">// 使用链表储存冲突元素</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyHashSet &#123; <span class="hljs-comment">// 构造函数，返回一个空的哈希集合</span><br>    <span class="hljs-keyword">return</span> MyHashSet&#123;<span class="hljs-built_in">make</span>([]list.List, base)&#125;<br>&#125;<br><br><span class="hljs-comment">// 哈希函数：对键值取模得到哈希值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> hash(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> key % base<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Add(key <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 向哈希集合中添加元素</span><br>    <span class="hljs-keyword">if</span> !s.Contains(key) &#123; <span class="hljs-comment">// 如果元素不在集合中</span><br>        h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>        s.data[h].PushBack(key) <span class="hljs-comment">// 将元素加入到链表中</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Remove(key <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 从哈希集合中删除元素</span><br>    h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span> e := s.data[h].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123; <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">if</span> e.Value.(<span class="hljs-type">int</span>) == key &#123; <span class="hljs-comment">// 如果元素等于要删除的元素</span><br>            s.data[h].Remove(e) <span class="hljs-comment">// 从链表中删除元素</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyHashSet)</span></span> Contains(key <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 判断某个元素是否在哈希集合中</span><br>    h := s.hash(key) <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span> e := s.data[h].Front(); e != <span class="hljs-literal">nil</span>; e = e.Next() &#123; <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">if</span> e.Value.(<span class="hljs-type">int</span>) == key &#123; <span class="hljs-comment">// 如果元素等于要查找的元素</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 返回 true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 没有找到元素，返回 false</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1396.设计地铁系统</title>
    <link href="/2023-05-18-0a0f1bd6a4a5.html"/>
    <url>/2023-05-18-0a0f1bd6a4a5.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/design-underground-system/description/">1396. 设计地铁系统 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230518233218.png"></p><p>设计题：</p><p>设计数据结构</p><ul><li>user<ul><li>startTime int  </li><li>endTime int</li><li>startStationName string</li><li>endStatationName string</li></ul></li><li>UndergroundSystem<ul><li>userMap map[int]*user</li><li>pathMap map[string][]int &#x2F;&#x2F; 存放对应路程的用时，用于计算平均时间</li></ul></li></ul><p>注意点：go语言针对结构体包含指针的，需要在具体实现前初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;<br>id <span class="hljs-type">int</span><br>startTime <span class="hljs-type">int</span><br>endTime <span class="hljs-type">int</span><br>startStationName <span class="hljs-type">string</span><br>endStatationName <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UndergroundSystem <span class="hljs-keyword">struct</span> &#123;<br>userMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user<br>pathMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span> <span class="hljs-comment">// 存放对应路程的用时，用于计算平均时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> UndergroundSystem &#123;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">return</span> UndergroundSystem&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*user),<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckIn(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//userMap 添加</span><br>this.userMap[id] = &amp;user&#123;id:id&#125; <span class="hljs-comment">// 重点！！！ 这里多层嵌套指针的时候现需要新建指针初始化，否则会报错找不到该地址</span><br>this.userMap[id].startTime = t<br>this.userMap[id].startStationName = stationName<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> CheckOut(id <span class="hljs-type">int</span>, stationName <span class="hljs-type">string</span>, t <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//出站时，更新user.end* ;append pathmap</span><br>useTime := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> _,ok := this.userMap[id] ;ok &#123;<br>this.userMap[id].endTime = t<br>this.userMap[id].endStatationName = stationName<br>&#125;<br><br>mapKey := this.userMap[id].startStationName +<span class="hljs-string">&quot;-&gt;&quot;</span> + this.userMap[id].endStatationName<br>useTime = this.userMap[id].endTime - this.userMap[id].startTime<br>this.pathMap[mapKey] = <span class="hljs-built_in">append</span>(this.pathMap[mapKey],useTime)<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *UndergroundSystem)</span></span> GetAverageTime(startStation <span class="hljs-type">string</span>, endStation <span class="hljs-type">string</span>) <span class="hljs-type">float64</span> &#123;<br>mapKey := startStation +<span class="hljs-string">&quot;-&gt;&quot;</span> + endStation<br><span class="hljs-keyword">return</span> average(this.pathMap[mapKey])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">average</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> s &#123;<br>sum +=v<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(sum)/<span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(s))<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your UndergroundSystem object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.CheckIn(id,stationName,t);</span><br><span class="hljs-comment"> * obj.CheckOut(id,stationName,t);</span><br><span class="hljs-comment"> * param_3 := obj.GetAverageTime(startStation,endStation);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 设计题 Constructor构建</title>
    <link href="/2023-05-14-776ea61b62a5.html"/>
    <url>/2023-05-14-776ea61b62a5.html</url>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，构造函数通常用于创建新对象并初始化其属性。对于 LeetCode 样例题目 “Design Parking System” 中的 ParkingSystem 结构体，可以这样编写 Constructor 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<br>    carNums <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 记录每种停车位的数量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(big <span class="hljs-type">int</span>, medium <span class="hljs-type">int</span>, small <span class="hljs-type">int</span>)</span></span> ParkingSystem &#123;<br>    <span class="hljs-keyword">return</span> ParkingSystem&#123;<br>        carNums: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: big, <span class="hljs-number">2</span>: medium, <span class="hljs-number">3</span>: small&#125;, <span class="hljs-comment">// 初始化 carNums 映射</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，我们使用传递给 Constructor 方法的三个整数参数来初始化 ParkingSystem 结构体的属性。具体而言，我们使用 map[int]int 类型的 carNums 映射保持每种车位类型的可用数量。在初始化结构体时，我们使用字面量映射来启用 1、2 和 3 的停车位类型，并将它们的值与输入参数big、medium 和 small 相关联。</p><p>请注意，当声明类似 structA map[int]structB 的嵌套 map 时，只需要在创建 A 实例时初始化外部映射即可。此时内部的 structB 映射会默认为 nil，但可以在需要使用时通过相应的方法或直接进行初始化以此。例如，当需要在内部映射中添加元素时，可以先检查是否为 nil，然后在需要时进行初始化。</p><p>具体来说，如果需要创建一个名为 A 的 map[int]B 类型的 map 以及名为 B 的 map[int]int 类型的嵌套 map，则可以按以下方式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]B<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := &amp;A&#123;<br>        m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]B),<br>    &#125;<br>    b := &amp;B&#123;<br>        m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    a.m[<span class="hljs-number">1</span>] = *b <span class="hljs-comment">// 给 A 中的第一个元素分配一个新的 B 结构体实例</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了类型 B 和 A。在 A 中，我们使用包含 int 键和 B 值的映射来保持所有项目的索引和子结构体指针。请注意，为了确保不会出现 <strong>nil 引用错误</strong>，我们还在代码中使用了 make 函数创建了一个空映射。</p><p>例如, 下边结构体中map 嵌套了另外一个结构体的map,<br>可以通过使用 make 函数和伪造的 Res 结构体实例定义方式来初始化一个新的 ParkingSystem 实例，然后在之后的代码中修改 carNums 映射对象。以下是一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Res <span class="hljs-keyword">struct</span> &#123;<br>    big <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ParkingSystem <span class="hljs-keyword">struct</span> &#123;<span class="hljs-keyword">map</span><br>    carNums <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Res <span class="hljs-comment">// map 嵌套map</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewParkingSystem</span><span class="hljs-params">()</span></span> *ParkingSystem &#123;<br>    <span class="hljs-keyword">return</span> &amp;ParkingSystem&#123;carNums: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Res)&#125; <span class="hljs-comment">// 只用先make 一个空map,指向Res</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ps := NewParkingSystem()<br>    ps.carNums[<span class="hljs-number">1</span>] = &amp;Res&#123;big: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为 NewParkingSystem 的函数，它返回指向新的 ParkingSystem 实例的指针，并在函数体中使用 make 函数创建一个新的空指针映射。</p><p>然后在主函数的其他位置，我们通过传入适当的值来修改 carNums 中的每个停车场位置类型。请注意，与之前相同，我们在此处使用 &amp; 参考运算符来提供指向新声明的 Res 结构体实例的指针。</p><p>总之，可以分别声明 ParkingSystem 和 Res 结构体，并通过调用适当的函数或编写正确的初始化代码，在以后的程序执行期间引用并修改它们。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言-copy</title>
    <link href="/2023-05-11-27c67ecef2a3.html"/>
    <url>/2023-05-11-27c67ecef2a3.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，copy 函数可以用于将一个切片（slice）的元素复制到另一个切片中。它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []Type)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>其中 dst 是目标切片，src 是源切片，Type 表示元素类型。函数返回值是复制的元素个数，即 len(src) 和 len(dst) 中较小的那个。</p><p>使用 copy 函数删除数组或切片中的元素，需要用到 append 函数和 copy 函数一起操作。具体步骤如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个包含元素的数组</span><br>a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 定义要删除的元素下标</span><br>index := <span class="hljs-number">2</span><br><span class="hljs-comment">// 利用 append 函数和 copy 函数删除指定下标的元素</span><br><span class="hljs-built_in">copy</span>(a[index:], a[index+<span class="hljs-number">1</span>:])<br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br><span class="hljs-comment">// 打印删除后的数组</span><br>fmt.Println(a) <span class="hljs-comment">// 输出 [1 2 4 5]</span><br></code></pre></td></tr></table></figure><p>上述代码中，首先定义一个包含 5 个元素的整型数组 a 和要删除的元素下标 index。然后调用 copy 函数将第 index+1 个元素开始的值复制到第 index 个位置，覆盖掉要删除的元素，然后再将数组长度减一，实现删除操作。最后打印删除后的数组。在实际使用时，还需判断删除下标的合法性等情况，以保证程序功能正确性。</p><p>在使用 copy 函数删除切片或数组中指定位置的元素时，需要将删除位置后面的元素向前移动一位，以覆盖被删除的元素。为了完成这个操作，可以使用切片的特性来实现。</p><p>在 Go 语言中，切片可以通过指定起始位置和结束位置来获取一个子切片。例如，对于一个长度为 5 的整型数组 a，我们可以通过以下方式获取从第二个元素到第四个元素组成的子切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">b := a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>这里的 1 表示起始位置（从零开始计数），表示第二个元素；4 表示结束位置，表示第五个元素之后的位置。注意，slice[start:end] 的结果包含起始位置对应的元素，但不包含结束位置对应的元素。</p><p>在使用 copy 函数删除切片或数组中指定位置的元素时，我们可以利用该特性，将删除位置之后的所有元素复制到它们原来的位置上，以实现向前移位的效果。具体来说，假设要删除的位置是 index，则可以将要删除位置之后的所有元素构造一个子切片，再将子切片复制到原来的位置上来实现删除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">copy</span>(a[index:], a[index+<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>这里，a[index:] 表示从要删除位置开始到切片结束的一个子切片，它的长度为 len(a) - index。因此，通过 copy 函数将它复制到自身的第 index 个元素位置上时，就可以将删除位置之后的所有元素向前移位，从而删除具体元素。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言-byte和rune 有什么区别 byte rune 转为int</title>
    <link href="/2023-05-11-257639a12a8e.html"/>
    <url>/2023-05-11-257639a12a8e.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，byte 和 rune 都是用来表示字符类型的数据类型。</p><p>byte 是 uint8 的别名，在 Go 中通常用于表示 ASCII 字符集中的一个字节。<br>rune 是 int32 的别名，在 Go 中通常用于表示 Unicode 字符集中的一个代码点。<br>因此，对于 ASCII 字符来说，byte 和 rune 的值是相同的，但是对于大部分 Unicode 字符来说，它们是不同的。</p><p>将 byte 或 rune 转换为 int 可以使用类型转换操作符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">b := <span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>i := <span class="hljs-type">int</span>(b) - <span class="hljs-type">int</span>(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">// 将 byte &#x27;0&#x27; 转换为 int 0</span><br><span class="hljs-comment">// 上边可以简写为</span><br>i := b - <span class="hljs-string">&#x27;0&#x27;</span><br>r := <span class="hljs-type">rune</span>(<span class="hljs-string">&#x27;中&#x27;</span>)<br>i := <span class="hljs-type">int</span>(r)             <span class="hljs-comment">// 将 rune &#x27;中&#x27; 转换为 int 类型（其实是它的 Unicode 码点）</span><br></code></pre></td></tr></table></figure><p>将 int 转换为 byte 或 rune 可以使用类型断言或类型转换操作符，但是需要注意溢出的情况。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">10</span><br>b := <span class="hljs-type">byte</span>(i)   <span class="hljs-comment">// 溢出！编译器会忽略高位部分，直接取低位部分的字节</span><br>r := <span class="hljs-type">rune</span>(i)<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0xFFFF</span> &#123;<br>    r = <span class="hljs-type">rune</span>(b) <span class="hljs-comment">// 类型断言</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过判断 r 是否小于 0xFFFF 来检测转换是否正确，因为 Unicode 的码点范围在 0～0x10FFFF，超过该范围的值会被认为是无效码点。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 200.岛屿数量</title>
    <link href="/2023-05-10-da8c57fb590a.html"/>
    <url>/2023-05-10-da8c57fb590a.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量 - 力扣（Leetcode）</a><br><img src="/../../imgs/Pasted%20image%2020230511010424.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 1 岛屿，0 海水， 见到岛屿则使用dfs 淹了这个所有1相连的岛屿，res++</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br>r := <span class="hljs-built_in">len</span>(grid)<br>c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">byte</span>, r)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br>visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, c)<br>&#125;<br><br><span class="hljs-comment">// 遍历二维slice</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; c; j++ &#123;<br><span class="hljs-comment">// 每个位置</span><br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                dfs(grid, i, j, visited)<br>                res++<br>            &#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>, visited [][]<span class="hljs-type">byte</span>)</span></span> &#123;<br>r := <span class="hljs-built_in">len</span>(grid)<br>c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">// 边界判断</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= r || j &gt;= c &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 判断值，是海水直接返回</span><br><span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">// 判断是否走过</span><br><span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 改变状态为海水,并修改为走过</span><br>grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    visited[i][j] = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-comment">//单层递归逻辑，四面八方递归</span><br>dfs(grid, i+<span class="hljs-number">1</span>, j, visited)<br>dfs(grid, i, j+<span class="hljs-number">1</span>, visited)<br>dfs(grid, i<span class="hljs-number">-1</span>, j, visited)<br>dfs(grid, i, j<span class="hljs-number">-1</span>, visited)<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用方向二维数组来遍历</p><p>可以使用二维切片dirs表示方向变化值，将每个递归调用拆分为多个方向，并在循环中使用方向切片来更新i和j的值。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>, visited [][]<span class="hljs-type">byte</span>)</span></span> &#123;<br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 定义方向变化值dirs</span><br>    dirs := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;<br><br>    <span class="hljs-comment">// 边界判断</span><br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= r || j &gt;= c &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 判断值，是海水直接返回</span><br>    <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否走过</span><br>    <span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 改变状态为海水,并修改为走过</span><br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    visited[i][j] = <span class="hljs-string">&#x27;1&#x27;</span><br><br>    <span class="hljs-comment">// 循环遍历dirs，对四个方向进行递归</span><br>    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>        new_i, new_j := i + d[<span class="hljs-number">0</span>], j + d[<span class="hljs-number">1</span>]<br>        dfs(grid, new_i, new_j, visited)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例代码中，我们定义了二维切片dirs，它保存了四个元素，分别代表四个方向的横向(x方向)和纵向(y方向)跨度。在dfs函数内部，我们遍历了dirs，并使用d[0]和d[1]来更新当前的i和j值。这样就可以对每个方向进行递归了。</p><p><strong>使用额外的visited 的时候，一定要作为dfs 的入参，让其拷贝一份</strong><br>在 <code>dfs</code> 函数的递归调用中，条件判断 <code>if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok</code> 可能会导致部分陆地未被正确访问。原因是 <code>visited</code> 在函<strong>数调用之间是全局共享的</strong>，而不是每次调用都重新初始化（leetcode 的测试环境会造成影响）。</p><p>为了解决这个问题，你可以将 <code>visited</code> 变量作为参数传递给 <code>dfs</code> 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码：</p><p>需要注意的是，如上所述，使用dirs表示方向变化会稍微增加代码的复杂性，但它还可以使函数更灵活，并在处理其他需要迭代解决问题时提供帮助。</p><h1 id="对应BFS实现"><a href="#对应BFS实现" class="headerlink" title="对应BFS实现"></a>对应BFS实现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> dirct = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; c; j++ &#123;<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                res++<br>                bfs(grid, i, j)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    queue := []point&#123;&#123;i, j&#125;&#125;<br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">// 标记为已访问</span><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        current := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dirct &#123;<br>            myRow := current.x + item[<span class="hljs-number">0</span>]<br>            myCol := current.y + item[<span class="hljs-number">1</span>]<br><br>            <span class="hljs-keyword">if</span> myRow &gt;= <span class="hljs-number">0</span> &amp;&amp; myRow &lt; r &amp;&amp; myCol &gt;= <span class="hljs-number">0</span> &amp;&amp; myCol &lt; c &amp;&amp; grid[myRow][myCol] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                grid[myRow][myCol] = <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">// 标记为已访问</span><br>                queue = <span class="hljs-built_in">append</span>(queue, point&#123;myRow, myCol&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// DFS </span><br><br><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> dirct = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    res := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[point]<span class="hljs-type">int</span>)  <span class="hljs-comment">// 使用局部变量，每次调用都重新初始化</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; r; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; c; j++ &#123;<br>            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                res++<br>                dfs(grid, i, j, visited)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, i, j <span class="hljs-type">int</span>, visited <span class="hljs-keyword">map</span>[point]<span class="hljs-type">int</span>)</span></span> &#123;<br>    r := <span class="hljs-built_in">len</span>(grid)<br>    c := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= r || j &gt;= c &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-comment">// 和visited 等价</span><br>    <span class="hljs-keyword">if</span> _, ok := visited[point&#123;i, j&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">// 和visited 等价</span><br>    visited[point&#123;i, j&#125;] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dirct &#123;<br>        myRow := i + item[<span class="hljs-number">0</span>]<br>        myCol := j + item[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> _, ok := visited[point&#123;myRow, myCol&#125;]; !ok &#123; <span class="hljs-comment">// 这里和前边 if _, ok := visited[point&#123;i, j&#125;]; ok 二选一</span><br>            dfs(grid, myRow, myCol, visited)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 需要注意的是岛屿数量的 Go 语言代码中，有一点需要注意。在 dfs 函数的递归调用中，条件判断 if _, ok := visited[point&#123;myRow, myCol&#125;]; !ok 可能会导致部分陆地未被正确访问。原因是 visited 在函数调用之间是全局共享的，而不是每次调用都重新初始化。</span><br><br><span class="hljs-comment">//为了解决这个问题，你可以将 visited 变量作为参数传递给 dfs 函数，确保在每次调用时都使用新的局部副本。以下是修改后的代码：</span><br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a> 岛屿问题一文搞定</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图遍历，岛屿问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体指针作为map key 结构体值改变对map有影响吗</title>
    <link href="/2023-05-10-7dfabb45bbc2.html"/>
    <url>/2023-05-10-7dfabb45bbc2.html</url>
    
    <content type="html"><![CDATA[<p>最近偶然用到了结构体指针作为map key 的场景。当时有点不太确定：<strong>go 语言使用map 时使用指针p作为key, 那修改指针p的值之后。这map 还包含p 吗？</strong><br>接下来让我们一起看看：</p><p>当将指针作为 Map 的 Key 时，实际上是把指针的值作为键来进行插入和查找操作。因此，如果修改了该指针所指向的变量的值，那么并不会影响已经添加到 Map 中的键。因为这个指针仍然具有相同的值，所以它可以被用作一个标识符来检索和操作存储在Map中的数据</p><p>例如，以下代码定义了一个map[*int]string类型的映射，将指针p用作key来插入和索引数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><br>x := <span class="hljs-number">1</span><br>p := &amp;x<br><br>m[p] = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-comment">// 添加数据</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br><br>*p = <span class="hljs-number">2</span> <span class="hljs-comment">// 修改变量x的值</span><br><br>fmt.Println(m) <span class="hljs-comment">// map[0xc000016088:A]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先创建了一个指针p，指向变量x的地址，并把p用作key将字符串”A”添加到了map中。</p><p>接下来，我们修改了变量x的值，将其从1修改为2。但是，当我们再次输出映射m时，发现其中的元素仍然是[p:”A”]。这是因为，在修改变量的值后，指针p的地址仍然相同，因此该指针作为键在Map中仍然有效。映射使用的是地址而不是变量的名称或值，因此不受值的更改的影响。</p><p>总之，在将指针用作Map键时，必须理解这种行为，并根据需要编写代码来处理和管理指针及其地址的值。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言删除指定索引元素</title>
    <link href="/2023-05-10-741623f2e4fb.html"/>
    <url>/2023-05-10-741623f2e4fb.html</url>
    
    <content type="html"><![CDATA[<p>在Go语言中，可以使用切片的操作和 append 函数来删除特定索引的元素。</p><p>以下是一个示例代码，它演示了如何删除切片中索引值为 i 的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    i := <span class="hljs-number">2</span> <span class="hljs-comment">// 要删除的索引</span><br><br>    <span class="hljs-comment">// 将要删除的元素从原始切片中删除，并返回剩下的元素组成的新切片</span><br>    b := <span class="hljs-built_in">append</span>(a[:i], a[i+<span class="hljs-number">1</span>:]...)<br><br>    fmt.Println(b) <span class="hljs-comment">// 输出 [1 2 4 5]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个整数切片 a，包含 1、2、3、4、5 五个元素。然后我们定义要删除的元素的索引位置 i 为 2（即第三个元素）。</p><p>接下来，我们使用 append 函数和切片切割（slice expression）操作，在 a[:i] 和 a[i+1:] 中间加入空白符号 (…)，以便将包含 a[i] 元素的子切片略过。也就是说，这个表达式等价于前 i 个元素和后面剩余的所有元素的连接。从而我们得到一个新的切片 b，其中不包含位于索引 i 处的元素。</p><p>最后，我们将结果赋值给变量 b 并打印输出它。注意，这个删除元素的操作不会改变原始切片 a 的内容。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言指定索引插入元素</title>
    <link href="/2023-05-10-5e3b5c8e7446.html"/>
    <url>/2023-05-10-5e3b5c8e7446.html</url>
    
    <content type="html"><![CDATA[<p>在Go语言中，可以使用切片（slice）的 append 函数和切片的切割（slice expression）操作来在指定索引位置插入元素。</p><p>下面是一个示例代码，它插入一个元素到切片的第二个位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    i := <span class="hljs-number">1</span> <span class="hljs-comment">// 要插入的位置</span><br>    b := <span class="hljs-built_in">append</span>(a[:i], <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>&#125;, a[i:]...)...) <span class="hljs-comment">// 在切片的第二个位置插入数字5</span><br>    fmt.Println(b) <span class="hljs-comment">// 输出 [1 5 2 3 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了切片 a，包含整数 1、2、3、4。然后我们定义要插入的位置 i 为第二个元素（也就是索引值为 1）。</p><p>接着，在 append 函数中，我们将原始切片 a 切割成两部分：从起始位置到插入位置的子切片 a[:i]，和从插入位置到末尾的子切片 a[i:]。我们在这两个子切片之间插入了元素 5，然后使用两个 append 函数将它们拼接回去。</p><p>最后，我们将结果赋值给变量 b 并打印输出它。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 108.将有序数组转换为二叉搜索树</title>
    <link href="/2023-05-04-ce9a22434c37.html"/>
    <url>/2023-05-04-ce9a22434c37.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（Leetcode）</a></p><p><img src="/../../imgs/Pasted%20image%2020230504232459.png"></p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>注意递归函数的返回值和输入值，确定终止条件，确定单层递归逻辑<br>注意递归函数定义，严格按照定义调用递归<br>使用前序遍历 中左右</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> traversal(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义：返回nums root 节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traversal</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>,left <span class="hljs-type">int</span> , right <span class="hljs-type">int</span>)</span></span> *TreeNode&#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right)/<span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;nums[mid],<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>&#125;<br>    root.Left =  traversal(nums,left,mid<span class="hljs-number">-1</span>) <span class="hljs-comment">// 把后边 root 节点添加到当前root left 左节点上</span><br>    root.Right = traversal(nums,mid+<span class="hljs-number">1</span>,right) <span class="hljs-comment">// 把后边 root 节点添加到当前root right 左节点上</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除ppt所有批注和备注</title>
    <link href="/2023-04-24-4faf63eb321c.html"/>
    <url>/2023-04-24-4faf63eb321c.html</url>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/Pasted%20image%2020230424222537.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222611.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222527.png"><br><img src="/../../imgs/Pasted%20image%2020230424222515.png"></p><p><img src="/../../imgs/Pasted%20image%2020230424222511.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言-接口</title>
    <link href="/2023-04-20-89710477a7ed.html"/>
    <url>/2023-04-20-89710477a7ed.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，接口(interface)是一种类型，它定义了对象的行为规范，即定义了一组方法签名，而不需要指定具体的实现。接口使得不同的类型可以通过实现相同的方法集合来进行互换使用。</p><p>以一个简单的例子来说明接口的作用，在下面这段代码中，接口Printer定义了一个打印的方法Print()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Printer <span class="hljs-keyword">interface</span> &#123;<br>    Print()<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span></span> Print() &#123;<br>    fmt.Println(u.name,<span class="hljs-string">&quot;我爱加班&quot;</span>)<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printAll</span><span class="hljs-params">(ps []Printer)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> ps &#123;<br>        p.Print()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> ps []Printer<br>    ps = <span class="hljs-built_in">append</span>(ps, User&#123;<span class="hljs-string">&quot;Alice&quot;</span>&#125;)<br>    ps = <span class="hljs-built_in">append</span>(ps, User&#123;<span class="hljs-string">&quot;Bob&quot;</span>&#125;)<br>    printAll(ps)<br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数中，我们创建了一个ps的切片，里面放了两个User类型的元素。然后调用printAll打印所有的元素，因为User类型实现了Printer接口中定义的Print() 方法，所以可以将User类型的变量赋值给Print()参数中的表达式，并且调用p.Print() 方法。最终的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Alice 我爱加班<br>Bob 我爱加班<br></code></pre></td></tr></table></figure><p>在这段代码中，我们通过接口将<strong>User类型</strong>与PrintAll() 函数解耦，这样当我们需要添加<strong>新的类型时，只需要实现Print()方法</strong>即可，而不需要修改<strong>PrintAll()函数实现</strong>。</p><p>比如现在需要有个老板类型，也要打印，我们只要实现老板对应的Print 方法即可，而不用修改<strong>PrintAll()函数实现</strong>。这样我们应该会更好理解接口的使用场景：适用于数量比较多的多个对象，<strong>有相同的特征</strong>，我们将其抽象出来，降低代码耦合性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Boss <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Boss)</span></span> Print() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;你明天不用来了&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>其实我们可以将其类比于现实生活中的“合同”或“协议”等，接口定义了一组规则和方法集合，当你实现接口时，就像在签署一个合同，你同意遵守这个合同的规定，将这个合同上的对应部分填上具体的内容，这样就可以按照<strong>合同的规定</strong>进行处理。</p><p>同时，接口的使用，使得代码更加灵活、可扩展和相互独立，降低了耦合性，提高了代码的可维护性和重复利用性。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言-多态</title>
    <link href="/2023-04-20-af074e588287.html"/>
    <url>/2023-04-20-af074e588287.html</url>
    
    <content type="html"><![CDATA[<p>Go语言中没有类，我们可以使用结构体作为对象，来绑定对应的方法。而接口是功能的抽象，是方法的集合。</p><p>我们来实现这样一个例子：</p><ul><li>实现猫和狗<strong>两个对象</strong>，并且他们都有动作：叫，<strong>但叫声不同</strong>。再实现一个<strong>对象鸟</strong>，他除了叫，还会<strong>飞</strong>。</li></ul><p>下面是基于Go语言，实现题目要求的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>    Cry()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;喵喵喵&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;汪汪汪&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Bird <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Bird)</span></span> Cry() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;叽叽喳喳&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b Bird)</span></span> Fly() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;我会飞&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> animal Animal<br><br>    <span class="hljs-comment">// 创建一只猫</span><br>    animal = Cat&#123;&#125;<br>    animal.Cry()<br><br>    <span class="hljs-comment">// 创建一只狗</span><br>    animal = Dog&#123;&#125;<br>    animal.Cry()<br><br>    <span class="hljs-comment">// 创建一只鸟</span><br>    bird := Bird&#123;&#125;<br>    animal = bird<br>    animal.Cry()<br>    bird.Fly()<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，定义了一个Animal接口和三个结构体Cat、Dog、Bird分别实现了这个接口。其中，Cat和Dog只能叫，而Bird除了叫外还可以飞行。在main函数中创建相应的对象并调用相应的方法。</p><p>运行上述代码，输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">喵喵喵<br>汪汪汪<br>叽叽喳喳<br>我会飞<br></code></pre></td></tr></table></figure><p>在这段代码中，我们使用了<strong>接口的多态特性</strong>，通过定义<strong>Animal接口</strong>，实现了<strong>不同类型的对象之间的通用性</strong>，并且在<strong>Bird中新增了Fly() 方法</strong>，符合面向对象的<strong>开放封闭原则</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>波纹</title>
    <link href="/2023-04-08-722322c4ddc3.html"/>
    <url>/2023-04-08-722322c4ddc3.html</url>
    
    <content type="html"><![CDATA[<p><img src="/../../imgs/IMG_1502-01-01.jpeg"><br>波光粼粼</p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影</tag>
      
      <tag>水</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 513.找树左下角的值</title>
    <link href="/2023-04-03-03cca064ab00.html"/>
    <url>/2023-04-03-03cca064ab00.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（Leetcode）</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg"></p><p><strong>输入:</strong> root &#x3D; [2,1,3]<br><strong>输出:</strong> 1</p><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg"></p><p><strong>输入:</strong> [1,2,3,4,null,5,6,null,null,7]<br><strong>输出:</strong> 7</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本题可以转化为什么呢？</p><blockquote><p>1.最后一层的最左边的数值，递归的话需要记录最后一层，并且记录最左边的值<br>2.如果是迭代呢？这个就更适合了，只要记录每层迭代中的第一个值，并且不断更新更大的值就好。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> depth <span class="hljs-type">int</span>   <span class="hljs-comment">// 全局变量 最大深度</span><br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>     <span class="hljs-comment">// 记录最终结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    depth, res = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>   <br>    dfs(root, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, d <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//这里判断nil ,后边左右节点就不用判断了</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 因为先遍历左边，所以左边如果有值，右边的同层不会更新结果</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &amp;&amp; depth &lt; d &#123; <br>        depth = d<br>        res = root.Val<br>    &#125;<br>    dfs(root.Left, d+<span class="hljs-number">1</span>)   <br>    dfs(root.Right, d+<span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 遍历每一层</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-comment">// 获取每一层的最左边的位置，更新res</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>res = top.Val<br>&#125;<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Left)<br>&#125;<br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Right)<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br><span class="hljs-comment">// 迭代2 每层用一个切片</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// 通过另外一个切片来添加的解法也要尝试学习一下</span><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 使用nextqueue 保存每一层，然后追加到queue</span><br>nextqueue := []*TreeNode&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br>    res = nextqueue[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>nextqueue = <span class="hljs-built_in">append</span>(nextqueue, top.Left)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>nextqueue = <span class="hljs-built_in">append</span>(nextqueue, top.Right)<br>&#125;<br>&#125;<br>queue = <span class="hljs-built_in">append</span>(queue,nextqueue...)<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>如果要求最右边的值呢？这里该怎么求呢？</p><p>只需要将 遍历左右的顺序颠倒一下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">-1</span><br>queue := []*TreeNode&#123;&#125;<br><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br>queue = <span class="hljs-built_in">append</span>(queue, root)<br><span class="hljs-comment">//res 在哪里更新呢？</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>size := <span class="hljs-built_in">len</span>(queue)<br><span class="hljs-comment">// 遍历每一层</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>top := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-comment">// 获取每一层的最左边的位置，更新res</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>res = top.Val<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Right != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Right)<br>&#125;<br><br><span class="hljs-keyword">if</span> top.Left != <span class="hljs-literal">nil</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, top.Left)<br>&#125;<br><br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 404.左叶子之和</title>
    <link href="/2023-03-29-c131676dd7b1.html"/>
    <url>/2023-03-29-c131676dd7b1.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 递归</span><br>res := <span class="hljs-number">0</span><br><span class="hljs-comment">// 终止条件</span><br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    leftNode := root.Left<br>leftNodeVal := sumOfLeftLeaves(root.Left) <span class="hljs-comment">// 左</span><br>    rightNodeVal := sumOfLeftLeaves(root.Right)<span class="hljs-comment">// 右</span><br><span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">nil</span> &amp;&amp; leftNode.Left == <span class="hljs-literal">nil</span> &amp;&amp; leftNode.Right == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 中</span><br>leftNodeVal = leftNode.Val<br>&#125;<br><span class="hljs-comment">// 单次循环</span><br>    res = leftNodeVal + rightNodeVal <span class="hljs-comment">// 中，左边+右边</span><br><span class="hljs-keyword">return</span> res <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 257.二叉树的所有路径</title>
    <link href="/2023-03-28-53b6b0695943.html"/>
    <url>/2023-03-28-53b6b0695943.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> res []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> path []<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">string</span> &#123;<br>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">0</span>)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>backTracking(root)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;<br><span class="hljs-comment">// 终点 左右子节点都为nil</span><br><span class="hljs-keyword">if</span> isLeafNode(root) &#123;<br>        NodeValStr := strconv.Itoa(root.Val)<br>    path = <span class="hljs-built_in">append</span>(path, NodeValStr)<br>pathStr := strings.Join(path, <span class="hljs-string">&quot;-&gt;&quot;</span>)<br>res = <span class="hljs-built_in">append</span>(res, pathStr)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 前序遍历 中左右</span><br><span class="hljs-comment">// 遍历 每次递归的操作</span><br>NodeVal:= strconv.Itoa(root.Val)<span class="hljs-comment">// 中</span><br>path = <span class="hljs-built_in">append</span>(path, NodeVal)<br><span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 左</span><br>backTracking(root.Left)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 右</span><br>backTracking(root.Right)<br>        path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isLeafNode</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">bool</span>&#123;<br><span class="hljs-keyword">if</span> node.Right==<span class="hljs-literal">nil</span> &amp;&amp; node.Left== <span class="hljs-literal">nil</span> &amp;&amp; node!= <span class="hljs-literal">nil</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 110.平衡二叉树</title>
    <link href="/2023-03-28-c58b9cf85e3e.html"/>
    <url>/2023-03-28-c58b9cf85e3e.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树 - 力扣（Leetcode）</a></p><p><font color="#2DC26B">简单 </font><br>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p><p><strong>输入：</strong>root &#x3D; [3,9,20,null,null,15,7]<br><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p><p><strong>输入：</strong>root &#x3D; [1,2,2,3,3,null,null,4,4]<br><strong>输出：</strong>false</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root &#x3D; []<br><strong>输出：</strong>true</p><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里是求<strong>高度</strong>： 节点到叶子节点的最长距离，使用<strong>后序遍历</strong><br><strong>深度</strong>是root 到该节点的最长距离（距离☞节点数），使用<strong>前序遍历</strong></p><p>因此只要分别计算左右子树的高度，并且做差不大于1就行</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用-1 记录 res 不是平衡二叉树<br>每次执行，都需要判断是不是等于-1，直接返回-1</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快来压缩你的博客图片</title>
    <link href="/2023-03-23-4868b6a1c39c.html"/>
    <url>/2023-03-23-4868b6a1c39c.html</url>
    
    <content type="html"><![CDATA[<p>虽然没多大变化 哈哈哈<br><img src="/../../imgs/Pasted%20image%2020230324011438.png"><br>再试试 更大更高清的图片<br><img src="/../../imgs/code-wallpaper-6.png"></p><p><img src="/../../imgs/Pasted%20image%2020230325200454.png"><br>实测,效果不太行….<br>但是还要介绍一下如何压缩哈哈哈，毕竟坑踩都踩了😂，怎么也得记录一下<br>待更新…</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>给你的博客 安装上PWA吧</title>
    <link href="/2023-03-23-49ace33ca004.html"/>
    <url>/2023-03-23-49ace33ca004.html</url>
    
    <content type="html"><![CDATA[<p>TODO:</p><ul><li>什么是PWA，可以提示添加到主屏幕<br>渐进式应用，提前缓存网站，像本地应用一样丝滑的使用网站</li><li>安装 hexo-pwa</li><li>由于hexo-pwa停止维护，需要解决报错</li><li>设置全局_config.yml 文件(非主题)</li></ul><p><img src="/../../imgs/Pasted%20image%2020230324004739.png"></p><p><img src="/../../imgs/ad6c5ebfc9a6401cde512120b6ed719.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 命令 将前台任务挂到后台运行</title>
    <link href="/2023-03-18-87649bcaf9cc.html"/>
    <url>/2023-03-18-87649bcaf9cc.html</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>   很多任务有时不能直接进行挂后台任务（比如需要输入密码的scp 命令），或者一时大意忘了直接挂后台。那么还有一个解救方式。使用<code>bg</code>  挂后台的命令。</p><p><strong>第一步：ctrl + z</strong></p><p><strong>第二步：jobs  查看任务id</strong></p><p><strong>第三步： bg %任务id</strong></p><p><img src="/../../imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230319125819.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客设置 obsidian 上传图片</title>
    <link href="/2023-03-18-4e4b648f656d.html"/>
    <url>/2023-03-18-4e4b648f656d.html</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本地写MD文档我是使用了github 和gitee 图床来着，但是发布到个人博客之后，发现支持都不好。所以选择了最原始的方案，复制图片到指定文件夹，然后连同这些图片文件夹一起上传到对应的git pages, 使用对应的<strong>相对路径</strong>就可以读取并显示图片。</p><p>而obsidian 可以实现插入图片的同时复制到图片到对应的路径，并生成MD 文档格式的链接。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="1-打开obsidian-文件与链接"><a href="#1-打开obsidian-文件与链接" class="headerlink" title="1. 打开obsidian - 文件与链接"></a>1. 打开obsidian - 文件与链接</h2><h2 id="2-按照下图配置"><a href="#2-按照下图配置" class="headerlink" title="2. 按照下图配置"></a>2. 按照下图配置</h2><p>   *　将内部链接类型 设置为 “基于当前笔记的<strong>相对路径</strong>”<br>     &gt; 因为我们的博客发布了之后，就只有source 文件夹下的文件，所以需要使用<strong>相对路径</strong></p><ul><li>取消wiki 链接 </li><li>指定图片的默认路径为 <code>source/imgs</code><br>&gt; 如果没有该文件夹，则需要先新建一下。</li></ul><p><img src="/../../imgs/Pasted%20image%2020230319131458.png"></p><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>网页可以成功显示图片</p><p><img src="/../../imgs/Pasted%20image%2020230319134051.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于我</title>
    <link href="/2023-03-13-519b5e93f019.html"/>
    <url>/2023-03-13-519b5e93f019.html</url>
    
    <content type="html"><![CDATA[<h1 id="博客链接"><a href="#博客链接" class="headerlink" title="博客链接"></a>博客链接</h1><p><a href="https://leiqichn.github.io/">国外链接</a><br><a href="https://leiqicn.gitee.io/">国内链接</a><br>大家可以根据网速情况选取任意一个网页浏览，两个网站内容是实时同步的。</p><p><img src="/../../imgs/%E7%99%BD%E9%B8%BD.png"></p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>大家好，我是Lei Qi, 毕业于复旦大学 生物信息专业，现转码农成功，任职于华为，担任软件开发工程师一职。本站是为了方便自己记录学习过程，和大家交流经验而建。也是为了学习web, 实现拥有自己一个网站的小目标，才有了本站。欢迎大家多多交流学习，祝大家学习愉快~</p>]]></content>
    
    
    <categories>
      
      <category>关于我</category>
      
    </categories>
    
    
    <tags>
      
      <tag>about</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
